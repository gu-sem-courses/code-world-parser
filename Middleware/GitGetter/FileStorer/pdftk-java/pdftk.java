/*
 *   This file is part of the pdftk port to java
 *
 *   Copyright (c) Marc Vinyals 2017-2018
 *
 *   The program is a java port of PDFtk, the PDF Toolkit
 *   Copyright (c) 2003-2013 Steward and Lee, LLC
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   The program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.gitlab.pdftk_java;

enum ErrorCode {
  NO_ERROR(0),
  ERROR(1),
  BUG(2),
  WARNING(3);

  final int code;
  ErrorCode(int code) {
    this.code = code;
  }
}
 /*
 *
 *   This file is part of the pdftk port to java
 *
 *   Copyright (c) Marc Vinyals 2017-2018
 *
 *   The program is a java port of PDFtk, the PDF Toolkit
 *   Copyright (c) 2003-2013 Steward and Lee, LLC
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   The program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.gitlab.pdftk_java;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

class LoadableInt {
  int ii= -1;
  boolean success;
  static int BufferInt( String buff, int buff_ii ) {
    //while( buff[buff_ii] && isspace(buff[buff_ii]) ) { ++buff_ii; }
    Pattern p = Pattern.compile("\\s?(\\d+).*"); // one or no spaces before data
    Matcher m = p.matcher(buff.substring(buff_ii));
    if (m.matches()) {
      return Integer.parseInt(m.group(1));
    }
    else {
      return 0;
    }
  }
  boolean LoadInt(String buff, String label) {
    int label_len= label.length();
    if ( buff.startsWith(label) ) {
      if( ii< 0 ) { // uninitialized ints are -1
        ii= BufferInt( buff, label_len );
      }
      else { // warning
        System.err.println("pdftk Warning: " + label + " (" + ii + ") not empty when reading new " + label + " (" + BufferInt( buff, label_len ) + ") -- skipping newer item");
      }
      return true;
    }
    return false;
  }
  LoadableInt( int ii ) {
    this.ii = ii;
  }
  public String toString() {
    return Integer.toString(ii);
  }
};
 /*
 *
 *   This file is part of the pdftk port to java
 *
 *   Copyright (c) Marc Vinyals 2017-2018
 *
 *   The program is a java port of PDFtk, the PDF Toolkit
 *   Copyright (c) 2003-2013 Steward and Lee, LLC
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   The program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.gitlab.pdftk_java;

class LoadableString {
  String ss= null;
  static String BufferString( String buff, int buff_ii ) {
    //while( buff[buff_ii] && isspace(buff[buff_ii]) ) { ++buff_ii; }
    if (buff_ii>=buff.length()) return "";
    if( Character.isWhitespace(buff.charAt(buff_ii)) ) // one or no spaces before data
      ++buff_ii;
    return( buff.substring( buff_ii ) );
  }
  boolean LoadString(String buff, String label) {
    int label_len= label.length();
    if ( buff.startsWith(label) ) {
      if( ss== null ) {
        ss= BufferString( buff, label_len );
      }
      else { // warning
        System.err.println("pdftk Warning: " + label + " (" + ss + ") already loaded when reading new " + label + " (" + BufferString( buff, label_len ) + ") -- skipping newer item");
      }
      return true;
    }
    return false;
  }
  LoadableString(String ss) {
    this.ss = ss;
  }
  public String toString() {
    return ss;
  }
};
 /*
 *
 *   This file is part of the pdftk port to java
 *
 *   Copyright (c) Marc Vinyals 2017-2018
 *
 *   The program is a java port of PDFtk, the PDF Toolkit
 *   Copyright (c) 2003-2013 Steward and Lee, LLC
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   The program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.gitlab.pdftk_java;

class PdfBookmark {
  static final String m_prefix= "Bookmark";
  static final String m_begin_mark= "BookmarkBegin";
  static final String m_title_label= "BookmarkTitle:";
  static final String m_level_label= "BookmarkLevel:";
  static final String m_page_number_label= "BookmarkPageNumber:";
  //static const string m_empty_string;

  String m_title = null;
  int m_level = -1;
  int m_page_num = -1; // zero means no destination
  boolean valid() { return( 0< m_level && 0<= m_page_num && m_title!= null ); }

  public String toString() {
    return m_begin_mark + System.lineSeparator() +
      m_title_label + " " + m_title + System.lineSeparator() +
      m_level_label + " " + m_level + System.lineSeparator() +
      m_page_number_label + " " + m_page_num + System.lineSeparator();
  }

  boolean loadTitle( String buff ) {
    LoadableString loader = new LoadableString( m_title );
    boolean success = loader.LoadString( buff, m_title_label );
    m_title = loader.ss;
    return success;
  }
  boolean loadLevel( String buff ) {
    LoadableInt loader = new LoadableInt( m_level );
    boolean success = loader.LoadInt( buff, m_level_label );
    m_level = loader.ii;
    return success;
  }
  boolean loadPageNum( String buff ) {
    LoadableInt loader = new LoadableInt( m_page_num );
    boolean success = loader.LoadInt( buff, m_page_number_label );
    m_page_num = loader.ii;
    return success;
  }
  
};
//
//ostream& operator<<( ostream& ss, const PdfBookmark& bb );
 /*
 *   This file is part of the pdftk port to java
 *
 *   Copyright (c) Marc Vinyals 2017-2018
 *
 *   The program is a java port of PDFtk, the PDF Toolkit
 *   Copyright (c) 2003-2013 Steward and Lee, LLC
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   The program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.gitlab.pdftk_java;

import java.util.Collections;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.Iterator;
import java.util.Scanner;

import java.io.InputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.FileNotFoundException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.IOException;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import pdftk.com.lowagie.text.Document;
import pdftk.com.lowagie.text.DocumentException;
import pdftk.com.lowagie.text.Rectangle;

import pdftk.com.lowagie.text.pdf.AcroFields;
import pdftk.com.lowagie.text.pdf.FdfReader;
import pdftk.com.lowagie.text.pdf.FdfWriter;
import pdftk.com.lowagie.text.pdf.XfdfReader;

import pdftk.com.lowagie.text.pdf.PdfAnnotation;
import pdftk.com.lowagie.text.pdf.PdfArray;
import pdftk.com.lowagie.text.pdf.PdfBoolean;
import pdftk.com.lowagie.text.pdf.PdfContentByte;
import pdftk.com.lowagie.text.pdf.PdfCopy;
import pdftk.com.lowagie.text.pdf.PdfDictionary;
import pdftk.com.lowagie.text.pdf.PdfFileSpecification;
import pdftk.com.lowagie.text.pdf.PdfImportedPage;
import pdftk.com.lowagie.text.pdf.PdfIndirectReference;
import pdftk.com.lowagie.text.pdf.PdfName;
import pdftk.com.lowagie.text.pdf.PdfNameTree;
import pdftk.com.lowagie.text.pdf.PdfNumber;
import pdftk.com.lowagie.text.pdf.PdfObject;
import pdftk.com.lowagie.text.pdf.PdfReader;
import pdftk.com.lowagie.text.pdf.PdfStamperImp;
import pdftk.com.lowagie.text.pdf.PdfWriter;

class TK_Session {
  
  boolean m_valid_b = false;
  boolean m_authorized_b = true;
  boolean m_input_pdf_readers_opened_b = false; // have m_input_pdf readers been opened?
  boolean m_verbose_reporting_b = false;
  boolean m_ask_about_warnings_b = pdftk.ASK_ABOUT_WARNINGS; // set default at compile-time

  //typedef unsigned long PageNumber;
  enum PageRotate { NORTH(0), EAST(90), SOUTH(180), WEST(270);
                    final int value;
                    PageRotate(int value) { this.value = value; }
  }; // DF rotation
  //typedef bool PageRotateAbsolute; // DF absolute / relative rotation

  static class InputPdf {
    String m_filename = "";
    String m_password = "";
    boolean m_authorized_b = true;

    // keep track of which pages get output under which readers,
    // because one reader mayn't output the same page twice;
    static class PagesReader {
      HashSet<Integer> first = new HashSet<Integer>();
      PdfReader second;
      PagesReader ( PdfReader second ) { this.second = second; }
    };
    ArrayList<PagesReader> m_readers = new ArrayList<PagesReader>();

    int m_num_pages = 0;

  };
  // pack input PDF in the order they're given on the command line
  ArrayList<InputPdf> m_input_pdf = new ArrayList<InputPdf>();
  //typedef vector< InputPdf >::size_type InputPdfIndex;

  // store input PDF handles here
  HashMap<String, Integer> m_input_pdf_index = new HashMap<String, Integer>();

InputPdf.PagesReader add_reader( InputPdf input_pdf_p, boolean keep_artifacts_b ) {
  boolean open_success_b= true;
  InputPdf.PagesReader pr= null;

  try {
    PdfReader reader= null;
    if( input_pdf_p.m_filename.equals( "PROMPT" ) ) {
      input_pdf_p.m_filename= pdftk.prompt_for_filename( "Please enter a filename for an input PDF:");
    }
    if( input_pdf_p.m_password.isEmpty() ) {
      reader= new PdfReader( input_pdf_p.m_filename );
    }
    else {
      if( input_pdf_p.m_password.equals( "PROMPT" ) ) {
        input_pdf_p.m_password = pdftk.prompt_for_password( "open", "the input PDF:\n   "+ input_pdf_p.m_filename );
      }

      byte[] password= passwords.utf8_password_to_pdfdoc( input_pdf_p.m_password,
                                         false ); // allow user to enter greatest selection of chars

      if ( password != null ) {
        reader= new PdfReader( input_pdf_p.m_filename, password );
        if( reader== null ) {
          System.err.println( "Error: Unexpected null from open_reader()" );
          return null; // <--- return
        }
      }
      else { // bad password
        System.err.println( "Error: Password used to decrypt input PDF:" );
        System.err.println( "   " + input_pdf_p.m_filename );
        System.err.println( "   includes invalid characters." );
        return null; // <--- return
      }
    }
    
    if( !keep_artifacts_b ) {
      // generally useful operations
      reader.consolidateNamedDestinations();
      reader.removeUnusedObjects();
      //reader->shuffleSubsetNames(); // changes the PDF subset names, but not the PostScript font names
    }

    input_pdf_p.m_num_pages= reader.getNumberOfPages();

    // keep tally of which pages have been laid claim to in this reader;
    // when creating the final PDF, this tally will be decremented
    pr = new InputPdf.PagesReader( reader );
    input_pdf_p.m_readers.add( pr );

    input_pdf_p.m_authorized_b= true; // instead of:  ( !reader->encrypted || reader->ownerPasswordUsed );

    if ( open_success_b && reader.encrypted && !reader.ownerPasswordUsed )
    {
      System.err.println( "WARNING: The creator of the input PDF:" );
      System.err.println( "   " + input_pdf_p.m_filename );
      System.err.println( "   has set an owner password (which is not required to handle this PDF)." );
      System.err.println( "   You did not supply this password. Please respect any copyright." );
    }

    if( !input_pdf_p.m_authorized_b ) {
      open_success_b= false;
    }
  }
  catch( IOException ioe_p ) { // file open error
    if( ioe_p.getMessage().equals( "Bad password" ) ) {
      input_pdf_p.m_authorized_b= false;
    }
    else if( ioe_p.getMessage().indexOf( "not found" ) != -1 ) {
      System.err.println( "Error: Unable to find file." );
    }
    else { // unexpected error
      System.err.println( "Error: Unexpected Exception in open_reader()" );
      ioe_p.printStackTrace(); // debug
    }
    open_success_b= false;
  }
  catch( Throwable t_p ) { // unexpected error
    System.err.println( "Error: Unexpected Exception in open_reader()" );
    t_p.printStackTrace(); // debug

    open_success_b= false;            
  }

  if( !input_pdf_p.m_authorized_b && m_ask_about_warnings_b ) {
    // prompt for a new password
    System.err.println( "The password you supplied for the input PDF:" );
    System.err.println( "   " + input_pdf_p.m_filename );
    System.err.println( "   did not work.  This PDF is encrypted, and you must supply the" );
    System.err.println( "   owner or the user password to open it. To quit, enter a blank" );
    System.err.println( "   password at the next prompt." );

    input_pdf_p.m_password = pdftk.prompt_for_password( "open", "the input PDF:\n   "+ input_pdf_p.m_filename );
    if( !input_pdf_p.m_password.isEmpty() ) { // reset flags try again
      input_pdf_p.m_authorized_b= true;
      return( add_reader(input_pdf_p) ); // <--- recurse, return
    }
  }

  // report
  if( !open_success_b ) { // file open error
    System.err.println( "Error: Failed to open PDF file: " );
    System.err.println( "   " + input_pdf_p.m_filename );
    if( !input_pdf_p.m_authorized_b ) {
      System.err.println( "   OWNER OR USER PASSWORD REQUIRED, but not given (or incorrect)" );
    }
  }

  // update session state
  m_authorized_b= m_authorized_b && input_pdf_p.m_authorized_b;

  return open_success_b ? pr : null;
}
  InputPdf.PagesReader add_reader( InputPdf input_pdf_p ) {
    return add_reader( input_pdf_p, false );
  }

boolean open_input_pdf_readers() {
  // try opening the input files and init m_input_pdf readers
  boolean open_success_b= true;

  if( !m_input_pdf_readers_opened_b ) {
    if( m_operation== keyword.filter_k && m_input_pdf.size()== 1 ) {
      // don't touch input pdf -- preserve artifacts
      open_success_b= ( add_reader( m_input_pdf.get(0), true ) != null );
    }
    else {
      for( InputPdf it : m_input_pdf ) {
        open_success_b = ( add_reader( it ) != null ) && open_success_b;
      }
    }
    m_input_pdf_readers_opened_b= open_success_b;
  }

  return open_success_b;
}

  
  ArrayList<String> m_input_attach_file_filename = new ArrayList<String>();
  int m_input_attach_file_pagenum = 0;

  String m_update_info_filename = "";
  boolean m_update_info_utf8_b = false;
  String m_update_xmp_filename = "";

  enum keyword {
    none_k,

    // the operations
    cat_k, // combine pages from input PDFs into a single output
    shuffle_k, // like cat, but interleaves pages from input ranges
    burst_k, // split a single, input PDF into individual pages
    barcode_burst_k, // barcode_burst project
    filter_k, // apply 'filters' to a single, input PDF based on output args
    dump_data_k, // no PDF output
    dump_data_utf8_k,
    dump_data_fields_k,
    dump_data_fields_utf8_k,
    dump_data_annots_k,
    generate_fdf_k,
    unpack_files_k, // unpack files from input; no PDF output

    // these are treated the same as operations,
    // but they are processed using the filter operation
    fill_form_k, // read FDF file and fill PDF form fields
    attach_file_k, // attach files to output
    update_info_k,
    update_info_utf8_k, // if info isn't utf-8, it is encoded using xml entities
    update_xmp_k,
    background_k, // promoted from output option to operation in pdftk 1.10
    multibackground_k, // feature added by Bernhard R. Link <brlink@debian.org>, Johann Felix Soden <johfel@gmx.de>
    stamp_k,
    multistamp_k, // feature added by Bernhard R. Link <brlink@debian.org>, Johann Felix Soden <johfel@gmx.de>
    rotate_k, // rotate given pages as directed

    // optional attach_file argument
    attach_file_to_page_k,

    // cat page range keywords
    end_k,
    even_k,
    odd_k,

    output_k,

    // encryption & decryption
    input_pw_k,
    owner_pw_k,
    user_pw_k,
    user_perms_k,

    // output arg.s, only
    encrypt_40bit_k,
    encrypt_128bit_k,

    // user permissions
    perm_printing_k,
    perm_modify_contents_k,
    perm_copy_contents_k,
    perm_modify_annotations_k,
    perm_fillin_k,
    perm_screen_readers_k,
    perm_assembly_k,
    perm_degraded_printing_k,
    perm_all_k,

    // filters
    filt_uncompress_k,
    filt_compress_k,

    // forms
    flatten_k,
    need_appearances_k,
    drop_xfa_k,
    drop_xmp_k,
    keep_first_id_k,
    keep_final_id_k,

    // pdftk options
    verbose_k,
    dont_ask_k,
    do_ask_k,

    // page rotation
    rot_north_k,
    rot_east_k,
    rot_south_k,
    rot_west_k,
    rot_left_k,
    rot_right_k,
    rot_upside_down_k
  };
static keyword is_keyword( String ss ) {
  ss = ss.toLowerCase();

  // operations
  if( ss.equals( "cat" ) ) {
    return keyword.cat_k;
  }
  else if( ss.equals( "shuffle" ) ) {
    return keyword.shuffle_k;
  }
  else if( ss.equals( "burst" ) ) {
    return keyword.burst_k;
  }
  else if( ss.equals( "filter" ) ) {
    return keyword.filter_k;
  }
  else if( ss.equals( "dump_data" ) ||
           ss.equals( "dumpdata" ) ||
           ss.equals( "data_dump" ) ||
           ss.equals( "datadump" ) ) {
    return keyword.dump_data_k;
  }
  else if( ss.equals( "dump_data_utf8" ) ) {
    return keyword.dump_data_utf8_k;
  }
  else if( ss.equals( "dump_data_fields" ) ) {
    return keyword.dump_data_fields_k;
  }
  else if( ss.equals( "dump_data_fields_utf8" ) ) {
    return keyword.dump_data_fields_utf8_k;
  }
  else if( ss.equals( "dump_data_annots" ) ) {
    return keyword.dump_data_annots_k;
  }
  else if( ss.equals( "generate_fdf" ) ||
           ss.equals( "fdfgen" ) ||
           ss.equals( "fdfdump" ) ||
           ss.equals( "dump_data_fields_fdf" ) ) {
    return keyword.generate_fdf_k;
  }
  else if( ss.equals( "fill_form" ) ||
           ss.equals( "fillform" ) ) {
    return keyword.fill_form_k;
  }
  else if( ss.equals( "attach_file" ) ||
           ss.equals( "attach_files" ) ||
           ss.equals( "attachfile" ) ) {
    return keyword.attach_file_k;
  }
  else if( ss.equals( "unpack_file" ) ||
           ss.equals( "unpack_files" ) ||
           ss.equals( "unpackfiles" ) ) {
    return keyword.unpack_files_k;
  }
  else if( ss.equals( "update_info" ) ||
           ss.equals( "undateinfo" ) ) {
    return keyword.update_info_k;
  }
  else if( ss.equals( "update_info_utf8" ) ||
           ss.equals( "undateinfoutf8" ) ) {
    return keyword.update_info_utf8_k;
  }
  /* requires more testing and work
  else if( strcmp( ss_copy, "update_xmp" ) ||
           strcmp( ss_copy, "undatexmp" ) ) {
    return update_xmp_k;
  }
  */
  else if( ss.equals( "background" ) ) {
    // pdftk 1.10: making background an operation
    // (and preserving old behavior for backwards compatibility)
    return keyword.background_k;
  }
  else if( ss.equals( "multibackground" ) ) {
    return keyword.multibackground_k;
  }
  else if( ss.equals( "multistamp" ) ) {
    return keyword.multistamp_k;
  }
  else if( ss.equals( "stamp" ) ) {
    return keyword.stamp_k;
  }
  else if( ss.equals( "rotate" ) ) {
    return keyword.rotate_k;
  }
  
  // cat range keywords
  else if( ss.startsWith( "end" ) ) { // note: strncmp
    return keyword.end_k;
  }
  else if( ss.startsWith( "even" ) ) { // note: strncmp
    return keyword.even_k;
  }
  else if( ss.startsWith( "odd" ) ) { // note: strncmp
    return keyword.odd_k;
  }

  // file attachment option
  else if( ss.equals( "to_page" ) ||
           ss.equals( "topage" ) ) {
    return keyword.attach_file_to_page_k;
  }

  else if( ss.equals( "output" ) ) {
    return keyword.output_k;
  }

  // encryption & decryption; depends on context
  else if( ss.equals( "owner_pw" ) ||
           ss.equals( "ownerpw" ) ) {
    return keyword.owner_pw_k;
  }
  else if( ss.equals( "user_pw" ) ||
           ss.equals( "userpw" ) ) {
    return keyword.user_pw_k;
  }
  else if( ss.equals( "input_pw" ) ||
           ss.equals( "inputpw" ) ) {
    return keyword.input_pw_k;
  }
  else if( ss.equals( "allow" ) ) {
    return keyword.user_perms_k;
  }

  // expect these only in output section
  else if( ss.equals( "encrypt_40bit" ) ||
           ss.equals( "encrypt_40bits" ) ||
           ss.equals( "encrypt40bit" ) ||
           ss.equals( "encrypt40bits" ) ||
           ss.equals( "encrypt40_bit" ) ||
           ss.equals( "encrypt40_bits" ) ||
           ss.equals( "encrypt_40_bit" ) ||
           ss.equals( "encrypt_40_bits" ) ) {
    return keyword.encrypt_40bit_k;
  }
  else if( ss.equals( "encrypt_128bit" ) ||
           ss.equals( "encrypt_128bits" ) ||
           ss.equals( "encrypt128bit" ) ||
           ss.equals( "encrypt128bits" ) ||
           ss.equals( "encrypt128_bit" ) ||
           ss.equals( "encrypt128_bits" ) ||
           ss.equals( "encrypt_128_bit" ) ||
           ss.equals( "encrypt_128_bits" ) ) {
    return keyword.encrypt_128bit_k;
  }
  
  // user permissions; must follow user_perms_k;
  else if( ss.equals( "printing" ) ) {
    return keyword.perm_printing_k;
  }
  else if( ss.equals( "modifycontents" ) ) {
    return keyword.perm_modify_contents_k;
  }
  else if( ss.equals( "copycontents" ) ) {
    return keyword.perm_copy_contents_k;
  }
  else if( ss.equals( "modifyannotations" ) ) {
    return keyword.perm_modify_annotations_k;
  }
  else if( ss.equals( "fillin" ) ) {
    return keyword.perm_fillin_k;
  }
  else if( ss.equals( "screenreaders" ) ) {
    return keyword.perm_screen_readers_k;
  }
  else if( ss.equals( "assembly" ) ) {
    return keyword.perm_assembly_k;
  }
  else if( ss.equals( "degradedprinting" ) ) {
    return keyword.perm_degraded_printing_k;
  }
  else if( ss.equals( "allfeatures" ) ) {
    return keyword.perm_all_k;
  }
  else if( ss.equals( "uncompress" ) ) {
    return keyword.filt_uncompress_k;
  }
  else if( ss.equals( "compress" ) ) {
    return keyword.filt_compress_k;
  }
  else if( ss.equals( "flatten" ) ) {
    return keyword.flatten_k;
  }
  else if( ss.equals( "need_appearances" ) ) {
    return keyword.need_appearances_k;
  }
  else if( ss.equals( "drop_xfa" ) ) {
    return keyword.drop_xfa_k;
  }
  else if( ss.equals( "drop_xmp" ) ) {
    return keyword.drop_xmp_k;
  }
  else if( ss.equals( "keep_first_id" ) ) {
    return keyword.keep_first_id_k;
  }
  else if( ss.equals( "keep_final_id" ) ) {
    return keyword.keep_final_id_k;
  }
  else if( ss.equals( "verbose" ) ) {
    return keyword.verbose_k;
  }
  else if( ss.equals( "dont_ask" ) ||
           ss.equals( "dontask" ) ) {
    return keyword.dont_ask_k;
  }
  else if( ss.equals( "do_ask" ) ) {
    return keyword.do_ask_k;
  }

  // more cat range keywords
  else if( ss.equals( "north" ) ) {
    return keyword.rot_north_k;
  }
  else if( ss.equals( "south" ) ) {
    return keyword.rot_south_k;
  }
  else if( ss.equals( "east" ) ) {
    return keyword.rot_east_k;
  }
  else if( ss.equals( "west" ) ) {
    return keyword.rot_west_k;
  }
  else if( ss.equals( "left" ) ) {
    return keyword.rot_left_k;
  }
  else if( ss.equals( "right" ) ) {
    return keyword.rot_right_k;
  }
  else if( ss.equals( "down" ) ) {
    return keyword.rot_upside_down_k;
  }
  
  return keyword.none_k;
}

static keyword consume_keyword( StringBuilder ssb ) {
  String ss = new String(ssb).toLowerCase();
  // cat range keywords
  if( ss.startsWith( "end" ) ) { // note: strncmp
    ssb.delete(0,3);
    return keyword.end_k;
  }
  else if( ss.startsWith( "even" ) ) { // note: strncmp
    ssb.delete(0,4);
    return keyword.even_k;
  }
  else if( ss.startsWith( "odd" ) ) { // note: strncmp
    ssb.delete(0,3);
    return keyword.odd_k;
  }
  else {
    ssb.setLength(0);
    return is_keyword( ss );
  }
}

  keyword m_operation = keyword.none_k;

  class PageRef {
    int m_input_pdf_index;
    int m_page_num; // 1-based
    PageRotate m_page_rot; // DF rotation
    boolean m_page_abs; // DF absolute / relative rotation

    PageRef( int input_pdf_index, int page_num) {
      m_input_pdf_index = input_pdf_index;
      m_page_num = page_num;
      m_page_rot = PageRotate.NORTH;
      m_page_abs = false;
    }
    PageRef( int input_pdf_index, int page_num,
             PageRotate page_rot, boolean page_abs ) {
      m_input_pdf_index = input_pdf_index;
      m_page_num = page_num;
      m_page_rot = page_rot;
      m_page_abs = page_abs;
    }
  };
  ArrayList<ArrayList<PageRef>> m_page_seq = new ArrayList<ArrayList<PageRef>>(); // one vector for each given page range

  String m_form_data_filename = "";
  String m_background_filename = "";
  String m_stamp_filename = "";
  String m_output_filename = "";
  boolean m_output_utf8_b = false;
  String m_output_owner_pw = "";
  String m_output_user_pw = "";
  int m_output_user_perms = 0;
  boolean m_multistamp_b = false; // use all pages of input stamp PDF, not just the first
  boolean m_multibackground_b = false; // use all pages of input background PDF, not just the first
  boolean m_output_uncompress_b = false;
  boolean m_output_compress_b = false;
  boolean m_output_flatten_b = false;
  boolean m_output_need_appearances_b = false;
  boolean m_output_drop_xfa_b = false;
  boolean m_output_drop_xmp_b = false;
  boolean m_output_keep_first_id_b = false;
  boolean m_output_keep_final_id_b = false;
  boolean m_cat_full_pdfs_b = true; // we are merging entire docs, not select pages

  enum encryption_strength {
    none_enc,
    bits40_enc,
    bits128_enc
  };
  encryption_strength m_output_encryption_strength = encryption_strength.none_enc;

  TK_Session( String[] args )
{
  ArgState arg_state = ArgState.input_files_e;

  // set one and only one to true when p/w used; use to
  // enforce rule that either all p/w use handles or no p/w use handles
  boolean password_using_handles_not_b= false;
  boolean password_using_handles_b= false;

  int password_input_pdf_index= 0;

  boolean fail_b= false;

  // first, look for our "dont_ask" or "do_ask" keywords, since this
  // setting must be known before we begin opening documents, etc.
  for( String argv : args ) {
    keyword kw= is_keyword( argv );
    if( kw== keyword.dont_ask_k ) {
      m_ask_about_warnings_b= false;
    }
    else if( kw== keyword.do_ask_k ) {
      m_ask_about_warnings_b= true;
    }
  }

  // iterate over cmd line arguments
  for( String argv : args ) {

    if (fail_b || arg_state== ArgState.done_e) break;
    keyword arg_keyword= is_keyword( argv );

    // these keywords can be false hits because of their loose matching requirements;
    // since they are suffixes to page ranges, their appearance here is most likely a false match;
    if( arg_keyword== keyword.end_k ||
        arg_keyword== keyword.even_k ||
        arg_keyword== keyword.odd_k )
      {
        arg_keyword= keyword.none_k;
      }  

    switch( arg_state ) {

    case input_files_e: 
    case input_pw_e: {
      // look for keywords that would advance our state,
      // and then handle the specifics of the above cases

      if( arg_keyword== keyword.input_pw_k ) { // input PDF passwords keyword

        arg_state= ArgState.input_pw_e;
      }
      else if( arg_keyword== keyword.cat_k ) {
        m_operation= keyword.cat_k;
        arg_state= ArgState.page_seq_e; // collect page sequeces
      }
      else if( arg_keyword== keyword.shuffle_k ) {
        m_operation= keyword.shuffle_k;
        arg_state= ArgState.page_seq_e; // collect page sequeces
      }
      else if( arg_keyword== keyword.burst_k ) {
        m_operation= keyword.burst_k;
        arg_state= ArgState.output_args_e; // makes "output <fn>" bit optional
      }
      else if( arg_keyword== keyword.filter_k ) {
        m_operation= keyword.filter_k;
        arg_state= ArgState.output_e; // look for an output filename
      }
      else if( arg_keyword== keyword.dump_data_k ) {
        m_operation= keyword.dump_data_k;
        arg_state= ArgState.output_e;
      }
      else if( arg_keyword== keyword.dump_data_utf8_k ) {
        m_operation= keyword.dump_data_k;
        m_output_utf8_b= true;
        arg_state= ArgState.output_e;
      }
      else if( arg_keyword== keyword.dump_data_fields_k ) {
        m_operation= keyword.dump_data_fields_k;
        arg_state= ArgState.output_e;
      }
      else if( arg_keyword== keyword.dump_data_fields_utf8_k ) {
        m_operation= keyword.dump_data_fields_k;
        m_output_utf8_b= true;
        arg_state= ArgState.output_e;
      }
      else if( arg_keyword== keyword.dump_data_k ) {
        m_operation= keyword.dump_data_k;
        arg_state= ArgState.output_e;
      }
      else if( arg_keyword== keyword.dump_data_annots_k ) {
        m_operation= keyword.dump_data_annots_k;
        arg_state= ArgState.output_e;
      }
      else if( arg_keyword== keyword.generate_fdf_k ) {
        m_operation= keyword.generate_fdf_k;
        m_output_utf8_b= true;
        arg_state= ArgState.output_e;
      }
      else if( arg_keyword== keyword.fill_form_k ) {
        m_operation= keyword.filter_k;
        arg_state= ArgState.form_data_filename_e; // look for an FDF filename
      }
      else if( arg_keyword== keyword.attach_file_k ) {
        m_operation= keyword.filter_k;
        arg_state= ArgState.attach_file_filename_e;
      }
      else if( arg_keyword== keyword.attach_file_to_page_k ) {
        arg_state= ArgState.attach_file_pagenum_e;
      }
      else if( arg_keyword== keyword.unpack_files_k ) {
        m_operation= keyword.unpack_files_k;
        arg_state= ArgState.output_e;
      }
      else if( arg_keyword== keyword.update_info_k ) {
        m_operation= keyword.filter_k;
        m_update_info_utf8_b= false;
        arg_state= ArgState.update_info_filename_e;
      }
      else if( arg_keyword== keyword.update_info_utf8_k ) {
        m_operation= keyword.filter_k;
        m_update_info_utf8_b= true;
        arg_state= ArgState.update_info_filename_e;
      }
      /*
      else if( arg_keyword== update_xmp_k ) {
        m_operation= filter_k;
        arg_state= update_xmp_filename_e;
      }
      */
      else if( arg_keyword== keyword.background_k ) {
        m_operation= keyword.filter_k;
        arg_state= ArgState.background_filename_e;
      }
      else if( arg_keyword== keyword.multibackground_k ) {
        m_operation= keyword.filter_k;
        m_multibackground_b= true;
        arg_state= ArgState.background_filename_e;
      }
      else if( arg_keyword== keyword.stamp_k ) {
        m_operation= keyword.filter_k;
        arg_state= ArgState.stamp_filename_e;
      }
      else if( arg_keyword== keyword.multistamp_k ) {
        m_operation= keyword.filter_k;
        m_multistamp_b= true;
        arg_state= ArgState.stamp_filename_e;
      }
      else if( arg_keyword== keyword.rotate_k ) {
        m_operation= keyword.filter_k;
        arg_state= ArgState.page_seq_e; // collect page sequeces
      }
      else if( arg_keyword== keyword.output_k ) { // we reached the output section
        arg_state= ArgState.output_filename_e;
      }
      else if( arg_keyword== keyword.none_k ) {
        // here is where the two cases (input_files_e, input_pw_e) diverge

        String handle, data;
        {
          Pattern p = Pattern.compile("(?:([A-Z]+)=)?(.*)");
          Matcher m = p.matcher(argv);
          m.matches();
          handle = m.group(1);
          data = m.group(2);
        }

        if( arg_state== ArgState.input_files_e ) {
          // input_files_e:
          // expecting input handle=filename pairs, or
          // an input filename w/o a handle
          //
          // treat argv[ii] like an optional input handle and filename
          // like this: [<handle>=]<filename>

          InputPdf input_pdf = new InputPdf();
          input_pdf.m_filename= data;

          if( handle == null ) { // no handle
            m_input_pdf.add( input_pdf );
          }
          else { // use given handle for filename; test, first

            // look up handle
            Integer it = m_input_pdf_index.get( handle );
            if( it!= null ) { // error: alreay in use

              System.err.println("Error: Handle given here: ");
              System.err.println("      " + argv);
              System.err.println("   is already associated with: ");
              System.err.println("      " + m_input_pdf.get(it).m_filename);
              System.err.println("   Exiting.");
              fail_b= true;
            }
            else { // add handle/filename association
              m_input_pdf.add( input_pdf );
              m_input_pdf_index.put(handle, m_input_pdf.size()- 1);
            }
          }
        } // end: arg_state== input_files_e

        else if( arg_state== ArgState.input_pw_e ) {
          // expecting input handle=password pairs, or
          // an input PDF password w/o a handle
          //
          // treat argv[ii] like an input handle and password
          // like this <handle>=<password>; if no handle is
          // given, assign passwords to input in order;

          // if handles not used for input PDFs, then assume
          // any equals signs found in p/w are part of p/w
          if( m_input_pdf_index.size()== 0 ) {
            handle= "";
            data= argv;
          }

          if( handle.isEmpty() ) { // no equal sign; try using default handles
            if( password_using_handles_b ) { // error: expected a handle

              System.err.println("Error: Expected a user-supplied handle for this input");
              System.err.println("   PDF password: " + argv);
              System.err.println();
              System.err.println("   Handles must be supplied with ~all~ input");
              System.err.println("   PDF passwords, or with ~no~ input PDF passwords.");
              System.err.println("   If no handles are supplied, then passwords are applied");
              System.err.println("   according to input PDF order.");
              System.err.println();
              System.err.println("   Handles are given like this: <handle>=<password>, and");
              System.err.println("   they must be single, upper case letters, like: A, B, etc.");
              fail_b= true;
            }
            else {
              password_using_handles_not_b= true;

              if( password_input_pdf_index< m_input_pdf.size() ) {
                m_input_pdf.get(password_input_pdf_index).m_password= argv;
                ++password_input_pdf_index;
              }
              else { // error
                System.err.println("Error: more input passwords than input PDF documents.");
                System.err.println("   Exiting.");
                fail_b= true;
              }
            }
          }
          else { // handle given; use for password
            if( password_using_handles_not_b ) { // error; remark and set fail_b

              System.err.println("Error: Expected ~no~ user-supplied handle for this input");
              System.err.println("   PDF password: " + argv);
              System.err.println();
              System.err.println("   Handles must be supplied with ~all~ input");
              System.err.println("   PDF passwords, or with ~no~ input PDF passwords.");
              System.err.println("   If no handles are supplied, then passwords are applied");
              System.err.println("   according to input PDF order.");
              System.err.println();
              System.err.println("   Handles are given like this: <handle>=<password>, and");
              System.err.println("   they must be single, upper case letters, like: A, B, etc.");
              fail_b= true;
            }
            else {
              password_using_handles_b= true;

              // look up this handle
              Integer it = m_input_pdf_index.get( handle );
              if( it!= null ) { // found

                if( m_input_pdf.get(it).m_password.isEmpty() ) {
                  m_input_pdf.get(it).m_password= data; // set
                }
                else { // error: password already given

                  System.err.println("Error: Handle given here: ");
                  System.err.println("      " + argv);
                  System.err.println("   is already associated with this password: ");
                  System.err.println("      " + m_input_pdf.get(it).m_password);
                  System.err.println("   Exiting.");
                  fail_b= true;
                }
              }
              else { // error: no input file matches this handle

                System.err.println("Error: Password handle: " + argv);
                System.err.println("   is not associated with an input PDF file.");
                System.err.println("   Exiting.");
                fail_b= true;
              }
            }
          }
        } // end: arg_state== input_pw_e
        else { // error
          System.err.println("Error: Internal error: unexpected arg_state.  Exiting.");
          fail_b= true;
        }
      }
      else { // error: unexpected keyword; remark and set fail_b
        System.err.println("Error: Unexpected command-line data: ");
        System.err.println("      " + argv);
        if( arg_state== ArgState.input_files_e ) {
          System.err.println("   where we were expecting an input PDF filename,");
          System.err.println("   operation (e.g. \"cat\") or \"input_pw\".  Exiting.");
        }
        else {
          System.err.println("   where we were expecting an input PDF password");
          System.err.println("   or operation (e.g. \"cat\").  Exiting.");
        }
        fail_b= true;
      }
    }
    break;

    case page_seq_e: {
      if( m_page_seq.isEmpty() ) {
        // we just got here; validate input filenames

        if( m_input_pdf.isEmpty() ) { // error; remark and set fail_b
          System.err.println("Error: No input files.  Exiting.");
          fail_b= true;
          break;
        }

        // try opening input PDF readers
        if( !open_input_pdf_readers() ) { // failure
          fail_b= true;
          break;
        }
      } // end: first pass init. pdf files

      if( arg_keyword== keyword.output_k ) {
        arg_state= ArgState.output_filename_e; // advance state
      }
      else if( arg_keyword== keyword.none_k || 
               arg_keyword== keyword.end_k )
        { // treat argv[ii] like a page sequence

          boolean even_pages_b= false;
          boolean odd_pages_b= false;

          Pattern p = Pattern.compile("([A-Z]*)(r?)([0-9]*)([^-]*)(-?)(r?)([0-9]*)(.*)");
          Matcher m = p.matcher(argv);
          m.matches();
          String handle = m.group(1);
          String pre_reverse = m.group(2);
          String pre_range = m.group(3);
          String pre_keywords = m.group(4);
          String hyphen = m.group(5);
          String post_reverse = m.group(6);
          String post_range = m.group(7);
          String post_keywords = m.group(8);

          int range_pdf_index= 0; { // defaults to first input document
            if( !handle.isEmpty() ) {
              // validate handle
              Integer it = m_input_pdf_index.get( handle );
              if( it== null ) { // error

                System.err.println("Error: Given handle has no associated file: ");
                System.err.println("   " + handle + ", used here: " + argv);
                System.err.println("   Exiting.");
                fail_b= true;
                break;
              }
              else {
                range_pdf_index= it;
              }
            }
          }

          // DF declare rotate vars
          PageRotate page_rotate= PageRotate.NORTH;
          boolean page_rotate_absolute= false;

          ////
          // beginning of page range

          boolean reverse_b= ( !pre_reverse.isEmpty() ); // single lc 'r' before page range

          // parse digits
          int page_num_beg= 0;
          boolean page_num_beg_out_of_range_b= false;
          StringBuilder trailing_keywords= new StringBuilder(pre_keywords);
          if ( !pre_range.isEmpty() ) {
            page_num_beg= Integer.parseInt(pre_range);
          }
          else if( !pre_keywords.isEmpty() ) { // look for usable keyword
            arg_keyword= consume_keyword( trailing_keywords );

            if( arg_keyword== keyword.end_k ) { // may be a single page ref or beg of range
              page_num_beg= m_input_pdf.get(range_pdf_index).m_num_pages;
            }
            else if ( !hyphen.isEmpty() ) {
              // error: can't have numbers ~and~ a keyword at the beginning of range
              System.err.println("Error: Unexpected combination of digits and text in");
              System.err.println("   page range start, here: " + argv);
              System.err.println("   Exiting.");
              fail_b= true;
              break;
            }
            else {
              // reset trailing_keywords again, since none have been handled yet,
              // but call to 'is_keyword()' above might have consumed one
              trailing_keywords = new StringBuilder(pre_keywords);
            }
          }

          if( m_input_pdf.get(range_pdf_index).m_num_pages< page_num_beg ) {
            // error: page number out of range
            System.err.println("Error: Range start page number exceeds size of PDF");
            System.err.println("   here: " + argv);
            System.err.println("   input PDF has: " + m_input_pdf.get(range_pdf_index).m_num_pages + " pages.");
            System.err.println("   Exiting.");
            fail_b= true;
            break;
          }

          if( reverse_b ) // above test ensures good value here
            page_num_beg= m_input_pdf.get(range_pdf_index).m_num_pages- page_num_beg+ 1;

          ////
          // end of page range

          int page_num_end= page_num_beg; // default value
          if( !hyphen.isEmpty() ) { // process second half of page range

            trailing_keywords = new StringBuilder(post_keywords);
            
            reverse_b= ( !post_reverse.isEmpty() ); // single lc 'r' before page range

            // parse digits
            if ( !post_range.isEmpty() ) {
              page_num_end= Integer.parseInt(post_range);
            }
            else if( !post_keywords.isEmpty() ) { // look for usable keyword
              arg_keyword= consume_keyword( trailing_keywords );
              
              if( arg_keyword== keyword.end_k ) {
                page_num_end= m_input_pdf.get(range_pdf_index).m_num_pages;
              }
              else { // error: hyphen but no range end
                System.err.println("Error: Unexpected range end; expected a page");
                System.err.println("   number or legal keyword, here: " + argv);
                System.err.println("   Exiting.");
                fail_b= true;
                break;
              }
            }

            if( m_input_pdf.get(range_pdf_index).m_num_pages< page_num_end ) {
              // error: page number out of range
              System.err.println("Error: Range end page number exceeds size of PDF");
              System.err.println("   input PDF has: " + m_input_pdf.get(range_pdf_index).m_num_pages + " pages.");
              System.err.println("   Exiting.");
              fail_b= true;
              break;
            }

            if( reverse_b ) // above test ensures good value here
              page_num_end= m_input_pdf.get(range_pdf_index).m_num_pages- page_num_end+ 1;

          }

          // trailing keywords (excluding "end" which should have been handled above)
          while( trailing_keywords.length() > 0 ) { // possibly more than one keyword, e.g., 3-endevenwest

            // read keyword
            arg_keyword= consume_keyword( trailing_keywords );

            if( arg_keyword== keyword.even_k ) {
              even_pages_b= true;
            }
            else if( arg_keyword== keyword.odd_k ) {
              odd_pages_b= true;
            }
            else if( arg_keyword== keyword.rot_north_k ) {
              page_rotate= PageRotate.NORTH; // rotate 0
              page_rotate_absolute= true;
            }
            else if( arg_keyword== keyword.rot_east_k ) {
              page_rotate= PageRotate.EAST; // rotate 90
              page_rotate_absolute= true;
            }
            else if( arg_keyword== keyword.rot_south_k ) {
              page_rotate= PageRotate.SOUTH; // rotate 180
              page_rotate_absolute= true;
            }
            else if( arg_keyword== keyword.rot_west_k ) {
              page_rotate= PageRotate.WEST; // rotate 270
              page_rotate_absolute= true;
            }
            else if( arg_keyword== keyword.rot_left_k ) {
              page_rotate= PageRotate.WEST; // rotate -90
              page_rotate_absolute= false;
            }
            else if( arg_keyword== keyword.rot_right_k ) {
              page_rotate= PageRotate.EAST; // rotate +90
              page_rotate_absolute= false;
            }
            else if( arg_keyword== keyword.rot_upside_down_k ) {
              page_rotate= PageRotate.SOUTH; // rotate +180
              page_rotate_absolute= false;
            }
            else { // error
              System.err.println("Error: Unexpected text in page range end, here: ");
              System.err.println("   " + argv /*(argv[ii]+ jj)*/);
              System.err.println("   Exiting.");
              System.err.println("   Acceptable keywords, for example: \"even\" or \"odd\".");
              System.err.println("   To rotate pages, use: \"north\" \"south\" \"east\"");
              System.err.println("       \"west\" \"left\" \"right\" or \"down\"");
              fail_b= true;
              break;
            }
          }

          ////
          // pack this range into our m_page_seq; 

          if( page_num_beg== 0 && page_num_end== 0 ) { // ref the entire document
            page_num_beg= 1;
            page_num_end= m_input_pdf.get(range_pdf_index).m_num_pages;

            // test that it's a /full/ pdf
            m_cat_full_pdfs_b= m_cat_full_pdfs_b && ( !even_pages_b && !odd_pages_b );
          }
          else if( page_num_beg== 0 || page_num_end== 0 ) { // error
            System.err.println("Error: Input page numbers include 0 (zero)");
            System.err.println("   The first PDF page is 1 (one)");
            System.err.println("   Exiting.");
            fail_b= true;
            break;
          }
          else // the user specified select pages
            m_cat_full_pdfs_b= false;

          ArrayList< PageRef > temp_page_seq = new ArrayList< PageRef >();
          boolean reverse_sequence_b= ( page_num_end< page_num_beg );
          if( reverse_sequence_b ) { // swap
            int temp= page_num_end;
            page_num_end= page_num_beg;
            page_num_beg= temp;
          }

          for( int kk= page_num_beg; kk<= page_num_end; ++kk ) {
            if( (!even_pages_b || ((kk % 2) == 0)) &&
                (!odd_pages_b || ((kk % 2) == 1)) )
              {
                if( kk<= m_input_pdf.get(range_pdf_index).m_num_pages ) {

                  // look to see if this page of this document
                  // has already been referenced; if it has,
                  // create a new reader; associate this page
                  // with a reader;
                  //
                  boolean associated = false;
                  for( InputPdf.PagesReader it : m_input_pdf.get(range_pdf_index).m_readers) {
                    if( !it.first.contains( kk ) ) { // kk not assoc. w/ this reader
                      it.first.add( kk ); // create association
                      associated = true;
                      break;
                    }
                  }
                  //
                  if( !associated ) {
                    // need to create a new reader for kk
                    InputPdf.PagesReader new_reader = add_reader( m_input_pdf.get(range_pdf_index) );
                    if ( new_reader != null) {
                      new_reader.first.add( kk );
                    }
                    else {
                      System.err.println("Internal Error: unable to add reader");
                      fail_b= true;
                      break;
                    }
                  }

                  //
                  temp_page_seq.add( new PageRef( range_pdf_index, kk, page_rotate, page_rotate_absolute ) ); // DF rotate

                }
                else { // error; break later to get most feedback
                  System.err.println("Error: Page number: " + kk);
                  System.err.println("   does not exist in file: " + m_input_pdf.get(range_pdf_index).m_filename);
                  fail_b= true;
                }
              }
          }
          if( fail_b )
            break;

          if( reverse_sequence_b ) {
            Collections.reverse ( temp_page_seq );
          }

          m_page_seq.add( temp_page_seq );

        }
      else { // error
        System.err.println("Error: expecting page ranges.  Instead, I got:");
        System.err.println("   " + argv);
        fail_b= true;
        break;
      }
    }
    break;

    case form_data_filename_e: {
      if( arg_keyword== keyword.none_k )
        { // treat argv[ii] like an FDF file filename
          
          if( m_form_data_filename.isEmpty() ) {
            m_form_data_filename = argv;
          }
          else { // error
            System.err.println("Error: Multiple fill_form filenames given: ");
            System.err.println("   " + m_form_data_filename + " and " + argv);
            System.err.println("Exiting.");
            fail_b= true;
            break;
          }

          // advance state
          arg_state= ArgState.output_e; // look for an output filename
        }
      else { // error
        System.err.println("Error: expecting a form data filename,");
        System.err.println("   instead I got this keyword: " + argv);
        System.err.println("Exiting.");
        fail_b= true;
        break;
      }
    } // end: case form_data_filename_e
    break;

    case attach_file_filename_e: {
      // keep packing filenames until we reach an expected keyword

      if( arg_keyword== keyword.attach_file_to_page_k ) {
        arg_state= ArgState.attach_file_pagenum_e; // advance state
      }
      else if( arg_keyword== keyword.output_k ) {
        arg_state= ArgState.output_filename_e; // advance state
      }
      else if( arg_keyword== keyword.none_k ) { 
        // pack argv[ii] into our list of attachment filenames
        m_input_attach_file_filename.add( argv );
      }
      else { // error
        System.err.println("Error: expecting an attachment filename,");
        System.err.println("   instead I got this keyword: " + argv);
        System.err.println("Exiting.");
        fail_b= true;
        break;
      }
    }
    break;

    case attach_file_pagenum_e: {
      if( argv.equals("PROMPT") ) { // query the user, later
        m_input_attach_file_pagenum= -1;
      }
      else if( argv.equals("end") ) { // attach to the final page
        m_input_attach_file_pagenum= -2;
      }
      else {
        try {
          m_input_attach_file_pagenum= Integer.parseInt(argv);
        }
        catch (NumberFormatException e) { // error
          System.err.println("Error: expecting a (1-based) page number.  Instead, I got:");
          System.err.println("   " + argv);
          System.err.println("Exiting.");
          fail_b= true;
        }
      }

      // advance state
      arg_state= ArgState.output_e; // look for an output filename

    } // end: case attach_file_pagenum_e
    break;

    case update_info_filename_e : {
      if( arg_keyword== keyword.none_k ) {
          if( m_update_info_filename.isEmpty() ) {
            m_update_info_filename = argv;
          }
          else { // error
            System.err.println("Error: Multiple update_info filenames given: ");
            System.err.println("   " + m_update_info_filename + " and " + argv);
            System.err.println("Exiting.");
            fail_b= true;
            break;
          }
        }
      else { // error
        System.err.println("Error: expecting an INFO file filename,");
        System.err.println("   instead I got this keyword: " + argv);
        System.err.println("Exiting.");
        fail_b= true;
        break;
      }

      // advance state
      arg_state= ArgState.output_e; // look for an output filename

    } // end: case update_info_filename_e
    break;

    /*
    case update_xmp_filename_e : {
      if( arg_keyword== none_k ) {
          if( m_update_xmp_filename.empty() ) {
            m_update_xmp_filename= argv[ii];
          }
          else { // error
            cerr << "Error: Multiple update_xmp filenames given: " << endl;
            cerr << "   " << m_update_xmp_filename << " and " << argv[ii] << endl;
            cerr << "Exiting." << endl;
            fail_b= true;
            break;
          }
        }
      else { // error
        cerr << "Error: expecting an XMP file filename," << endl;
        cerr << "   instead I got this keyword: " << argv[ii] << endl;
        cerr << "Exiting." << endl;
        fail_b= true;
        break;
      }

      // advance state
      arg_state= output_e; // look for an output filename

    } // end: case update_xmp_filename_e
    break;
    */

    case output_e: {
      if( m_input_pdf.isEmpty() ) { // error; remark and set fail_b
        System.err.println("Error: No input files.  Exiting.");
        fail_b= true;
        break;
      }

      if( arg_keyword== keyword.output_k ) {
        arg_state= ArgState.output_filename_e; // advance state
      }
      else { // error
        System.err.println("Error: expecting \"output\" keyword.  Instead, I got:");
        System.err.println("   " + argv);
        fail_b= true;
        break;
      }
    }
    break;

    case output_filename_e: {
      // we have closed all possible input operations and arguments;
      // see if we should perform any default action based on the input state
      //
      if( m_operation== keyword.none_k ) {
        if( 1< m_input_pdf.size() ) {
          // no operation given for multiple input PDF, so combine them
          m_operation= keyword.cat_k;
        }
        else {
          m_operation= keyword.filter_k;
        }
      }
      
      // try opening input PDF readers (in case they aren't already)
      if( !open_input_pdf_readers() ) { // failure
        fail_b= true;
        break;
      }

      if( ( m_operation== keyword.cat_k ||
            m_operation== keyword.shuffle_k ) )
        {
          if( m_page_seq.isEmpty() ) {
            // combining pages, but no sequences given; merge all input PDFs in order
            for( int ii= 0; ii< m_input_pdf.size(); ++ii ) {
              InputPdf input_pdf= m_input_pdf.get(ii);

              ArrayList< PageRef > temp_page_seq = new ArrayList< PageRef >();
              for( int jj= 1; jj<= input_pdf.m_num_pages; ++jj ) {
                temp_page_seq.add( new PageRef( ii, jj ) ); // DF rotate
                input_pdf.m_readers.get(input_pdf.m_readers.size()-1).first.add( jj ); // create association
              }
              m_page_seq.add( temp_page_seq );
            }
          }
          /* no longer necessary -- are upstream testing is smarter
          else { // page ranges or docs (e.g. A B A) were given
            m_cat_full_pdfs_b= false; // TODO: handle cat A B A case for bookmarks
          }
          */
        }

      if( m_output_filename.isEmpty() ) {
        m_output_filename = argv;

        if( !m_output_filename.equals("-") ) { // input and output may both be "-" (stdin and stdout)
          // simple-minded test to see if output matches an input filename
          for( InputPdf it : m_input_pdf )
            {
              if( it.m_filename.equals(m_output_filename) ) {
                System.err.println("Error: The given output filename: " + m_output_filename);
                System.err.println("   matches an input filename.  Exiting.");
                fail_b= true;
                break;
              }
            }
        }
      }
      else { // error
        System.err.println("Error: Multiple output filenames given: ");
        System.err.println("   " + m_output_filename + " and " + argv);
        System.err.println("Exiting.");
        fail_b= true;
        break;
      }

      // advance state
      arg_state= ArgState.output_args_e;
    }
    break;

    case output_args_e: {
      // output args are order-independent but must follow "output <fn>", if present;
      // we are expecting any of these keywords:
      // owner_pw_k, user_pw_k, user_perms_k ...
      // added output_k case in pdftk 1.10; this permits softer "output <fn>" enforcement
      //

      ArgStateMutable arg_state_m = new ArgStateMutable();
      arg_state_m.value = arg_state;
      if( handle_some_output_options( arg_keyword, arg_state_m ) ) {
        arg_state = arg_state_m.value;
      }
      else {
        System.err.println("Error: Unexpected data in output section: ");
        System.err.println("      " + argv);
        System.err.println("Exiting.");
        fail_b= true;
        break;
      }
    }
    break;

    case output_owner_pw_e: {
      if( m_output_owner_pw.isEmpty() ) {

        if( argv.equals("PROMPT") || !argv.equals( m_output_user_pw ) ) {
          m_output_owner_pw= argv;
        }
        else { // error: identical user and owner password
          // are interpreted by Acrobat (per the spec.) that
          // the doc has no owner password
          System.err.println("Error: The user and owner passwords are the same.");
          System.err.println("   PDF Viewers interpret this to mean your PDF has");
          System.err.println("   no owner password, so they must be different.");
          System.err.println("   Or, supply no owner password to pdftk if this is");
          System.err.println("   what you desire.");
          System.err.println("Exiting.");
          fail_b= true;
          break;
        }
      }
      else { // error: we already have an output owner pw
        System.err.println("Error: Multiple output owner passwords given: ");
        System.err.println("   " + m_output_owner_pw + " and " + argv);
        System.err.println("Exiting.");
        fail_b= true;
        break;
      }

      // revert state
      arg_state= ArgState.output_args_e;
    }
    break;

    case output_user_pw_e: {
      if( m_output_user_pw.isEmpty() ) {
        if( argv.equals("PROMPT") || !m_output_owner_pw.equals(argv) ) {
          m_output_user_pw= argv;
        }
        else { // error: identical user and owner password
          // are interpreted by Acrobat (per the spec.) that
          // the doc has no owner password
          System.err.println("Error: The user and owner passwords are the same.");
          System.err.println("   PDF Viewers interpret this to mean your PDF has");
          System.err.println("   no owner password, so they must be different.");
          System.err.println("   Or, supply no owner password to pdftk if this is");
          System.err.println("   what you desire.");
          System.err.println("Exiting.");
          fail_b= true;
          break;
        }
      }
      else { // error: we already have an output user pw
        System.err.println("Error: Multiple output user passwords given: ");
        System.err.println("   " + m_output_user_pw + " and " + argv);
        System.err.println("Exiting.");
        fail_b= true;
        break;
      }

      // revert state
      arg_state= ArgState.output_args_e;
    }
    break;

    case output_user_perms_e: {

      // we may be given any number of permission arguments,
      // so keep an eye out for other, state-altering keywords
      ArgStateMutable arg_state_m = new ArgStateMutable();
      arg_state_m.value = arg_state;
      if( handle_some_output_options( arg_keyword, arg_state_m ) ) {
        arg_state = arg_state_m.value;
        break;
      }

      switch( arg_keyword ) {

        // possible permissions
      case perm_printing_k:
        // if both perm_printing_k and perm_degraded_printing_k
        // are given, then perm_printing_k wins;
        m_output_user_perms|= 
          PdfWriter.AllowPrinting;
        break;
      case perm_modify_contents_k:
        // Acrobat 5 and 6 don't set both bits, even though
        // they both respect AllowModifyContents --> AllowAssembly;
        // so, no harm in this;
        m_output_user_perms|= 
          ( PdfWriter.AllowModifyContents | PdfWriter.AllowAssembly );
        break;
      case perm_copy_contents_k:
        // Acrobat 5 _does_ allow the user to allow copying contents
        // yet hold back screen reader perms; this is counter-intuitive,
        // and Acrobat 6 does not allow Copy w/o SceenReaders;
        m_output_user_perms|= 
          ( PdfWriter.AllowCopy | PdfWriter.AllowScreenReaders );
        break;
      case perm_modify_annotations_k:
        m_output_user_perms|= 
          ( PdfWriter.AllowModifyAnnotations | PdfWriter.AllowFillIn );
        break;
      case perm_fillin_k:
        m_output_user_perms|= 
          PdfWriter.AllowFillIn;
        break;
      case perm_screen_readers_k:
        m_output_user_perms|= 
          PdfWriter.AllowScreenReaders;
        break;
      case perm_assembly_k:
        m_output_user_perms|= 
          PdfWriter.AllowAssembly;
        break;
      case perm_degraded_printing_k:
        m_output_user_perms|= 
          PdfWriter.AllowDegradedPrinting;
        break;
      case perm_all_k:
        m_output_user_perms= 
          ( PdfWriter.AllowPrinting | // top quality printing
            PdfWriter.AllowModifyContents |
            PdfWriter.AllowCopy |
            PdfWriter.AllowModifyAnnotations |
            PdfWriter.AllowFillIn |
            PdfWriter.AllowScreenReaders |
            PdfWriter.AllowAssembly );
        break;

      default: // error: unexpected matter
        System.err.println("Error: Unexpected data in output section: ");
        System.err.println("      " + argv);
        System.err.println("Exiting.");
        fail_b= true;
        break;
      }
    }
    break;

    case background_filename_e : {
      if( arg_keyword== keyword.none_k ) {
        if( m_background_filename.isEmpty() ) {
          m_background_filename = argv;
        }
        else { // error
          System.err.println("Error: Multiple background filenames given: ");
          System.err.println("   " + m_background_filename + " and " + argv);
          System.err.println("Exiting.");
          fail_b= true;
          break;
        }
      }
      else { // error
        System.err.println("Error: expecting a PDF filename for background operation,");
        System.err.println("   instead I got this keyword: " + argv);
        System.err.println("Exiting.");
        fail_b= true;
        break;
      }

      // revert state
      // this is more liberal than used with other operations, since we want
      // to preserve backward-compatibility with pdftk 1.00 where "background"
      // was documented as an output option; in pdftk 1.10 we changed it to
      // an operation
      arg_state= ArgState.output_args_e;
    }
    break;

    case stamp_filename_e : {
      if( arg_keyword== keyword.none_k ) {
        if( m_stamp_filename.isEmpty() ) {
          m_stamp_filename = argv;
        }
        else { // error
          System.err.println("Error: Multiple stamp filenames given: ");
          System.err.println("   " + m_stamp_filename + " and " + argv);
          System.err.println("Exiting.");
          fail_b= true;
          break;
        }
      }
      else { // error
        System.err.println("Error: expecting a PDF filename for stamp operation,");
        System.err.println("   instead I got this keyword: " + argv);
        System.err.println("Exiting.");
        fail_b= true;
        break;
      }

      // advance state
      arg_state= ArgState.output_e; // look for an output filename
    }
    break;

    default: { // error
      System.err.println("Internal Error: Unexpected arg_state.  Exiting.");
      fail_b= true;
      break;
    }

    } // end: switch(arg_state)

  } // end: iterate over command-line arguments

  if( fail_b ) {
    System.err.println("Errors encountered.  No output created.");
    m_valid_b= false;

    m_input_pdf.clear();

    // preserve other data members for diagnostic dump
  }
  else {
    m_valid_b= true;

    if(!m_input_pdf_readers_opened_b ) {
      open_input_pdf_readers();
    }
  }
}

boolean is_valid() {
  return( m_valid_b &&

          ( m_operation== keyword.dump_data_k ||
            m_operation== keyword.dump_data_fields_k ||
            m_operation== keyword.dump_data_annots_k ||
            m_operation== keyword.generate_fdf_k ||
            m_authorized_b ) &&

          !m_input_pdf.isEmpty() &&
          m_input_pdf_readers_opened_b &&

          ( m_operation== keyword.cat_k ||
            m_operation== keyword.shuffle_k ||
            m_operation== keyword.burst_k ||
            m_operation== keyword.filter_k ||
            m_operation== keyword.dump_data_k ||
            m_operation== keyword.dump_data_utf8_k ||
            m_operation== keyword.dump_data_fields_k ||
            m_operation== keyword.dump_data_fields_utf8_k ||
            m_operation== keyword.dump_data_annots_k ||
            m_operation== keyword.generate_fdf_k ||
            m_operation== keyword.unpack_files_k ) &&

          // these op.s require a single input PDF file
          ( !( m_operation== keyword.burst_k ||
               m_operation== keyword.filter_k ) ||
            ( m_input_pdf.size()== 1 ) ) &&

          // these op.s do not require an output filename
          ( m_operation== keyword.burst_k ||
            m_operation== keyword.dump_data_k ||
            m_operation== keyword.dump_data_fields_k ||
            m_operation== keyword.dump_data_annots_k ||
            m_operation== keyword.generate_fdf_k ||
            m_operation== keyword.unpack_files_k ||
            !m_output_filename.isEmpty() ) );
}

void dump_session_data()
{
  if( !m_verbose_reporting_b )
    return;

  if( !m_input_pdf_readers_opened_b ) {
    System.out.println( "Input PDF Open Errors" );
    return;
  }

  //
  if( is_valid() ) {
    System.out.println( "Command Line Data is valid." );
  }
  else { 
    System.out.println( "Command Line Data is NOT valid." );
  }

  // input files
  System.out.println();
  System.out.println( "Input PDF Filenames & Passwords in Order\n( <filename>[, <password>] ) " );
  if( m_input_pdf.isEmpty() ) {
    System.out.println( "   No input PDF filenames have been given." );
  }
  else {
    for( InputPdf it : m_input_pdf )
      {
        System.out.print( "   " + it.m_filename );
        if( !it.m_password.isEmpty() ) {
          System.out.print( ", " + it.m_password );
        }

        if( !it.m_authorized_b ) {
          System.out.print( ", OWNER OR USER PASSWORD REQUIRED, but not given (or incorrect)" );
        }

        System.out.println();
      }
  }

  // operation
  System.out.println();
  System.out.println( "The operation to be performed: " );
  switch( m_operation ) {
  case cat_k:
    System.out.println( "   cat - Catenate given page ranges into a new PDF." );
    break;
  case shuffle_k:
    System.out.println( "   shuffle - Interleave given page ranges into a new PDF." );
    break;
  case burst_k:
    System.out.println( "   burst - Split a single, input PDF into individual pages." );
    break;
  case filter_k:
    System.out.println( "   filter - Apply 'filters' to a single, input PDF based on output args." );
    System.out.println( "      (When the operation is omitted, this is the default.)" );
    break;
  case dump_data_k:
    System.out.println( "   dump_data - Report statistics on a single, input PDF." );
    break;
  case dump_data_fields_k:
    System.out.println( "   dump_data_fields - Report form field data on a single, input PDF." );
    break;
  case dump_data_annots_k:
    System.out.println( "   dump_data_annots - Report annotation data on a single, input PDF." );
    break;
  case generate_fdf_k:
    System.out.println( "   generate_fdf - Generate a dummy FDF file from a PDF." );
    break;
  case unpack_files_k:
    System.out.println( "   unpack_files - Copy PDF file attachments into given directory." );
    break;
  case none_k:
    System.out.println( "   NONE - No operation has been given.  See usage instructions." );
    break;
  default:
    System.out.println( "   INTERNAL ERROR - An unexpected operation has been given." );
    break;
  }

  // pages
  /*
  cout << endl;
  cout << "The following pages will be operated on, in the given order." << endl;
  if( m_page_seq.empty() ) {
    cout << "   No pages or page ranges have been given." << endl;
  }
  else {
    for( vector< PageRef >::const_iterator it= m_page_seq.begin();
         it!= m_page_seq.end(); ++it )
      {
        map< string, InputPdf >::const_iterator jt=
          m_input_pdf.find( it->m_handle );
        if( jt!= m_input_pdf.end() ) {
          cout << "   Handle: " << it->m_handle << "  File: " << jt->second.m_filename;
          cout << "  Page: " << it->m_page_num << endl;
        }
        else { // error
          cout << "   Internal Error: handle not found in m_input_pdf: " << it->m_handle << endl;
        }
      }
  }
  */

  // output file; may be PDF or text
  System.out.println();
  System.out.println( "The output file will be named:" );
  if( m_output_filename.isEmpty() ) {
    System.out.println( "   No output filename has been given." );
  }
  else {
    System.out.println( "   " + m_output_filename );
  }

  // output encryption
  System.out.println();
  boolean output_encrypted_b= 
    m_output_encryption_strength!= encryption_strength.none_enc ||
    !m_output_user_pw.isEmpty() ||
    !m_output_owner_pw.isEmpty();

  System.out.println( "Output PDF encryption settings:" );
  if( output_encrypted_b ) {
    System.out.println( "   Output PDF will be encrypted." );

    switch( m_output_encryption_strength ) {
    case none_enc:
      System.out.println( "   Encryption strength not given. Defaulting to: 128 bits." );
      break;
    case bits40_enc:
      System.out.println( "   Given output encryption strength: 40 bits" );
      break;
    case bits128_enc:
      System.out.println( "   Given output encryption strength: 128 bits" );
      break;
    }

    System.out.println();
    {

      if( m_output_user_pw.isEmpty() )
        System.out.println( "   No user password given." );
      else
        System.out.println( "   Given user password: " + m_output_user_pw );
      if( m_output_owner_pw.isEmpty() )
        System.out.println( "   No owner password given." );
      else
        System.out.println( "   Given owner password: " + m_output_owner_pw );
      //
      // the printing section: Top Quality or Degraded, but not both;
      // AllowPrinting is a superset of both flag settings
      if( (m_output_user_perms & PdfWriter.AllowPrinting)== PdfWriter.AllowPrinting )
        System.out.println( "   ALLOW Top Quality Printing" );
      else if( (m_output_user_perms & PdfWriter.AllowPrinting)== PdfWriter.AllowDegradedPrinting )
        System.out.println( "   ALLOW Degraded Printing (Top-Quality Printing NOT Allowed)" );
      else
        System.out.println( "   Printing NOT Allowed" );
      if( (m_output_user_perms & PdfWriter.AllowModifyContents)== PdfWriter.AllowModifyContents )
        System.out.println( "   ALLOW Modifying of Contents" );
      else
        System.out.println( "   Modifying of Contents NOT Allowed" );
      if( (m_output_user_perms & PdfWriter.AllowCopy)== PdfWriter.AllowCopy )
        System.out.println( "   ALLOW Copying of Contents" );
      else
        System.out.println( "   Copying of Contents NOT Allowed" );
      if( (m_output_user_perms & PdfWriter.AllowModifyAnnotations)== PdfWriter.AllowModifyAnnotations )
        System.out.println( "   ALLOW Modifying of Annotations" );
      else
        System.out.println( "   Modifying of Annotations NOT Allowed" );
      if( (m_output_user_perms & PdfWriter.AllowFillIn)== PdfWriter.AllowFillIn )
        System.out.println( "   ALLOW Fill-In" );
      else
        System.out.println( "   Fill-In NOT Allowed" );
      if( (m_output_user_perms & PdfWriter.AllowScreenReaders)== PdfWriter.AllowScreenReaders )
        System.out.println( "   ALLOW Screen Readers" );
      else
        System.out.println( "   Screen Readers NOT Allowed" );
      if( (m_output_user_perms & PdfWriter.AllowAssembly)== PdfWriter.AllowAssembly )
        System.out.println( "   ALLOW Assembly" );
      else
        System.out.println( "   Assembly NOT Allowed" );
    }
  }
  else {
    System.out.println( "   Output PDF will not be encrypted." );
  }

  // compression filter
  System.out.println();
  if( m_operation!= keyword.filter_k ||
      output_encrypted_b ||
      !( m_output_compress_b ||
         m_output_uncompress_b ) )
    {
      System.out.println( "No compression or uncompression being performed on output." );
    }
  else {
    if( m_output_compress_b ) {
      System.out.println( "Compression will be applied to some PDF streams." );
    }
    else {
      System.out.println( "Some PDF streams will be uncompressed." );
    }
  }
}

  void attach_files
  ( PdfReader input_reader_p,
    PdfWriter writer_p ) throws IOException
{
  if( !m_input_attach_file_filename.isEmpty() ) {

    if( m_input_attach_file_pagenum== -1 ) { // our signal to prompt the user for a pagenum
      System.out.println( "Please enter the page number you want to attach these files to." );
      System.out.println( "   The first page is 1.  The final page is \"end\"." );
      System.out.println( "   To attach files at the document level, just press Enter." );

      Scanner s = new Scanner(System.in);
      String buff= s.nextLine();
      if ( buff.isEmpty() ) { // attach to document
        m_input_attach_file_pagenum= 0;
      }
      if ( buff.equals( "end" ) ) { // the final page
        m_input_attach_file_pagenum= input_reader_p.getNumberOfPages();
      }
      else {
        Pattern p = Pattern.compile("([0-9]*).*");
        Matcher m = p.matcher(buff);
        m.matches();
        try {
          m_input_attach_file_pagenum= Integer.valueOf(m.group(1));
        }
        catch (NumberFormatException e) {
          m_input_attach_file_pagenum= 0;
        }
      }
    }
    else if( m_input_attach_file_pagenum== -2 ) { // the final page ("end")
      m_input_attach_file_pagenum= input_reader_p.getNumberOfPages();
    }

    if( m_input_attach_file_pagenum != 0 ) { // attach to a page using annotations
      final int trans= 27;
      final int margin= 18;

      if( 0< m_input_attach_file_pagenum &&
          m_input_attach_file_pagenum<= input_reader_p.getNumberOfPages() ) {

        PdfDictionary page_p= input_reader_p.getPageN( m_input_attach_file_pagenum );
        if( page_p != null && page_p.isDictionary() ) {

          Rectangle crop_box_p= 
            input_reader_p.getCropBox( m_input_attach_file_pagenum );
          float corner_top= crop_box_p.top()- margin;
          float corner_left= crop_box_p.left()+ margin;

          PdfArray annots_p= (PdfArray)
            input_reader_p.getPdfObject( page_p.get( PdfName.ANNOTS ) );
          boolean annots_new_b= false;
          if( annots_p == null ) { // create Annots array
            annots_p= new PdfArray();
            annots_new_b= true;
          }
          else { // grab corner_top and corner_left from the bottom right of the newest annot
            ArrayList<PdfObject> annots_array_p= annots_p.getArrayList();
            for( PdfObject ii : annots_array_p ) {
              PdfDictionary annot_p= (PdfDictionary)
                input_reader_p.getPdfObject( ii );
              if( annot_p != null && annot_p.isDictionary() ) {
                PdfArray annot_bbox_p= (PdfArray)
                  input_reader_p.getPdfObject( annot_p.get( PdfName.RECT ) );
                if( annot_bbox_p != null && annot_bbox_p.isArray() ) {
                  ArrayList<PdfObject> bbox_array_p= annot_bbox_p.getArrayList();
                  if( bbox_array_p.size()== 4 ) {
                    corner_top= ((PdfNumber)bbox_array_p.get( 1 )).floatValue();
                    corner_left= ((PdfNumber)bbox_array_p.get( 2 )).floatValue();
                  }
                }
              }
            }
          }
          if( annots_p != null && annots_p.isArray() ) {
            for( String vit :  m_input_attach_file_filename )
              {
                if( vit.equals("PROMPT") ) {
                  vit= pdftk.prompt_for_filename( "Please enter a filename for attachment:" );
                }

                String filename= attachments.drop_path(vit);

                // wrap our location over page bounds, if needed
                if( crop_box_p.right() < corner_left+ trans ) {
                  corner_left= crop_box_p.left()+ margin;
                }
                if( corner_top- trans< crop_box_p.bottom() ) {
                  corner_top= crop_box_p.top()- margin;
                }

                Rectangle annot_bbox_p= 
                  new Rectangle( corner_left,
                                        corner_top- trans,
                                        corner_left+ trans,
                                        corner_top );
                                    
                PdfAnnotation annot_p=
                  PdfAnnotation.createFileAttachment
                  ( writer_p,
                    annot_bbox_p,
                    filename, // contents
                    null,
                    vit, // the file path
                    filename ); // display name

                PdfIndirectReference ref_p=
                  writer_p.addToBody( annot_p ).getIndirectReference();

                annots_p.add( ref_p );

                // advance the location of our annotation
                corner_left+= trans;
                corner_top-= trans;
              }
            if( annots_new_b ) { // add new Annots array to page dict
              PdfIndirectReference ref_p=
                writer_p.addToBody( annots_p ).getIndirectReference();
              page_p.put( PdfName.ANNOTS, ref_p );              
            }
          }
        }
        else { // error
          System.err.println( "Internal Error: unable to get page dictionary" );
        }
      }
      else { // error
        System.err.print( "Error: page number " + m_input_attach_file_pagenum );
        System.err.println( " is not present in the input PDF." );
      }
    }
    else { // attach to document using the EmbeddedFiles name tree
      PdfDictionary catalog_p= input_reader_p.catalog; // to top, Root dict
      if( catalog_p != null && catalog_p.isDictionary() ) {

        // the Names dict
        PdfDictionary names_p= (PdfDictionary)
          input_reader_p.getPdfObject( catalog_p.get( PdfName.NAMES ) );
        boolean names_new_b= false;
        if( names_p == null ) { // create Names dict
          names_p= new PdfDictionary();
          names_new_b= true;
        }
        if( names_p != null && names_p.isDictionary() ) {

          // the EmbeddedFiles name tree (ref. 1.5, sec. 3.8.5), which is a dict at top
          PdfDictionary emb_files_tree_p= (PdfDictionary)
            input_reader_p.getPdfObject( names_p.get( PdfName.EMBEDDEDFILES ) );
          HashMap<String,PdfIndirectReference> emb_files_map_p= null;
          boolean emb_files_tree_new_b= false;
          if( emb_files_tree_p != null ) { // read current name tree of attachments into a map
            emb_files_map_p= PdfNameTree.readTree( emb_files_tree_p );
          }
          else { // create material
            emb_files_map_p= new HashMap<String,PdfIndirectReference>();
            emb_files_tree_new_b= true;
          }

          ////
          // add matter to name tree

          for( String vit :  m_input_attach_file_filename )
            {
              if( vit.equals( "PROMPT" ) ) {
                vit= pdftk.prompt_for_filename( "Please enter a filename for attachment:" );
              }

              String filename= attachments.drop_path(vit);

              PdfFileSpecification filespec_p= null;
              try {
                // create the file spec. from file
                filespec_p= 
                  PdfFileSpecification.fileEmbedded
                  ( writer_p,
                    vit, // the file path
                    filename, // the display name
                    null );
              }
              catch( IOException ioe_p ) { // file open error
                System.err.println( "Error: Failed to open attachment file: " );
                System.err.println( "   " + vit );
                System.err.println( "   Skipping this file." );
                continue;
              }

              // add file spec. to PDF via indirect ref.
              PdfIndirectReference ref_p=
                writer_p.addToBody( filespec_p ).getIndirectReference();

              // contruct a name, if necessary, to prevent possible key collision on the name tree
              String key_p= vit;
              for(int counter=1; emb_files_map_p.containsKey( key_p ); ++counter ) { // append a unique suffix
                key_p = vit + "-" + counter;
              }

              // add file spec. to map
              emb_files_map_p.put( key_p, ref_p );
            }

          if( !emb_files_map_p.isEmpty() ) {
            // create a name tree from map
            PdfDictionary emb_files_tree_new_p=
              PdfNameTree.writeTree( emb_files_map_p, writer_p );

            if( emb_files_tree_new_b && emb_files_tree_new_p != null) {
              // adding new material
              PdfIndirectReference ref_p=
                writer_p.addToBody( emb_files_tree_new_p ).getIndirectReference();
              names_p.put( PdfName.EMBEDDEDFILES, ref_p );
            }
            else if( emb_files_tree_p != null && emb_files_tree_new_p != null ) {
              // supplementing old material
              emb_files_tree_p.merge( emb_files_tree_new_p );
            }
            else { // error
              System.err.println( "Internal Error: no valid EmbeddedFiles tree to add to PDF." );
            }

            if( names_new_b ) {
              // perform addToBody only after packing new names_p into names_p;
              // use the resulting ref. to pack our new Names dict. into the catalog (Root)
              PdfIndirectReference ref_p=
                writer_p.addToBody( names_p ).getIndirectReference();
              catalog_p.put( PdfName.NAMES, ref_p );
            }
          }
        }
        else { // error
          System.err.println( "Internal Error: couldn't read or create PDF Names dictionary." );
        }
      }
      else { // error
        System.err.println( "Internal Error: couldn't read input PDF Root dictionary." );
        System.err.println( "   File attachment failed; no new files attached to output." );
      }
    }
  }
}

  void unpack_files
    ( PdfReader input_reader_p )
{
  // output pathname; PROMPT if necessary
  String output_pathname= attachments.normalize_pathname( m_output_filename );

  { // unpack document attachments
    PdfDictionary catalog_p= input_reader_p.catalog; // to top, Root dict
    if( catalog_p != null && catalog_p.isDictionary() ) {

      // the Names dict
      PdfDictionary names_p= (PdfDictionary)
        input_reader_p.getPdfObject( catalog_p.get( PdfName.NAMES ) );
      if( names_p != null && names_p.isDictionary() ) {

        // the EmbeddedFiles name tree (ref. 1.5, sec. 3.8.5), which is a dict at top
        PdfDictionary emb_files_tree_p= (PdfDictionary)
          input_reader_p.getPdfObject( names_p.get( PdfName.EMBEDDEDFILES ) );
        HashMap<Object, PdfObject> emb_files_map_p= null;
        if( emb_files_tree_p != null && emb_files_tree_p.isDictionary() ) { 
          // read current name tree of attachments into a map
          emb_files_map_p= PdfNameTree.readTree( emb_files_tree_p );

          for( PdfObject value_p : emb_files_map_p.values() ) {
            PdfDictionary filespec_p= (PdfDictionary)
              input_reader_p.getPdfObject( value_p );
            if( filespec_p != null && filespec_p.isDictionary() ) {

              attachments.unpack_file( input_reader_p,
                           filespec_p,
                           output_pathname,
                           m_ask_about_warnings_b );
            }
          }
        }
      }
    }
  }

  { // unpack page attachments
    int num_pages= input_reader_p.getNumberOfPages();
    for( int ii= 1; ii<= num_pages; ++ii ) { // 1-based page ref.s

        PdfDictionary page_p= input_reader_p.getPageN( ii );
        if( page_p != null && page_p.isDictionary() ) {

          PdfArray annots_p= (PdfArray)
            input_reader_p.getPdfObject( page_p.get( PdfName.ANNOTS ) );
          if( annots_p != null && annots_p.isArray() ) {

            ArrayList<PdfObject> annots_array_p = annots_p.getArrayList();
            for( PdfObject jj : annots_array_p ) {
              PdfDictionary annot_p= (PdfDictionary)
                input_reader_p.getPdfObject( jj );
              if( annot_p != null && annot_p.isDictionary() ) {

                PdfName subtype_p= (PdfName)
                  input_reader_p.getPdfObject( annot_p.get( PdfName.SUBTYPE ) );
                if( subtype_p != null && subtype_p.isName() && 
                    subtype_p.equals(PdfName.FILEATTACHMENT) ) {
                  
                  PdfDictionary filespec_p= (PdfDictionary)
                    input_reader_p.getPdfObject( annot_p.get( PdfName.FS ) );
                  if( filespec_p != null && filespec_p.isDictionary() ) {
                    
                    attachments.unpack_file( input_reader_p,
                                 filespec_p,
                                 output_pathname,
                                 m_ask_about_warnings_b );
                  }
                }
              }
            }
          }
        }
      
    }
  }
}

////
// when uncompressing a PDF, we add this marker to every page,
// so the PDF is easier to navigate; when compressing a PDF,
// we remove this marker

static final String g_page_marker= "pdftk_PageNum";
static void
add_mark_to_page( PdfReader reader_p,
                  int page_index,
                  int page_num )
{
  PdfName page_marker_p=
    new PdfName( g_page_marker );
  PdfDictionary page_p= reader_p.getPageN( page_index );
  if( page_p != null && page_p.isDictionary() ) {
    page_p.put( page_marker_p, new PdfNumber( page_num ) );
  }
}
static void
add_marks_to_pages( PdfReader reader_p )
{
  int num_pages= reader_p.getNumberOfPages();
  for( int ii= 1; ii<= num_pages; ++ii ) { // 1-based page ref.s
    add_mark_to_page( reader_p, ii, ii );
  }
}
static void
remove_mark_from_page( PdfReader reader_p,
                       int page_num )
{
  PdfName page_marker_p=
    new PdfName( g_page_marker );
  PdfDictionary page_p= reader_p.getPageN( page_num );
  if( page_p != null && page_p.isDictionary() ) {
    page_p.remove( page_marker_p );
  }
}
static void
remove_marks_from_pages( PdfReader reader_p )
{
  int num_pages= reader_p.getNumberOfPages();
  for( int ii= 1; ii<= num_pages; ++ii ) { // 1-based page ref.s
    remove_mark_from_page( reader_p, ii );
  }
}
  
static void
apply_rotation_to_page( PdfReader reader_p, int page_num, int rotation, boolean absolute ) {
  // DF rotate
  PdfDictionary page_p= reader_p.getPageN( page_num );
  if( !absolute ) {
    rotation= reader_p.getPageRotation( page_num )+ rotation;
  }
  rotation= rotation % 360;
  page_p.remove( PdfName.ROTATE );
  if( rotation!= PageRotate.NORTH.value ) { // default rotation
    page_p.put( PdfName.ROTATE,
                new PdfNumber( rotation ) );
  }
}

ErrorCode create_output_page( PdfCopy writer_p, PageRef page_ref, int output_page_count ) {
  ErrorCode ret_val= ErrorCode.NO_ERROR;

  // get the reader associated with this page ref.
  if( page_ref.m_input_pdf_index< m_input_pdf.size() ) {
    InputPdf page_pdf= m_input_pdf.get( page_ref.m_input_pdf_index );

    if( m_verbose_reporting_b ) {
      System.out.print("   Adding page " + page_ref.m_page_num + " X" + page_ref.m_page_rot + "X "); // DF rotate
      System.out.println(" from " + page_pdf.m_filename);
    }

    // take the first, associated reader and then disassociate
    PdfReader input_reader_p= null;
    for (InputPdf.PagesReader mt : page_pdf.m_readers) {
      if( mt.first.contains( page_ref.m_page_num )) { // assoc. found
        input_reader_p= mt.second;
        mt.first.remove( page_ref.m_page_num ); // remove this assoc.
        break;
      }
    }

    if( input_reader_p != null) {

      //
      if( m_output_uncompress_b ) {
        add_mark_to_page( input_reader_p, page_ref.m_page_num, output_page_count+ 1 );
      }
      else if( m_output_compress_b ) {
        remove_mark_from_page( input_reader_p, page_ref.m_page_num );
      }

      // DF rotate
      apply_rotation_to_page( input_reader_p, page_ref.m_page_num, page_ref.m_page_rot.value, page_ref.m_page_abs );

      //
      try {
        PdfImportedPage page_p= 
          writer_p.getImportedPage( input_reader_p, page_ref.m_page_num );
        try {
          writer_p.addPage( page_p );
        }
        catch (DocumentException e) {
          System.err.print("Internal Error: addPage() failed for: ");
          System.err.println(page_ref.m_page_num + " in file: " + page_pdf.m_filename);
          ret_val= ErrorCode.BUG;
        }
      }
      catch (IOException e) { // error
        System.err.print("Internal Error: getImportedPage() failed for: ");
        System.err.println(page_ref.m_page_num + " in file: " + page_pdf.m_filename);
        ret_val= ErrorCode.BUG;
      }
    }
    else { // error
      System.err.print("Internal Error: no reader found for page: ");
      System.err.println(page_ref.m_page_num + " in file: " + page_pdf.m_filename);
      ret_val= ErrorCode.BUG;
    }
  }
  else { // error
    System.err.println("Internal Error: Unable to find handle in m_input_pdf.");
    ret_val= ErrorCode.BUG;
  }

  return ret_val;
}

static char GetPdfVersionChar( PdfName version_p ) {
  char version_cc= PdfWriter.VERSION_1_4; // default

  if( version_p != null )
    if( version_p.equals( PdfName.VERSION_1_4 ) )
      version_cc= PdfWriter.VERSION_1_4;
    else if( version_p.equals( PdfName.VERSION_1_5 ) )
      version_cc= PdfWriter.VERSION_1_5;
    else if( version_p.equals( PdfName.VERSION_1_6 ) )
      version_cc= PdfWriter.VERSION_1_6;
    else if( version_p.equals( PdfName.VERSION_1_7 ) )
      version_cc= PdfWriter.VERSION_1_7;
    else if( version_p.equals( PdfName.VERSION_1_3 ) )
      version_cc= PdfWriter.VERSION_1_3;
    else if( version_p.equals( PdfName.VERSION_1_2 ) )
      version_cc= PdfWriter.VERSION_1_2;
    else if( version_p.equals( PdfName.VERSION_1_1 ) )
      version_cc= PdfWriter.VERSION_1_1;
    else if( version_p.equals( PdfName.VERSION_1_0 ) )
      version_cc= PdfWriter.VERSION_1_0;

  return version_cc;
}

ErrorCode create_output() {
  ErrorCode ret_val= ErrorCode.NO_ERROR; // default: no error

  if( is_valid() ) {

    /*
    bool rdfcat_available_b= false;
    { // is rdfcat available?  first character should be a digit;
      // grab stderr to keep messages appearing to user;
      // 2>&1 might not work on older versions of Windows (e.g., 98);
      FILE* pp= popen( "rdfcat --version 2>&1", "r" );
      if( pp ) {
        int cc= fgetc( pp );
        if( '0'<= cc && cc<= '9' ) {
          rdfcat_available_b= true;
        }
        pclose( pp );
      }
    }
    */

    if( m_verbose_reporting_b ) {
      System.out.println();
      System.out.println("Creating Output ...");
    }

    String creator= "pdftk " + pdftk.PDFTK_VER + " - www.pdftk.com";
    String jv_creator_p= creator;

    if( m_output_owner_pw.equals("PROMPT") ) {
      m_output_owner_pw = pdftk.prompt_for_password( "owner", "the output PDF" );
    }
    if( m_output_user_pw.equals("PROMPT") ) {
      m_output_user_pw= pdftk.prompt_for_password( "user", "the output PDF");
    }

    byte[] output_owner_pw_p= new byte[0];
    if( !m_output_owner_pw.isEmpty() ) {
      output_owner_pw_p= passwords.utf8_password_to_pdfdoc(m_output_owner_pw, true );
      if (output_owner_pw_p == null) { // error
        System.err.println("Error: Owner password used to encrypt output PDF includes");
        System.err.println("   invalid characters.");
        System.err.println("   No output created.");
        ret_val= ErrorCode.ERROR;
      }
    }

    byte[] output_user_pw_p= new byte[0];
    if( !m_output_user_pw.isEmpty() ) {
      output_user_pw_p= passwords.utf8_password_to_pdfdoc(m_output_user_pw, true );
      if (output_user_pw_p == null) { // error
        System.err.println("Error: User password used to encrypt output PDF includes");
        System.err.println("   invalid characters.");
        System.err.println("   No output created.");
        ret_val= ErrorCode.ERROR;
      }
    }

    if( ret_val != ErrorCode.NO_ERROR )
      return ret_val; // <--- exit

    try {
      switch( m_operation ) {

      case cat_k :
      case shuffle_k : { // catenate pages or shuffle pages
        Document output_doc_p= new Document();

        OutputStream ofs_p= 
          pdftk.get_output_stream( m_output_filename, 
                             m_ask_about_warnings_b );

        if( ofs_p == null ) { // file open error
          ret_val= ErrorCode.ERROR;
          break;
        }
        PdfCopy writer_p= new PdfCopy( output_doc_p, ofs_p );

        // update to suit any features that we add, e.g. encryption;
        char max_version_cc= PdfWriter.VERSION_1_2;

        //
        output_doc_p.addCreator( jv_creator_p );

        // un/compress output streams?
        if( m_output_uncompress_b ) {
          writer_p.filterStreams= true;
          writer_p.compressStreams= false;
        }
        else if( m_output_compress_b ) {
          writer_p.filterStreams= false;
          writer_p.compressStreams= true;
        }

        // encrypt output?
        if( m_output_encryption_strength!= encryption_strength.none_enc ||
            !m_output_owner_pw.isEmpty() || 
            !m_output_user_pw.isEmpty() )
          {
            // if no stregth is given, default to 128 bit,
            boolean bit128_b=
              ( m_output_encryption_strength!= encryption_strength.bits40_enc );

            writer_p.setEncryption( output_user_pw_p,
                                     output_owner_pw_p,
                                     m_output_user_perms,
                                     bit128_b );

            if( bit128_b )
              max_version_cc= PdfWriter.VERSION_1_4;
            else // 1.1 probably okay, here
              max_version_cc= PdfWriter.VERSION_1_3;
          }

        // copy file ID?
        if( m_output_keep_first_id_b ||
            m_output_keep_final_id_b )
          {
            PdfReader input_reader_p= 
              m_output_keep_first_id_b ?
              m_input_pdf.get(0).m_readers.get(0).second :
              m_input_pdf.get(m_input_pdf.size()- 1).m_readers.get(0).second;
                
            PdfDictionary trailer_p= input_reader_p.getTrailer();
            
            PdfArray file_id_p= (PdfArray) input_reader_p.getPdfObject( trailer_p.get( PdfName.ID ) );
            if( file_id_p != null && file_id_p.isArray() ) {

              writer_p.setFileID( file_id_p );
            }
          }

        // set output PDF version to the max PDF ver of all the input PDFs;
        // also find the maximum extension levels, if present -- this can
        // only be added /after/ opening the document;
        //
        // collected extensions information; uses PdfName::hashCode() for key
        HashMap< PdfName, PdfName > ext_base_versions = new HashMap< PdfName, PdfName >();
        HashMap< PdfName, Integer > ext_levels = new HashMap< PdfName, Integer >();
        for( InputPdf it : m_input_pdf)
          {
            PdfReader reader_p= it.m_readers.get(0).second;

            ////
            // PDF version number

            // version in header
            if( max_version_cc< reader_p.getPdfVersion() )
              max_version_cc= reader_p.getPdfVersion();

            // version override in catalog; used only if greater than header version, per PDF spec;
            PdfDictionary catalog_p= reader_p.getCatalog();
            if( catalog_p.contains( PdfName.VERSION ) ) {

              PdfName version_p= (PdfName) reader_p.getPdfObject( catalog_p.get( PdfName.VERSION ) );
              char version_cc= GetPdfVersionChar( version_p );

              if( max_version_cc< version_cc )
                max_version_cc= version_cc;
            }

            ////
            // PDF extensions

            if( catalog_p.contains( PdfName.EXTENSIONS ) ) {
              PdfDictionary extensions_p= (PdfDictionary) reader_p.getPdfObject( catalog_p.get( PdfName.EXTENSIONS ) );
              if( extensions_p != null && extensions_p.isDictionary() ) {

                // iterate over developers
                Set<PdfObject> keys_p= extensions_p.getKeys();
                Iterator<PdfObject> kit= keys_p.iterator();
                while( kit.hasNext() ) {
                  PdfName developer_p= (PdfName) reader_p.getPdfObject( kit.next() );
                    
                  PdfDictionary dev_exts_p= (PdfDictionary) reader_p.getPdfObject( extensions_p.get( developer_p ) );
                  if( dev_exts_p != null && dev_exts_p.isDictionary() ) {

                    if( dev_exts_p.contains( PdfName.BASEVERSION ) &&
                        dev_exts_p.contains( PdfName.EXTENSIONLEVEL ) )
                      {
                        // use the greater base version or the greater extension level

                        PdfName base_version_p= (PdfName) reader_p.getPdfObject( dev_exts_p.get( PdfName.BASEVERSION ) );
                        PdfNumber ext_level_p= (PdfNumber) reader_p.getPdfObject( dev_exts_p.get( PdfName.EXTENSIONLEVEL ) );

                        if( !ext_base_versions.containsKey( developer_p ) ||
                            GetPdfVersionChar( ext_base_versions.get( developer_p ) )<
                            GetPdfVersionChar( base_version_p ) )
                          { // new developer or greater base version
                            ext_base_versions.put( developer_p, base_version_p );
                            ext_levels.put( developer_p, ext_level_p.intValue() );
                          }
                        else if( GetPdfVersionChar( ext_base_versions.get( developer_p ) )==
                                 GetPdfVersionChar( base_version_p ) &&
                                 ext_levels.get( developer_p )< ext_level_p.intValue() )
                          { // greater extension level for current base version
                            ext_levels.put( developer_p, ext_level_p.intValue() );
                          }
                      }
                  }
                }
              }
            }
          }
        // set the pdf version
        writer_p.setPdfVersion( max_version_cc );

        // open the doc
        output_doc_p.open();

        // set any pdf version extensions we might have found
        if( !ext_base_versions.isEmpty() ) {
          PdfDictionary extensions_dict_p= new PdfDictionary();
          PdfIndirectReference extensions_ref_p= writer_p.getPdfIndirectReference();
          for( Map.Entry<PdfName, PdfName> it : ext_base_versions.entrySet())
            {
              PdfDictionary ext_dict_p= new PdfDictionary();
              ext_dict_p.put( PdfName.BASEVERSION, it.getValue() );
              ext_dict_p.put( PdfName.EXTENSIONLEVEL, 
                              new PdfNumber( ext_levels.get(it.getKey()) ) );
              
              extensions_dict_p.put( it.getKey(), ext_dict_p );
            }

          writer_p.addToBody( extensions_dict_p, extensions_ref_p );
          writer_p.setExtensions( extensions_ref_p );
        }

        if( m_operation== keyword.shuffle_k ) {
          int max_seq_length= 0;
          for( ArrayList< PageRef > jt : m_page_seq)
            {
              max_seq_length= ( max_seq_length< jt.size() ) ? jt.size() : max_seq_length;
            }

          int output_page_count= 0;
          // iterate over ranges
          for( int ii= 0; ( ii< max_seq_length && ret_val== ErrorCode.NO_ERROR ); ++ii ) {
            // iterate over ranges
            for( ArrayList< PageRef > jt : m_page_seq )
              {
                if (ret_val != ErrorCode.NO_ERROR) break;
                if( ii< jt.size() ) {
                  ret_val= create_output_page( writer_p, jt.get(ii), output_page_count );
                  ++output_page_count;
                }
              }
          }
        }
        else { // cat_k
          
          int output_page_count= 0;
          // iterate over page ranges
          for( ArrayList< PageRef > jt : m_page_seq )
            {
              if (ret_val != ErrorCode.NO_ERROR) break;
              // iterate over pages in page range
              for( PageRef it : jt )
                {
                  if (ret_val != ErrorCode.NO_ERROR) break;
                  ret_val= create_output_page( writer_p, it, output_page_count );
                  ++output_page_count;
                }
            }

          // first impl added a bookmark for each input PDF and then
          // added any of that PDFs bookmarks under that; now it
          // appends input PDF bookmarks, which is more attractive;
          // OTOH, some folks might want pdftk to add bookmarks for
          // input PDFs, esp if they don't have bookmarks -- TODO
          // but then, it would be nice to allow the user to specify
          // a label -- using the PDF filename is unattractive;
          if( m_cat_full_pdfs_b ) { // add bookmark info
            // cerr << "cat full pdfs!" << endl; // debug

            PdfDictionary output_outlines_p= 
              new PdfDictionary( PdfName.OUTLINES );
            PdfIndirectReference output_outlines_ref_p= 
              writer_p.getPdfIndirectReference();

            PdfDictionary after_child_p= null;
            PdfIndirectReference after_child_ref_p= null;
              
            int page_count= 1;
            int num_bookmarks_total= 0;
            /* used for adding doc bookmarks
            itext::PdfDictionary* prev_p= 0;
            itext::PdfIndirectReference* prev_ref_p= 0;
            */
            // iterate over page ranges; each full PDF has one page seq in m_page_seq;
            // using m_page_seq instead of m_input_pdf, so the doc order is right
            for( ArrayList< PageRef > jt : m_page_seq)
              {
                PdfReader reader_p=
                  m_input_pdf.get(jt.get(0).m_input_pdf_index).m_readers.get(0).second;
                long reader_page_count= 
                  m_input_pdf.get(jt.get(0).m_input_pdf_index).m_num_pages;
            
                /* used for adding doc bookmarks
                itext::PdfDictionary* item_p= new itext::PdfDictionary();
                itext::PdfIndirectReference* item_ref_p= writer_p->getPdfIndirectReference();

                item_p->put( itext::PdfName::PARENT, outlines_ref_p );
                item_p->put( itext::PdfName::TITLE, 
                             new itext::PdfString( JvNewStringUTF( (*it).m_filename.c_str() ) ) );
                  
                // wire into linked list
                if( prev_p ) {
                  prev_p->put( itext::PdfName::NEXT, item_ref_p );
                  item_p->put( itext::PdfName::PREV, prev_ref_p );
                }
                else { // first item; wire into outlines dict
                  output_outlines_p->put( itext::PdfName::FIRST, item_ref_p );
                }

                // the destination
                itext::PdfDestination* dest_p= new itext::PdfDestination(itext::PdfDestination::FIT);
                itext::PdfIndirectReference* page_ref_p= writer_p->getPageReference( page_count );
                if( page_ref_p ) {
                  dest_p->addPage( page_ref_p );
                }
                item_p->put( itext::PdfName::DEST, dest_p );
                */

                // pdf bookmarks -> children
                { 
                  PdfDictionary catalog_p= reader_p.getCatalog();
                  PdfDictionary outlines_p= (PdfDictionary) reader_p.getPdfObject( catalog_p.get( PdfName.OUTLINES ) );
                  if( outlines_p != null && outlines_p.isDictionary() ) {

                    PdfDictionary top_outline_p= (PdfDictionary)
                      reader_p.getPdfObject( outlines_p.get( PdfName.FIRST ) );
                    if( top_outline_p != null && top_outline_p.isDictionary() ) {

                      ArrayList<PdfBookmark> bookmark_data = new ArrayList<PdfBookmark>();
                      int rr= bookmarks.ReadOutlines( bookmark_data, top_outline_p, 0, reader_p, true );
                      if( rr== 0 && !bookmark_data.isEmpty() ) {

                        // passed in by reference, so must use variable:
                        bookmarks.BuildBookmarksState state = new bookmarks.BuildBookmarksState();
                        state.final_child_p = after_child_p;
                        state.final_child_ref_p = after_child_ref_p;
                        state.num_bookmarks_total = num_bookmarks_total;
                        bookmarks.BuildBookmarks( writer_p,
                                        bookmark_data.listIterator(),
                                        //item_p, item_ref_p, // used for adding doc bookmarks
                                        output_outlines_p, output_outlines_ref_p,
                                        after_child_p, after_child_ref_p,
                                        0,
                                        page_count- 1, // page offset is 0-based
                                        0,
                                        true,
                                        state);
                        after_child_p = state.final_child_p;
                        after_child_ref_p = state.final_child_ref_p;
                        num_bookmarks_total = state.num_bookmarks_total;
                      }
                      /*
                      else if( rr!= 0 )
                      cerr << "ReadOutlines error" << endl; // debug
                      else
                      cerr << "empty bookmark data" << endl; // debug
                      */
                    }
                  }
                  /*
                  else
                    cerr << "no outlines" << endl; // debug
                  */
                }

                /* used for adding doc bookmarks
                // finished with prev; add to body
                if( prev_p )
                  writer_p->addToBody( prev_p, prev_ref_p );

                prev_p= item_p;
                prev_ref_p= item_ref_p;
                */

                page_count+= reader_page_count;

              }
            /* used for adding doc bookmarks
            if( prev_p ) { // wire into outlines dict
              // finished with prev; add to body
              writer_p->addToBody( prev_p, prev_ref_p );

              output_outlines_p->put( itext::PdfName::LAST, prev_ref_p );
              output_outlines_p->put( itext::PdfName::COUNT, new itext::PdfNumber( (jint)m_input_pdf.size() ) );
            }
            */

            if( num_bookmarks_total != 0 ) { // we encountered bookmarks

              // necessary for serial appending to outlines
              if( after_child_p != null && after_child_ref_p != null )
                writer_p.addToBody( after_child_p, after_child_ref_p );

              writer_p.addToBody( output_outlines_p, output_outlines_ref_p );
              writer_p.setOutlines( output_outlines_ref_p );
            }
          }
          
        }

        output_doc_p.close();
        writer_p.close();
      }
      break;
      
      case burst_k : { // burst input into pages

        // we should have been given only a single, input file
        if( 1< m_input_pdf.size() ) { // error
          System.err.println("Error: Only one input PDF file may be given for \"burst\" op.");
          System.err.println("   No output created.");
          break;
        }

        // grab the first reader, since there's only one
        PdfReader input_reader_p= 
          m_input_pdf.get(0).m_readers.get(0).second;
        int input_num_pages= 
          m_input_pdf.get(0).m_num_pages;

        if( m_output_filename.equals("PROMPT") ) {
          m_output_filename = pdftk.prompt_for_filename( "Please enter a filename pattern for the PDF pages (e.g. pg_%04d.pdf):");
        }
        if( m_output_filename.isEmpty() ) {
          m_output_filename= "pg_%04d.pdf";
        }

        // locate the input PDF Info dictionary that holds metadata
        PdfDictionary input_info_p= null; {
          PdfDictionary input_trailer_p= input_reader_p.getTrailer();
          if( input_trailer_p != null && input_trailer_p.isDictionary() ) {
            input_info_p= (PdfDictionary)
              input_reader_p.getPdfObject( input_trailer_p.get( PdfName.INFO ) );
            if( input_info_p != null && input_info_p.isDictionary() ) {
              // success
            }
            else {
              input_info_p= null;
            }
          }
        }

        for( int ii= 0; ii< input_num_pages; ++ii ) {

          // the filename
          String jv_output_filename_p= String.format(m_output_filename, ii+ 1);

          Document output_doc_p= new Document();
          FileOutputStream ofs_p= new FileOutputStream( jv_output_filename_p );
          PdfCopy writer_p= new PdfCopy( output_doc_p, ofs_p );
          writer_p.setFromReader( input_reader_p );

          output_doc_p.addCreator( jv_creator_p );

          // un/compress output streams?
          if( m_output_uncompress_b ) {
            writer_p.filterStreams= true;
            writer_p.compressStreams= false;
          }
          else if( m_output_compress_b ) {
            writer_p.filterStreams= false;
            writer_p.compressStreams= true;
          }

          // encrypt output?
          if( m_output_encryption_strength!= encryption_strength.none_enc ||
              !m_output_owner_pw.isEmpty() || 
              !m_output_user_pw.isEmpty() )
            {
              // if no stregth is given, default to 128 bit,
              boolean bit128_b=
                ( m_output_encryption_strength!= encryption_strength.bits40_enc );

              writer_p.setEncryption( output_user_pw_p,
                                       output_owner_pw_p,
                                       m_output_user_perms,
                                       bit128_b );
            }

          output_doc_p.open(); // must open writer before copying (possibly) indirect object

          { // copy the Info dictionary metadata
            if( input_info_p != null ) {
              PdfDictionary writer_info_p= writer_p.getInfo();
              if( writer_info_p != null ) {
                PdfDictionary info_copy_p= writer_p.copyDictionary( input_info_p );
                if( info_copy_p != null ) {
                  writer_info_p.putAll( info_copy_p );
                }
              }
            }
            byte[] input_reader_xmp_p= input_reader_p.getMetadata();
            if( input_reader_xmp_p != null ) {
              writer_p.setXmpMetadata( input_reader_xmp_p );
            }
          }

          PdfImportedPage page_p= 
            writer_p.getImportedPage( input_reader_p, ii+ 1 );
          writer_p.addPage( page_p );

          output_doc_p.close();
          writer_p.close();
        }

        ////
        // dump document data

        String doc_data_fn= "doc_data.txt";
        if( !m_output_filename.isEmpty() ) {
          int loc= m_output_filename.lastIndexOf(File.separatorChar);
          if( loc >= 0 ) {
            doc_data_fn= m_output_filename.substring( 0, loc )+ File.separatorChar + doc_data_fn;
          }
        }
        try {
          PrintStream ofs = pdftk.get_print_stream( doc_data_fn, m_output_utf8_b );
          report.ReportOnPdf( ofs, input_reader_p, m_output_utf8_b );
        }
        catch (FileNotFoundException e) { // error
          System.err.println("Error: unable to open file for output: doc_data.txt");
          ret_val= ErrorCode.ERROR;
        }

      }
      break;

      case filter_k: { // apply operations to given PDF file

        // we should have been given only a single, input file
        if( 1< m_input_pdf.size() ) { // error
          System.err.println("Error: Only one input PDF file may be given for this");
          System.err.println("   operation.  Maybe you meant to use the \"cat\" operator?");
          System.err.println("   No output created.");
          ret_val= ErrorCode.ERROR;
          break;
        }

        // try opening the FDF file before we get too involved;
        // if input is stdin ("-"), don't pass it to both the FDF and XFDF readers
        FdfReader fdf_reader_p= null;
        XfdfReader xfdf_reader_p= null;
        if( m_form_data_filename.equals("PROMPT") ) { // handle case where user enters '-' or (empty) at the prompt
          m_form_data_filename = pdftk.prompt_for_filename( "Please enter a filename for the form data:");
        }
        if( !m_form_data_filename.isEmpty() ) { // we have form data to process
          if( m_form_data_filename.equals("-") ) { // form data on stdin
            //JArray<jbyte>* in_arr= itext::RandomAccessFileOrArray::InputStreamToArray( java::System::in );
            
            // first try fdf
            try {
              fdf_reader_p= new FdfReader( System.in );
            }
            catch( IOException ioe_p ) { // file open error

              // maybe it's xfdf?
              try {
                xfdf_reader_p= new XfdfReader( System.in );
              }
              catch( IOException ioe2_p ) { // file open error
                System.err.println("Error: Failed read form data on stdin.");
                System.err.println("   No output created.");
                ret_val= ErrorCode.ERROR;
                //ioe_p->printStackTrace(); // debug
                break;
              }
            }
          }
          else { // form data file

            // first try fdf
            try {
              fdf_reader_p=
                new FdfReader( m_form_data_filename );
            }
            catch( IOException ioe_p ) { // file open error
              // maybe it's xfdf?
              try {
                xfdf_reader_p=
                  new XfdfReader( m_form_data_filename );
              }
              catch( IOException ioe2_p ) { // file open error
                System.err.println("Error: Failed to open form data file: ");
                System.err.println("   " + m_form_data_filename);
                System.err.println("   No output created.");
                ret_val= ErrorCode.ERROR;
                //ioe_p->printStackTrace(); // debug
                break;
              }
            }
          }
        }

        // try opening the PDF background or stamp before we get too involved
        PdfReader mark_p= null;
        boolean background_b= true; // set false for stamp
        //
        // background
        if( m_background_filename.equals("PROMPT") ) {
          m_background_filename = pdftk.prompt_for_filename( "Please enter a filename for the background PDF:");
        }
        if( !m_background_filename.isEmpty() ) {
          try {
            mark_p= new PdfReader( m_background_filename );
            mark_p.removeUnusedObjects();
            //reader->shuffleSubsetNames(); // changes the PDF subset names, but not the PostScript font names
          }
          catch( IOException ioe_p ) { // file open error
            System.err.println("Error: Failed to open background PDF file: ");
            System.err.println("   " + m_background_filename);
            System.err.println("   No output created.");
            ret_val= ErrorCode.ERROR;
            break;
          }
        }
        //
        // stamp
        if( mark_p == null ) {
          if( m_stamp_filename.equals("PROMPT") ) {
            m_stamp_filename = pdftk.prompt_for_filename( "Please enter a filename for the stamp PDF:");
          }
          if( !m_stamp_filename.isEmpty() ) {
            background_b= false;
            try {
              mark_p= new PdfReader( m_stamp_filename );
              mark_p.removeUnusedObjects();
              //reader->shuffleSubsetNames(); // changes the PDF subset names, but not the PostScript font names
            }
            catch( IOException ioe_p ) { // file open error
              System.err.println("Error: Failed to open stamp PDF file: ");
              System.err.println("   " + m_stamp_filename);
              System.err.println("   No output created.");
              ret_val= ErrorCode.ERROR;
              break;
            }
          }
        }

        //
        OutputStream ofs_p= pdftk.get_output_stream( m_output_filename, m_ask_about_warnings_b );
        if( ofs_p == null ) { // file open error
          System.err.println("Error: unable to open file for output: " + m_output_filename);
          ret_val= ErrorCode.ERROR;
          break;
        }

        //
        PdfReader input_reader_p= m_input_pdf.get(0).m_readers.get(0).second;

        // drop the xfa?
        if( m_output_drop_xfa_b ) {
          PdfDictionary catalog_p= input_reader_p.catalog;
          if( catalog_p != null && catalog_p.isDictionary() ) {
              
            PdfDictionary acro_form_p= (PdfDictionary)
              input_reader_p.getPdfObject( catalog_p.get( PdfName.ACROFORM ) );
            if( acro_form_p != null && acro_form_p.isDictionary() ) {

              acro_form_p.remove( PdfName.XFA );
            }
          }
        }

        // drop the xmp?
        if( m_output_drop_xmp_b ) {
          PdfDictionary catalog_p= input_reader_p.catalog;
          if( catalog_p != null && catalog_p.isDictionary() ) {
              
            catalog_p.remove( PdfName.METADATA );
          }
        }

        //
        PdfStamperImp writer_p=
          new PdfStamperImp( input_reader_p, ofs_p, '\0', false /* append mode */ );

        // update the info?
        if( m_update_info_filename.equals("PROMPT") ) {
          m_update_info_filename = pdftk.prompt_for_filename( "Please enter an Info file filename:");
        }
        if( !m_update_info_filename.isEmpty() ) {
          if( m_update_info_filename.equals("-") ) {
            if( !data_import.UpdateInfo( input_reader_p, System.in, m_update_info_utf8_b ) ) {
              System.err.println("Warning: no Info added to output PDF.");
              ret_val= ErrorCode.WARNING;
            }
          }
          else {
            try {
              FileInputStream ifs = new FileInputStream( m_update_info_filename );
              if( !data_import.UpdateInfo( input_reader_p, ifs, m_update_info_utf8_b ) ) {
                System.err.println("Warning: no Info added to output PDF.");
                ret_val= ErrorCode.WARNING;
              }
            }
            catch ( FileNotFoundException e ) { // error
              System.err.println("Error: unable to open FDF file for input: " + m_update_info_filename);
              ret_val= ErrorCode.ERROR;
              break;
            }
          }
        }

        /*
        // update the xmp?
        if( !m_update_xmp_filename.empty() ) {
          if( rdfcat_available_b ) {
            if( m_update_xmp_filename== "PROMPT" ) {
              prompt_for_filename( "Please enter an Info file filename:",
                                   m_update_xmp_filename );
            }
            if( !m_update_xmp_filename.empty() ) {
              UpdateXmp( input_reader_p, m_update_xmp_filename );
            }
          }
          else { // error
            cerr << "Error: to use this feature, you must install the rdfcat program." << endl;
            cerr << "   Perhaps the replace_xmp feature would suit you, instead?" << endl;
            break;
          }
        }
        */

        // rotate pages?
        if( !m_page_seq.isEmpty() ) {
          for( ArrayList< PageRef > jt : m_page_seq ) {
            for ( PageRef kt : jt ) {
              apply_rotation_to_page( input_reader_p, kt.m_page_num,
                                      kt.m_page_rot.value, kt.m_page_abs );
            }
          }
        }

        // un/compress output streams?
        if( m_output_uncompress_b ) {
          add_marks_to_pages( input_reader_p );
          writer_p.filterStreams= true;
          writer_p.compressStreams= false;
        }
        else if( m_output_compress_b ) {
          remove_marks_from_pages( input_reader_p );
          writer_p.filterStreams= false;
          writer_p.compressStreams= true;
        }

        // encrypt output?
        if( m_output_encryption_strength!= encryption_strength.none_enc ||
            !m_output_owner_pw.isEmpty() ||
            !m_output_user_pw.isEmpty() )
          {

            // if no stregth is given, default to 128 bit,
            // (which is incompatible w/ Acrobat 4)
            boolean bit128_b=
              ( m_output_encryption_strength!= encryption_strength.bits40_enc );

            writer_p.setEncryption( output_user_pw_p,
                                      output_owner_pw_p,
                                      m_output_user_perms,
                                      bit128_b );
          }

        // fill form fields?
        if( fdf_reader_p != null || xfdf_reader_p != null ) {
          if( input_reader_p.getAcroForm() != null ) { // we really have a form to fill

            AcroFields fields_p= writer_p.getAcroFields();
            fields_p.setGenerateAppearances( true ); // have iText create field appearances
            if( ( fdf_reader_p != null && fields_p.setFields( fdf_reader_p ) ) ||
                ( xfdf_reader_p != null && fields_p.setFields( xfdf_reader_p ) ) )
              { // Rich Text input found

                // set the PDF so that Acrobat will create appearances;
                // this might appear contradictory to our setGenerateAppearances( true ) call,
                // above; setting this, here, allows us to keep the generated appearances,
                // in case the PDF is opened somewhere besides Acrobat; yet, Acrobat/Reader
                // will create the Rich Text appearance if it has a chance
                m_output_need_appearances_b= true;
                /*
                itext::PdfDictionary* catalog_p= input_reader_p->catalog;
                if( catalog_p && catalog_p->isDictionary() ) {
              
                  itext::PdfDictionary* acro_form_p= (itext::PdfDictionary*)
                    input_reader_p->getPdfObject( catalog_p->get( itext::PdfName::ACROFORM ) );
                  if( acro_form_p && acro_form_p->isDictionary() ) {

                    acro_form_p->put( itext::PdfName::NEEDAPPEARANCES, itext::PdfBoolean::PDFTRUE );
                  }
                }
                */
              }
          }
          else { // warning
            System.err.println("Warning: input PDF is not an acroform, so its fields were not filled.");
            ret_val= ErrorCode.WARNING;
          }
        }

        // flatten form fields?
        writer_p.setFormFlattening( m_output_flatten_b );

        // cue viewer to render form field appearances?
        if( m_output_need_appearances_b ) {
          PdfDictionary catalog_p= input_reader_p.catalog;
          if( catalog_p != null && catalog_p.isDictionary() ) {
            PdfDictionary acro_form_p= (PdfDictionary)
              input_reader_p.getPdfObject( catalog_p.get( PdfName.ACROFORM ) );
            if( acro_form_p != null && acro_form_p.isDictionary() ) {
              acro_form_p.put( PdfName.NEEDAPPEARANCES, 
                                PdfBoolean.PDFTRUE );
            }
          }
        }

        // add background/watermark?
        if( mark_p != null ) {

          int mark_num_pages= 1; // default: use only the first page of mark
          if( m_multistamp_b || m_multibackground_b ) { // use all pages of mark
            mark_num_pages= mark_p.getNumberOfPages();
          }

          // the mark information; initialized inside loop
          PdfImportedPage mark_page_p= null;
          Rectangle mark_page_size_p= null;
          int mark_page_rotation= 0;

          // iterate over document's pages, adding mark_page as
          // a layer above (stamp) or below (watermark) the page content;
          // scale mark_page and move it so it fits within the document's page;
          //
          int num_pages= input_reader_p.getNumberOfPages();
          for( int ii= 0; ii< num_pages; ) {
            ++ii; // page refs are 1-based, not 0-based

            // the mark page and its geometry
            if( ii<= mark_num_pages ) {
              mark_page_size_p= mark_p.getCropBox( ii );
              mark_page_rotation= mark_p.getPageRotation( ii );
              for( int mm= 0; mm< mark_page_rotation; mm+=90 ) {
                mark_page_size_p= mark_page_size_p.rotate();
              }

              // create a PdfTemplate from the first page of mark
              // (PdfImportedPage is derived from PdfTemplate)
              mark_page_p= writer_p.getImportedPage( mark_p, ii );
            }

            // the target page geometry
            Rectangle doc_page_size_p= 
              input_reader_p.getCropBox( ii );
            int doc_page_rotation= input_reader_p.getPageRotation( ii );
            for( int mm= 0; mm< doc_page_rotation; mm+=90 ) {
              doc_page_size_p= doc_page_size_p.rotate();
            }

            float h_scale= doc_page_size_p.width() / mark_page_size_p.width();
            float v_scale= doc_page_size_p.height() / mark_page_size_p.height();
            float mark_scale= (h_scale< v_scale) ? h_scale : v_scale;

            float h_trans= (float)(doc_page_size_p.left()- mark_page_size_p.left()* mark_scale +
                                     (doc_page_size_p.width()- 
                                      mark_page_size_p.width()* mark_scale) / 2.0);
            float v_trans= (float)(doc_page_size_p.bottom()- mark_page_size_p.bottom()* mark_scale +
                                     (doc_page_size_p.height()- 
                                      mark_page_size_p.height()* mark_scale) / 2.0);
          
            PdfContentByte content_byte_p= 
              ( background_b ) ? writer_p.getUnderContent( ii ) : writer_p.getOverContent( ii );

            if( mark_page_rotation== 0 ) {
              content_byte_p.addTemplate( mark_page_p, 
                                           mark_scale, 0,
                                           0, mark_scale,
                                           h_trans, 
                                           v_trans );
            }
            else if( mark_page_rotation== 90 ) {
              content_byte_p.addTemplate( mark_page_p, 
                                           0, -1* mark_scale,
                                           mark_scale, 0,
                                           h_trans, 
                                           v_trans+ mark_page_size_p.height()* mark_scale );
            }
            else if( mark_page_rotation== 180 ) {
              content_byte_p.addTemplate( mark_page_p, 
                                           -1* mark_scale, 0,
                                           0, -1* mark_scale,
                                           h_trans+ mark_page_size_p.width()* mark_scale, 
                                           v_trans+ mark_page_size_p.height()* mark_scale );
            }
            else if( mark_page_rotation== 270 ) {
              content_byte_p.addTemplate( mark_page_p, 
                                           0, mark_scale,
                                           -1* mark_scale, 0,
                                           h_trans+ mark_page_size_p.width()* mark_scale, v_trans );
            }
          }
        }

        // attach file to document?
        if( !m_input_attach_file_filename.isEmpty() ) {
          this.attach_files( input_reader_p,
                              writer_p );
        }

        // performed in add_reader(), but this eliminates objects after e.g. drop_xfa, drop_xmp
        input_reader_p.removeUnusedObjects();

        // done; write output
        writer_p.close();
      }
      break;

      case dump_data_fields_k :
      case dump_data_annots_k :
      case dump_data_k: { // report on input document

        // we should have been given only a single, input file
        if( 1< m_input_pdf.size() ) { // error
          System.err.println("Error: Only one input PDF file may be used for the dump_data operation");
          System.err.println("   No output created.");
          ret_val= ErrorCode.ERROR;
          break;
        }

        PdfReader input_reader_p=
          m_input_pdf.get(0).m_readers.get(0).second;

        try {
          PrintStream ofs = pdftk.get_print_stream( m_output_filename, m_output_utf8_b );
          if( m_operation== keyword.dump_data_k ) {
            report.ReportOnPdf( ofs, input_reader_p, m_output_utf8_b );
          }
          else if( m_operation== keyword.dump_data_fields_k ) {
            report.ReportAcroFormFields( ofs, input_reader_p, m_output_utf8_b );
          }
          else if( m_operation== keyword.dump_data_annots_k ) {
            report.ReportAnnots( ofs, input_reader_p, m_output_utf8_b );
          }
        }
        catch (FileNotFoundException e) { // error
          System.err.println("Error: unable to open file for output: " + m_output_filename);
        }
      }
      break;

      case generate_fdf_k : { // create a dummy FDF file that would work with the input PDF form

        // we should have been given only a single, input file
        if( 1< m_input_pdf.size() ) { // error
          System.err.println("Error: Only one input PDF file may be used for the generate_fdf operation");
          System.err.println("   No output created.");
          break;
        }

        PdfReader input_reader_p= 
          m_input_pdf.get(0).m_readers.get(0).second;

        OutputStream ofs_p= 
          pdftk.get_output_stream( m_output_filename, 
                             m_ask_about_warnings_b );
        if( ofs_p != null ) {
          FdfWriter writer_p= new FdfWriter();
          input_reader_p.getAcroFields().exportAsFdf( writer_p );
          writer_p.writeTo( ofs_p );
          // no writer_p->close() function

          //delete writer_p; // OK? GC? -- NOT okay!
        }
        else { // error: get_output_stream() reports error
          ret_val= ErrorCode.ERROR;
          break;
        }
      }
        break;

      case unpack_files_k: { // copy PDF file attachments into current directory

        // we should have been given only a single, input file
        if( 1< m_input_pdf.size() ) { // error
          System.err.println("Error: Only one input PDF file may be given for \"unpack_files\" op.");
          System.err.println("   No output created.");
          ret_val= ErrorCode.ERROR;
          break;
        }

        PdfReader input_reader_p= 
          m_input_pdf.get(0).m_readers.get(0).second;

        this.unpack_files( input_reader_p );
      }
        break;
      default:
        // error
        System.err.println("Unexpected pdftk Error in create_output()");
        ret_val= ErrorCode.BUG;
        break;
      }
    }
    catch( Throwable t_p )
      {
        System.err.println("Unhandled Java Exception in create_output():");
        t_p.printStackTrace();
        ret_val= ErrorCode.BUG;
      }
  }
  else { // error
    ret_val= ErrorCode.ERROR;
  }

  return ret_val;
}

  private enum ArgState {
    input_files_e,
    input_pw_e,

    page_seq_e,
    form_data_filename_e,
    
    attach_file_filename_e,
    attach_file_pagenum_e,

    update_info_filename_e,
    update_xmp_filename_e,

    output_e, // state where we expect output_k, next
    output_filename_e,

    output_args_e, // output args are order-independent; switch here
    output_owner_pw_e,
    output_user_pw_e,
    output_user_perms_e,

    background_filename_e,
    stamp_filename_e,

    done_e
  };
  class ArgStateMutable {
    ArgState value;
  }

  // convenience function; return true iff handled
  private boolean handle_some_output_options( TK_Session.keyword kw, ArgStateMutable arg_state_p )
{
  switch( kw ) {
  case output_k:
    // added this case for the burst operation and "output" support;
    // also helps with backward compatibility of the "background" feature
    // change state
    arg_state_p.value= ArgState.output_filename_e;
    break;

    // state-altering keywords
  case owner_pw_k:
    // change state
    arg_state_p.value= ArgState.output_owner_pw_e;
    break;
  case user_pw_k:
    // change state
    arg_state_p.value= ArgState.output_user_pw_e;
    break;
  case user_perms_k:
    // change state
    arg_state_p.value= ArgState.output_user_perms_e;
    break;

    ////
    // no arguments to these keywords, so the state remains unchanged
  case encrypt_40bit_k:
    m_output_encryption_strength= encryption_strength.bits40_enc;
    break;
  case encrypt_128bit_k:
    m_output_encryption_strength= encryption_strength.bits128_enc;
    break;
  case filt_uncompress_k:
    m_output_uncompress_b= true;
    break;
  case filt_compress_k:
    m_output_compress_b= true;
    break;
  case flatten_k:
    m_output_flatten_b= true;
    break;
  case need_appearances_k:
    m_output_need_appearances_b= true;
    break;
  case drop_xfa_k:
    m_output_drop_xfa_b= true;
    break;
  case drop_xmp_k:
    m_output_drop_xmp_b= true;
    break;
  case keep_first_id_k:
    m_output_keep_first_id_b= true;
    break;
  case keep_final_id_k:
    m_output_keep_final_id_b= true;
    break;
  case verbose_k:
    m_verbose_reporting_b= true;
    break;
  case dont_ask_k:
    m_ask_about_warnings_b= false;
    break;
  case do_ask_k:
    m_ask_about_warnings_b= true;
    break;

  case background_k:
    if( m_operation!= keyword.filter_k ) { // warning
      System.err.println("Warning: the \"background\" output option works only in filter mode.");
      System.err.println("  This means it won't work in combination with \"cat\", \"burst\",");
      System.err.println("  \"attach_file\", etc.  To run pdftk in filter mode, simply omit");
      System.err.println("  the operation, e.g.: pdftk in.pdf output out.pdf background back.pdf");
      System.err.println("  Or, use background as an operation; this is the preferred technique:");
      System.err.println("    pdftk in.pdf background back.pdf output out.pdf");
    }
    // change state
    arg_state_p.value= ArgState.background_filename_e;
    break;

  default: // not handled here; no change to *arg_state_p
    return false;
  }

  return true;
}

};
 /*
 *
 *   This file is part of the pdftk port to java
 *
 *   Copyright (c) Marc Vinyals 2017-2018
 *
 *   The program is a java port of PDFtk, the PDF Toolkit
 *   Copyright (c) 2003-2013 Steward and Lee, LLC
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   The program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.gitlab.pdftk_java;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;

import pdftk.com.lowagie.text.pdf.PdfDictionary;
import pdftk.com.lowagie.text.pdf.PdfName;
import pdftk.com.lowagie.text.pdf.PdfReader;
import pdftk.com.lowagie.text.pdf.PdfStream;
import pdftk.com.lowagie.text.pdf.PdfString;
import pdftk.com.lowagie.text.pdf.PRStream;

class attachments {
static String
  drop_path( String ss )
{
  int loc = ss.lastIndexOf( File.separatorChar );
  if( loc != -1 && loc!= ss.length()- 1 ) {
    return ss.substring( loc+ 1 );
  }
  return ss;
}

static String
normalize_pathname( String output_pathname )
{
  if( output_pathname== "PROMPT" ) {
    output_pathname = pdftk.prompt_for_filename( "Please enter the directory where you want attachments unpacked:" );
  }
  if( output_pathname.lastIndexOf( File.separatorChar )== output_pathname.length()- 1 ) {
    return output_pathname;
  }
  else{ // add delim to end
    return output_pathname+ File.separatorChar;
  }
}

static void
unpack_file( PdfReader input_reader_p,
             PdfDictionary filespec_p,
             String output_pathname,
             boolean ask_about_warnings_b )
{
  if( filespec_p != null && filespec_p.isDictionary() ) {

    PdfName type_p= (PdfName)
      input_reader_p.getPdfObject( filespec_p.get( PdfName.TYPE ) );
    if( type_p != null && type_p.isName() && 
        ( type_p.compareTo( PdfName.FILESPEC )== 0 ||
          type_p.compareTo( PdfName.F )== 0 ) )
      {
        PdfDictionary ef_p= (PdfDictionary)
          input_reader_p.getPdfObject( filespec_p.get( PdfName.EF ) );
        if( ef_p != null && ef_p.isDictionary() ) {

          // UF introduced in PDF 1.7
          PdfString fn_p= (PdfString)
            input_reader_p.getPdfObject( filespec_p.get( PdfName.UF ) );
          if( fn_p == null ) { // try the F key
            fn_p= (PdfString)
            input_reader_p.getPdfObject( filespec_p.get( PdfName.F ) );
          }

          if( fn_p != null && fn_p.isString() ) {

            // patch by Johann Felix Soden <johfel@gmx.de>
            // patch tweaked by Sid Steward:
            // toString() doesn't ensure conversion from internal encoding (e.g., Y+diaeresis)
            String fn_str = fn_p.toUnicodeString();
            String fn= drop_path( fn_str );

            // did the user supply a path?
            if( !output_pathname.isEmpty() ) { // prepend it
              fn= output_pathname+ fn; // output_pathname has been normalized, already
            }
                      
            // assuming that F key is used to store the data, and not DOS, Mac, or Unix
            PdfStream f_p= (PdfStream)
              input_reader_p.getPdfObject( ef_p.get( PdfName.F ) );
            if( f_p != null && f_p.isStream() ) {

              try {
                byte[] bytes_p= input_reader_p.getStreamBytes( (PRStream)f_p );

                if( ask_about_warnings_b ) {
                  // test for existing file by this name
                  if ( pdftk.file_exists( fn ) ) {
                    if ( !pdftk.confirm_overwrite( fn ) ) {
                      System.out.println( "   Skipping: " + fn );
                      return; // <--- return
                    }
                  }
                }
                FileOutputStream ofs = new FileOutputStream( fn );
                ofs.write( bytes_p );
                ofs.close();
              }
              catch ( IOException e ) { // error
                System.err.println( "Error: unable to create the file:" );
                System.err.println( "   " + fn );
                System.err.println( "   Skipping.");
              }
            }
          }
        }
      }
  }
}
  
}
 /*
 *
 *   This file is part of the pdftk port to java
 *
 *   Copyright (c) Marc Vinyals 2017-2018
 *
 *   The program is a java port of PDFtk, the PDF Toolkit
 *   Copyright (c) 2003-2013 Steward and Lee, LLC
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   The program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.gitlab.pdftk_java;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.ListIterator;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

import pdftk.com.lowagie.text.pdf.PdfArray;
import pdftk.com.lowagie.text.pdf.PdfDestination;
import pdftk.com.lowagie.text.pdf.PdfDictionary;
import pdftk.com.lowagie.text.pdf.PdfIndirectReference;
import pdftk.com.lowagie.text.pdf.PdfObject;
import pdftk.com.lowagie.text.pdf.PdfName;
import pdftk.com.lowagie.text.pdf.PdfNumber;
import pdftk.com.lowagie.text.pdf.PdfReader;
import pdftk.com.lowagie.text.pdf.PdfString;
import pdftk.com.lowagie.text.pdf.PdfWriter;
import pdftk.com.lowagie.text.pdf.PRIndirectReference;

class bookmarks {

static int
GetPageNumber( PdfDictionary dict_p,
               PdfReader reader_p,
               HashMap<PdfDictionary, Integer> cache )
// take a PdfPage dictionary and return its page location in the document;
// recurse our way up the pages tree, counting pages as we go;
// dict_p may be a page or a page tree object;
// return value is zero-based;
{
  { // consult the cache
    Integer it = cache.get( dict_p );
    if ( it != null ) return it;
  }

  int ret_val= 0;

  if( dict_p != null && dict_p.contains( PdfName.PARENT ) ) {
    PdfDictionary parent_p= (PdfDictionary)
      reader_p.getPdfObject( dict_p.get( PdfName.PARENT ) );
    if( parent_p!= null && parent_p.isDictionary() ) {
      // a parent is a page tree object and will have Kids

      // recurse up the page tree
      int sum_pages= GetPageNumber( parent_p, reader_p, cache );

      PdfArray parent_kids_p= (PdfArray)
        reader_p.getPdfObject( parent_p.get( PdfName.KIDS ) );
      if( parent_kids_p!= null && parent_kids_p.isArray() ) {
        // Kids may be Pages or Page Tree Nodes

        // iterate over *dict_p's parent's kids until we run into *dict_p
        ArrayList<PRIndirectReference> kids_p= parent_kids_p.getArrayList();
        if( kids_p!= null ) {
          for( PRIndirectReference kids_ii : kids_p ) {

            PdfDictionary kid_p= (PdfDictionary)
              reader_p.getPdfObject( kids_ii );
            if( kid_p!= null && kid_p.isDictionary() ) {

              if( kid_p== dict_p ) // we have what we were looking for
                ret_val= sum_pages;

              // is kid a page, or is kid a page tree object? add count to sum;
              // PdfDictionary::isPage() and PdfDictionary::isPages()
              // are not reliable, here

              PdfName kid_type_p= (PdfName)
                reader_p.getPdfObject( kid_p.get( PdfName.TYPE ) );
              if( kid_type_p!= null && kid_type_p.isName() ) {

                if( kid_type_p.equals( PdfName.PAGE ) ) {
                  // *kid_p is a Page

                  // store page number in our cache
                  cache.put( kid_p, sum_pages );

                  //
                  sum_pages+= 1;
                }
                else if( kid_type_p.equals( PdfName.PAGES ) ) {
                  // *kid_p is a Page Tree Node

                  PdfNumber count_p= (PdfNumber)
                    reader_p.getPdfObject( kid_p.get( PdfName.COUNT ) );
                  if( count_p != null && count_p.isNumber() ) {

                    //
                    sum_pages+= count_p.intValue();
                  }
                  else { // error
                    System.err.println( "pdftk Error in GetPageNumber(): invalid count;" );
                  }
                }
                else { // error
                  System.err.println( "pdftk Error in GetPageNumber(): unexpected kid type;" );
                }
              }
              else { // error
                System.err.println( "pdftk Error in GetPageNumber(): invalid kid_type_p;" );
              }
            }
            else { // error
              System.err.println( "pdftk Error in GetPageNumber(): invalid kid_p;" );
            }
          } // done iterating over kids

        }
        else { // error
          System.err.println( "pdftk Error in GetPageNumber(): invalid kids_p;" );
        }
      }
      else { // error
        System.err.println( "pdftk Error in GetPageNumber(): invalid kids array;" );
      }
    }
    else { // error
      System.err.println( "pdftk Error in GetPageNumber(): invalid parent;" );
    }
  }
  else {
    // *dict_p has no parent; end recursion
    ret_val= 0;
    cache.put( dict_p, ret_val );
  }

  return ret_val;
}
  
static int 
ReadOutlines( ArrayList<PdfBookmark> bookmark_data,
              PdfDictionary outline_p,
              int level,
              PdfReader reader_p,              
              boolean utf8_b ) {

  int ret_val= 0;
  HashMap<PdfDictionary, Integer> cache = new HashMap<PdfDictionary, Integer>();

  while( outline_p != null ) {

    // load this with collected data, then add to vector
    PdfBookmark bookmark = new PdfBookmark();

    // the title
    PdfString title_p= (PdfString)
      reader_p.getPdfObject( outline_p.get( PdfName.TITLE ) );
    if( title_p != null && title_p.isString() ) {

      bookmark.m_title= report.OutputPdfString( title_p, utf8_b );
    }
    else { // error
      ret_val= 1;
    }

    // the level; 1-based to jive with HTML heading level concept
    bookmark.m_level= level+ 1;

    // page number, 1-based; 
    // a zero value indicates no page destination or an error
    {
      boolean fail_b= false;

      // the destination object may take be in a couple different places
      // and may take a couple, different forms

      PdfObject destination_p= null; {
        if( outline_p.contains( PdfName.DEST ) ) {
          destination_p=
            reader_p.getPdfObject( outline_p.get( PdfName.DEST ) );
        }
        else if( outline_p.contains( PdfName.A ) ) {

          PdfDictionary action_p= (PdfDictionary)
            reader_p.getPdfObject( outline_p.get( PdfName.A ) );
          if( action_p != null && action_p.isDictionary() ) {

            PdfName s_p= (PdfName)
              reader_p.getPdfObject( action_p.get( PdfName.S ) );
            if( s_p != null && s_p.isName() ) {

              if( s_p.equals( PdfName.GOTO ) ) {
                destination_p=
                  reader_p.getPdfObject( action_p.get( PdfName.D ) );
              }
              else { // immediate action is not a link in this document;
                // not an error
                // fail_b= true;
              }
            }
            else { // error
              fail_b= true;
            }
          }
          else { // error
            fail_b= true;
          }
        }
        else { // unexpected
          fail_b= true;
        }
      }

      // destination is an array
      if( destination_p != null && destination_p.isArray() ) {

        ArrayList<PRIndirectReference> array_list_p= ((PdfArray)destination_p).getArrayList();
        if( array_list_p != null && !array_list_p.isEmpty() ) {

          PdfDictionary page_p= (PdfDictionary)
            reader_p.getPdfObject( array_list_p.get(0) );

          if( page_p !=null && page_p.isDictionary() ) {
            bookmark.m_page_num= GetPageNumber(page_p, reader_p, cache)+ 1;
          }
          else { // error
            fail_b= true;
          }
        }
        else { // error
          fail_b= true;
        }
      } // TODO: named destinations handling
      else { // error
        fail_b= true;
      }

      if( fail_b ) { // output our 'null page reference' code
        bookmark.m_page_num= 0;
      }
    }

    // add bookmark to collected data
    if( 0< bookmark.m_level )
      bookmark_data.add( bookmark );

    // recurse into any children
    if( outline_p.contains( PdfName.FIRST ) ) {

      PdfDictionary child_p= (PdfDictionary)
        reader_p.getPdfObject( outline_p.get( PdfName.FIRST ) );
      if( child_p != null && child_p.isDictionary() ) {

        ret_val+= ReadOutlines( bookmark_data, child_p, level+ 1, reader_p, utf8_b );
      }
    }

    // iterate over siblings
    if( outline_p.contains( PdfName.NEXT ) ) {

      PdfDictionary sibling_p= (PdfDictionary)
        reader_p.getPdfObject( outline_p.get( PdfName.NEXT ) );
      if( sibling_p != null && sibling_p.isDictionary() ) {
        outline_p= sibling_p;
      }
      else // break out of loop
        outline_p= null;
    }
    else // break out of loop
      outline_p= null;
  }

  return ret_val;
}
  
static void
RemoveBookmarks( PdfReader reader_p,
                 PdfDictionary bookmark_p )
// call reader_p->removeUnusedObjects() afterward
{
  if( bookmark_p.contains( PdfName.FIRST ) ) { // recurse
    PdfDictionary first_p= (PdfDictionary)
      reader_p.getPdfObject( bookmark_p.get( PdfName.FIRST ) );
    RemoveBookmarks( reader_p, first_p );

    bookmark_p.remove( PdfName.FIRST );
  }

  if( bookmark_p.contains( PdfName.NEXT ) ) { // recurse
    PdfDictionary next_p= (PdfDictionary)
      reader_p.getPdfObject( bookmark_p.get( PdfName.NEXT ) );
    RemoveBookmarks( reader_p, next_p );

    bookmark_p.remove( PdfName.NEXT );
  }

  bookmark_p.remove( PdfName.PARENT );
  bookmark_p.remove( PdfName.PREV );
  bookmark_p.remove( PdfName.LAST );
}
  
static class BuildBookmarksState {
  PdfDictionary final_child_p;
  PdfIndirectReference final_child_ref_p;
  int num_bookmarks_total;
};

// Translator note: returns num_bookmarks_total
static int
BuildBookmarks(PdfReader reader_p,
               ListIterator<PdfBookmark> it,
               PdfDictionary parent_p,
               PRIndirectReference parent_ref_p,
               int parent_level,
               boolean utf8_b ) {
  int num_bookmarks_total = 0;

  PdfDictionary bookmark_prev_p= null;
  PRIndirectReference bookmark_first_ref_p= null;
  PRIndirectReference bookmark_prev_ref_p= null;
  int num_bookmarks= 0;

  PdfBookmark it_content = it.next();it.previous();
  if( parent_level+ 1< it_content.m_level ) { // first child jumping levels

    ////
    // add missing level

    ++num_bookmarks; ++num_bookmarks_total;
    PdfDictionary bookmark_p= new PdfDictionary();
    PRIndirectReference bookmark_ref_p= reader_p.getPRIndirectReference( bookmark_p );
    bookmark_first_ref_p= bookmark_ref_p;

    bookmark_p.put( PdfName.PARENT, (PdfObject)parent_ref_p );

    PdfString title_p= new PdfString( "" );
    bookmark_p.put( PdfName.TITLE, title_p );

    bookmark_prev_p= bookmark_p;
    bookmark_prev_ref_p= bookmark_ref_p;

    // recurse in loop
  }

  for( ;it.hasNext(); it.next() ) {
    it_content = it.next();it.previous();
  
    if( parent_level+ 1< it_content.m_level ) { // encountered child; recurse
      num_bookmarks_total += BuildBookmarks( reader_p,
                               it,
                               bookmark_prev_p, // parent
                               bookmark_prev_ref_p,
                               parent_level+ 1,
                               utf8_b );
      it.previous();
      continue;
    }
    else if( it_content.m_level< parent_level+ 1 ) {
      break; // no more children; add children to parent and return
    }

    ////
    // create child

    ++num_bookmarks; ++num_bookmarks_total;
    PdfDictionary bookmark_p= new PdfDictionary();
    PRIndirectReference bookmark_ref_p= reader_p.getPRIndirectReference( bookmark_p );
    if( bookmark_first_ref_p==null )
      bookmark_first_ref_p= bookmark_ref_p;

    bookmark_p.put( PdfName.PARENT, (PdfObject)parent_ref_p );

    if( bookmark_prev_ref_p!=null ) {
      bookmark_p.put( PdfName.PREV, (PdfObject)bookmark_prev_ref_p );
      bookmark_prev_p.put( PdfName.NEXT, (PdfObject)bookmark_ref_p );
    }

    if( utf8_b ) { // UTF-8 encoded input
      bookmark_p.put( PdfName.TITLE,
                       new PdfString( it_content.m_title /*,
                       itext::PdfObject::TEXT_UNICODE*/ ) );
    }
    else { // XML entities input
      String jvs = data_import.XmlStringToJcharArray( it_content.m_title );

      bookmark_p.put( PdfName.TITLE,
                       new PdfString( jvs /*,
                       itext::PdfObject::TEXT_UNICODE*/ ) );
    }

    if( 0< it_content.m_page_num ) { // destination
      PdfDestination dest_p= new PdfDestination(PdfDestination.FIT);
      PRIndirectReference page_ref_p= reader_p.getPageOrigRef( it_content.m_page_num );
      if( page_ref_p!=null ) {
        dest_p.addPage( (PdfIndirectReference)page_ref_p );
      }
      bookmark_p.put( PdfName.DEST, dest_p );
    }

    bookmark_prev_p= bookmark_p;
    bookmark_prev_ref_p= bookmark_ref_p;
  }

  if( bookmark_first_ref_p!=null && bookmark_prev_ref_p!=null ) {
    // pack these children into parent before returning
    parent_p.put( PdfName.FIRST, (PdfObject)bookmark_first_ref_p );
    parent_p.put( PdfName.LAST, (PdfObject)bookmark_prev_ref_p );
    if( parent_level== 0 ) {
      parent_p.put( PdfName.COUNT, new PdfNumber( num_bookmarks_total ) );
    }
    else {
      parent_p.put( PdfName.COUNT, new PdfNumber( num_bookmarks ) );
    }
  }

  return num_bookmarks_total;
}
  
// for use with writers, e.g. PdfCopy (esp. PdfCopy.setOutlines())
static void
BuildBookmarks(PdfWriter writer_p,
               ListIterator<PdfBookmark> it,
               PdfDictionary parent_p,
               PdfIndirectReference parent_ref_p,
               PdfDictionary after_child_p,
               PdfIndirectReference after_child_ref_p,
               int parent_level,
               int page_num_offset,
               int level_offset,
               boolean utf8_b,
               BuildBookmarksState state)
  throws IOException
{
  // when using after_child, caller must
  // call writer_p->addToBody( after_child_p, after_child_ref_p ) upon return
  PdfDictionary bookmark_prev_p= after_child_p;
  PdfIndirectReference bookmark_prev_ref_p= after_child_ref_p;

  PdfIndirectReference bookmark_first_ref_p= null;
  int num_bookmarks= 0;

  PdfBookmark it_content = it.next();it.previous();
  if( parent_level+ 1< it_content.m_level ) { // first child jumping levels

    ////
    // add missing level

    ++num_bookmarks; ++state.num_bookmarks_total;
    PdfDictionary bookmark_p= new PdfDictionary();
    PdfIndirectReference bookmark_ref_p= writer_p.getPdfIndirectReference();
    bookmark_first_ref_p= bookmark_ref_p;

    bookmark_p.put( PdfName.PARENT, (PdfObject)parent_ref_p );

    PdfString title_p= new PdfString( "" );
    bookmark_p.put( PdfName.TITLE, title_p );

    bookmark_prev_p= bookmark_p;
    bookmark_prev_ref_p= bookmark_ref_p;

    // recurse in loop
  }

  for( ;it.hasNext(); it.next() ) {
    it_content = it.next();it.previous();
  
    if( parent_level+ 1< it_content.m_level ) { // encountered child; recurse
      BuildBookmarks( writer_p,
                      it,
                      bookmark_prev_p, // parent
                      bookmark_prev_ref_p,
                      null, null,
                      parent_level+ 1,
                      page_num_offset,
                      level_offset,
                      utf8_b,
                      state );
      it.previous();
      continue;
    }
    else if( it_content.m_level< parent_level+ 1 ) {
      break; // no more children; add children to parent and return
    }

    ////
    // create child

    ++num_bookmarks; ++state.num_bookmarks_total;
    PdfDictionary bookmark_p= new PdfDictionary();
    PdfIndirectReference bookmark_ref_p= writer_p.getPdfIndirectReference();
    if( bookmark_first_ref_p == null )
      bookmark_first_ref_p= bookmark_ref_p;

    bookmark_p.put( PdfName.PARENT, (PdfObject)parent_ref_p );

    if( bookmark_prev_ref_p != null ) {
      bookmark_p.put( PdfName.PREV, (PdfObject)bookmark_prev_ref_p );
      bookmark_prev_p.put( PdfName.NEXT, (PdfObject)bookmark_ref_p );
    }

    if( utf8_b ) { // UTF-8 encoded input
      bookmark_p.put( PdfName.TITLE,
                       new PdfString( it_content.m_title /*,
                       itext::PdfObject::TEXT_UNICODE*/ ) );
    }
    else { // XML entities input
      String jvs = data_import.XmlStringToJcharArray( it_content.m_title );

      bookmark_p.put( PdfName.TITLE,
                       new PdfString( jvs /*,
                       itext::PdfObject::TEXT_UNICODE*/ ) );
    }

    if( 0< it_content.m_page_num ) { // destination
      PdfDestination dest_p= new PdfDestination(PdfDestination.FIT);
      PdfIndirectReference page_ref_p= 
        writer_p.getPageReference( it_content.m_page_num+ page_num_offset );
      if( page_ref_p != null ) {
        dest_p.addPage( (PdfIndirectReference)page_ref_p );
      }
      bookmark_p.put( PdfName.DEST, dest_p );
    }

    // finished with prev; add to body
    if( bookmark_prev_p != null )
      writer_p.addToBody( bookmark_prev_p, bookmark_prev_ref_p );

    bookmark_prev_p= bookmark_p;
    bookmark_prev_ref_p= bookmark_ref_p;
  }

  // finished with prev; add to body (unless we're appending)
  if( bookmark_prev_p != null && after_child_p == null )
    writer_p.addToBody( bookmark_prev_p, bookmark_prev_ref_p );

  if( bookmark_first_ref_p != null && bookmark_prev_ref_p != null ) {
    // pack these children into parent before returning
    if( !parent_p.contains( PdfName.FIRST ) ) // in case we're appending
      parent_p.put( PdfName.FIRST, (PdfObject)bookmark_first_ref_p );
    parent_p.put( PdfName.LAST, (PdfObject)bookmark_prev_ref_p );
    if( parent_level== 0 ) { // only for top-level "outlines" dict
      parent_p.put( PdfName.COUNT, new PdfNumber( state.num_bookmarks_total ) );
    }
    else {
      parent_p.put( PdfName.COUNT, new PdfNumber( num_bookmarks ) );
    }
  }

  // pass back to calling function so it can call BuildBookmarks serially
  state.final_child_p= bookmark_prev_p;
  state.final_child_ref_p= bookmark_prev_ref_p;
}

};
 /*
 *   This file is part of the pdftk port to java
 *
 *   Copyright (c) Marc Vinyals 2017-2018
 *
 *   The program is a java port of PDFtk, the PDF Toolkit
 *   Copyright (c) 2003-2013 Steward and Lee, LLC
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   The program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.gitlab.pdftk_java;

import java.util.ArrayList;
import java.util.Scanner;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

import org.apache.commons.lang3.StringEscapeUtils;

import pdftk.com.lowagie.text.Rectangle;
import pdftk.com.lowagie.text.pdf.PdfArray;
import pdftk.com.lowagie.text.pdf.PdfBoolean;
import pdftk.com.lowagie.text.pdf.PdfDictionary;
import pdftk.com.lowagie.text.pdf.PdfName;
import pdftk.com.lowagie.text.pdf.PdfNumber;
import pdftk.com.lowagie.text.pdf.PdfObject;
import pdftk.com.lowagie.text.pdf.PdfReader;
import pdftk.com.lowagie.text.pdf.PdfString;
import pdftk.com.lowagie.text.pdf.PdfWriter;
import pdftk.com.lowagie.text.pdf.PRIndirectReference;

class data_import {
  
static PdfData
  LoadDataFile( InputStream input_stream )
{
  PdfData pdf_data_p = new PdfData();
  Scanner ifs = new Scanner( input_stream );

  String buff= "";

  String buff_prev= "";
  int buff_prev_len= 0;

  PdfInfo info = new PdfInfo();
  boolean info_b= false;

  PdfBookmark bookmark = new PdfBookmark();
  boolean bookmark_b= false;

  boolean eof = !ifs.hasNextLine();
  
  while( !eof ) {
    eof = !ifs.hasNextLine();
    if (eof) buff = "";
    else buff = ifs.nextLine();

    if( eof ||
        buff.startsWith( PdfInfo.m_begin_mark ) ||
        buff.startsWith( PdfBookmark.m_begin_mark ) ||
        buff.startsWith( report.PdfPageLabel.m_begin_mark ) ||
        !buff_prev.isEmpty() && !buff.startsWith( buff_prev ) )
    { // start of a new record or end of file
      // pack data and reset

      if( info_b ) {
        if( info.valid() ) {
          pdf_data_p.m_info.add( info );
        }
        else { // warning
          System.err.println( "pdftk Warning: data info record not valid -- skipped; data:" );
          System.err.print( info );
        }
      }
      else if( bookmark_b ) {
        if( bookmark.valid() ) {
          pdf_data_p.m_bookmarks.add( bookmark );
        }
        else { // warning
          System.err.println( "pdftk Warning: data bookmark record not valid -- skipped; data:" );
          System.err.print( bookmark );
        }
      }

      // reset
      buff_prev= "";
      //
      info= new PdfInfo();
      info_b= false;
      //
      bookmark= new PdfBookmark();
      bookmark_b= false;
    }

    // whitespace or comment; skip
    if( buff.isEmpty() || buff.startsWith("#") ) {
      continue;
    }

    // info record
    else if( buff.startsWith( PdfInfo.m_prefix ) ) {
      buff_prev_len= PdfInfo.m_prefix.length();
      info_b= true;
      
      if( buff.startsWith( PdfInfo.m_begin_mark ) ||
          info.loadKey( buff ) ||
          info.loadValue( buff ) )
        {
          // success
        }
      else { // warning
        System.err.println( "pdftk Warning: unexpected Info case in LoadDataFile(); continuing" );
      }
    }

    // bookmark record
    else if( buff.startsWith( PdfBookmark.m_prefix ) ) {
      buff_prev_len= PdfBookmark.m_prefix.length();
      bookmark_b= true;
      
      if( buff.startsWith( PdfBookmark.m_begin_mark ) ||
          bookmark.loadTitle( buff ) ||
          bookmark.loadLevel( buff ) ||
          bookmark.loadPageNum( buff ) )
      {
        // success
      }
      else { // warning
        System.err.println( "pdftk Warning: unexpected Bookmark case in LoadDataFile(); continuing" );
      }
    }
    
    // page label record
    else if( buff.startsWith( report.PdfPageLabel.m_prefix ) ) {
      buff_prev_len= 0;
      // TODO
    }
    
    // page media record
    else if( buff.startsWith( report.PdfPageMedia.m_prefix ) ) {
      buff_prev_len= 0;
      // TODO
    }

    // pdf id
    else if( buff.startsWith( PdfData.m_prefix ) ) {
      buff_prev_len= 0; // not a record
      
      if( pdf_data_p.loadID0( buff ) ||
          pdf_data_p.loadID1( buff ) )
        {
          // success
        }
      else { // warning
        System.err.println( "pdftk Warning: unexpected PdfID case in LoadDataFile(); continuing" );
      }
    }

    // number of pages
    else if( pdf_data_p.loadNumPages( buff ) ) {
      buff_prev_len= 0; // not a record
    }

    else { // warning
      System.err.println( "pdftk Warning: unexpected case 1 in LoadDataFile(); continuing" );
    }
      
    buff_prev = buff.substring( 0, buff_prev_len );
  }

  if( buff_prev_len!= 0 ) { // warning; some incomplete record hasn't been packed
    System.err.println( "pdftk Warning in LoadDataFile(): incomplete record;" );
  }

  return pdf_data_p;
}
  
static boolean
UpdateInfo( PdfReader reader_p,
            InputStream ifs,
            boolean utf8_b ) {
  boolean ret_val_b= true;

  PdfData pdf_data = LoadDataFile( ifs );
  if( pdf_data != null ) {
    
    { // trailer data
      PdfDictionary trailer_p= reader_p.getTrailer();
      if( trailer_p != null && trailer_p.isDictionary() ) {

        // bookmarks
        if( !pdf_data.m_bookmarks.isEmpty() ) {
          
          // build bookmarks
          PdfDictionary outlines_p= new PdfDictionary( PdfName.OUTLINES );
          if( outlines_p != null ) {
            PRIndirectReference outlines_ref_p= reader_p.getPRIndirectReference( outlines_p );

            int num_bookmarks_total = bookmarks.BuildBookmarks( reader_p,
                            pdf_data.m_bookmarks.listIterator(),
                            outlines_p,
                            outlines_ref_p,
                            0,
                            utf8_b );
            
            PdfDictionary root_p= (PdfDictionary)
              reader_p.getPdfObject( trailer_p.get( PdfName.ROOT ) );
            if( root_p.contains( PdfName.OUTLINES ) ) {
              // erase old bookmarks
              PdfDictionary old_outlines_p= (PdfDictionary)
                reader_p.getPdfObject( root_p.get( PdfName.OUTLINES ) );
              bookmarks.RemoveBookmarks( reader_p, old_outlines_p );
            }
            // insert into document
            root_p.put( PdfName.OUTLINES, (PdfObject)outlines_ref_p );
          }
        }

        // metadata
        if( !pdf_data.m_info.isEmpty() ) {
          PdfDictionary info_p= (PdfDictionary)
            reader_p.getPdfObject( trailer_p.get( PdfName.INFO ) );
          if( info_p != null && info_p.isDictionary() ) {

            for( PdfInfo it : pdf_data.m_info ) {
              if( it.m_value.isEmpty() ) {
                info_p.remove( new PdfName( it.m_key ) );
              }
              else {
                if( utf8_b ) { // UTF-8 encoded input
                  info_p.put( new PdfName( it.m_key ) ,
                               // patch by Quentin Godfroy <godfroy@clipper.ens.fr>, Chris Adams <cadams@salk.edu>
                               new PdfString( it.m_value ) );
                }
                else { // XML entities input
                  String jvs = XmlStringToJcharArray( it.m_value );
                  info_p.put( new PdfName( it.m_key ),
                               new PdfString( jvs ) );
                }
              }
            }
          }
          else { // error
            System.err.println( "pdftk Error in UpdateInfo(): no Info dictionary found;" );
            ret_val_b= false;
          }
        }
      }
      else { // error
        System.err.println( "pdftk Error in UpdateInfo(): no document trailer found;" );
        ret_val_b= false;
      }
    }

  }
  else { // error
    System.err.println( "pdftk Error in UpdateInfo(): LoadDataFile() failure;" );
  }
  // cerr << pdf_data; // debug

  return ret_val_b;
}

//////
////
// created for data import, maybe useful for export, too

//
static class PdfInfo {
  static final String m_prefix= "Info";
  static final String m_begin_mark= "InfoBegin";
  static final String m_key_label= "InfoKey:";
  static final String m_value_label= "InfoValue:";

  String m_key = null;
  String m_value = null;

  boolean valid() { return( m_key!= null && m_value!= null ); }

  public String toString() {
    return m_begin_mark + System.lineSeparator() +
      m_key_label + " " + m_key + System.lineSeparator() +
      m_value_label + " " + m_value + System.lineSeparator();
  }
  boolean loadKey ( String buff ) {
    LoadableString loader = new LoadableString( m_key );
    boolean success = loader.LoadString( buff, m_key_label );
    m_key = loader.ss;
    return success;
  }
  boolean loadValue ( String buff ) {
    LoadableString loader = new LoadableString( m_value );
    boolean success = loader.LoadString( buff, m_value_label );
    m_value = loader.ss;
    return success;
  }
};

static class PdfData {
  ArrayList<PdfInfo> m_info = new ArrayList<PdfInfo>();
  ArrayList<PdfBookmark> m_bookmarks = new ArrayList<PdfBookmark>();

  static final String m_prefix= "PdfID";
  static final String m_id_0_label= "PdfID0:";
  static final String m_id_1_label= "PdfID1:";
  static final String m_num_pages_label= "NumberOfPages:";
  
  int m_num_pages = -1;

  String m_id_0 = null;
  String m_id_1 = null;

  public String toString() {
    StringBuilder ss = new StringBuilder();
    for (PdfInfo vit : m_info) {
      ss.append(vit);
    }
    ss.append("PdfID0: " + m_id_0 + System.lineSeparator() +
              "PdfID1: " + m_id_1 + System.lineSeparator() +
              "NumberOfPages: " + m_num_pages + System.lineSeparator());
    for (PdfBookmark vit : m_bookmarks) {
      ss.append(vit);
    }
    return ss.toString();
  }

  boolean loadNumPages ( String buff ) {
    LoadableInt loader = new LoadableInt( m_num_pages );
    boolean success = loader.LoadInt( buff, m_num_pages_label );
    m_num_pages = loader.ii;
    return success;
  }
  boolean loadID0 ( String buff ) {
    LoadableString loader = new LoadableString( m_id_0 );
    boolean success = loader.LoadString( buff, m_id_0_label );
    m_id_0 = loader.ss;
    return success;
  }
  boolean loadID1 ( String buff ) {
    LoadableString loader = new LoadableString( m_id_1 );
    boolean success = loader.LoadString( buff, m_id_1_label );
    m_id_1 = loader.ss;
    return success;
  }
};

static String
XmlStringToJcharArray( String jvs )
{
  return StringEscapeUtils.unescapeXml( jvs );
}

};
 /*
 *
 *   This file is part of the pdftk port to java
 *
 *   Copyright (c) Marc Vinyals 2017-2018
 *
 *   The program is a java port of PDFtk, the PDF Toolkit
 *   Copyright (c) 2003-2013 Steward and Lee, LLC
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   The program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.gitlab.pdftk_java;

import java.util.ArrayList;
import java.nio.charset.StandardCharsets;

/*
  password character mapping by Acrobat (pre-1.7 PDF)

  * characters in PDFDocEncoding use PDFDocEncoding
  * some PDFDocEncoding characters are not accepted as input into Acrobat/Reader --
      this is consistent with the next rule:
  * unicode 0x200 and up: Acrobat/Reader prohibits input
  * some chars below 0x200 are mapped to . (period)
  * some chars below 0x200 are mapped to non-accented ASCII char
  * many points are mapped to Windows CP-1250

  These were tested on Windows 7 using Acrobat 7.  From what I've read, Adobe's mapping
  of characters that aren't in PDFDocEncoding is platform dependent.  So this map should
  only be used for mapping PDF passwords for decryption.  When encrypting, it would be
  best to enforce a limited set of characters for the purpose of platform independence.

*/

class passwords {

// unicode 0x100 - 0x1FF
final static int[] unicode_latin_extended_windows_map=
  {
    // latin extended a
    'A',  //U+0100      Latin Capital Letter A with macron
    'a',  //U+0101      Latin Small Letter A with macron
    0xC3, //U+0102      Latin Capital Letter A with breve
    0xC4, //U+0103      Latin Small Letter A with breve
    0xA5, //U+0104      Latin Capital Letter A with ogonek
    0xB9, //U+0105      Latin Small Letter A with ogonek
    0xC6, //U+0106      Latin Capital Letter C with acute
    0xE6, //U+0107      Latin Small Letter C with acute
    '.',  //U+0108      Latin Capital Letter C with circumflex
    '.',  //U+0109      Latin Small Letter C with circumflex
    '.',  //U+010A      Latin Capital Letter C with dot above
    '.',  //U+010B      Latin Small Letter C with dot above
    0xC8, //U+010C      Latin Capital Letter C with caron
    0xE8, //U+010D      Latin Small Letter C with caron
    0xCF, //U+010E      Latin Capital Letter D with caron
    0xEF, //U+010F      Latin Small Letter D with caron
    0xD0, //U+0110      Latin Capital Letter D with stroke
    0xF0, //U+0111      Latin Small Letter D with stroke
    'E',  //U+0112      Latin Capital Letter E with macron
    'e',  //U+0113      Latin Small Letter E with macron
    '.',  //U+0114      Latin Capital Letter E with breve
    '.',  //U+0115      Latin Small Letter E with breve
    'E',  //U+0116      Latin Capital Letter E with dot above
    'e',  //U+0117      Latin Small Letter E with dot above
    0xCA, //U+0118      Latin Capital Letter E with ogonek
    0xEA, //U+0119      Latin Small Letter E with ogonek
    0xCC, //U+011A      Latin Capital Letter E with caron
    0xEC, //U+011B      Latin Small Letter E with caron
    '.',  //U+011C      Latin Capital Letter G with circumflex
    '.',  //U+011D      Latin Small Letter G with circumflex
    'G',  //U+011E      Latin Capital Letter G with breve
    'g',  //U+011F      Latin Small Letter G with breve
    '.',  //U+0120      Latin Capital Letter G with dot above
    '.',  //U+0121      Latin Small Letter G with dot above
    'G',  //U+0122      Latin Capital Letter G with cedilla
    'g',  //U+0123      Latin Small Letter G with cedilla
    '.',  //U+0124      Latin Capital Letter H with circumflex
    '.',  //U+0125      Latin Small Letter H with circumflex
    '.',  //U+0126      Latin Capital Letter H with stroke
    '.',  //U+0127      Latin Small Letter H with stroke
    '.',  //U+0128      Latin Capital Letter I with tilde
    '.',  //U+0129      Latin Small Letter I with tilde
    'I',  //U+012A      Latin Capital Letter I with macron
    'i',  //U+012B      Latin Small Letter I with macron
    '.',  //U+012C      Latin Capital Letter I with breve
    '.',  //U+012D      Latin Small Letter I with breve
    'I',  //U+012E      Latin Capital Letter I with ogonek
    'i',  //U+012F      Latin Small Letter I with ogonek
    'I',  //U+0130      Latin Capital Letter I with dot above
    'i',  //U+0131      Latin Small Letter dotless I
    '.',  //U+0132      Latin Capital Ligature IJ
    '.',  //U+0133      Latin Small Ligature IJ
    '.',  //U+0134      Latin Capital Letter J with circumflex
    '.',  //U+0135      Latin Small Letter J with circumflex
    'K',  //U+0136      Latin Capital Letter K with cedilla
    'k',  //U+0137      Latin Small Letter K with cedilla
    '.',  //U+0138      Latin Small Letter Kra
    0xC5, //U+0139      Latin Capital Letter L with acute
    0xE5, //U+013A      Latin Small Letter L with acute
    'L',  //U+013B      Latin Capital Letter L with cedilla
    'l',  //U+013C      Latin Small Letter L with cedilla
    0xBC, //U+013D      Latin Capital Letter L with caron
    0xBE, //U+013E      Latin Small Letter L with caron
    '.',  //U+013F      Latin Capital Letter L with middle dot
    '.',  //U+0140      Latin Small Letter L with middle dot
    0xA3, //U+0141      Latin Capital Letter L with stroke
    0xB3, //U+0142      Latin Small Letter L with stroke
    0xD1, //U+0143      Latin Capital Letter N with acute
    0xF1, //U+0144      Latin Small Letter N with acute
    'N',  //U+0145      Latin Capital Letter N with cedilla
    'n',  //U+0146      Latin Small Letter N with cedilla
    0xD2, //U+0147      Latin Capital Letter N with caron
    0xF2, //U+0148      Latin Small Letter N with caron
    '.',  //U+0149      Latin Small Letter N preceded by apostrophe[1]
    '.',  //U+014A      Latin Capital Letter Eng
    '.',  //U+014B      Latin Small Letter Eng
    'O',  //U+014C      Latin Capital Letter O with macron
    'o',  //U+014D      Latin Small Letter O with macron
    '.',  //U+014E      Latin Capital Letter O with breve
    '.',  //U+014F      Latin Small Letter O with breve
    0xD5, //U+0150      Latin Capital Letter O with double acute
    0xF5, //U+0151      Latin Small Letter O with double acute
    0226, //U+0152      Latin Capital Ligature OE (mapped to PDFDocEncoding)
    0234, //U+0153      Latin Small Ligature OE (mapped to PDFDocEncoding)
    0xC0, //U+0154      Latin Capital Letter R with acute
    0xE0, //U+0155      Latin Small Letter R with acute
    'R',  //U+0156      Latin Capital Letter R with cedilla
    'r',  //U+0157      Latin Small Letter R with cedilla
    0xD8, //U+0158      Latin Capital Letter R with caron
    0xF8, //U+0159      Latin Small Letter R with caron
    0x8C, //U+015A      Latin Capital Letter S with acute
    0x9C, //U+015B      Latin Small Letter S with acute
    '.',  //U+015C      Latin Capital Letter S with circumflex
    '.',  //U+015D      Latin Small Letter S with circumflex
    0xAA, //U+015E      Latin Capital Letter S with cedilla
    0xBA, //U+015F      Latin Small Letter S with cedilla
    0x8A, //U+0160      Latin Capital Letter S with caron
    0x9A, //U+0161      Latin Small Letter S with caron
    0xDE, //U+0162      Latin Capital Letter T with cedilla
    0xFE, //U+0163      Latin Small Letter T with cedilla
    0x8D, //U+0164      Latin Capital Letter T with caron
    0x9D, //U+0165      Latin Small Letter T with caron
    'T',  //U+0166      Latin Capital Letter T with stroke
    't',  //U+0167      Latin Small Letter T with stroke
    '.',  //U+0168      Latin Capital Letter U with tilde
    '.',  //U+0169      Latin Small Letter U with tilde
    'U',  //U+016A      Latin Capital Letter U with macron
    'u',  //U+016B      Latin Small Letter U with macron
    '.',  //U+016C      Latin Capital Letter U with breve
    '.',  //U+016D      Latin Small Letter U with breve
    0xD9, //U+016E      Latin Capital Letter U with ring above
    0xF9, //U+016F      Latin Small Letter U with ring above
    0xDB, //U+0170      Latin Capital Letter U with double acute
    0xFB, //U+0171      Latin Small Letter U with double acute
    'U',  //U+0172      Latin Capital Letter U with ogonek
    'u',  //U+0173      Latin Small Letter U with ogonek
    '.',  //U+0174      Latin Capital Letter W with circumflex
    '.',  //U+0175      Latin Small Letter W with circumflex
    '.',  //U+0176      Latin Capital Letter Y with circumflex
    '.',  //U+0177      Latin Small Letter Y with circumflex
    0230, //U+0178      Latin Capital Letter Y with diaeresis (mapped to PDFDocEncoding)
    0x8F, //U+0179      Latin Capital Letter Z with acute
    0x9F, //U+017A      Latin Small Letter Z with acute
    0xAF, //U+017B      Latin Capital Letter Z with dot above
    0xBF, //U+017C      Latin Small Letter Z with dot above
    0231, //U+017D      Latin Capital Letter Z with caron (mapped to PDFDocEncoding)
    0236, //U+017E      Latin Small Letter Z with caron (mapped to PDFDocEncoding)
    '.',  //U+017F      Latin Small Letter long S

    // portion of latin extended b
    'b',  //U+0180     &#384;   Latin Small Letter B with stroke
    '.',  //U+0181     &#385;   Latin Capital Letter B with hook
    '.',  //U+0182     &#386;   Latin Capital Letter B with top bar
    '.',  //U+0183     &#387;   Latin Small Letter B with top bar
    '.',  //U+0184     &#388;   Latin Capital Letter Tone Six
    '.',  //U+0185     &#389;   Latin Small Letter Tone Six
    '.',  //U+0186     &#390;   Latin Capital Letter Open O
    '.',  //U+0187     &#391;   Latin Capital Letter C with hook
    '.',  //U+0188     &#392;   Latin Small Letter C with hook
    0xD0,  //U+0189     &#393;   Latin Capital Letter African D
    '.',  //U+018A     &#394;   Latin Capital Letter D with hook
    '.',  //U+018B     &#395;   Latin Capital Letter D with top bar
    '.',  //U+018C     &#396;   Latin Small Letter D with top bar
    '.',  //U+018D     &#397;   Latin Small Letter Turned Delta
    '.',  //U+018E     &#398;   Latin Capital Letter Reversed E
    '.',  //U+018F     &#399;   Latin Capital Letter Schwa
    '.',  //U+0190     &#400;   Latin Capital Letter Open E
    0x83,  //U+0191     &#401;   Latin Capital Letter F with hook (from win cp-1252)(maybe)
    0x83,  //U+0192     &#402;   Latin Small Letter F with hook (from win cp-1252)(maybe)
    '.',  //U+0193     &#403;   Latin Capital Letter G with hook
    '.',  //U+0194     &#404;   Latin Capital Letter Gamma
    '.',  //U+0195     &#405;   Latin Small Letter HV
    '.',  //U+0196     &#406;   Latin Capital Letter Iota
    'I',  //U+0197     &#407;   Latin Capital Letter I with stroke
    '.',  //U+0198     &#408;   Latin Capital Letter K with hook
    '.',  //U+0199     &#409;   Latin Small Letter K with hook
    'l',  //U+019A     &#410;   Latin Small Letter L with bar
    '.',  //U+019B     &#411;   Latin Small Letter Lambda with stroke
    '.',  //U+019C     &#412;   Latin Capital Letter Turned M
    '.',  //U+019D     &#413;   Latin Capital Letter N with left hook
    '.',  //U+019E     &#414;   Latin Small Letter N with long right leg
    'O',  //U+019F     &#415;   Latin Capital Letter O with middle tilde
    'O',  //U+01A0     &#416;   Latin Capital Letter O with horn
    'o',  //U+01A1     &#417;   Latin Small Letter O with horn
    '.',  //U+01A2     &#418;   Latin Capital Letter OI (= Latin Capital Letter Gha)
    '.',  //U+01A3     &#419;   Latin Small Letter OI (= Latin Small Letter Gha)
    '.',  //U+01A4     &#420;   Latin Capital Letter P with hook
    '.',  //U+01A5     &#421;   Latin Small Letter P with hook
    '.',  //U+01A6     &#422;   Latin Letter YR
    '.',  //U+01A7     &#423;   Latin Capital Letter Tone Two
    '.',  //U+01A8     &#424;   Latin Small Letter Tone Two
    '.',  //U+01A9     &#425;   Latin Capital Letter Esh
    '.',  //U+01AA     &#426;   Latin Letter Reversed Esh Loop
    't',  //U+01AB     &#427;   Latin Small Letter T with palatal hook
    '.',  //U+01AC     &#428;   Latin Capital Letter T with hook
    '.',  //U+01AD     &#429;   Latin Small Letter T with hook
    'T',  //U+01AE     &#430;   Latin Capital Letter T with retroflex hook
    'U',  //U+01AF     &#431;   Latin Capital Letter U with horn
    'u',  //U+01B0     &#432;   Latin Small Letter U with horn
    '.',  //U+01B1     &#433;   Latin Capital Letter Upsilon
    '.',  //U+01B2     &#434;   Latin Capital Letter V with hook
    '.',  //U+01B3     &#435;   Latin Capital Letter Y with hook
    '.',  //U+01B4     &#436;   Latin Small Letter Y with hook
    '.',  //U+01B5     &#437;   Latin Capital Letter Z with stroke
    '.',  //U+01B6     &#438;   Latin Small Letter Z with stroke
    '.',  //U+01B7     &#439;   Latin Capital Letter Ezh
    '.',  //U+01B8     &#440;   Latin Capital Letter Ezh reversed
    '.',  //U+01B9     &#441;   Latin Small Letter Ezh reversed
    '.',  //U+01BA     &#442;   Latin Small Letter Ezh with tail
    '.',  //U+01BB     &#443;   Latin Letter Two with stroke
    '.',  //U+01BC     &#444;   Latin Capital Letter Tone Five
    '.',  //U+01BD     &#445;   Latin Small Letter Tone Five
    '.',  //U+01BE     &#446;   Latin Letter Inverted Glottal Stop with stroke
    '.',  //U+01BF     &#447;   Latin Letter Wynn
    '|',  //U+01C0     &#448;   Latin Letter Dental Click

    // I couldn't figure this one out
    '.',  //U+01C1     &#449;   Latin Letter Lateral Click

    '.',  //U+01C2     &#450;   Latin Letter Alveolar Click
    '!',  //U+01C3     &#451;   Latin Letter Retroflex Click
    '.',  //U+01C4     &#452;   Latin Capital Letter DZ with caron
    '.',  //U+01C5     &#453;   Latin Capital Letter D with Small Letter Z with caron
    '.',  //U+01C6     &#454;   Latin Small Letter DZ with caron
    '.',  //U+01C7     &#455;   Latin Capital Letter LJ
    '.',  //U+01C8     &#456;   Latin Capital Letter L with Small Letter J
    '.',  //U+01C9     &#457;   Latin Small Letter LJ
    '.',  //U+01CA     &#458;   Latin Capital Letter NJ
    '.',  //U+01CB     &#459;   Latin Capital Letter N with Small Letter J
    '.',  //U+01CC     &#460;   Latin Small Letter NJ
    '.',  //U+01CD     &#461;   Latin Capital Letter A with caron
    '.',  //U+01CE     &#462;   Latin Small Letter A with caron
    '.',  //U+01CF     &#463;   Latin Capital Letter I with caron
    '.',  //U+01D0     &#464;   Latin Small Letter I with caron
    '.',  //U+01D1     &#465;   Latin Capital Letter O with caron
    '.',  //U+01D2     &#466;   Latin Small Letter O with caron
    '.',  //U+01D3     &#467;   Latin Capital Letter U with caron
    '.',  //U+01D4     &#468;   Latin Small Letter U with caron
    '.',  //U+01D5     &#469;   Latin Capital Letter U with diaeresis and macron
    '.',  //U+01D6     &#470;   Latin Small Letter U with diaeresis and macron
    '.',  //U+01D7     &#471;   Latin Capital Letter U with diaeresis and acute
    '.',  //U+01D8     &#472;   Latin Small Letter U with diaeresis and acute
    '.',  //U+01D9     &#473;   Latin Capital Letter U with diaeresis and caron
    '.',  //U+01DA     &#474;   Latin Small Letter U with diaeresis and caron
    '.',  //U+01DB     &#475;   Latin Capital Letter U with diaeresis and grave
    '.',  //U+01DC     &#476;   Latin Small Letter U with diaeresis and grave
    '.',  //U+01DD     &#477;   Latin Small Letter Turned E
    'A',  //U+01DE     &#478;   Latin Capital Letter A with diaeresis and macron
    'a',  //U+01DF     &#479;   Latin Small Letter A with diaeresis and macron
    '.',  //U+01E0     &#480;   Latin Capital Letter A with dot above and macron
    '.',  //U+01E1     &#481;   Latin Small Letter A with dot above and macron
    '.',  //U+01E2     &#482;   Latin Capital Letter  with macron
    '.',  //U+01E3     &#483;   Latin Small Letter  with macron
    'G',  //U+01E4     &#484;   Latin Capital Letter G with stroke
    'g',  //U+01E5     &#485;   Latin Small Letter G with stroke
    '.',  //U+01E6     &#486;   Latin Capital Letter G with caron
    '.',  //U+01E7     &#487;   Latin Small Letter G with caron
    '.',  //U+01E8     &#488;   Latin Capital Letter K with caron
    '.',  //U+01E9     &#489;   Latin Small Letter K with caron
    '.',  //U+01EA     &#490;   Latin Capital Letter O with ogonek
    '.',  //U+01EB     &#491;   Latin Small Letter O with ogonek
    'O',  //U+01EC     &#492;   Latin Capital Letter O with ogonek and macron
    'o',  //U+01ED     &#493;   Latin Small Letter O with ogonek and macron
    '.',  //U+01EE     &#494;   Latin Capital Letter Ezh with caron
    '.',  //U+01EF     &#495;   Latin Small Letter Ezh with caron
    '.',  //U+01F0     &#496;   Latin Small Letter J with caron
    '.',  //U+01F1     &#497;   Latin Capital Letter DZ
    '.',  //U+01F2     &#498;   Latin Capital Letter D with Small Letter Z
    '.',  //U+01F3     &#499;   Latin Small Letter DZ
    '.',  //U+01F4     &#500;   Latin Capital Letter G with acute
    '.',  //U+01F5     &#501;   Latin Small Letter G with acute
    '.',  //U+01F6     &#502;   Latin Capital Letter Hwair
    '.',  //U+01F7     &#503;   Latin Capital Letter Wynn
    '.',  //U+01F8     &#504;   Latin Capital Letter N with grave
    '.',  //U+01F9     &#505;   Latin Small Letter N with grave
    '.',  //U+01FA     &#506;   Latin Capital Letter A with ring above and acute
    '.',  //U+01FB     &#507;   Latin Small Letter A with ring above and acute
    '.',  //U+01FC     &#508;   Latin Capital Letter  with acute
    '.',  //U+01FD     &#509;   Latin Small Letter  with acute
    '.',  //U+01FE     &#510;   Latin Capital Letter O with stroke and acute
    '.'   //U+01FF     &#511;   Latin Small Letter O with stroke and acute
  };

/*
  Older PDF security passwords use PDFDocEncoding, which is a modified iso-8859-1.
  Newer PDF security (version 5) passwords use unicode.
  This function is just for older PDF security passwords, since pdftk doesn't yet
  handle version 5 security.
  In practice, Acrobat/Reader accepts password characters outside of PDFDocEncoding.

  Returns -1 if input ss uses invalid characters
  otherwise returns the number of bytes copied to bb.
  If bb is null, then returns the number of bytes needed to copy ss.

  If we are encrypting, allow only the most conservative set of input characters
  in order to maximize platform independence.
  If we are decrypting, allow as many input characters as possible.

  TRANSLATOR NOTES:
  Returns a byte array; null if input uses invalid characters.
*/
static byte[] utf8_password_to_pdfdoc( String ss_, boolean encrypt_b ) {

  byte[] ss = ss_.getBytes(StandardCharsets.UTF_8);
  int ss_size = ss.length;
  ArrayList<Byte> bb = new ArrayList<Byte>(ss_size);

  for( int ii= 0; ii< ss_size; ) {

    // decode UTF-8
    int data= 0;
    //
    // our greatest valid point is 0x2122, so testing out to three bytes is enough
    if( (ss[ii] & 0x80) == 0 ) 
      { // single byte
        data= ss[ii];
        ii++;
      }
    else if( (ss[ii] & 0xE0) == 0xC0 && 
             ii+ 1< ss_size && (ss[ii+ 1] & 0xC0)== 0x80 ) 
      { // two-byte
        data= (ss[ii] & 0x1f);
        data= data<< 6;
        data= data+ (ss[ii+ 1] & 0x3f);
        ii+= 2;
      }
    else if( (ss[ii] & 0xF0) == 0xE0 && 
             ii+ 1< ss_size && (ss[ii+ 1] & 0xC0)== 0x80 && 
             ii+ 2< ss_size && (ss[ii+ 2] & 0xC0)== 0x80 ) 
      { // three-byte
        data= (ss[ii] & 0x0f);
        data= data<< 6;
        data= data+ (ss[ii+ 1] & 0x3f);
        data= data<< 6;
        data= data+ (ss[ii+ 2] & 0x3f);
        ii+= 3;
      }
    else { // something else: out of range
      return null;
    }

    if( 0x20<= data && data< 0x7f || 0xa0<= data && data<= 0xff ) {
      // data point good
    }
    else { // convert some unicode points to PDFDocEncoding

      switch( data ) {
      case 0x0152: // OE ligature
        data= 0226;
        break;
      case 0x0153: // oe ligature
        data= 0234;
        break;
      case 0x0160: // Scaron
        data= 0227;
        break;
      case 0x017E: // zcaron
        data= 0236;
        break;
      case 0x0178: // Ydieresis
        data= 0230;
        break;
      case 0x017D: // Zcaron
        data= 0231;
        break;
      case 0x0192: // florin
        data= 0206;
        break;
      case 0x0161: // scaron
        data= 0235;
        break;
      default:
        if( encrypt_b ) { // data point out of bounds
          return null;
        }
        else {
          // password is being used to decrypt, so test for more mappings to PDFDocEncoding;

          if( 0x100<= data && data<= 0x1FF ) {
            // use our latin extended windows map; these points are accepted by Acrobat/Reader
            // but are mapped to single-byte alternatives in a platform-dependent way
            data= unicode_latin_extended_windows_map[ data- 0x100 ];
          }
          else {
            // in practice, Acorbat/Reader won't allow these characters to be input for V4 security and earlier;
            switch( data ) {
            case 0x20AC: // Euro
              data= 0240;
              break;
            case 0x2022: // bullet
              data= 0200;
              break;
            case 0x2020: // dagger
              data= 0201;
              break;
            case 0x2021: // daggerdbl
              data= 0202;
              break;
            case 0x2026: // ellipsis
              data= 0203;
              break;
            case 0x02C6: // circumflex
              data= 0032;
              break;
            case 0x2014 : // emdash
              data= 0204;
              break;
            case 0x2013: // endash
              data= 0205;
              break;
            case 0x2039: // guilsinglleft
              data= 0210;
              break;
            case 0x203A: // guilsinglright
              data= 0211;
              break;
            case 0x2030: // perthousand
              data= 0213;
              break;
            case 0x201E: // quotedblbase
              data= 0214;
              break;
            case 0x201C: // quotedblleft
              data= 0215;
              break;
            case 0x201D: // quotedblright
              data= 0216;
              break;
            case 0x2018: // quoteleft
              data= 0217;
              break;
            case 0x2019: // quoteright
              data= 0220;
              break;
            case 0x201A: // quotesinglebase
              data= 0221;
              break;
            case 0x02DC: // tilde
              data= 0037;
              break;
            case 0x2122: // trademark
              data= 0222;
              break;
            default:

              return null; // data point is still out of bounds
            }
          }
        }
      }
    }

    bb.add((byte)data);
  }

  byte[] out = new byte[bb.size()];
  for (int i=0; i<out.length; ++i) out[i]=bb.get(i);
  return out;
}

};
 /*
 *
 *   This file is part of the pdftk port to java
 *
 *   Copyright (c) Marc Vinyals 2017-2018
 *
 *   The program is a java port of PDFtk, the PDF Toolkit
 *   Copyright (c) 2003-2013 Steward and Lee, LLC
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   The program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.gitlab.pdftk_java;

import java.io.BufferedWriter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintStream;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;

public class pdftk {

/* TODO: should read from compiler */
static final String PDFTK_VER = "3.0.2";
static final boolean ASK_ABOUT_WARNINGS = false;

static String
prompt_for_password( String pass_name, 
                     String pass_app) {
  System.out.println( "Please enter the " + pass_name + " password to use on " + pass_app + "." );
  System.out.println( "   It can be empty, or have a maximum of 32 characters:" );
  Scanner s = new Scanner(System.in);
  String password= s.nextLine();
  if( 32< password.length() ) { // too long; trim
    System.out.println( "The password you entered was over 32 characters long," );
    System.out.println( "   so I am dropping: \"" + password.substring( 32 ) + "\"" );
    password= password.substring( 0, 32 );
  }
  return password;
}

static String
prompt_for_filename( String message ) {
  // input could be multibyte, so try working
  // with bytes instead of formatted input features

  System.out.println( message );

  Scanner s = new Scanner(System.in);
  return s.nextLine();
}

static boolean
confirm_overwrite( String filename ) {
  System.out.println("Warning: the output file: " + filename + " already exists.  Overwrite? (y/n)");
  Scanner s = new Scanner(System.in);
  String buff= s.nextLine();
  return buff.startsWith("y") || buff.startsWith("Y");
}

static boolean
file_exists( String filename ) {
  try {
    FileInputStream fp= new FileInputStream( filename );
    return true;
  }
  catch ( FileNotFoundException e ) {
    return false;
  }
}
  
static OutputStream
get_output_stream( String output_filename,
                   boolean ask_about_warnings_b ) {
  OutputStream os_p= null;

  if( output_filename.isEmpty() || output_filename.equals("PROMPT") ) {
    output_filename = prompt_for_filename( "Please enter a name for the output:" );
    // recurse; try again
    return get_output_stream( output_filename,
                              ask_about_warnings_b );
  }
  if( output_filename.equals("-") ) { // stdout
    os_p= System.out;
  }
  else {
    if( ask_about_warnings_b ) {
      // test for existing file by this name
      boolean output_exists_b= false;
      if( file_exists( output_filename ) ) {
        if( !confirm_overwrite( output_filename ) ) {
          // recurse; try again
          return get_output_stream( "PROMPT",
                                    ask_about_warnings_b );
        }
      }
    }

    // attempt to open the stream
    try {
      os_p= new FileOutputStream( output_filename );
    }
    catch( IOException ioe_p ) { // file open error
      System.err.println("Error: Failed to open output file: ");
      System.err.println("   " + output_filename);
      System.err.println("   No output created.");
      os_p= null;
    }
  }

  return os_p;
}

static PrintStream
get_print_stream(String m_output_filename, boolean m_output_utf8_b )
throws IOException
{
  Charset encoding = ( m_output_utf8_b ? StandardCharsets.UTF_8 : StandardCharsets.US_ASCII );
  if(m_output_filename.isEmpty() || m_output_filename.equals("-")) {
    return new PrintStream(System.out, true, encoding.name() );
  }
  else {
    return new PrintStream(m_output_filename, encoding.name() );
  }
}
  
public static void main(String[] args) {
  boolean help_b= false;
  boolean version_b= false;
  boolean synopsis_b= ( args.length == 0 );
  ErrorCode ret_val= ErrorCode.NO_ERROR; // default: no error

  for( String argv : args) {
    version_b = version_b ||
      (argv.equals("--version")) ||
      (argv.equals("-version"));
    help_b = help_b ||
      (argv.equals("--help")) ||
      (argv.equals("-help")) ||
      (argv.equals("-h"));
  }

  if( help_b ) {
    describe_full();
  }
  else if( version_b ) {
    describe_header();
  }
  else if( synopsis_b ) {
    describe_synopsis();
  }
  else {
    try {
      TK_Session tk_session = new TK_Session( args );

      tk_session.dump_session_data();

      if( tk_session.is_valid() ) {
        // create_output() prints necessary error messages
        ret_val= tk_session.create_output();
      }
      else { // error
        System.err.println("Done.  Input errors, so no output created.");
        ret_val= ErrorCode.ERROR;
      }
    }
    // per https://bugs.launchpad.net/ubuntu/+source/pdftk/+bug/544636
    catch( java.lang.ClassCastException c_p ) {
      String message= c_p.getMessage();
      if( message.indexOf("com.lowagie.text.pdf.PdfDictionary")>= 0 &&
          message.indexOf("com.lowagie.text.pdf.PRIndirectReference")>= 0 )
      {
        System.err.println("Error: One input PDF seems to not conform to the PDF standard.");
        System.err.println("Perhaps the document information dictionary is a direct object");
        System.err.println("   instead of an indirect reference.");
        System.err.println("Please report this bug to the program which produced the PDF.");
        System.err.println();
      }
      System.err.println("Java Exception:");
      c_p.printStackTrace();
      ret_val= ErrorCode.ERROR;
    }
    catch( java.lang.Throwable t_p ) {
      System.err.println("Unhandled Java Exception in main():");
      t_p.printStackTrace();
      ret_val= ErrorCode.BUG;
    }
  }
  if ( ret_val == ErrorCode.BUG ) {
    describe_bug_report();
  }
  System.exit(ret_val.code);
}

static void
describe_header() {
  System.out.println("pdftk port to java " + PDFTK_VER + " a Handy Tool for Manipulating PDF Documents");
  System.out.println("Copyright (c) 2017-2018 Marc Vinyals - https://gitlab.com/pdftk-java/pdftk");
  System.out.println("Copyright (c) 2003-2013 Steward and Lee, LLC.");
  System.out.println("pdftk includes a modified version of the iText library.");
  System.out.println("Copyright (c) 1999-2009 Bruno Lowagie, Paulo Soares, et al.");
  System.out.println("This is free software; see the source code for copying conditions. There is");
  System.out.println("NO warranty, not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.");
}

static void
describe_synopsis() {
  System.out.println(
"SYNOPSIS\n" +
"       pdftk <input PDF files | - | PROMPT>\n" +
"      [ input_pw <input PDF owner passwords | PROMPT> ]\n" +
"      [ <operation> <operation arguments> ]\n" +
"      [ output <output filename | - | PROMPT> ]\n" +
"      [ encrypt_40bit | encrypt_128bit ]\n" +
"      [ allow <permissions> ]\n" +
"      [ owner_pw <owner password | PROMPT> ]\n" +
"      [ user_pw <user password | PROMPT> ]\n" +
"      [ flatten ] [ need_appearances ]\n" +
"      [ compress | uncompress ]\n" +
"      [ keep_first_id | keep_final_id ] [ drop_xfa ] [ drop_xmp ]\n" +
"      [ verbose ] [ dont_ask | do_ask ]\n" +
"       Where:\n" +
"      <operation> may be empty, or:\n" +
"      [ cat | shuffle | burst | rotate |\n" +
"        generate_fdf | fill_form |\n" +
"        background | multibackground |\n" +
"        stamp | multistamp |\n" +
"        dump_data | dump_data_utf8 |\n" +
"        dump_data_fields | dump_data_fields_utf8 |\n" +
"        dump_data_annots |\n" +
"        update_info | update_info_utf8 |\n" +
"        attach_files | unpack_files ]\n" +
"\n" +
"       For Complete Help: pdftk --help\n");
}

static void
describe_full() {
  describe_header();
  System.out.println();

  describe_synopsis();
  System.out.println();

  System.out.println(
"DESCRIPTION\n" +
"       If PDF is electronic paper, then pdftk is an electronic staple-remover,\n" +
"       hole-punch, binder, secret-decoder-ring, and X-Ray-glasses.  Pdftk is a\n" +
"       simple tool for doing everyday things with PDF documents.  Use it to:\n" +
"\n" +
"       * Merge PDF Documents or Collate PDF Page Scans\n" +
"       * Split PDF Pages into a New Document\n" +
"       * Rotate PDF Documents or Pages\n" +
"       * Decrypt Input as Necessary (Password Required)\n" +
"       * Encrypt Output as Desired\n" +
"       * Fill PDF Forms with X/FDF Data and/or Flatten Forms\n" +
"       * Generate FDF Data Stencils from PDF Forms\n" +
"       * Apply a Background Watermark or a Foreground Stamp\n" +
"       * Report PDF Metrics, Bookmarks and Metadata\n" +
"       * Add/Update PDF Bookmarks or Metadata\n" +
"       * Attach Files to PDF Pages or the PDF Document\n" +
"       * Unpack PDF Attachments\n" +
"       * Burst a PDF Document into Single Pages\n" +
"       * Uncompress and Re-Compress Page Streams\n" +
"       * Repair Corrupted PDF (Where Possible)\n" +
"\n" +
"OPTIONS\n" +
"       A summary of options is included below.\n" +
"\n" +
"       --help, -h\n" +
"        Show this summary of options.\n" +
"\n" +
"       <input PDF files | - | PROMPT>\n" +
"        A list of the input PDF files. If you plan to combine these PDFs\n" +
"        (without using handles) then list files in the order you want\n" +
"        them combined.  Use - to pass a single PDF into pdftk via stdin.\n" +
"        Input files can be associated with handles, where a handle is\n" +
"        one or more upper-case letters:\n" +
"\n" +
"        <input PDF handle>=<input PDF filename>\n" +
"\n" +
"        Handles are often omitted.  They are useful when specifying PDF\n" +
"        passwords or page ranges, later.\n" +
"\n" +
"        For example: A=input1.pdf QT=input2.pdf M=input3.pdf\n" +
"\n" +
"       [input_pw <input PDF owner passwords | PROMPT>]\n" +
"        Input PDF owner passwords, if necessary, are associated with\n" +
"        files by using their handles:\n" +
"\n" +
"        <input PDF handle>=<input PDF file owner password>\n" +
"\n" +
"        If handles are not given, then passwords are associated with\n" +
"        input files by order.\n" +
"\n" +
"        Most pdftk features require that encrypted input PDF are accom-\n" +
"        panied by the ~owner~ password. If the input PDF has no owner\n" +
"        password, then the user password must be given, instead.  If the\n" +
"        input PDF has no passwords, then no password should be given.\n" +
"\n" +
"        When running in do_ask mode, pdftk will prompt you for a pass-\n" +
"        word if the supplied password is incorrect or none was given.\n" +
"\n" +
"       [<operation> <operation arguments>]\n" +
"        Available operations are: cat, shuffle, burst, rotate, gener-\n" +
"        ate_fdf, fill_form, background, multibackground, stamp, multi-\n" +
"        stamp, dump_data, dump_data_utf8, dump_data_fields,\n" +
"        dump_data_fields_utf8, dump_data_annots, update_info,\n" +
"        update_info_utf8, attach_files, unpack_files. Some operations\n" +
"        takes additional arguments, described below.\n" +
"\n" +
"        If this optional argument is omitted, then pdftk runs in 'fil-\n" +
"        ter' mode.  Filter mode takes only one PDF input and creates a\n" +
"        new PDF after applying all of the output options, like encryp-\n" +
"        tion and compression.\n" +
"\n" +
"    cat [<page ranges>]\n" +
"     Assembles (catenates) pages from input PDFs to create a new\n" +
"     PDF. Use cat to merge PDF pages or to split PDF pages from\n" +
"     documents. You can also use it to rotate PDF pages. Page\n" +
"     order in the new PDF is specified by the order of the given\n" +
"     page ranges. Page ranges are described like this:\n" +
"\n" +
"     <input PDF handle>[<begin page number>[-<end page num-\n" +
"     ber>[<qualifier>]]][<page rotation>]\n" +
"\n" +
"     Where the handle identifies one of the input PDF files, and\n" +
"     the beginning and ending page numbers are one-based refer-\n" +
"     ences to pages in the PDF file.  The qualifier can be even or\n" +
"     odd, and the page rotation can be north, south, east, west,\n" +
"     left, right, or down.\n" +
"\n" +
"     If a PDF handle is given but no pages are specified, then the\n" +
"     entire PDF is used. If no pages are specified for any of the\n" +
"     input PDFs, then the input PDFs' bookmarks are also merged\n" +
"     and included in the output.\n" +
"\n" +
"     If the handle is omitted from the page range, then the pages\n" +
"     are taken from the first input PDF.\n" +
"\n" +
"     The even qualifier causes pdftk to use only the even-numbered\n" +
"     PDF pages, so 1-6even yields pages 2, 4 and 6 in that order.\n" +
"     6-1even yields pages 6, 4 and 2 in that order.\n" +
"\n" +
"     The odd qualifier works similarly to the even.\n" +
"\n" +
"     The page rotation setting can cause pdftk to rotate pages and\n" +
"     documents.  Each option sets the page rotation as follows (in\n" +
"     degrees): north: 0, east: 90, south: 180, west: 270, left:\n" +
"     -90, right: +90, down: +180. left, right, and down make rela-\n" +
"     tive adjustments to a page's rotation.\n" +
"\n" +
"     If no arguments are passed to cat, then pdftk combines all\n" +
"     input PDFs in the order they were given to create the output.\n" +
"\n" +
"     NOTES:\n" +
"     * <end page number> may be less than <begin page number>.\n" +
"     * The keyword end may be used to reference the final page of\n" +
"     a document instead of a page number.\n" +
"     * Reference a single page by omitting the ending page number.\n" +
"     * The handle may be used alone to represent the entire PDF\n" +
"     document, e.g., B1-end is the same as B.\n" +
"     * You can reference page numbers in reverse order by prefix-\n" +
"     ing them with the letter r. For example, page r1 is the last\n" +
"     page of the document, r2 is the next-to-last page of the doc-\n" +
"     ument, and rend is the first page of the document. You can\n" +
"     use this prefix in ranges, too, for example r3-r1 is the last\n" +
"     three pages of a PDF.\n" +
"\n" +
"     Page Range Examples without Handles:\n" +
"     1-endeast - rotate entire document 90 degrees\n" +
"     5 11 20 - take single pages from input PDF\n" +
"     5-25oddwest - take odd pages in range, rotate 90 degrees\n" +
"     6-1 - reverse pages in range from input PDF\n" +
"\n" +
"     Page Range Examples Using Handles:\n" +
"     Say A=in1.pdf B=in2.pdf, then:\n" +
"     A1-21 - take range from in1.pdf\n" +
"     Bend-1odd - take all odd pages from in2.pdf in reverse order\n" +
"     A72 - take a single page from in1.pdf\n" +
"     A1-21 Beven A72 - assemble pages from both in1.pdf and\n" +
"     in2.pdf\n" +
"     Awest - rotate entire in1.pdf document 90 degrees\n" +
"     B - use all of in2.pdf\n" +
"     A2-30evenleft - take the even pages from the range, remove 90\n" +
"     degrees from each page's rotation\n" +
"     A A - catenate in1.pdf with in1.pdf\n" +
"     Aevenwest Aoddeast - apply rotations to even pages, odd pages\n" +
"     from in1.pdf\n" +
"     Awest Bwest Bdown - catenate rotated documents\n" +
"\n" +
"    shuffle [<page ranges>]\n" +
"     Collates pages from input PDFs to create a new PDF.  Works\n" +
"     like the cat operation except that it takes one page at a\n" +
"     time from each page range to assemble the output PDF.  If one\n" +
"     range runs out of pages, it continues with the remaining\n" +
"     ranges.  Ranges can use all of the features described above\n" +
"     for cat, like reverse page ranges, multiple ranges from a\n" +
"     single PDF, and page rotation.  This feature was designed to\n" +
"     help collate PDF pages after scanning paper documents.\n" +
"\n" +
"    burst  Splits a single input PDF document into individual pages.\n" +
"     Also creates a report named doc_data.txt which is the same as\n" +
"     the output from dump_data.  If the output section is omitted,\n" +
"     then PDF pages are named: pg_%04d.pdf, e.g.: pg_0001.pdf,\n" +
"     pg_0002.pdf, etc.  To name these pages yourself, supply a\n" +
"     printf-styled format string via the output section.  For\n" +
"     example, if you want pages named: page_01.pdf, page_02.pdf,\n" +
"     etc., pass output page_%02d.pdf to pdftk.  Encryption can be\n" +
"     applied to the output by appending output options such as\n" +
"     owner_pw, e.g.:\n" +
"\n" +
"     pdftk in.pdf burst owner_pw foopass\n" +
"\n" +
"    rotate [<page ranges>]\n" +
"     Takes a single input PDF and rotates just the specified\n" +
"     pages.  All other pages remain unchanged.  The page order\n" +
"     remains unchaged.  Specify the pages to rotate using the same\n" +
"     notation as you would with cat, except you omit the pages\n" +
"     that you aren't rotating:\n" +
"\n" +
"     [<begin page number>[-<end page number>[<qualifier>]]][<page\n" +
"     rotation>]\n" +
"\n" +
"     The qualifier can be even or odd, and the page rotation can\n" +
"     be north, south, east, west, left, right, or down.\n" +
"\n" +
"     Each option sets the page rotation as follows (in degrees):\n" +
"     north: 0, east: 90, south: 180, west: 270, left: -90, right:\n" +
"     +90, down: +180. left, right, and down make relative adjust-\n" +
"     ments to a page's rotation.\n" +
"\n" +
"     The given order of the pages doesn't change the page order in\n" +
"     the output.\n" +
"\n" +
"    generate_fdf\n" +
"     Reads a single input PDF file and generates an FDF file suit-\n" +
"     able for fill_form out of it to the given output filename or\n" +
"     (if no output is given) to stdout.  Does not create a new\n" +
"     PDF.\n" +
"\n" +
"    fill_form <FDF data filename | XFDF data filename | - | PROMPT>\n" +
"     Fills the single input PDF's form fields with the data from\n" +
"     an FDF file, XFDF file or stdin. Enter the data filename\n" +
"     after fill_form, or use - to pass the data via stdin, like\n" +
"     so:\n" +
"\n" +
"     pdftk form.pdf fill_form data.fdf output form.filled.pdf\n" +
"\n" +
"     If the input FDF file includes Rich Text formatted data in\n" +
"     addition to plain text, then the Rich Text data is packed\n" +
"     into the form fields as well as the plain text.  Pdftk also\n" +
"     sets a flag that cues Reader/Acrobat to generate new field\n" +
"     appearances based on the Rich Text data.  So when the user\n" +
"     opens the PDF, the viewer will create the Rich Text appear-\n" +
"     ance on the spot.  If the user's PDF viewer does not support\n" +
"     Rich Text, then the user will see the plain text data\n" +
"     instead.  If you flatten this form before Acrobat has a\n" +
"     chance to create (and save) new field appearances, then the\n" +
"     plain text field data is what you'll see.\n" +
"\n" +
"     Also see the flatten and need_appearances options.\n" +
"\n" +
"    background <background PDF filename | - | PROMPT>\n" +
"     Applies a PDF watermark to the background of a single input\n" +
"     PDF.  Pass the background PDF's filename after background\n" +
"     like so:\n" +
"\n" +
"     pdftk in.pdf background back.pdf output out.pdf\n" +
"\n" +
"     Pdftk uses only the first page from the background PDF and\n" +
"     applies it to every page of the input PDF.  This page is\n" +
"     scaled and rotated as needed to fit the input page.  You can\n" +
"     use - to pass a background PDF into pdftk via stdin.\n" +
"\n" +
"     If the input PDF does not have a transparent background (such\n" +
"     as a PDF created from page scans) then the resulting back-\n" +
"     ground won't be visible -- use the stamp operation instead.\n" +
"\n" +
"    multibackground <background PDF filename | - | PROMPT>\n" +
"     Same as the background operation, but applies each page of\n" +
"     the background PDF to the corresponding page of the input\n" +
"     PDF.  If the input PDF has more pages than the stamp PDF,\n" +
"     then the final stamp page is repeated across these remaining\n" +
"     pages in the input PDF.\n" +
"\n" +
"    stamp <stamp PDF filename | - | PROMPT>\n" +
"     This behaves just like the background operation except it\n" +
"     overlays the stamp PDF page on top of the input PDF docu-\n" +
"     ment's pages.  This works best if the stamp PDF page has a\n" +
"     transparent background.\n" +
"\n" +
"    multistamp <stamp PDF filename | - | PROMPT>\n" +
"     Same as the stamp operation, but applies each page of the\n" +
"     background PDF to the corresponding page of the input PDF.\n" +
"     If the input PDF has more pages than the stamp PDF, then the\n" +
"     final stamp page is repeated across these remaining pages in\n" +
"     the input PDF.\n" +
"\n" +
"    dump_data\n" +
"     Reads a single input PDF file and reports its metadata, book-\n" +
"     marks (a/k/a outlines), page metrics (media, rotation and\n" +
"     labels), data embedded by STAMPtk (see STAMPtk's embed\n" +
"     option) and other data to the given output filename or (if no\n" +
"     output is given) to stdout.  Non-ASCII characters are encoded\n" +
"     as XML numerical entities.  Does not create a new PDF.\n" +
"\n" +
"    dump_data_utf8\n" +
"     Same as dump_data excepct that the output is encoded as\n" +
"     UTF-8.\n" +
"\n" +
"    dump_data_fields\n" +
"     Reads a single input PDF file and reports form field statis-\n" +
"     tics to the given output filename or (if no output is given)\n" +
"     to stdout. Non-ASCII characters are encoded as XML numerical\n" +
"     entities. Does not create a new PDF.\n" +
"\n" +
"    dump_data_fields_utf8\n" +
"     Same as dump_data_fields excepct that the output is encoded\n" +
"     as UTF-8.\n" +
"\n" +
"    dump_data_annots\n" +
"     This operation currently reports only link annotations.\n" +
"     Reads a single input PDF file and reports annotation informa-\n" +
"     tion to the given output filename or (if no output is given)\n" +
"     to stdout. Non-ASCII characters are encoded as XML numerical\n" +
"     entities. Does not create a new PDF.\n" +
"\n" +
"    update_info <info data filename | - | PROMPT>\n" +
"     Changes the bookmarks and metadata in a single PDF's Info\n" +
"     dictionary to match the input data file. The input data file\n" +
"     uses the same syntax as the output from dump_data. Non-ASCII\n" +
"     characters should be encoded as XML numerical entities.\n" +
"\n" +
"     This operation does not change the metadata stored in the\n" +
"     PDF's XMP stream, if it has one. (For this reason you should\n" +
"     include a ModDate entry in your updated info with a current\n" +
"     date/timestamp, format: D:YYYYMMDDHHmmSS, e.g. D:201307241346\n" +
"     -- omitted data after YYYY revert to default values.)\n" +
"\n" +
"     For example:\n" +
"\n" +
"     pdftk in.pdf update_info in.info output out.pdf\n" +
"\n" +
"    update_info_utf8 <info data filename | - | PROMPT>\n" +
"     Same as update_info except that the input is encoded as\n" +
"     UTF-8.\n" +
"\n" +
"    attach_files <attachment filenames | PROMPT> [to_page <page number |\n" +
"    PROMPT>]\n" +
"     Packs arbitrary files into a PDF using PDF's file attachment\n" +
"     features. More than one attachment may be listed after\n" +
"     attach_files. Attachments are added at the document level\n" +
"     unless the optional to_page option is given, in which case\n" +
"     the files are attached to the given page number (the first\n" +
"     page is 1, the final page is end). For example:\n" +
"\n" +
"     pdftk in.pdf attach_files table1.html table2.html to_page 6\n" +
"     output out.pdf\n" +
"\n" +
"    unpack_files\n" +
"     Copies all of the attachments from the input PDF into the\n" +
"     current folder or to an output directory given after output.\n" +
"     For example:\n" +
"\n" +
"     pdftk report.pdf unpack_files output ~/atts/\n" +
"\n" +
"     or, interactively:\n" +
"\n" +
"     pdftk report.pdf unpack_files output PROMPT\n" +
"\n" +
"       [output <output filename | - | PROMPT>]\n" +
"        The output PDF filename may not be set to the name of an input\n" +
"        filename. Use - to output to stdout.  When using the dump_data\n" +
"        operation, use output to set the name of the output data file.\n" +
"        When using the unpack_files operation, use output to set the\n" +
"        name of an output directory.  When using the burst operation,\n" +
"        you can use output to control the resulting PDF page filenames\n" +
"        (described above).\n" +
"\n" +
"       [encrypt_40bit | encrypt_128bit]\n" +
"        If an output PDF user or owner password is given, output PDF\n" +
"        encryption strength defaults to 128 bits.  This can be overrid-\n" +
"        den by specifying encrypt_40bit.\n" +
"\n" +
"       [allow <permissions>]\n" +
"        Permissions are applied to the output PDF only if an encryption\n" +
"        strength is specified or an owner or user password is given.  If\n" +
"        permissions are not specified, they default to 'none,' which\n" +
"        means all of the following features are disabled.\n" +
"\n" +
"        The permissions section may include one or more of the following\n" +
"        features:\n" +
"\n" +
"        Printing\n" +
"         Top Quality Printing\n" +
"\n" +
"        DegradedPrinting\n" +
"         Lower Quality Printing\n" +
"\n" +
"        ModifyContents\n" +
"         Also allows Assembly\n" +
"\n" +
"        Assembly\n" +
"\n" +
"        CopyContents\n" +
"         Also allows ScreenReaders\n" +
"\n" +
"        ScreenReaders\n" +
"\n" +
"        ModifyAnnotations\n" +
"         Also allows FillIn\n" +
"\n" +
"        FillIn\n" +
"\n" +
"        AllFeatures\n" +
"         Allows the user to perform all of the above, and top\n" +
"         quality printing.\n" +
"\n" +
"       [owner_pw <owner password | PROMPT>]\n" +
"\n" +
"       [user_pw <user password | PROMPT>]\n" +
"        If an encryption strength is given but no passwords are sup-\n" +
"        plied, then the owner and user passwords remain empty, which\n" +
"        means that the resulting PDF may be opened and its security\n" +
"        parameters altered by anybody.\n" +
"\n" +
"       [compress | uncompress]\n" +
"        These are only useful when you want to edit PDF code in a text\n" +
"        editor like vim or emacs.  Remove PDF page stream compression by\n" +
"        applying the uncompress filter. Use the compress filter to\n" +
"        restore compression.\n" +
"\n" +
"       [flatten]\n" +
"        Use this option to merge an input PDF's interactive form fields\n" +
"        (and their data) with the PDF's pages. Only one input PDF may be\n" +
"        given. Sometimes used with the fill_form operation.\n" +
"\n" +
"       [need_appearances]\n" +
"        Sets a flag that cues Reader/Acrobat to generate new field\n" +
"        appearances based on the form field values.  Use this when fill-\n" +
"        ing a form with non-ASCII text to ensure the best presentation\n" +
"        in Adobe Reader or Acrobat.  It won't work when combined with\n" +
"        the flatten option.\n" +
"\n" +
"       [keep_first_id | keep_final_id]\n" +
"        When combining pages from multiple PDFs, use one of these\n" +
"        options to copy the document ID from either the first or final\n" +
"        input document into the new output PDF. Otherwise pdftk creates\n" +
"        a new document ID for the output PDF. When no operation is\n" +
"        given, pdftk always uses the ID from the (single) input PDF.\n" +
"\n" +
"       [drop_xfa]\n" +
"        If your input PDF is a form created using Acrobat 7 or Adobe\n" +
"        Designer, then it probably has XFA data.  Filling such a form\n" +
"        using pdftk yields a PDF with data that fails to display in\n" +
"        Acrobat 7 (and 6?).  The workaround solution is to remove the\n" +
"        form's XFA data, either before you fill the form using pdftk or\n" +
"        at the time you fill the form. Using this option causes pdftk to\n" +
"        omit the XFA data from the output PDF form.\n" +
"\n" +
"        This option is only useful when running pdftk on a single input\n" +
"        PDF.  When assembling a PDF from multiple inputs using pdftk,\n" +
"        any XFA data in the input is automatically omitted.\n" +
"\n" +
"       [drop_xmp]\n" +
"        Many PDFs store document metadata using both an Info dictionary\n" +
"        (old school) and an XMP stream (new school).  Pdftk's\n" +
"        update_info operation can update the Info dictionary, but not\n" +
"        the XMP stream.  The proper remedy for this is to include a\n" +
"        ModDate entry in your updated info with a current date/time-\n" +
"        stamp. The date/timestamp format is: D:YYYYMMDDHHmmSS, e.g.\n" +
"        D:201307241346 -- omitted data after YYYY revert to default val-\n" +
"        ues. This newer ModDate should cue PDF viewers that the Info\n" +
"        metadata is more current than the XMP data.\n" +
"\n" +
"        Alternatively, you might prefer to remove the XMP stream from\n" +
"        the PDF altogether -- that's what this option does.  Note that\n" +
"        objects inside the PDF might have their own, separate XMP meta-\n" +
"        data streams, and that drop_xmp does not remove those.  It only\n" +
"        removes the PDF's document-level XMP stream.\n" +
"\n" +
"       [verbose]\n" +
"        By default, pdftk runs quietly. Append verbose to the end and it\n" +
"        will speak up.\n" +
"\n" +
"       [dont_ask | do_ask]\n" +
"        Depending on the compile-time settings (see ASK_ABOUT_WARNINGS),\n" +
"        pdftk might prompt you for further input when it encounters a\n" +
"        problem, such as a bad password. Override this default behavior\n" +
"        by adding dont_ask (so pdftk won't ask you what to do) or do_ask\n" +
"        (so pdftk will ask you what to do).\n" +
"\n" +
"        When running in dont_ask mode, pdftk will over-write files with\n" +
"        its output without notice.\n" +
"\n" +
"EXAMPLES\n" +
"       Collate scanned pages\n" +
"   pdftk A=even.pdf B=odd.pdf shuffle A B output collated.pdf\n" +
"   or if odd.pdf is in reverse order:\n" +
"   pdftk A=even.pdf B=odd.pdf shuffle A Bend-1 output collated.pdf\n" +
"\n" +
"       Decrypt a PDF\n" +
"   pdftk secured.pdf input_pw foopass output unsecured.pdf\n" +
"\n" +
"       Encrypt a PDF using 128-bit strength (the default), withhold all per-\n" +
"       missions (the default)\n" +
"   pdftk 1.pdf output 1.128.pdf owner_pw foopass\n" +
"\n" +
"       Same as above, except password 'baz' must also be used to open output\n" +
"       PDF\n" +
"   pdftk 1.pdf output 1.128.pdf owner_pw foo user_pw baz\n" +
"\n" +
"       Same as above, except printing is allowed (once the PDF is open)\n" +
"   pdftk 1.pdf output 1.128.pdf owner_pw foo user_pw baz allow printing\n" +
"\n" +
"       Join in1.pdf and in2.pdf into a new PDF, out1.pdf\n" +
"   pdftk in1.pdf in2.pdf cat output out1.pdf\n" +
"   or (using handles):\n" +
"   pdftk A=in1.pdf B=in2.pdf cat A B output out1.pdf\n" +
"   or (using wildcards):\n" +
"   pdftk *.pdf cat output combined.pdf\n" +
"\n" +
"       Remove page 13 from in1.pdf to create out1.pdf\n" +
"   pdftk in.pdf cat 1-12 14-end output out1.pdf\n" +
"   or:\n" +
"   pdftk A=in1.pdf cat A1-12 A14-end output out1.pdf\n" +
"\n" +
"       Apply 40-bit encryption to output, revoking all permissions (the\n" +
"       default). Set the owner PW to 'foopass'.\n" +
"   pdftk 1.pdf 2.pdf cat output 3.pdf encrypt_40bit owner_pw foopass\n" +
"\n" +
"       Join two files, one of which requires the password 'foopass'. The out-\n" +
"       put is not encrypted.\n" +
"   pdftk A=secured.pdf 2.pdf input_pw A=foopass cat output 3.pdf\n" +
"\n" +
"       Uncompress PDF page streams for editing the PDF in a text editor (e.g.,\n" +
"       vim, emacs)\n" +
"   pdftk doc.pdf output doc.unc.pdf uncompress\n" +
"\n" +
"       Repair a PDF's corrupted XREF table and stream lengths, if possible\n" +
"   pdftk broken.pdf output fixed.pdf\n" +
"\n" +
"       Burst a single PDF document into pages and dump its data to\n" +
"       doc_data.txt\n" +
"   pdftk in.pdf burst\n" +
"\n" +
"       Burst a single PDF document into encrypted pages. Allow low-quality\n" +
"       printing\n" +
"   pdftk in.pdf burst owner_pw foopass allow DegradedPrinting\n" +
"\n" +
"       Write a report on PDF document metadata and bookmarks to report.txt\n" +
"   pdftk in.pdf dump_data output report.txt\n" +
"\n" +
"       Rotate the first PDF page to 90 degrees clockwise\n" +
"   pdftk in.pdf cat 1east 2-end output out.pdf\n" +
"\n" +
"       Rotate an entire PDF document to 180 degrees\n" +
"   pdftk in.pdf cat 1-endsouth output out.pdf\n" +
"\n" +
"NOTES\n" +
"       This is a port of pdftk to java. See https://gitlab.com/pdftk-java/pdftk\n" +
"       The original program can be found at www.pdftk.com\n" +
"\n" +
"AUTHOR\n" +
"       Original author of pdftk is Sid Steward (sid.steward at pdflabs dot com).");
}

static void describe_bug_report() {
  System.err.println("There was a problem with pdftk-java. Please report it at");
  System.err.println("https://gitlab.com/pdftk-java/pdftk/issues");
  System.err.println("including the message above, the version of pdftk-java (" + PDFTK_VER + "), and if possible steps to reproduce the error.");
}

};

 /*
 *   This file is part of the pdftk port to java
 *
 *   Copyright (c) Marc Vinyals 2017-2018
 *
 *   The program is a java port of PDFtk, the PDF Toolkit
 *   Copyright (c) 2003-2013 Steward and Lee, LLC
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   The program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.gitlab.pdftk_java;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Set;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.nio.charset.StandardCharsets;
import java.text.NumberFormat;


import org.apache.commons.lang3.StringEscapeUtils;

import pdftk.com.lowagie.text.Rectangle;
import pdftk.com.lowagie.text.pdf.PdfArray;
import pdftk.com.lowagie.text.pdf.PdfBoolean;
import pdftk.com.lowagie.text.pdf.PdfDictionary;
import pdftk.com.lowagie.text.pdf.PdfName;
import pdftk.com.lowagie.text.pdf.PdfNumber;
import pdftk.com.lowagie.text.pdf.PdfObject;
import pdftk.com.lowagie.text.pdf.PdfReader;
import pdftk.com.lowagie.text.pdf.PdfString;
import pdftk.com.lowagie.text.pdf.PdfWriter;
import pdftk.com.lowagie.text.pdf.PRIndirectReference;
import pdftk.com.lowagie.text.pdf.PRStream;

class report {

static String
OutputXmlString( String jss_p )
{
  return StringEscapeUtils.escapeXml10( jss_p );
}

static String
OutputUtf8String( String jss_p )
{
  return jss_p;
}
  
static String
OutputPdfString( PdfString pdfss_p,
                 boolean utf8_b )
{
  if( pdfss_p != null && pdfss_p.isString() ) {
    String jss_p= pdfss_p.toUnicodeString();
    if( utf8_b ) {
      return OutputUtf8String( jss_p );
    }
    else {
      return OutputXmlString( jss_p );
    }
  }
  return "";
}

static String
OutputPdfName( PdfName pdfnn_p )
{
  if( pdfnn_p != null && pdfnn_p.isName() ) {
    String jnn_p= new String( pdfnn_p.getBytes() );
    jnn_p= PdfName.decodeName( jnn_p );
    return OutputXmlString( jnn_p );
  }
  return "";
}

static String
OutputPdfStringOrName( PdfObject pdfoo_p ,
                       boolean utf8_b )
{
  if( pdfoo_p != null && pdfoo_p.isString() ) {
    return OutputPdfString( (PdfString)pdfoo_p, utf8_b );
  }
  else if( pdfoo_p != null && pdfoo_p.isName() ) {
    return OutputPdfName( (PdfName)pdfoo_p );
  }
  return null;
}

static class FormField {
  String m_ft = ""; // type
  String m_tt = ""; // name
  String m_tu = ""; // alt. name
  int m_ff = 0; // flags
  Set<String> m_vv = new HashSet<String>(); // value -- may be an array
  String m_dv = ""; // default value

  // variable-text features
  int m_qq = 0; // quadding (justification)
  String m_ds = ""; // default style (rich text)
  byte[] m_rv = new byte[0]; // rich text value

  int m_maxlen = 0;

  // for checkboxes and such
  Set<String> m_states = new HashSet<String>(); // possible states
  // states as (value,display) pairs
  Set<List<String>> m_states_value_display = new HashSet<List<String>>();
  String m_state = "";

  FormField () {}
  FormField( FormField copy ) {
    m_ft = copy.m_ft;
    m_tt = copy.m_tt;
    m_tu = copy.m_tu;
    m_ff = copy.m_ff;
    m_vv = new HashSet<String>( copy.m_vv );
    m_dv = copy.m_dv;
    m_qq = copy.m_qq;
    m_ds = copy.m_ds;
    m_rv = Arrays.copyOf( copy.m_rv, copy.m_rv.length );
    m_maxlen = copy.m_maxlen;
    m_states = new HashSet<String>( copy.m_states );
    m_states_value_display = new HashSet<List<String>>();
    for (List<String> l : copy.m_states_value_display) {
      m_states_value_display.add( new ArrayList<String>(l) );
    }
    m_state = copy.m_state;
  }

  void addOptions(PdfReader reader_p,
                  PdfArray opts_p,
                  boolean utf8_b) {
    ArrayList<PdfObject> opts_a = opts_p.getArrayList();
    for( PdfObject opts_ii : opts_a ) {
      PdfObject opt_p= reader_p.getPdfObject( opts_ii );
      if (opt_p == null) continue;
      if( opt_p.isString() ) {
        // Option is a text string
        m_states.add( OutputPdfString( (PdfString)opt_p, utf8_b ) );
      }
      else if ( opt_p.isArray() ) {
        // Option is an array (value, display)
        ArrayList<PdfString> opt_value_display_p =
          ((PdfArray)opt_p).getArrayList();
        if (opt_value_display_p.size() != 2) continue;
        ArrayList<String> opt_value_display_a = new ArrayList<String>();
        for (PdfString subopt_p : opt_value_display_p) {
          opt_value_display_a.add( OutputPdfString( subopt_p, utf8_b ) );
        }
        m_states_value_display.add(opt_value_display_a);
      }
    }
  }

};

static void
  OutputFormField( PrintStream ofs,
                   FormField ff )
{
  ofs.println( "---" ); // delim
  ofs.println( "FieldType: " + ff.m_ft );
  ofs.println( "FieldName: " + ff.m_tt );
  if( !ff.m_tu.isEmpty() )
    ofs.println( "FieldNameAlt: " + ff.m_tu );
  ofs.println( "FieldFlags: " + ff.m_ff );
  for( String it : ff.m_vv ) {
    ofs.println( "FieldValue: " + it );
  }
  if( !ff.m_dv.isEmpty() )
    ofs.println( "FieldValueDefault: " + ff.m_dv );

  ofs.print( "FieldJustification: " );
  switch( ff.m_qq ) {
  case 0:
    ofs.println( "Left" );
    break;
  case 1:
    ofs.println( "Center" );
    break;
  case 2:
    ofs.println( "Right" );
    break;
  default:
    ofs.println( ff.m_qq );
    break;
  }
  
  if( !ff.m_ds.isEmpty() )
    ofs.println( "FieldStyleDefault: " + ff.m_ds );
  if( ff.m_rv.length > 0 ) {
    ofs.print( "FieldValueRichText: ");
    try {
      ofs.write( ff.m_rv );
    }
    catch (IOException e) {}
    ofs.println();
  }
  if( 0< ff.m_maxlen )
    ofs.println( "FieldMaxLength: " + ff.m_maxlen );

  for( String it : ff.m_states ) {
    ofs.println( "FieldStateOption: " + it );
  }
  for( List<String> it : ff.m_states_value_display ) {
    ofs.println( "FieldStateOption: " + it.get(0) );
    ofs.println( "FieldStateOptionDisplay: " + it.get(1) );
  }
}

  
static boolean
ReportAcroFormFields( PrintStream ofs,
                      PdfArray kids_array_p,
                      FormField acc_state,
                      PdfReader reader_p,
                      boolean utf8_b )
{
  FormField prev_state= new FormField( acc_state );
  boolean ret_val_b= false;

  ArrayList<PRIndirectReference> kids_p= kids_array_p.getArrayList();
  if( kids_p != null ) {
    for( PRIndirectReference kids_ii : kids_p ) {

      PdfDictionary kid_p= (PdfDictionary)
        reader_p.getPdfObject( kids_ii );
      if( kid_p != null && kid_p.isDictionary() ) {

        // field type
        if( kid_p.contains( PdfName.FT ) ) {
          PdfName ft_p= (PdfName)
            reader_p.getPdfObject( kid_p.get( PdfName.FT ) );
          if( ft_p != null && ft_p.isName() ) {
            
            if( ft_p.equals( PdfName.BTN ) ) { // button
              acc_state.m_ft= "Button";
            }
            else if( ft_p.equals( PdfName.TX ) ) { // text
              acc_state.m_ft= "Text";
            }
            else if( ft_p.equals( PdfName.CH ) ) { // choice
              acc_state.m_ft= "Choice";
            }
            else if( ft_p.equals( PdfName.SIG ) ) { // signature
              acc_state.m_ft= "Signature";
            }
            else { // warning
              System.err.println( "pdftk Warning in ReportAcroFormFields(): unexpected field type;" );
            }
          }
        }

        // field name; special inheritance rule: prepend parent name
        if( kid_p.contains( PdfName.T ) ) {
          PdfString pdfs_p= (PdfString)
            reader_p.getPdfObject( kid_p.get( PdfName.T ) );
          if( pdfs_p != null && pdfs_p.isString() ) {
            if( !acc_state.m_tt.isEmpty() ) {
              acc_state.m_tt= acc_state.m_tt + ".";
            }
            acc_state.m_tt = acc_state.m_tt + OutputPdfString( pdfs_p, utf8_b );
          }
        }

        // field alt. name
        if( kid_p.contains( PdfName.TU ) ) {
          PdfString pdfs_p= (PdfString)
            reader_p.getPdfObject( kid_p.get( PdfName.TU ) );
          if( pdfs_p != null && pdfs_p.isString() ) {
            acc_state.m_tu= OutputPdfString( pdfs_p, utf8_b );
          }
        }
        else {
          acc_state.m_tu="";
        }

        // field flags; inheritable
        if( kid_p.contains( PdfName.FF ) ) {
          PdfNumber pdfs_p= (PdfNumber)
            reader_p.getPdfObject( kid_p.get( PdfName.FF ) );
          if( pdfs_p != null && pdfs_p.isNumber() ) {
            acc_state.m_ff= pdfs_p.intValue();
          }
        }

        // field value; inheritable; may be string or name
        if( kid_p.contains( PdfName.V ) ) {
          PdfObject pdfs_p= 
            reader_p.getPdfObject( kid_p.get( PdfName.V ) );

          if( pdfs_p == null ) continue;
          String maybe_output = OutputPdfStringOrName( pdfs_p, utf8_b );
          if ( maybe_output != null ) {
            acc_state.m_vv.add( maybe_output );
          }
          else if( pdfs_p.isArray() ) {
            // multiple selections
            ArrayList<PRIndirectReference> vv_p= ((PdfArray)pdfs_p).getArrayList();
            for( PRIndirectReference vv_ii : vv_p ) {
              PdfObject pdfs_p_2= (PdfObject)
                reader_p.getPdfObject( vv_ii );
              String maybe_output_2 = OutputPdfStringOrName( pdfs_p_2, utf8_b );
              if ( maybe_output != null ) {
                acc_state.m_vv.add( maybe_output_2 );
              }
            }
          }
        }

        // default value; inheritable
        if( kid_p.contains( PdfName.DV ) ) {
          PdfObject pdfs_p= (PdfObject)
            reader_p.getPdfObject( kid_p.get( PdfName.DV ) );
          String maybe_output = OutputPdfStringOrName( pdfs_p, utf8_b );
          if( maybe_output != null ) {
            acc_state.m_dv= maybe_output;
          }
        }

        // quadding; inheritable
        if( kid_p.contains( PdfName.Q ) ) {
          PdfNumber pdfs_p= (PdfNumber)
            reader_p.getPdfObject( kid_p.get( PdfName.Q ) );
          if( pdfs_p != null && pdfs_p.isNumber() ) {

            acc_state.m_qq= pdfs_p.intValue();
          }
        }

        // default style
        if( kid_p.contains( PdfName.DS ) ) {
          PdfString pdfs_p= (PdfString)
            reader_p.getPdfObject( kid_p.get( PdfName.DS ) );
          if( pdfs_p != null && pdfs_p.isString() ) {
            acc_state.m_ds= OutputPdfString( pdfs_p, utf8_b );
          }
        }
        else {
          acc_state.m_ds="";
        }

        // rich text value; may be a string or a stream
        if( kid_p.contains( PdfName.RV ) ) {
          PdfObject pdfo_p= (PdfObject)
            reader_p.getPdfObject( kid_p.get( PdfName.RV ) );
          if( pdfo_p != null && pdfo_p.isString() ) { // string
            PdfString pdfs_p= (PdfString)pdfo_p;
            String name_oss= OutputPdfString( pdfs_p, utf8_b );
            acc_state.m_rv= name_oss.getBytes( StandardCharsets.UTF_8 );
          }
          else if( pdfo_p != null && pdfo_p.isStream() ) { // stream
            PRStream pdfs_p= (PRStream)pdfo_p;
            acc_state.m_rv = pdfs_p.getBytes();
          }
        }
        else {
          acc_state.m_rv=new byte[0];
        }

        // maximum length; inheritable
        if( kid_p.contains( PdfName.MAXLEN ) ) {
          PdfNumber pdfs_p= (PdfNumber)
            reader_p.getPdfObject( kid_p.get( PdfName.MAXLEN ) );
          if( pdfs_p != null && pdfs_p.isNumber() ) {

            acc_state.m_maxlen= pdfs_p.intValue();
          }
        }

        // available states
        if( kid_p.contains( PdfName.AP ) ) {
          PdfDictionary ap_p= (PdfDictionary)
            reader_p.getPdfObject( kid_p.get( PdfName.AP ) );
          if( ap_p != null && ap_p.isDictionary() ) {

            // this is one way to cull button option names: iterate over
            // appearance state names

            // N
            if( ap_p.contains( PdfName.N ) ) {
              PdfObject n_p= 
                reader_p.getPdfObject( ap_p.get( PdfName.N ) );
              if( n_p != null && n_p.isDictionary() ) {
                Set<PdfName> n_set_p= ((PdfDictionary)n_p).getKeys();
                for( PdfName key_p : n_set_p ) {
                  acc_state.m_states.add( OutputPdfName( key_p ) );
                }
              }
            }

            // D
            if( ap_p.contains( PdfName.D ) ) {
              PdfObject n_p= 
                reader_p.getPdfObject( ap_p.get( PdfName.D ) );
              if( n_p != null && n_p.isDictionary() ) {
                Set<PdfName> n_set_p= ((PdfDictionary)n_p).getKeys();
                for( PdfName key_p : n_set_p ) {
                  acc_state.m_states.add( OutputPdfName( key_p ) );
                }
              }
            }

            // R
            if( ap_p.contains( PdfName.R ) ) {
              PdfObject n_p= 
                reader_p.getPdfObject( ap_p.get( PdfName.N ) );
              if( n_p != null && n_p.isDictionary() ) {
                Set<PdfName> n_set_p= ((PdfDictionary)n_p).getKeys();
                for( PdfName key_p : n_set_p ) {
                  acc_state.m_states.add( OutputPdfName( key_p ) );
                }
              }
            }

          }
        }

        // list-box / combo-box possible states
        if( kid_p.contains( PdfName.OPT ) ) {
          PdfObject kid_opts_p= 
            reader_p.getPdfObject( kid_p.get( PdfName.OPT ) );
          if( kid_opts_p != null && kid_opts_p.isArray() ) {
            acc_state.addOptions( reader_p, (PdfArray)kid_opts_p, utf8_b );
          }
        }

        if( kid_p.contains( PdfName.KIDS ) ) { // recurse
          PdfArray kid_kids_p= (PdfArray)
            reader_p.getPdfObject( kid_p.get( PdfName.KIDS )  );
          if( kid_kids_p != null && kid_kids_p.isArray() ) {

            boolean kids_have_names_b=
              ReportAcroFormFields( ofs, kid_kids_p, acc_state, reader_p, utf8_b );

            if( !kids_have_names_b &&
                kid_p.contains( PdfName.T ) )
              { 
                // dump form field
                OutputFormField( ofs, acc_state );
              }

            // reset state; 
            acc_state= new FormField(prev_state);
          }
          else { // error
          }
        }
        else if( kid_p.contains( PdfName.T ) ) { 
          // term. field; dump form field
          OutputFormField( ofs, acc_state );

          // reset state; 
          acc_state= new FormField(prev_state);

          // record presense of field name
          ret_val_b= true;
        }

      }
    }
  }
  else { // warning
    System.err.println( "pdftk Warning in ReportAcroFormFields(): unable to get ArrayList;" );
  }

  return ret_val_b;
}

  
static void
ReportAcroFormFields( PrintStream ofs,
                      PdfReader reader_p,
                      boolean utf8_b ) {
  PdfDictionary catalog_p= reader_p.catalog;
  if( catalog_p != null && catalog_p.isDictionary() ) {
    
    PdfDictionary acro_form_p= (PdfDictionary)
      reader_p.getPdfObject( catalog_p.get( PdfName.ACROFORM ) );
    if( acro_form_p != null && acro_form_p.isDictionary() ) {

      PdfArray fields_p= (PdfArray)
        reader_p.getPdfObject( acro_form_p.get( PdfName.FIELDS ) );
      if( fields_p != null && fields_p.isArray() ) {

        // enter recursion
        FormField root_field_state = new FormField();
        ReportAcroFormFields( ofs, fields_p, root_field_state, reader_p, utf8_b );
      }
    }
  }
  else { // error
    System.err.println( "pdftk Error in ReportAcroFormFields(): unable to access PDF catalog;" );
  }

}

static void
ReportAction( PrintStream ofs, 
              PdfReader reader_p,
              PdfDictionary action_p,
              boolean utf8_b,
              String prefix )
{
  if( action_p.contains( PdfName.S ) ) {
    PdfName s_p= (PdfName)
      reader_p.getPdfObject( action_p.get( PdfName.S ) );

    // URI action
    if( s_p.equals( PdfName.URI ) ) {
      ofs.println( prefix + "ActionSubtype: URI" );

      // report URI
      if( action_p.contains( PdfName.URI ) ) {
        PdfString uri_p= (PdfString)
          reader_p.getPdfObject( action_p.get( PdfName.URI ) );
        if( uri_p != null && uri_p.isString() ) {
          
          ofs.println( prefix + "ActionURI: " +
                       OutputPdfString( uri_p, utf8_b ) );
        }
      }

      // report IsMap
      if( action_p.contains( PdfName.ISMAP ) ) {
        PdfBoolean ismap_p= (PdfBoolean)
          reader_p.getPdfObject( action_p.get( PdfName.ISMAP ) );
        if( ismap_p != null && ismap_p.isBoolean() )
          if( ismap_p.booleanValue() )
            ofs.println( prefix + "ActionIsMap: true" );
          else
            ofs.println( prefix + "ActionIsMap: false" );
      }
      else
        ofs.println( prefix + "ActionIsMap: false" );
    }
  }

  // subsequent actions? can be a single action or an array
  if( action_p.contains( PdfName.NEXT ) ) {
    PdfObject next_p= reader_p.getPdfObject( action_p.get( PdfName.NEXT ) );
    if( next_p.isDictionary() ) {
      ReportAction( ofs, reader_p, (PdfDictionary)next_p, utf8_b, prefix );
    }
    else if( next_p.isArray() ) {
      ArrayList<PRIndirectReference> actions_p= ((PdfArray)next_p).getArrayList();
      for( PRIndirectReference ii : actions_p ) {
        PdfDictionary next_action_p= (PdfDictionary)
          reader_p.getPdfObject( ii );
        if( next_action_p != null && next_action_p.isDictionary() )
          ReportAction( ofs, reader_p, next_action_p, utf8_b, prefix ); // recurse
      }
    }
  }
}
  
static final int LLx= 0;
static final int LLy= 1;
static final int URx= 2;
static final int URy= 3;
  
static void
ReportAnnot( PrintStream ofs,
             PdfReader reader_p,
             int page_num,
             PdfDictionary page_p,
             PdfDictionary annot_p,
             boolean utf8_b )
{
  // report things common to all annots

  // subtype
  PdfName subtype_p= (PdfName)
    reader_p.getPdfObject( annot_p.get( PdfName.SUBTYPE ) );
  if( subtype_p != null && subtype_p.isName() ) {
    ofs.println( "AnnotSubtype: " + OutputPdfName( subtype_p ) );
  }

  ////
  // rect

  // get raw rect from annot
  float[] rect = { 0.0f, 0.0f, 0.0f, 0.0f };
  PdfArray rect_p= (PdfArray)
    reader_p.getPdfObject( annot_p.get( PdfName.RECT ) );
  if( rect_p != null && rect_p.isArray() ) {
    ArrayList<PRIndirectReference> rect_al_p= rect_p.getArrayList();
    if( rect_al_p != null && rect_al_p.size()== 4 ) {

      for( int ii= 0; ii< 4; ++ii ) {
        PdfNumber coord_p= (PdfNumber)
          reader_p.getPdfObject( rect_al_p.get( ii ) );
        if( coord_p != null && coord_p.isNumber() )
          rect[ ii ]= (float)coord_p.floatValue();
        else
          rect[ ii ]= -1; // error value
      }
    }
  }
  
  // transform rect according to page crop box
  // grab width and height for later xform
  float page_crop_width= 0;
  float page_crop_height= 0;
  {
    Rectangle page_crop_p= reader_p.getCropBox( page_num );
    rect[0]= rect[0]- page_crop_p.left();
    rect[1]= rect[1]- page_crop_p.bottom();
    rect[2]= rect[2]- page_crop_p.left();
    rect[3]= rect[3]- page_crop_p.bottom();

    page_crop_width= (float)(page_crop_p.right()- page_crop_p.left());
    page_crop_height= (float)(page_crop_p.top()- page_crop_p.bottom());
  }

  // create new rect based on page rotation
  int page_rot= (int)(reader_p.getPageRotation( page_num )) % 360;
  float[] rot_rect = { 0.0f, 0.0f, 0.0f, 0.0f };
  switch( page_rot ) {

  case 90:
    rot_rect[0]= rect[LLy];
    rot_rect[1]= page_crop_width- rect[URx];
    rot_rect[2]= rect[URy];
    rot_rect[3]= page_crop_width- rect[LLx];
    break;

  case 180:
    rot_rect[0]= page_crop_width- rect[URx];
    rot_rect[1]= page_crop_height- rect[URy];
    rot_rect[2]= page_crop_width- rect[LLx];
    rot_rect[3]= page_crop_height- rect[LLy];
    break;

  case 270:
    rot_rect[0]= page_crop_height- rect[URy];
    rot_rect[1]= rect[LLx];
    rot_rect[2]= page_crop_height- rect[LLy];
    rot_rect[3]= rect[URx];
    break;

  default: // 0 deg
    rot_rect[0]= rect[0];
    rot_rect[1]= rect[1];
    rot_rect[2]= rect[2];
    rot_rect[3]= rect[3];
    break;
  }

  // output rotated rect
  ofs.println( "AnnotRect: " + rot_rect[0] + " " + rot_rect[1] +
               " " + rot_rect[2] + " " + rot_rect[3] );

}

static void
ReportAnnots( PrintStream ofs,
              PdfReader reader_p,
              boolean utf8_b ) {
  reader_p.resetReleasePage();

  ////
  // document information

  // document page count
  ofs.println("NumberOfPages: " + (int)reader_p.getNumberOfPages());

  // document base url
  PdfDictionary uri_p= (PdfDictionary)
    reader_p.getPdfObject( reader_p.catalog.get( PdfName.URI ) );
  if( uri_p != null && uri_p.isDictionary() ) {
    
    PdfString base_p= (PdfString)
      reader_p.getPdfObject( uri_p.get( PdfName.BASE ) );
    if( base_p != null && base_p.isString() ) {
      ofs.println("PdfUriBase: " + OutputPdfString( base_p, utf8_b ));
    }
  }

  ////
  // iterate over pages

  for( int ii= 1; ii<= reader_p.getNumberOfPages(); ++ii ) {
    PdfDictionary page_p= reader_p.getPageN( ii );

    PdfArray annots_p= (PdfArray)
      reader_p.getPdfObject( page_p.get( PdfName.ANNOTS ) );
    if( annots_p != null && annots_p.isArray() ) {

      ArrayList<PRIndirectReference> annots_al_p= annots_p.getArrayList();
      if( annots_al_p != null ) {

        // iterate over annotations
        for( PRIndirectReference jj : annots_al_p ) {

          PdfDictionary annot_p= (PdfDictionary)
            reader_p.getPdfObject( jj );
          if( annot_p != null && annot_p.isDictionary() ) {

            PdfName type_p= (PdfName)
              reader_p.getPdfObject( annot_p.get( PdfName.TYPE ) );
            if( type_p.equals( PdfName.ANNOT ) ) {

              PdfName subtype_p= (PdfName)
                reader_p.getPdfObject( annot_p.get( PdfName.SUBTYPE ) );
            
              // link annotation
              if( subtype_p.equals( PdfName.LINK ) ) {

                ofs.println("---"); // delim
                ReportAnnot( ofs, reader_p, ii, page_p, annot_p, utf8_b ); // base annot items
                ofs.println("AnnotPageNumber: " + ii);

                // link-specific items
                if( annot_p.contains( PdfName.A ) ) { // action
                  PdfDictionary action_p= (PdfDictionary)
                    reader_p.getPdfObject( annot_p.get( PdfName.A ) );
                  if( action_p != null && action_p.isDictionary() ) {

                    ReportAction( ofs, reader_p, action_p, utf8_b, "Annot" );
                  }
                }
              }
            }
          }
        }
      }
    }
    reader_p.releasePage( ii );
  }
  reader_p.resetReleasePage();
}

//
static class PdfPageLabel {
  static final String m_prefix= "PageLabel";
  static final String m_begin_mark= "PageLabelBegin";
  // TODO
};

//
class PdfPageMedia {
  static final String m_prefix= "PageMedia";
  static final String m_begin_mark= "PageMediaBegin";
  // TODO
};

static void
ReportOutlines( PrintStream ofs, 
                PdfDictionary outline_p,
                PdfReader reader_p,
                boolean utf8_b )
{
  ArrayList<PdfBookmark> bookmark_data = new ArrayList<PdfBookmark>();
  bookmarks.ReadOutlines( bookmark_data,
                          outline_p,
                          0,
                          reader_p,
                          utf8_b );
  
  for( PdfBookmark it : bookmark_data ) {
    ofs.print( it );
  }
}

static void
ReportInfo( PrintStream ofs,
            PdfReader reader_p,
            PdfDictionary info_p,
            boolean utf8_b ) {
  if( info_p != null && info_p.isDictionary() ) {
    Set<PdfName> keys_p= info_p.getKeys();

    // iterate over Info keys
    for( PdfName key_p : keys_p ) {

      int key_len= key_p.getBytes().length - 1; // minus one for init. slash

      PdfObject value_p= reader_p.getPdfObject( info_p.get( key_p ) );

      // don't output empty keys or values
      if( 0< key_len &&
          value_p.isString() && 
          0< ((PdfString)value_p).toUnicodeString().length() ) 
        { // ouput
          ofs.println( data_import.PdfInfo.m_begin_mark );

          ofs.println( data_import.PdfInfo.m_key_label + " " +
                       OutputPdfName( key_p ) );

          ofs.println( data_import.PdfInfo.m_value_label + " " +
                       OutputPdfString( (PdfString)value_p, utf8_b ) );
        }
    }

  }
  else { // error
  }
}

static void
ReportPageLabels( PrintStream ofs,
                  PdfDictionary numtree_node_p,
                  PdfReader reader_p,
                  boolean utf8_b )
  // if *numtree_node_p has Nums, report them;
  // else if *numtree_node_p has Kids, recurse
  // output 1-based page numbers; that's what we do for bookmarks
{
  PdfArray nums_p= (PdfArray)
    reader_p.getPdfObject( numtree_node_p.get( PdfName.NUMS ) );
  if( nums_p != null && nums_p.isArray() ) {
    // report page numbers

    ArrayList<PRIndirectReference> labels_p= nums_p.getArrayList();
    if( labels_p != null ) {
      for( Iterator<PRIndirectReference> labels_ii = labels_p.iterator(); labels_ii.hasNext(); ) {
        
        // label index
        PdfNumber index_p= (PdfNumber)
          reader_p.getPdfObject( labels_ii.next() );

        // label dictionary
        PdfDictionary label_p= (PdfDictionary)
          reader_p.getPdfObject( labels_ii.next() );

        if( index_p != null && index_p.isNumber() &&
            label_p != null && label_p.isDictionary() )
          {
            ofs.println( PdfPageLabel.m_begin_mark );

            // PageLabelNewIndex
            ofs.println( "PageLabelNewIndex: " + (long)(index_p.intValue())+ 1 );
            
            { // PageLabelStart
              ofs.print( "PageLabelStart: " ); 
              PdfNumber start_p= (PdfNumber)
                reader_p.getPdfObject( label_p.get( PdfName.ST ) );
              if( start_p != null && start_p.isNumber() ) {
                ofs.println( (long)(start_p.intValue()) );
              }
              else {
                ofs.println( "1" ); // the default
              }
            }

            { // PageLabelPrefix
              PdfString prefix_p= (PdfString)
                reader_p.getPdfObject( label_p.get( PdfName.P ) );
              if( prefix_p != null && prefix_p.isString() ) {
                ofs.println( "PageLabelPrefix: " +
                             OutputPdfString( prefix_p, utf8_b ) );
              }
            }

            { // PageLabelNumStyle
              PdfName r_p= new PdfName("r");
              PdfName a_p= new PdfName("a");

              PdfName style_p= (PdfName)
                reader_p.getPdfObject( label_p.get( PdfName.S ) );
              ofs.print( "PageLabelNumStyle: " );
              if( style_p != null && style_p.isName() ) {
                if( style_p.equals( PdfName.D ) ) {
                  ofs.println( "DecimalArabicNumerals" );
                }
                else if( style_p.equals( PdfName.R ) ) {
                  ofs.println( "UppercaseRomanNumerals" );
                }
                else if( style_p.equals( r_p ) ) {
                  ofs.println( "LowercaseRomanNumerals" );
                }
                else if( style_p.equals( PdfName.A ) ) {
                  ofs.println( "UppercaseLetters" );
                }
                else if( style_p.equals( a_p ) ) {
                  ofs.println( "LowercaseLetters" );
                }
                else { // error
                  ofs.println( "[PDFTK ERROR]" );
                }
              }
              else { // default
                ofs.println( "NoNumber" );
              }
            }

          }
        else { // error
          ofs.println( "[PDFTK ERROR: INVALID label_p IN ReportPageLabelNode]" );
        }
      }
    }
    else { // error
      ofs.println( "[PDFTK ERROR: INVALID labels_p IN ReportPageLabelNode]" );
    }
  }
  else { // try recursing
    PdfArray kids_p= (PdfArray)
      reader_p.getPdfObject( numtree_node_p.get( PdfName.KIDS ) );
    if( kids_p != null && kids_p.isArray() ) {

      ArrayList<PRIndirectReference> kids_ar_p= kids_p.getArrayList();
      if( kids_ar_p != null ) {
        for( PRIndirectReference kids_ii : kids_ar_p ) {

          PdfDictionary kid_p= (PdfDictionary)
            reader_p.getPdfObject( kids_ii );
          if( kid_p != null && kid_p.isDictionary() ) {

            // recurse
            ReportPageLabels( ofs, kid_p, reader_p, utf8_b );
          }
          else { // error
            ofs.println( "[PDFTK ERROR: INVALID kid_p]" );
          }
        }
      }
      else { // error
        ofs.println( "[PDFTK ERROR: INVALID kids_ar_p]" );
      }
    }
    else { // error; a number tree must have one or the other
      ofs.println( "[PDFTK ERROR: INVALID PAGE LABEL NUMBER TREE]" );
    }
  }
}
  
static void
ReportOnPdf( PrintStream ofs,
             PdfReader reader_p,
             boolean utf8_b )
{
  { // trailer data
    PdfDictionary trailer_p= reader_p.getTrailer();
    if( trailer_p != null && trailer_p.isDictionary() ) {

      { // metadata
        PdfDictionary info_p= (PdfDictionary)
          reader_p.getPdfObject( trailer_p.get( PdfName.INFO ) );
        if( info_p != null && info_p.isDictionary() ) {
            
          ReportInfo( ofs, reader_p, info_p, utf8_b );
        }
        else { // warning
          System.err.println( "Warning: no info dictionary found" );
        }
      }

      { // pdf ID; optional
        PdfArray id_p= (PdfArray)
          reader_p.getPdfObject( trailer_p.get( PdfName.ID ) );
        if( id_p != null && id_p.isArray() ) {

          ArrayList<PRIndirectReference> id_al_p= id_p.getArrayList();
          if( id_al_p != null ) {

            for( int ii= 0; ii< id_al_p.size(); ++ii ) {
              ofs.print( "PdfID" + ii + ": " );

              PdfString id_ss_p= (PdfString)
                reader_p.getPdfObject( id_al_p.get(ii) );
              if( id_ss_p != null && id_ss_p.isString() ) {
                
                byte[] bb= id_ss_p.getBytes();
                if( bb!=null && bb.length > 0 ) {
                  for( byte bb_ss : bb ) {
                    ofs.printf( "%02x", bb_ss );
                  }
                }
              }
              else { // error
                System.err.println( "pdftk Error in ReportOnPdf(): invalid pdf id array string;" );
              }

              ofs.println();
            }
          }
          else { // error
            System.err.println( "pdftk Error in ReportOnPdf(): invalid ID ArrayList" );
          }
        }
      }

    }
    else { // error
      System.err.println( "pdftk Error in ReportOnPdf(): invalid trailer;" );
    }
  }

  int numPages= reader_p.getNumberOfPages();

  { // number of pages and outlines
    PdfDictionary catalog_p= reader_p.catalog;
    if( catalog_p != null && catalog_p.isDictionary() ) {

      // number of pages
      /*
      itext::PdfDictionary* pages_p= (itext::PdfDictionary*)
        reader_p->getPdfObject( catalog_p->get( itext::PdfName::PAGES ) );
      if( pages_p && pages_p->isDictionary() ) {

        itext::PdfNumber* count_p= (itext::PdfNumber*)
          reader_p->getPdfObject( pages_p->get( itext::PdfName::COUNT ) );
        if( count_p && count_p->isNumber() ) {

          ofs << "NumberOfPages: " << (unsigned int)count_p->intValue() << endl;
        }
        else { // error
          cerr << "pdftk Error in ReportOnPdf(): invalid count_p;" << endl;
        }
      }
      else { // error
        cerr << "pdftk Error in ReportOnPdf(): invalid pages_p;" << endl;
      }
      */
      ofs.println( "NumberOfPages: " + numPages );

      // outlines; optional
      PdfDictionary outlines_p= (PdfDictionary)
        reader_p.getPdfObject( catalog_p.get( PdfName.OUTLINES ) );
      if( outlines_p != null && outlines_p.isDictionary() ) {

        PdfDictionary top_outline_p= (PdfDictionary)
          reader_p.getPdfObject( outlines_p.get( PdfName.FIRST ) );
        if( top_outline_p != null && top_outline_p.isDictionary() ) {

          ReportOutlines( ofs, top_outline_p, reader_p, utf8_b );
        }
        else { // error
          // okay, not a big deal
          // cerr << "Internal Error: invalid top_outline_p in ReportOnPdf()" << endl;
        }
      }

    }
    else { // error
      System.err.println( "pdftk Error in ReportOnPdf(): couldn't find catalog;" );
    }
  }

  { // page metrics, rotation, stamptkData
    for( int ii= 1; ii<= numPages; ++ii ) {
      PdfDictionary page_p= reader_p.getPageN( ii );

      ofs.println( PdfPageMedia.m_begin_mark );
      ofs.println( "PageMediaNumber: " + ii );

      ofs.println( "PageMediaRotation: " + reader_p.getPageRotation( page_p ) );

      NumberFormat c_format = NumberFormat.getInstance(Locale.ROOT);
      
      Rectangle page_rect_p= reader_p.getPageSize( page_p );
      if( page_rect_p != null ) {
        ofs.println( "PageMediaRect: " 
            + c_format.format(page_rect_p.left()) + " "
            + c_format.format(page_rect_p.bottom()) + " "
            + c_format.format(page_rect_p.right()) + " "
            + c_format.format(page_rect_p.top()) );
        ofs.println( "PageMediaDimensions: " 
            + c_format.format(page_rect_p.right()- page_rect_p.left()) + " "
            + c_format.format(page_rect_p.top()- page_rect_p.bottom()) );
      }
      
      Rectangle page_crop_p= reader_p.getBoxSize( page_p, PdfName.CROPBOX );
      if( page_crop_p != null && 
          !( page_crop_p.left()== page_rect_p.left() &&
             page_crop_p.bottom()== page_rect_p.bottom() &&
             page_crop_p.right()== page_rect_p.right() &&
             page_crop_p.top()== page_rect_p.top() ) )
        {
          ofs.println( "PageMediaCropRect: " 
              + c_format.format(page_crop_p.left()) + " "
              + c_format.format(page_crop_p.bottom()) + " "
              + c_format.format(page_crop_p.right()) + " "
              + c_format.format(page_crop_p.top()) );
        } 

      PdfString stamptkData_p= page_p.getAsString( PdfName.STAMPTKDATA );
      if( stamptkData_p != null ) {
        ofs.println( "PageMediaStamptkData: " +
                     OutputPdfString( stamptkData_p, utf8_b ) );
      }

      reader_p.releasePage( ii );
    }
  }

  { // page labels (a/k/a logical page numbers)
    PdfDictionary catalog_p= reader_p.catalog;
    if( catalog_p != null && catalog_p.isDictionary() ) {

      PdfDictionary pagelabels_p= (PdfDictionary)
        reader_p.getPdfObject( catalog_p.get( PdfName.PAGELABELS ) );
      if( pagelabels_p != null && pagelabels_p.isDictionary() ) {

        ReportPageLabels( ofs, pagelabels_p, reader_p, utf8_b );
      }
    }
    else { // error
      System.err.println( "pdftk Error in ReportOnPdf(): couldn't find catalog (2);" );
    }
  }

} // end: ReportOnPdf

};
 /*
 * $Id$
 *
 * Copyright 2007 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.exceptions;

import java.io.IOException;

/**
 * Typed exception used when opening an existing PDF document.
 * Gets thrown when the document isn't a valid PDF document.
 * @since 2.1.5 It was written for iText 2.0.8, but moved to another package
 */
public class BadPasswordException extends IOException {

	/** Serial Version UID. */
	private static final long serialVersionUID = -4333706268155063964L;

	/**
	 * Creates an exception saying the user password was incorrect.
	 */
	public BadPasswordException(String message) {
		super(message);
	}
}
 /*
 * $Id$
 *
 * Copyright 2009 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999-2009 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000-2009 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.exceptions;

/**
 * Typed exception used when creating PDF syntax that isn't valid.
 * @since 2.1.6
 */
public class IllegalPdfSyntaxException extends IllegalArgumentException {

	/** Serial version ID */
	private static final long serialVersionUID = -643024246596031671L;

	/**
	 * Creates an exception saying the PDF syntax isn't correct.
	 * @param	message	some extra info about the exception
	 */
	public IllegalPdfSyntaxException(String message) {
		super(message);
	}
}
 /*
 * $Id$
 *
 * Copyright 2009 Bruno Lowagie
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999-2009 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000-2009 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.exceptions;

import java.io.IOException;

/**
 * Typed exception used when opening an existing PDF document.
 * Gets thrown when the document isn't a valid PDF document.
 * @since 2.1.5
 */
public class InvalidPdfException extends IOException {

	/** a serial version UID */
	private static final long serialVersionUID = -2319614911517026938L;

	/**
	 * Creates an instance of a NoPdfException.
	 * @param	message	the reason why the document isn't a PDF document according to iText.
	 */
	public InvalidPdfException(String message) {
		super(message);
	}
}
 /*
 * $Id$
 *
 * Copyright 2009 Bruno Lowagie
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999-2009 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000-2009 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.exceptions;
/**
 * Typed exception used when opening an existing PDF document.
 * Gets thrown when the document isn't a valid PDF document according to iText,
 * but it's different from the InvalidPdfException in the sense that it may
 * be an iText limitation (most of the times it isn't but you might have
 * bumped into something that has been added to the PDF specs, but that isn't
 * supported in iText yet).
 * @since 2.1.5
 */
public class UnsupportedPdfException extends InvalidPdfException {

	/** a serial version UID */
	private static final long serialVersionUID = 2180764250839096628L;

	/**
	 * Creates an instance of an UnsupportedPdfException.
	 * @param	message	the reason why the document isn't a PDF document according to iText.
	 */
	public UnsupportedPdfException(String message) {
		super(message);
	}
}
 /*
 * $Id: MarkupParser.java,v 1.53 2005/05/09 08:40:41 blowagie Exp $
 * $Name:  $
 *
 * Copyright 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.markup;

import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.HashMap;
import java.util.Properties;
import java.util.StringTokenizer;

import pdftk.com.lowagie.text.Element;
import pdftk.com.lowagie.text.ExceptionConverter;
import pdftk.com.lowagie.text.Font;
import pdftk.com.lowagie.text.FontFactory;
import pdftk.com.lowagie.text.ListItem;
import pdftk.com.lowagie.text.Paragraph;
import pdftk.com.lowagie.text.Phrase;
import pdftk.com.lowagie.text.Rectangle;
// import pdftk.com.lowagie.text.SimpleCell; ssteward: dropped in 1.44
// import pdftk.com.lowagie.text.SimpleTable; ssteward: dropped in 1.44

/**
 * This class is a HashMap that contains selectors (String) and styles (a
 * Properties object). Given a tag and its attributes (id/class), this class can
 * return an iText object with the according style.
 * 
 * @author blowagie
 */
public class MarkupParser extends HashMap {
    
    // constants
    private static final long serialVersionUID = 2643594602455839674L;

	/**
	 * HashMap with styles for each known combination of tag/id/class. The key
	 * is a String-combination, the value a Properties object.
	 */
	protected HashMap stylecache = new HashMap();

	/**
	 * HashMap with fonts for each known combination of tag/id/class. The key is
	 * the same String-combination used for the stylecache.
	 */
	protected HashMap fontcache = new HashMap();

	// processing CSS

	/**
	 * Creates new MarkupParser
	 * 
	 * @param file
	 *            the path to a CSS file.
	 */
	public MarkupParser(String file) {
		super();
		try {
			FileReader reader = new FileReader(file);
			BufferedReader br = new BufferedReader(reader);
			StringBuffer buf = new StringBuffer();
			String line;
			while ((line = br.readLine()) != null) {
				buf.append(line.trim());
			}
			String string = buf.toString();
			string = removeComment(string, "/*", "*/");
			StringTokenizer tokenizer = new StringTokenizer(string, "}");
			String tmp;
			int pos;
			String selector;
			String attributes;
			while (tokenizer.hasMoreTokens()) {
				tmp = tokenizer.nextToken();
				pos = tmp.indexOf("{");
				if (pos > 0) {
					selector = tmp.substring(0, pos).trim();
					attributes = tmp.substring(pos + 1).trim();
					if (attributes.endsWith("}"))
						attributes = attributes.substring(0, attributes
								.length() - 1);
					put(selector, parseAttributes(attributes));
				}
			}
		} catch (Exception e) {
			throw new ExceptionConverter(e);
		}
	}

	/**
	 * Removes the comments sections of a String.
	 * 
	 * @param string
	 *            the original String
	 * @param startComment
	 *            the String that marks the start of a Comment section
	 * @param endComment
	 *            the String that marks the end of a Comment section.
	 * @return the String stripped of its comment section
	 */
	public static String removeComment(String string, String startComment,
			String endComment) {
		StringBuffer result = new StringBuffer();
		int pos = 0;
		int end = endComment.length();
		int start = string.indexOf(startComment, pos);
		while (start > -1) {
			result.append(string.substring(pos, start));
			pos = string.indexOf(endComment, start) + end;
			start = string.indexOf(startComment, pos);
		}
		result.append(string.substring(pos));
		return result.toString();
	}

	/**
	 * This method parses a String with attributes and returns a Properties
	 * object.
	 * 
	 * @param string
	 *            a String of this form: 'key1="value1"; key2="value2";...
	 *            keyN="valueN" '
	 * @return a Properties object
	 */
	public static Properties parseAttributes(String string) {
		Properties result = new Properties();
		if (string == null)
			return result;
		StringTokenizer keyValuePairs = new StringTokenizer(string, ";");
		StringTokenizer keyValuePair;
		String key;
		String value;
		while (keyValuePairs.hasMoreTokens()) {
			keyValuePair = new StringTokenizer(keyValuePairs.nextToken(), ":");
			if (keyValuePair.hasMoreTokens())
				key = keyValuePair.nextToken().trim();
			else
				continue;
			if (keyValuePair.hasMoreTokens())
				value = keyValuePair.nextToken().trim();
			else
				continue;
			if (value.startsWith("\""))
				value = value.substring(1);
			if (value.endsWith("\""))
				value = value.substring(0, value.length() - 1);
			result.setProperty(key, value);
		}
		return result;
	}

	// reading attributevalues

	/**
	 * Parses a length.
	 * 
	 * @param string
	 *            a length in the form of an optional + or -, followed by a
	 *            number and a unit.
	 * @return a float
	 */

	public static float parseLength(String string) {
		int pos = 0;
		int length = string.length();
		boolean ok = true;
		while (ok && pos < length) {
			switch (string.charAt(pos)) {
			case '+':
			case '-':
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case '.':
				pos++;
				break;
			default:
				ok = false;
			}
		}
		if (pos == 0)
			return 0f;
		if (pos == length)
			return Float.valueOf(string + "f").floatValue();
		float f = Float.valueOf(string.substring(0, pos) + "f").floatValue();
		string = string.substring(pos);
		// inches
		if (string.startsWith("in")) {
			return f * 72f;
		}
		// centimeters
		if (string.startsWith("cm")) {
			return (f / 2.54f) * 72f;
		}
		// millimeters
		if (string.startsWith("mm")) {
			return (f / 25.4f) * 72f;
		}
		// picas
		if (string.startsWith("pc")) {
			return f * 12f;
		}
		// default: we assume the length was measured in points
		return f;
	}

	/**
	 * Converts a <CODE>Color</CODE> into a HTML representation of this <CODE>
	 * Color</CODE>.
	 * 
	 * @param color
	 *            the <CODE>Color</CODE> that has to be converted.
	 * @return the HTML representation of this <COLOR>Color </COLOR>
	 */

	public static Color decodeColor(String color) {
		int red = 0;
		int green = 0;
		int blue = 0;
		try {
			red = Integer.parseInt(color.substring(1, 3), 16);
			green = Integer.parseInt(color.substring(3, 5), 16);
			blue = Integer.parseInt(color.substring(5), 16);
		} catch (Exception sioobe) {
			// empty on purpose
		}
		return new Color(red, green, blue);
	}

	// helper methods

	/**
	 * Generates a key for an tag/id/class combination and adds the style
	 * attributes to the stylecache.
	 * 
	 * @param attributes
	 *            a Properties object with the tagname and the attributes of the
	 *            tag.
	 * @return a key
	 */
	private String getKey(Properties attributes) {
		String tag = attributes.getProperty(MarkupTags.ITEXT_TAG);
		String id = attributes.getProperty(MarkupTags.HTML_ATTR_CSS_ID);
		String cl = attributes.getProperty(MarkupTags.HTML_ATTR_CSS_CLASS);
		if (id == null) {
			id = "";
		} else {
			id = "#" + id;
		}
		if (cl == null) {
			cl = "";
		} else {
			cl = "." + cl;
		}
		String key = tag + id + cl;
		if (!stylecache.containsKey(key) && key.length() > 0) {
			Properties props = new Properties();
			Properties tagprops = (Properties) get(tag);
			Properties idprops = (Properties) get(id);
			Properties clprops = (Properties) get(cl);
			Properties tagidprops = (Properties) get(tag + id);
			Properties tagclprops = (Properties) get(tag + cl);
			if (tagprops != null)
				props.putAll(tagprops);
			if (idprops != null)
				props.putAll(idprops);
			if (clprops != null)
				props.putAll(clprops);
			if (tagidprops != null)
				props.putAll(tagidprops);
			if (tagclprops != null)
				props.putAll(tagclprops);
			stylecache.put(key, props);
		}
		return key;
	}

	// getting the objects based on the tag and its attributes

	/**
	 * Returns pagebreak information.
	 * 
	 * @param attributes
	 * @return true if a page break is needed before the tag
	 */
	public boolean getPageBreakBefore(Properties attributes) {
		String key = getKey(attributes);
		Properties styleattributes = (Properties) stylecache.get(key);
		if (styleattributes != null
				&& MarkupTags.CSS_VALUE_ALWAYS.equals(styleattributes
						.getProperty(MarkupTags.CSS_KEY_PAGE_BREAK_BEFORE))) {
			return true;
		}
		return false;
	}

	/**
	 * Returns pagebreak information.
	 * 
	 * @param attributes
	 * @return true if a page break is needed after the tag
	 */
	public boolean getPageBreakAfter(Properties attributes) {
		String key = getKey(attributes);
		Properties styleattributes = (Properties) stylecache.get(key);
		if (styleattributes != null
				&& MarkupTags.CSS_VALUE_ALWAYS.equals(styleattributes
						.getProperty(MarkupTags.CSS_KEY_PAGE_BREAK_AFTER))) {
			return true;
		}
		return false;
	}

	/**
	 * Returns an object based on a tag and its attributes.
	 * 
	 * @param attributes
	 *            a Properties object with the tagname and the attributes of the
	 *            tag.
	 * @return an iText object
	 */
	public Element getObject(Properties attributes) {
		String key = getKey(attributes);
		Properties styleattributes = (Properties) stylecache.get(key);
		if (styleattributes != null
				&& MarkupTags.CSS_VALUE_HIDDEN.equals(styleattributes
						.get(MarkupTags.CSS_KEY_VISIBILITY))) {
			return null;
		}
		String display = styleattributes
				.getProperty(MarkupTags.CSS_KEY_DISPLAY);
		Element element = null;
		if (MarkupTags.CSS_VALUE_INLINE.equals(display)) {
			element = retrievePhrase(getFont(attributes), styleattributes);
		} else if (MarkupTags.CSS_VALUE_BLOCK.equals(display)) {
			element = retrieveParagraph(getFont(attributes), styleattributes);
		} else if (MarkupTags.CSS_VALUE_LISTITEM.equals(display)) {
			element = retrieveListItem(getFont(attributes), styleattributes);
		} /* ssteward: dropped in pdftk 1.44:
		  else if (MarkupTags.CSS_VALUE_TABLECELL.equals(display)) {
			element = retrieveTableCell(attributes, styleattributes);
		} else if (MarkupTags.CSS_VALUE_TABLEROW.equals(display)) {
			element = retrieveTableRow(attributes, styleattributes);
		} else if (MarkupTags.CSS_VALUE_TABLE.equals(display)) {
			element = retrieveTable(attributes, styleattributes);
		} */
		return element;
	}

	/**
	 * Returns a font based on the ID and CLASS attributes of a tag.
	 * 
	 * @param attributes
	 *            a Properties object with the tagname and the attributes of the
	 *            tag.
	 * @return an iText Font;
	 */
	public Font getFont(Properties attributes) {
		String key = getKey(attributes);
		Font f = (Font) fontcache.get(key);
		if (f != null) {
			return f;
		} else {
			Properties styleattributes = (Properties) stylecache.get(key);
			f = retrieveFont(styleattributes);
			fontcache.put(key, f);
		}
		return f;
	}

	/**
	 * Returns a rectangle based on the width and height attributes of a tag,
	 * can be overridden by the ID and CLASS attributes.
	 * 
	 * @param attrs
	 *            the attributes that came with the tag
	 * @return an iText Rectangle object
	 */
	public Rectangle getRectangle(Properties attrs) {
		String width = null;
		String height = null;
		String key = getKey(attrs);
		Properties styleattributes = (Properties) stylecache.get(key);
		if (styleattributes != null) {
			width = styleattributes.getProperty(MarkupTags.HTML_ATTR_WIDTH);
			height = styleattributes.getProperty(MarkupTags.HTML_ATTR_HEIGHT);
		}
		if (width == null)
			width = attrs.getProperty(MarkupTags.HTML_ATTR_WIDTH);
		if (height == null)
			height = attrs.getProperty(MarkupTags.HTML_ATTR_HEIGHT);
		if (width == null || height == null)
			return null;
		return new Rectangle(parseLength(width), parseLength(height));
	}

	// retrieving objects based on the styleAttributes

	/**
	 * Retrieves a Phrase based on some style attributes.
	 * 
	 * @param font
	 * @param styleattributes
	 *            a Properties object containing keys and values
	 * @return an iText Phrase object
	 */
	public Element retrievePhrase(Font font, Properties styleattributes) {
		Phrase p = new Phrase("", font);
		if (styleattributes == null)
			return p;
		String leading = styleattributes
				.getProperty(MarkupTags.CSS_KEY_LINEHEIGHT);
		if (leading != null) {
			if (leading.endsWith("%")) {
				p.setLeading(p.font().size() * (parseLength(leading) / 100f));
			} else {
				p.setLeading(parseLength(leading));
			}
		}
		return p;
	}

	/**
	 * Retrieves a Paragraph based on some style attributes.
	 * 
	 * @param font
	 * @param styleattributes
	 *            a Properties object containing keys and values
	 * @return an iText Paragraph object
	 */
	public Element retrieveParagraph(Font font, Properties styleattributes) {
		Paragraph p = new Paragraph((Phrase) retrievePhrase(font,
				styleattributes));
		if (styleattributes == null)
			return p;
		String margin = styleattributes.getProperty(MarkupTags.CSS_KEY_MARGIN);
		float f;
		if (margin != null) {
			f = parseLength(margin);
			p.setIndentationLeft(f);
			p.setIndentationRight(f);
			p.setSpacingBefore(f);
			p.setSpacingAfter(f);
		}
		margin = styleattributes.getProperty(MarkupTags.CSS_KEY_MARGINLEFT);
		if (margin != null) {
			f = parseLength(margin);
			p.setIndentationLeft(f);
		}
		margin = styleattributes.getProperty(MarkupTags.CSS_KEY_MARGINRIGHT);
		if (margin != null) {
			f = parseLength(margin);
			p.setIndentationRight(f);
		}
		margin = styleattributes.getProperty(MarkupTags.CSS_KEY_MARGINTOP);
		if (margin != null) {
			f = parseLength(margin);
			p.setSpacingBefore(f);
		}
		margin = styleattributes.getProperty(MarkupTags.CSS_KEY_MARGINBOTTOM);
		if (margin != null) {
			f = parseLength(margin);
			p.setSpacingAfter(f);
		}
		String align = styleattributes
				.getProperty(MarkupTags.CSS_KEY_TEXTALIGN);
		if (MarkupTags.CSS_VALUE_TEXTALIGNLEFT.equals(align)) {
			p.setAlignment(Element.ALIGN_LEFT);
		} else if (MarkupTags.CSS_VALUE_TEXTALIGNRIGHT.equals(align)) {
			p.setAlignment(Element.ALIGN_RIGHT);
		} else if (MarkupTags.CSS_VALUE_TEXTALIGNCENTER.equals(align)) {
			p.setAlignment(Element.ALIGN_CENTER);
		} else if (MarkupTags.CSS_VALUE_TEXTALIGNJUSTIFY.equals(align)) {
			p.setAlignment(Element.ALIGN_JUSTIFIED);
		}
		return p;
	}

	/**
	 * Gets a table based on the styleattributes.
	 * 
	 * @param attributes
	 * @param styleattributes
	 * @return an iText Table
	 */
    /* ssteward: dropped in 1.44
	private Element retrieveTable(Properties attributes,
			Properties styleattributes) {
		SimpleTable table = new SimpleTable();
		applyBordersColors(table, attributes, styleattributes);
		return table;
	}
    */

	/**
	 * Returns a Cell based on the styleattributes.
	 * 
	 * @param attributes
	 * @param styleattributes
	 * @return an iText Cell
	 */
    /* ssteward: dropped in 1.44
	private Element retrieveTableRow(Properties attributes,
			Properties styleattributes) {
		SimpleCell row = new SimpleCell(SimpleCell.ROW);
		applyBordersColors(row, attributes, styleattributes);
		String width = null;
		if (attributes != null)
			width = attributes.getProperty(MarkupTags.HTML_ATTR_WIDTH);
		if (width == null)
			width = styleattributes.getProperty(MarkupTags.HTML_ATTR_WIDTH);
		if (width != null) {
			if (width.endsWith("%")) {
				row.setWidthpercentage(parseLength(width));
			} else {
				row.setWidth(parseLength(width));
			}
		}
		String margin = styleattributes.getProperty(MarkupTags.CSS_KEY_MARGIN);
		float f;
		if (margin != null) {
			f = parseLength(margin);
			row.setSpacing(f);
		}
		margin = styleattributes.getProperty(MarkupTags.CSS_KEY_MARGINLEFT);
		if (margin != null) {
			f = parseLength(margin);
			row.setSpacing_left(f);
		}
		margin = styleattributes.getProperty(MarkupTags.CSS_KEY_MARGINRIGHT);
		if (margin != null) {
			f = parseLength(margin);
			row.setSpacing_right(f);
		}
		margin = styleattributes.getProperty(MarkupTags.CSS_KEY_MARGINTOP);
		if (margin != null) {
			f = parseLength(margin);
			row.setSpacing_top(f);
		}
		margin = styleattributes.getProperty(MarkupTags.CSS_KEY_MARGINBOTTOM);
		if (margin != null) {
			f = parseLength(margin);
			row.setSpacing_bottom(f);
		}
		String padding = styleattributes.getProperty(MarkupTags.CSS_KEY_PADDING);
		if (padding != null) {
			f = parseLength(padding);
			row.setPadding(f);
		}
		padding = styleattributes.getProperty(MarkupTags.CSS_KEY_PADDINGLEFT);
		if (padding != null) {
			f = parseLength(padding);
			row.setSpacing_left(f);
		}
		padding = styleattributes.getProperty(MarkupTags.CSS_KEY_PADDINGRIGHT);
		if (padding != null) {
			f = parseLength(padding);
			row.setSpacing_right(f);
		}
		padding = styleattributes.getProperty(MarkupTags.CSS_KEY_PADDINGTOP);
		if (padding != null) {
			f = parseLength(padding);
			row.setSpacing_top(f);
		}
		padding = styleattributes.getProperty(MarkupTags.CSS_KEY_PADDINGBOTTOM);
		if (padding != null) {
			f = parseLength(padding);
			row.setSpacing_bottom(f);
		}
		return row;
	}
    */

	/**
	 * Returns a Cell based on the styleattributes.
	 * 
	 * @param attributes
	 * @param styleattributes
	 * @return an iText Cell
	 */
    /* ssteward: dropped in 1.44
	private Element retrieveTableCell(Properties attributes,
			Properties styleattributes) {
		SimpleCell cell = (SimpleCell) retrieveTableRow(attributes,
				styleattributes);
		cell.setCellgroup(false);
		return cell;
	}
    */

	/**
	 * Returns a ListItem based on the styleattributes.
	 * 
	 * @param font
	 * @param styleattributes
	 * @return an iText ListItem
	 */
	private Element retrieveListItem(Font font, Properties styleattributes) {
		ListItem li = new ListItem();
		return li;
	}

	/**
	 * Applies colors to a Rectangle object.
	 * @param rect
	 * @param attributes
	 * @param styleattributes
	 */
    /* ssteward omit:
	private void applyBordersColors(Rectangle rect, Properties attributes,	Properties styleattributes) {
		String s = styleattributes.getProperty(MarkupTags.CSS_KEY_BORDERWIDTH);
		float f;
		if (s != null) {
			f = parseLength(s);
			rect.setBorderWidth(f);
		}
		s = styleattributes.getProperty(MarkupTags.CSS_KEY_BORDERWIDTHLEFT);
		if (s != null) {
			f = parseLength(s);
			rect.setBorderWidthLeft(f);
		}
		s = styleattributes.getProperty(MarkupTags.CSS_KEY_BORDERWIDTHRIGHT);
		if (s != null) {
			f = parseLength(s);
			rect.setBorderWidthRight(f);
		}
		s = styleattributes.getProperty(MarkupTags.CSS_KEY_BORDERWIDTHTOP);
		if (s != null) {
			f = parseLength(s);
			rect.setBorderWidthTop(f);
		}
		s = styleattributes.getProperty(MarkupTags.CSS_KEY_BORDERWIDTHBOTTOM);
		if (s != null) {
			f = parseLength(s);
			rect.setBorderWidthBottom(f);
		}
		s = styleattributes.getProperty(MarkupTags.CSS_KEY_BORDERCOLOR);
		if (s != null) {
			rect.setBorderColor(decodeColor(s));
		}
	}
    */

	/**
	 * Retrieves a font from the FontFactory based on some style attributes.
	 * Looks for the font-family, font-size, font-weight, font-style and color.
	 * Takes the default encoding and embedded value.
	 * 
	 * @param styleAttributes
	 *            a Properties object containing keys and values
	 * @return an iText Font object
	 */

	public Font retrieveFont(Properties styleAttributes) {
		String fontname = null;
		String encoding = FontFactory.defaultEncoding;
		boolean embedded = FontFactory.defaultEmbedding;
		float size = Font.UNDEFINED;
		int style = Font.NORMAL;
		Color color = null;
		String value = (String) styleAttributes
				.get(MarkupTags.CSS_KEY_FONTFAMILY);
		if (value != null) {
			if (value.indexOf(",") == -1) {
				fontname = value.trim();
			} else {
				String tmp;
				while (value.indexOf(",") != -1) {
					tmp = value.substring(0, value.indexOf(",")).trim();
					if (FontFactory.isRegistered(tmp)) {
						fontname = tmp;
						break;
					} else {
						value = value.substring(value.indexOf(",") + 1);
					}
				}
			}
		}
		if ((value = (String) styleAttributes.get(MarkupTags.CSS_KEY_FONTSIZE)) != null) {
			size = MarkupParser.parseLength(value);
		}
		if ((value = (String) styleAttributes
				.get(MarkupTags.CSS_KEY_FONTWEIGHT)) != null) {
			style |= Font.getStyleValue(value);
		}
		if ((value = (String) styleAttributes.get(MarkupTags.CSS_KEY_FONTSTYLE)) != null) {
			style |= Font.getStyleValue(value);
		}
		if ((value = (String) styleAttributes.get(MarkupTags.CSS_KEY_COLOR)) != null) {
			color = MarkupParser.decodeColor(value);
		}
		return FontFactory.getFont(fontname, encoding, embedded, size, style,
				color);
	}
} /*
 * $Id: MarkupTags.java,v 1.50 2005/05/03 14:44:38 blowagie Exp $
 * $Name:  $
 *
 * Copyright 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.markup;

/**
 * A class that contains all the possible tagnames and their attributes.
 */

public class MarkupTags {
	
	// iText specific
	
	/** the key for any tag */
	public static final String ITEXT_TAG = "tag";

	// HTML tags

	/** the markup for the body part of a file */
	public static final String HTML_TAG_BODY = "body";
	
	/** The DIV tag. */
	public static final String HTML_TAG_DIV = "div";

	/** This is a possible HTML-tag. */
	public static final String HTML_TAG_LINK = "link";

	/** The SPAN tag. */
	public static final String HTML_TAG_SPAN = "span";

	// HTML attributes

	/** the height attribute. */
	public static final String HTML_ATTR_HEIGHT = "height";

	/** the hyperlink reference attribute. */
	public static final String HTML_ATTR_HREF = "href";

	/** This is a possible HTML attribute for the LINK tag. */
	public static final String HTML_ATTR_REL = "rel";

	/** This is used for inline css style information */
	public static final String HTML_ATTR_STYLE = "style";

	/** This is a possible HTML attribute for the LINK tag. */
	public static final String HTML_ATTR_TYPE = "type";

	/** This is a possible HTML attribute. */
	public static final String HTML_ATTR_STYLESHEET = "stylesheet";

	/** the width attribute. */
	public static final String HTML_ATTR_WIDTH = "width";

	/** attribute for specifying externally defined CSS class */
	public static final String HTML_ATTR_CSS_CLASS = "class";

	/** The ID attribute. */
	public static final String HTML_ATTR_CSS_ID = "id";

	// HTML values
	
	/** This is a possible value for the language attribute (SCRIPT tag). */
	public static final String HTML_VALUE_JAVASCRIPT = "text/javascript";
	
	/** This is a possible HTML attribute for the LINK tag. */
	public static final String HTML_VALUE_CSS = "text/css";

	// CSS keys

	/** the CSS tag for background color */
	public static final String CSS_KEY_BGCOLOR = "background-color";

	/** the CSS tag for text color */
	public static final String CSS_KEY_COLOR = "color";

	/** CSS key that indicate the way something has to be displayed */
	public static final String CSS_KEY_DISPLAY = "display";

	/** the CSS tag for the font family */
	public static final String CSS_KEY_FONTFAMILY = "font-family";

	/** the CSS tag for the font size */
	public static final String CSS_KEY_FONTSIZE = "font-size";

	/** the CSS tag for the font style */
	public static final String CSS_KEY_FONTSTYLE = "font-style";

	/** the CSS tag for the font weight */
	public static final String CSS_KEY_FONTWEIGHT = "font-weight";

	/** the CSS tag for text decorations */
	public static final String CSS_KEY_LINEHEIGHT = "line-height";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_MARGIN = "margin";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_MARGINLEFT = "margin-left";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_MARGINRIGHT = "margin-right";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_MARGINTOP = "margin-top";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_MARGINBOTTOM = "margin-bottom";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_PADDING = "padding";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_PADDINGLEFT = "padding-left";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_PADDINGRIGHT = "padding-right";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_PADDINGTOP = "padding-top";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_PADDINGBOTTOM = "padding-bottom";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_BORDERCOLOR = "border-color";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_BORDERWIDTH = "border-width";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_BORDERWIDTHLEFT = "border-left-width";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_BORDERWIDTHRIGHT = "border-right-width";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_BORDERWIDTHTOP = "border-top-width";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_BORDERWIDTHBOTTOM = "border-bottom-width";

	/** the CSS tag for adding a page break when the document is printed */
	public static final String CSS_KEY_PAGE_BREAK_AFTER = "page-break-after";

	/** the CSS tag for adding a page break when the document is printed */
	public static final String CSS_KEY_PAGE_BREAK_BEFORE = "page-break-before";

	/** the CSS tag for the horizontal alignment of an object */
	public static final String CSS_KEY_TEXTALIGN = "text-align";

	/** the CSS tag for text decorations */
	public static final String CSS_KEY_TEXTDECORATION = "text-decoration";

	/** the CSS tag for text decorations */
	public static final String CSS_KEY_VERTICALALIGN = "vertical-align";

	/** the CSS tag for the visibility of objects */
	public static final String CSS_KEY_VISIBILITY = "visibility";

	// CSS values

	/** value for the CSS tag for adding a page break when the document is printed */
	public static final String CSS_VALUE_ALWAYS = "always";

	/** A possible value for the DISPLAY key */
	public static final String CSS_VALUE_BLOCK = "block";

	/** a CSS value for text font weight */
	public static final String CSS_VALUE_BOLD = "bold";

	/** the value if you want to hide objects. */
	public static final String CSS_VALUE_HIDDEN = "hidden";

	/** A possible value for the DISPLAY key */
	public static final String CSS_VALUE_INLINE = "inline";
	
	/** a CSS value for text font style */
	public static final String CSS_VALUE_ITALIC = "italic";

	/** a CSS value for text decoration */
	public static final String CSS_VALUE_LINETHROUGH = "line-through";

	/** A possible value for the DISPLAY key */
	public static final String CSS_VALUE_LISTITEM = "list-item";
	
	/** a CSS value */
	public static final String CSS_VALUE_NONE = "none";

	/** a CSS value */
	public static final String CSS_VALUE_NORMAL = "normal";

	/** a CSS value for text font style */
	public static final String CSS_VALUE_OBLIQUE = "oblique";

	/** A possible value for the DISPLAY key */
	public static final String CSS_VALUE_TABLE = "table";

	/** A possible value for the DISPLAY key */
	public static final String CSS_VALUE_TABLEROW = "table-row";

	/** A possible value for the DISPLAY key */
	public static final String CSS_VALUE_TABLECELL = "table-cell";

	/** the CSS value for a horizontal alignment of an object */
	public static final String CSS_VALUE_TEXTALIGNLEFT = "left";

	/** the CSS value for a horizontal alignment of an object */
	public static final String CSS_VALUE_TEXTALIGNRIGHT = "right";

	/** the CSS value for a horizontal alignment of an object */
	public static final String CSS_VALUE_TEXTALIGNCENTER = "center";

	/** the CSS value for a horizontal alignment of an object */
	public static final String CSS_VALUE_TEXTALIGNJUSTIFY = "justify";

	/** a CSS value for text decoration */
	public static final String CSS_VALUE_UNDERLINE = "underline";

} /*
 * $Id$
 *
 * Copyright 2006 Paulo Soares
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */
package pdftk.com.lowagie.text.pdf.crypto;

import org.bouncycastle.crypto.BlockCipher;
import org.bouncycastle.crypto.engines.AESFastEngine;
import org.bouncycastle.crypto.modes.CBCBlockCipher;
import org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.crypto.params.ParametersWithIV;

/**
 * Creates an AES Cipher with CBC and padding PKCS5/7.
 * @author Paulo Soares (psoares@consiste.pt)
 */
public class AESCipher {
    private PaddedBufferedBlockCipher bp;
    
    /** Creates a new instance of AESCipher */
    public AESCipher(boolean forEncryption, byte[] key, byte[] iv) {
        BlockCipher aes = new AESFastEngine();
        BlockCipher cbc = new CBCBlockCipher(aes);
        bp = new PaddedBufferedBlockCipher(cbc);
        KeyParameter kp = new KeyParameter(key);
        ParametersWithIV piv = new ParametersWithIV(kp, iv);
        bp.init(forEncryption, piv);
    }
    
    public byte[] update(byte[] inp, int inpOff, int inpLen) {
        int neededLen = bp.getUpdateOutputSize(inpLen);
        byte[] outp = null;
        if (neededLen > 0)
            outp = new byte[neededLen];
        else
            neededLen = 0;
        bp.processBytes(inp, inpOff, inpLen, outp, 0);
        return outp;
    }
    
    public byte[] doFinal() {
        int neededLen = bp.getOutputSize(0);
        byte[] outp = new byte[neededLen];
        int n = 0;
        try {
            n = bp.doFinal(outp, 0);
        } catch (Exception ex) {
            return outp;
        }
        if (n != outp.length) {
            byte[] outp2 = new byte[n];
            System.arraycopy(outp, 0, outp2, 0, n);
            return outp2;
        }
        else
            return outp;
    }
    
}
 /*
 * $Id$
 *
 * Copyright 2006 Paulo Soares
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */
package pdftk.com.lowagie.text.pdf.crypto;

public class ARCFOUREncryption {
    private byte state[] = new byte[256];
    private int x;
    private int y;

    /** Creates a new instance of ARCFOUREncryption */
    public ARCFOUREncryption() {
    }
    
    public void prepareARCFOURKey(byte key[]) {
        prepareARCFOURKey(key, 0, key.length);
    }

    public void prepareARCFOURKey(byte key[], int off, int len) {
        int index1 = 0;
        int index2 = 0;
        for (int k = 0; k < 256; ++k)
            state[k] = (byte)k;
        x = 0;
        y = 0;
        byte tmp;
        for (int k = 0; k < 256; ++k) {
            index2 = (key[index1 + off] + state[k] + index2) & 255;
            tmp = state[k];
            state[k] = state[index2];
            state[index2] = tmp;
            index1 = (index1 + 1) % len;
        }
    }

    public void encryptARCFOUR(byte dataIn[], int off, int len, byte dataOut[], int offOut) {
        int length = len + off;
        byte tmp;
        for (int k = off; k < length; ++k) {
            x = (x + 1) & 255;
            y = (state[x] + y) & 255;
            tmp = state[x];
            state[x] = state[y];
            state[y] = tmp;
            dataOut[k - off + offOut] = (byte)(dataIn[k] ^ state[(state[x] + state[y]) & 255]);
        }
    }

    public void encryptARCFOUR(byte data[], int off, int len) {
        encryptARCFOUR(data, off, len, data, off);
    }

    public void encryptARCFOUR(byte dataIn[], byte dataOut[]) {
        encryptARCFOUR(dataIn, 0, dataIn.length, dataOut, 0);
    }

    public void encryptARCFOUR(byte data[]) {
        encryptARCFOUR(data, 0, data.length, data, 0);
    }   
} /*
 * $Id$
 *
 * Copyright 2006 Paulo Soares
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */
package pdftk.com.lowagie.text.pdf.crypto;

/**
 * An initialization vector generator for a CBC block encryption. It's a random generator based on ARCFOUR.
 * @author Paulo Soares (psoares@consiste.pt)
 */
public final class IVGenerator {
    
    private static ARCFOUREncryption arcfour;
    
    static {
        arcfour = new ARCFOUREncryption();
        long time = System.currentTimeMillis();
        long mem = Runtime.getRuntime().freeMemory();
        String s = time + "+" + mem;
        arcfour.prepareARCFOURKey(s.getBytes());
    }
    
    /** Creates a new instance of IVGenerator */
    private IVGenerator() {
    }
    
    /**
     * Gets a 16 byte random initialization vector.
     * @return a 16 byte random initialization vector
     */
    public static byte[] getIV() {
        return getIV(16);
    }
    
    /**
     * Gets a random initialization vector.
     * @param len the length of the initialization vector
     * @return a random initialization vector
     */
    public static byte[] getIV(int len) {
        byte[] b = new byte[len];
        synchronized (arcfour) {
            arcfour.encryptARCFOUR(b);
        }
        return b;
    }    
} /*
 * Copyright 2004 by Paulo Soares.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */
package pdftk.com.lowagie.text.pdf.fonts;

/**
 * A class to facilitate the loading of resources
 *
 * @author Paulo Soares (psoares@consiste.pt)
 */
public class FontsResourceAnchor {
    
    /**
     * Creates a FontsResourceAnchor
     */
    public FontsResourceAnchor() {
    }
    
}
 /*
 * $Id$
 *
 * Copyright 2006 Bruno Lowagie
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf.interfaces;

import pdftk.com.lowagie.text.pdf.PdfAcroForm;
import pdftk.com.lowagie.text.pdf.PdfAnnotation;
import pdftk.com.lowagie.text.pdf.PdfFormField;

public interface PdfAnnotations {

    /**
     * Use this methods to get the AcroForm object.
     * Use this method only if you know what you're doing
     * @return the PdfAcroform object of the PdfDocument
     */
    public PdfAcroForm getAcroForm();
    
    /**
     * Use this methods to add a <CODE>PdfAnnotation</CODE> or a <CODE>PdfFormField</CODE>
     * to the document. Only the top parent of a <CODE>PdfFormField</CODE>
     * needs to be added.
     * @param annot the <CODE>PdfAnnotation</CODE> or the <CODE>PdfFormField</CODE> to add
     */
    public void addAnnotation(PdfAnnotation annot);
    /**
     * Use this method to adds the <CODE>PdfAnnotation</CODE>
     * to the calculation order array.
     * @param annot the <CODE>PdfAnnotation</CODE> to be added
     */
    public void addCalculationOrder(PdfFormField annot);
    
    /**
     * Use this method to set the signature flags.
     * @param f the flags. This flags are ORed with current ones
     */
    public void setSigFlags(int f);
}
 /*
 * $Id$
 *
 * Copyright 2006 Bruno Lowagie
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf.interfaces;

import pdftk.com.lowagie.text.DocumentException;
import pdftk.com.lowagie.text.pdf.PdfAction;
import pdftk.com.lowagie.text.pdf.PdfName;

/**
 * A PDF document can have an open action and other additional actions.
 */

public interface PdfDocumentActions {

    /**
     * When the document opens it will jump to the destination with
     * this name.
     * @param name the name of the destination to jump to
     */
    public void setOpenAction(String name);
    
    /**
     * When the document opens this <CODE>action</CODE> will be
     * invoked.
     * @param action the action to be invoked
     */
    public void setOpenAction(PdfAction action);
    
    /**
     * Additional-actions defining the actions to be taken in
     * response to various trigger events affecting the document
     * as a whole. The actions types allowed are: <CODE>DOCUMENT_CLOSE</CODE>,
     * <CODE>WILL_SAVE</CODE>, <CODE>DID_SAVE</CODE>, <CODE>WILL_PRINT</CODE>
     * and <CODE>DID_PRINT</CODE>.
     *
     * @param actionType the action type
     * @param action the action to execute in response to the trigger
     * @throws DocumentException on invalid action type
     */
    public void setAdditionalAction(PdfName actionType, PdfAction action) throws DocumentException;

} /*
 * $Id$
 *
 * Copyright 2006 Bruno Lowagie
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf.interfaces;

import java.security.cert.Certificate;

import pdftk.com.lowagie.text.DocumentException;

/**
 * Encryption settings are described in section 3.5 (more specifically
 * section 3.5.2) of the PDF Reference 1.7.
 * They are explained in section 3.3.3 of the book 'iText in Action'.
 * The values of the different  preferences were originally stored
 * in class PdfWriter, but they have been moved to this separate interface
 * for reasons of convenience.
 */

public interface PdfEncryptionSettings {

    
    /**
     * Sets the encryption options for this document. The userPassword and the
     * ownerPassword can be null or have zero length. In this case the ownerPassword
     * is replaced by a random string. The open permissions for the document can be
     * AllowPrinting, AllowModifyContents, AllowCopy, AllowModifyAnnotations,
     * AllowFillIn, AllowScreenReaders, AllowAssembly and AllowDegradedPrinting.
     * The permissions can be combined by ORing them.
     * @param userPassword the user password. Can be null or empty
     * @param ownerPassword the owner password. Can be null or empty
     * @param permissions the user permissions
     * @param encryptionType the type of encryption. It can be one of STANDARD_ENCRYPTION_40, STANDARD_ENCRYPTION_128 or ENCRYPTION_AES128.
     * Optionally DO_NOT_ENCRYPT_METADATA can be ored to output the metadata in cleartext
     * @throws DocumentException if the document is already open
     */
    public void setEncryption(byte userPassword[], byte ownerPassword[], int permissions, int encryptionType) throws DocumentException;

    /**
     * Sets the certificate encryption options for this document. An array of one or more public certificates
     * must be provided together with an array of the same size for the permissions for each certificate.
     *  The open permissions for the document can be
     *  AllowPrinting, AllowModifyContents, AllowCopy, AllowModifyAnnotations,
     *  AllowFillIn, AllowScreenReaders, AllowAssembly and AllowDegradedPrinting.
     *  The permissions can be combined by ORing them.
     * Optionally DO_NOT_ENCRYPT_METADATA can be ored to output the metadata in cleartext
     * @param certs the public certificates to be used for the encryption
     * @param permissions the user permissions for each of the certificates
     * @param encryptionType the type of encryption. It can be one of STANDARD_ENCRYPTION_40, STANDARD_ENCRYPTION_128 or ENCRYPTION_AES128.
     * @throws DocumentException if the document is already open
     */
    public void setEncryption(Certificate[] certs, int[] permissions, int encryptionType) throws DocumentException;
} /*
 * $Id$
 *
 * Copyright 2006 Bruno Lowagie
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf.interfaces;

import pdftk.com.lowagie.text.DocumentException;
import pdftk.com.lowagie.text.pdf.PdfAction;
import pdftk.com.lowagie.text.pdf.PdfName;
import pdftk.com.lowagie.text.pdf.PdfTransition;

/**
 * A PDF page can have an open and/or close action.
 */

public interface PdfPageActions {
    
    /**
     * Sets the open and close page additional action.
     * @param actionType the action type. It can be <CODE>PdfWriter.PAGE_OPEN</CODE>
     * or <CODE>PdfWriter.PAGE_CLOSE</CODE>
     * @param action the action to perform
     * @throws DocumentException if the action type is invalid
     */    
    public void setPageAction(PdfName actionType, PdfAction action) throws DocumentException;

    /**
     * Sets the display duration for the page (for presentations)
     * @param seconds   the number of seconds to display the page
     */
    public void setDuration(int seconds);
    
    /**
     * Sets the transition for the page
     * @param transition   the Transition object
     */
    public void setTransition(PdfTransition transition);
}
 /*
 * $Id$
 *
 * Copyright 2006 Bruno Lowagie
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf.interfaces;

public interface PdfRunDirection {
    
    /** Sets the run direction. This is only used as a placeholder
     * as it does not affect anything.
     * @param runDirection the run direction
     */    
    public void setRunDirection(int runDirection);
    
    /** Gets the run direction.
     * @return the run direction
     */    
    public int getRunDirection();
}
 /*
 * $Id$
 *
 * Copyright 2006 Bruno Lowagie
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf.interfaces;

import pdftk.com.lowagie.text.pdf.PdfDeveloperExtension;
import pdftk.com.lowagie.text.pdf.PdfName;

/**
 * The PDF version is described in the PDF Reference 1.7 p92
 * (about the PDF Header) and page 139 (the version entry in
 * the Catalog). You'll also find info about setting the version
 * in the book 'iText in Action' sections 2.1.3 (PDF Header)
 * and 3.3 (Version history).
 */

public interface PdfVersion {
    
    /**
	 * If the PDF Header hasn't been written yet,
	 * this changes the version as it will appear in the PDF Header.
	 * If the PDF header was already written to the OutputStream,
	 * this changes the version as it will appear in the Catalog.
	 * @param version	a character representing the PDF version
	 */
	public void setPdfVersion(char version);
    /**
	 * If the PDF Header hasn't been written yet,
	 * this changes the version as it will appear in the PDF Header,
	 * but only if the parameter refers to a higher version.
	 * If the PDF header was already written to the OutputStream,
	 * this changes the version as it will appear in the Catalog.
	 * @param version	a character representing the PDF version
	 */
	public void setAtLeastPdfVersion(char version);
	/**
	 * Sets the PDF version as it will appear in the Catalog.
	 * Note that this only has effect if you use a later version
	 * than the one that appears in the header; this method
	 * ignores the parameter if you try to set a lower version.
	 * @param version	the PDF name that will be used for the Version key in the catalog
	 */
	public void setPdfVersion(PdfName version);
	/**
	 * Adds a developer extension to the Extensions dictionary
	 * in the Catalog.
	 * @param de	an object that contains the extensions prefix and dictionary
	 * @since	2.1.6
	 */
	public void addDeveloperExtension(PdfDeveloperExtension de);
} /*
 * $Id$
 *
 * Copyright 2006 Bruno Lowagie
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf.interfaces;

import pdftk.com.lowagie.text.pdf.PdfName;
import pdftk.com.lowagie.text.pdf.PdfObject;

/**
 * Viewer preferences are described in section 3.6.1 and 8.1 of the
 * PDF Reference 1.7 (Table 3.25 on p139-142 and Table 8.1 on p579-581).
 * They are explained in section 13.1 of the book 'iText in Action'.
 * The values of the different  preferences were originally stored
 * in class PdfWriter, but they have been moved to this separate interface
 * for reasons of convenience.
 */

public interface PdfViewerPreferences {	
		
    /**
     * Sets the page layout and page mode preferences by ORing one or two of these constants.
     * <p>
     * <ul>
     * <li>The page layout to be used when the document is opened (choose one).
     *   <ul>
     *   <li><b>PAGE_LAYOUT_SINGLE_PAGE</b> - Display one page at a time. (default)
     *   <li><b>PAGE_LAYOUT_ONE_COLUMN</b> - Display the pages in one column.
     *   <li><b>PAGE_LAYOUT_TWO_COLUMN_LEFT</b> - Display the pages in two columns, with
     *       oddnumbered pages on the left.
     *   <li><b>PAGE_LAYOUT_TWO_COLUMN_RIGHT</b> - Display the pages in two columns, with
     *       oddnumbered pages on the right.
     *   <li><b>PAGE_LAYOUT_TWO_PAGE_LEFT</b> - Display the pages two at a time, with
     *       oddnumbered pages on the left.
     *   <li><b>PAGE_LAYOUT_TWO_PAGE_RIGHT</b> - Display the pages two at a time, with
     *       oddnumbered pages on the right.
     *   </ul>
     * <li>The page mode how the document should be displayed
     *     when opened (choose one).
     *   <ul>
     *   <li><b>PAGE_MODE_USE_NONE</b> - Neither document outline nor thumbnail images visible. (default)
     *   <li><b>PAGE_MODE_USE_OUTLINES</b> - Document outline visible.
     *   <li><b>PAGE_MODE_USE_THUMBS</b> - Thumbnail images visible.
     *   <li><b>PAGE_MODE_FULL_SCREEN</b> - Full-screen mode, with no menu bar, window
     *       controls, or any other window visible.
     *   <li><b>PAGE_MODE_USE_OC</b> - Optional content group panel visible
     *   <li><b>PAGE_MODE_USE_ATTACHMENTS</b> - Attachments panel visible
     *   </ul>
     * </ul>
     * For backward compatibility these values are also supported,
     * but it's better to use method <code>addViewerPreference(key, value)</code>
     * if you want to change the following preferences:
     * <ul>
     * <li><b>HIDE_TOOLBAR</b> - A flag specifying whether to hide the viewer application's tool
     *     bars when the document is active.
     * <li><b>HIDE_MENUBAR</b> - A flag specifying whether to hide the viewer application's
     *     menu bar when the document is active.
     * <li><b>HIDE_WINDOW_UI</b> - A flag specifying whether to hide user interface elements in
     *     the document's window (such as scroll bars and navigation controls),
     *     leaving only the document's contents displayed.
     * <li><b>FIT_WINDOW</b> - A flag specifying whether to resize the document's window to
     *     fit the size of the first displayed page.
     * <li><b>CENTER_WINDOW</b> - A flag specifying whether to position the document's window
     *     in the center of the screen.
     * <li><b>DISPLAY_DOC_TITLE</b> - A flag specifying whether to display the document's title
     *     in the top bar.
     * <li>The predominant reading order for text. This entry has no direct effect on the
     *     document's contents or page numbering, but can be used to determine the relative
     *     positioning of pages when displayed side by side or printed <i>n-up</i> (choose one).
     *   <ul>
     *   <li><b>DIRECTION_L2R</b> - Left to right
     *   <li><b>DIRECTION_R2L</b> - Right to left (including vertical writing systems such as
     *       Chinese, Japanese, and Korean)
     *   </ul>
     * <li>The document's page mode, specifying how to display the
     *     document on exiting full-screen mode. It is meaningful only
     *     if the page mode is <b>PageModeFullScreen</b> (choose one).
     *   <ul>
     *   <li><b>NON_FULL_SCREEN_PAGE_MODE_USE_NONE</b> - Neither document outline nor thumbnail images
     *       visible
     *   <li><b>NON_FULL_SCREEN_PAGE_MODE_USE_OUTLINES</b> - Document outline visible
     *   <li><b>NON_FULL_SCREEN_PAGE_MODE_USE_THUMBS</b> - Thumbnail images visible
     *   <li><b>NON_FULL_SCREEN_PAGE_MODE_USE_OC</b> - Optional content group panel visible
     *   </ul>
     * <li><b>PRINT_SCALING_NONE</b> - Indicates that the print dialog should reflect no page scaling.
     * </ul>
     * @param preferences the viewer preferences
	 * @see PdfViewerPreferences#addViewerPreference
     */
    public void setViewerPreferences(int preferences);
    
    /**
     * Adds a viewer preference.
     * <ul>
     * <li>In case the key is one of these values:
     * 		<ul>
     * 			<li>PdfName.<b>HIDETOOLBAR</b>
     * 			<li>PdfName.<b>HIDEMENUBAR</b>
     * 			<li>PdfName.<b>HIDEWINDOWUI</b>
     * 			<li>PdfName.<b>FITWINDOW</b>
     * 			<li>PdfName.<b>CENTERWINDOW</b>
     * 			<li>PdfName.<b>DISPLAYDOCTITLE</b>
     * 		</ul>
     * The value must be a of type PdfBoolean (true or false).
     * <li>In case the key is PdfName.<b>NONFULLSCREENPAGEMODE</b>,
     * the value must be one of these names:
     * 		<ul>
     * 			<li>PdfName.<b>USENONE</b>
     * 			<li>PdfName.<b>USEOUTLINES</b>
     * 			<li>PdfName.<b>USETHUMBS</b>
     * 			<li>PdfName.<b>USEOC</b>
     * 		</ul>
     * <li>In case the key is PdfName.DIRECTION,
     * the value must be one of these names:
     * 		<ul>
     * 			<li>PdfName.<b>L2R</b>
     * 			<li>PdfName.<b>R2L</b>
     * 		</ul>
     * <li>In case the key is one of these values:
     * 		<ul>
     * 			<li>PdfName.<b>VIEWAREA</b>
     * 			<li>PdfName.<b>VIEWCLIP</b>
     * 			<li>PdfName.<b>PRINTAREA</b>
     * 			<li>PdfName.<b>PRINTCLIP</b>
     * 		</ul>
     * 	The value must be one of these names:
     * 		<ul>
     * 			<li>PdfName.<b>MEDIABOX</b>
     * 			<li>PdfName.<b>CROPBOX</b>
     * 			<li>PdfName.<b>BLEEDBOX</b>
     * 			<li>PdfName.<b>TRIMBOX</b>
     * 			<li>PdfName.<b>ARTBOX</b>
     * 		</ul>
     * <li>In case the key is PdfName.<b>PRINTSCALING</b>, the value can be
     * 		<ul>
     * 			<li>PdfName.<b>APPDEFAULT</b>
     * 			<li>PdfName.<b>NONE</b>
     * 		</ul>
     * <li>In case the key is PdfName.<b>DUPLEX</b>, the value can be:
     * 		<ul>
     * 			<li>PdfName.<b>SIMPLEX</b>
     * 			<li>PdfName.<b>DUPLEXFLIPSHORTEDGE</b>
     * 			<li>PdfName.<b>DUPLEXFLIPLONGEDGE</b>
     * 		</ul>
     * <li>In case the key is PdfName.<b>PICKTRAYBYPDFSIZE</b>, the value must be of type PdfBoolean.
     * <li>In case the key is PdfName.<b>PRINTPAGERANGE</b>, the value must be of type PdfArray.
     * <li>In case the key is PdfName.<b>NUMCOPIES</b>, the value must be of type PdfNumber.
     * <ul>
     * </ul>
     * @param key	the name of the viewer preference
     * @param value	the value of the viewer preference
	 * @see PdfViewerPreferences#setViewerPreferences
     */
    public void addViewerPreference(PdfName key, PdfObject value);    	
} /*
 * $Id$
 *
 * Copyright 2006 Bruno Lowagie
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf.interfaces;

public interface PdfXConformance {
    
    /**
     * Sets the PDF/X conformance level.
     * Allowed values are PDFX1A2001, PDFX32002, PDFA1A and PDFA1B.
     * It must be called before opening the document.
     * @param pdfxConformance the conformance level
     */    
    public void setPDFXConformance(int pdfxConformance);

	/**
	 * Getter for the PDF/X Conformance value.
	 * @return the pdfxConformance
	 */
	public int getPDFXConformance();
	
    /**
     * Checks if the PDF/X Conformance is necessary.
     * @return true if the PDF has to be in conformance with any of the PDF/X specifications
     */
    public boolean isPdfX();
}
 /*
 * $Id$
 *
 * Copyright 2006 Bruno Lowagie
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf.internal;

import java.io.IOException;

import pdftk.com.lowagie.text.DocWriter;
import pdftk.com.lowagie.text.pdf.OutputStreamCounter;
import pdftk.com.lowagie.text.pdf.PdfDeveloperExtension;
import pdftk.com.lowagie.text.pdf.PdfDictionary;
import pdftk.com.lowagie.text.pdf.PdfName;
import pdftk.com.lowagie.text.pdf.PdfWriter;
import pdftk.com.lowagie.text.pdf.interfaces.PdfVersion;

/**
 * Stores the PDF version information,
 * knows how to write a PDF Header,
 * and how to add the version to the catalog (if necessary).
 */

public class PdfVersionImp implements PdfVersion {
    
    /** Contains different strings that are part of the header. */
    public static final byte[][] HEADER = {
    	DocWriter.getISOBytes("\n"),
    	DocWriter.getISOBytes("%PDF-"),
    	DocWriter.getISOBytes("\n%\u00e2\u00e3\u00cf\u00d3\n")
    };
    
	/** Indicates if the header was already written. */
	protected boolean headerWasWritten = false;
	/** Indicates if we are working in append mode. */
	protected boolean appendmode = false;
	/** The version that was or will be written to the header. */
	protected char header_version = PdfWriter.VERSION_1_4;
	/** The version that will be written to the catalog. */
	protected PdfName catalog_version = null;
	/**
	 * The extensions dictionary.
	 * @since	2.1.6
	 */
	protected PdfDictionary extensions = null;
	
	/**
	 * @see pdftk.com.lowagie.text.pdf.interfaces.PdfVersion#setPdfVersion(char)
	 */
	public void setPdfVersion(char version) {
		if (headerWasWritten || appendmode) {
			setPdfVersion(getVersionAsName(version));
		}
		else {
			this.header_version = version;
		}
	}
	
	/**
	 * @see pdftk.com.lowagie.text.pdf.interfaces.PdfVersion#setAtLeastPdfVersion(char)
	 */
	public void setAtLeastPdfVersion(char version) {
		if (version > header_version) {
			setPdfVersion(version);
		}
	}
	
	/**
	 * @see pdftk.com.lowagie.text.pdf.interfaces.PdfVersion#setPdfVersion(pdftk.com.lowagie.text.pdf.PdfName)
	 */
	public void setPdfVersion(PdfName version) {
		if (catalog_version == null || catalog_version.compareTo(version) < 0) {
			this.catalog_version = version;
		}
	}
	
	/**
	 * Sets the append mode.
	 */
	public void setAppendmode(boolean appendmode) {
		this.appendmode = appendmode;
	}
	
	/**
	 * Writes the header to the OutputStreamCounter.
	 * @throws IOException 
	 */
	public void writeHeader(OutputStreamCounter os) throws IOException {
		if (appendmode) {
			os.write(HEADER[0]);
		}
		else {
			os.write(HEADER[1]);
			os.write(getVersionAsByteArray(header_version));
			os.write(HEADER[2]);
			headerWasWritten = true;
		}
	}
	
	/**
	 * Returns the PDF version as a name.
	 * @param version	the version character.
	 */
	public PdfName getVersionAsName(char version) {
		switch(version) {
		case PdfWriter.VERSION_1_2:
			return PdfWriter.PDF_VERSION_1_2;
		case PdfWriter.VERSION_1_3:
			return PdfWriter.PDF_VERSION_1_3;
		case PdfWriter.VERSION_1_4:
			return PdfWriter.PDF_VERSION_1_4;
		case PdfWriter.VERSION_1_5:
			return PdfWriter.PDF_VERSION_1_5;
		case PdfWriter.VERSION_1_6:
			return PdfWriter.PDF_VERSION_1_6;
		case PdfWriter.VERSION_1_7:
			return PdfWriter.PDF_VERSION_1_7;
		default:
			return PdfWriter.PDF_VERSION_1_4;
		}
	}
	
	/**
	 * Returns the version as a byte[].
	 * @param version the version character
	 */
	public byte[] getVersionAsByteArray(char version) {
		return DocWriter.getISOBytes(getVersionAsName(version).toString().substring(1));
	}

	/** Adds the version to the Catalog dictionary. */
	public void addToCatalog(PdfDictionary catalog) {
		if(catalog_version != null) {
			catalog.put(PdfName.VERSION, catalog_version);
		}
		if (extensions != null) {
			catalog.put(PdfName.EXTENSIONS, extensions);
		}
	}

	/**
	 * @see pdftk.com.lowagie.text.pdf.interfaces.PdfVersion#addDeveloperExtension(pdftk.com.lowagie.text.pdf.PdfDeveloperExtension)
	 * @since	2.1.6
	 */
	public void addDeveloperExtension(PdfDeveloperExtension de) {
		if (extensions == null) {
			extensions = new PdfDictionary();
		}
		else {
			PdfDictionary extension = extensions.getAsDict(de.getPrefix());
			if (extension != null) {
				int diff = de.getBaseversion().compareTo(extension.getAsName(PdfName.BASEVERSION));
				if (diff < 0)
					return;
				diff = de.getExtensionLevel() - extension.getAsNumber(PdfName.EXTENSIONLEVEL).intValue();
				if (diff <= 0)
					return;
			}
		}
		extensions.put(de.getPrefix(), de.getDeveloperExtensions());
	}
} /*
 * $Id$
 *
 * Copyright 2006 Bruno Lowagie
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf.internal;

import pdftk.com.lowagie.text.pdf.PdfArray;
import pdftk.com.lowagie.text.pdf.PdfBoolean;
import pdftk.com.lowagie.text.pdf.PdfDictionary;
import pdftk.com.lowagie.text.pdf.PdfName;
import pdftk.com.lowagie.text.pdf.PdfNumber;
import pdftk.com.lowagie.text.pdf.PdfObject;
import pdftk.com.lowagie.text.pdf.PdfReader;
import pdftk.com.lowagie.text.pdf.PdfWriter;
import pdftk.com.lowagie.text.pdf.interfaces.PdfViewerPreferences;

/**
 * Stores the information concerning viewer preferences,
 * and contains the business logic that allows you to set viewer preferences.
 */

public class PdfViewerPreferencesImp implements PdfViewerPreferences {
	public static final PdfName[] VIEWER_PREFERENCES = {
			PdfName.HIDETOOLBAR,			// 0
			PdfName.HIDEMENUBAR,            // 1
			PdfName.HIDEWINDOWUI,           // 2
			PdfName.FITWINDOW,              // 3
			PdfName.CENTERWINDOW,			// 4
			PdfName.DISPLAYDOCTITLE,		// 5
			PdfName.NONFULLSCREENPAGEMODE,	// 6
			PdfName.DIRECTION,				// 7
			PdfName.VIEWAREA,				// 8
			PdfName.VIEWCLIP,				// 9
			PdfName.PRINTAREA,				// 10
			PdfName.PRINTCLIP,				// 11
			PdfName.PRINTSCALING,			// 12
			PdfName.DUPLEX,					// 13
			PdfName.PICKTRAYBYPDFSIZE,		// 14
			PdfName.PRINTPAGERANGE,			// 15
			PdfName.NUMCOPIES				// 16
		};


    /** A series of viewer preferences. */
    public static final PdfName NONFULLSCREENPAGEMODE_PREFERENCES[] = {
    	PdfName.USENONE, PdfName.USEOUTLINES, PdfName.USETHUMBS, PdfName.USEOC
    };
    /** A series of viewer preferences. */
    public static final PdfName DIRECTION_PREFERENCES[] = {
    	PdfName.L2R, PdfName.R2L
    };
	/** A series of viewer preferences. */
	public static final PdfName PAGE_BOUNDARIES[] = {
		PdfName.MEDIABOX, PdfName.CROPBOX, PdfName.BLEEDBOX, PdfName.TRIMBOX, PdfName.ARTBOX
	};
	/** A series of viewer preferences */
	public static final PdfName PRINTSCALING_PREFERENCES[] = {
		PdfName.APPDEFAULT, PdfName.NONE
	};
	/** A series of viewer preferences. */
	public static final PdfName DUPLEX_PREFERENCES[] = {
		PdfName.SIMPLEX, PdfName.DUPLEXFLIPSHORTEDGE, PdfName.DUPLEXFLIPLONGEDGE
	};
	
	/** This value will hold the viewer preferences for the page layout and page mode. */
	private int pageLayoutAndMode = 0;
	
	/** This dictionary holds the viewer preferences (other than page layout and page mode). */
	private PdfDictionary viewerPreferences = new PdfDictionary();
	
	/** The mask to decide if a ViewerPreferences dictionary is needed */
	private static final int viewerPreferencesMask = 0xfff000;

	/**
	 * Returns the page layout and page mode value.
	 */
	public int getPageLayoutAndMode() {
		return pageLayoutAndMode;
	}

	/**
	 * Returns the viewer preferences.
	 */
	public PdfDictionary getViewerPreferences() {
		return viewerPreferences;
	}
	
	/**
	 * Sets the viewer preferences as the sum of several constants.
	 * 
	 * @param preferences
	 *            the viewer preferences
	 * @see PdfViewerPreferences#setViewerPreferences
	 */
	public void setViewerPreferences(int preferences) {
		this.pageLayoutAndMode |= preferences;
		// for backwards compatibility, it is also possible
		// to set the following viewer preferences with this method:
		if ((preferences & viewerPreferencesMask) != 0) {
			pageLayoutAndMode = ~viewerPreferencesMask & pageLayoutAndMode;
			if ((preferences & PdfWriter.HideToolbar) != 0)
				viewerPreferences.put(PdfName.HIDETOOLBAR, PdfBoolean.PDFTRUE);
			if ((preferences & PdfWriter.HideMenubar) != 0)
				viewerPreferences.put(PdfName.HIDEMENUBAR, PdfBoolean.PDFTRUE);
			if ((preferences & PdfWriter.HideWindowUI) != 0)
				viewerPreferences.put(PdfName.HIDEWINDOWUI, PdfBoolean.PDFTRUE);
			if ((preferences & PdfWriter.FitWindow) != 0)
				viewerPreferences.put(PdfName.FITWINDOW, PdfBoolean.PDFTRUE);
			if ((preferences & PdfWriter.CenterWindow) != 0)
				viewerPreferences.put(PdfName.CENTERWINDOW, PdfBoolean.PDFTRUE);
			if ((preferences & PdfWriter.DisplayDocTitle) != 0)
				viewerPreferences.put(PdfName.DISPLAYDOCTITLE, PdfBoolean.PDFTRUE);
			
			if ((preferences & PdfWriter.NonFullScreenPageModeUseNone) != 0)
				viewerPreferences.put(PdfName.NONFULLSCREENPAGEMODE, PdfName.USENONE);
			else if ((preferences & PdfWriter.NonFullScreenPageModeUseOutlines) != 0)
				viewerPreferences.put(PdfName.NONFULLSCREENPAGEMODE, PdfName.USEOUTLINES);
			else if ((preferences & PdfWriter.NonFullScreenPageModeUseThumbs) != 0)
				viewerPreferences.put(PdfName.NONFULLSCREENPAGEMODE, PdfName.USETHUMBS);
			else if ((preferences & PdfWriter.NonFullScreenPageModeUseOC) != 0)
				viewerPreferences.put(PdfName.NONFULLSCREENPAGEMODE, PdfName.USEOC);

			if ((preferences & PdfWriter.DirectionL2R) != 0)
				viewerPreferences.put(PdfName.DIRECTION, PdfName.L2R);
			else if ((preferences & PdfWriter.DirectionR2L) != 0)
				viewerPreferences.put(PdfName.DIRECTION, PdfName.R2L);

			if ((preferences & PdfWriter.PrintScalingNone) != 0)
				viewerPreferences.put(PdfName.PRINTSCALING, PdfName.NONE);			
		}
	}
	
	/**
	 * Given a key for a viewer preference (a PdfName object),
	 * this method returns the index in the VIEWER_PREFERENCES array.
	 * @param key	a PdfName referring to a viewer preference
	 * @return	an index in the VIEWER_PREFERENCES array
	 */
	private int getIndex(PdfName key) {
		for (int i = 0; i < VIEWER_PREFERENCES.length; i++) {
			if (VIEWER_PREFERENCES[i].equals(key))
				return i;
		}
		return -1;
	}
	
	/**
	 * Checks if some value is valid for a certain key.
	 */
	private boolean isPossibleValue(PdfName value, PdfName[] accepted) {
		for (int i = 0; i < accepted.length; i++) {
			if (accepted[i].equals(value)) {
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Sets the viewer preferences for printing.
	 */
	public void addViewerPreference(PdfName key, PdfObject value) {
		switch(getIndex(key)) {
		case 0: // HIDETOOLBAR
		case 1: // HIDEMENUBAR
		case 2: // HIDEWINDOWUI
		case 3: // FITWINDOW
		case 4: // CENTERWINDOW
		case 5: // DISPLAYDOCTITLE
		case 14: // PICKTRAYBYPDFSIZE
			if (value instanceof PdfBoolean) {
				viewerPreferences.put(key, value);
			}
			break;
		case 6: // NONFULLSCREENPAGEMODE
			if (value instanceof PdfName
					&& isPossibleValue((PdfName)value, NONFULLSCREENPAGEMODE_PREFERENCES)) {
				viewerPreferences.put(key, value);
			}
			break;
		case 7: // DIRECTION
			if (value instanceof PdfName
					&& isPossibleValue((PdfName)value, DIRECTION_PREFERENCES)) {
				viewerPreferences.put(key, value);
			}
			break;
		case 8:  // VIEWAREA
		case 9:  // VIEWCLIP
		case 10: // PRINTAREA
		case 11: // PRINTCLIP
			if (value instanceof PdfName
					&& isPossibleValue((PdfName)value, PAGE_BOUNDARIES)) {
				viewerPreferences.put(key, value);
			}
			break;
		case 12: // PRINTSCALING
			if (value instanceof PdfName
					&& isPossibleValue((PdfName)value, PRINTSCALING_PREFERENCES)) {
				viewerPreferences.put(key, value);
			}
			break;
		case 13: // DUPLEX
			if (value instanceof PdfName
					&& isPossibleValue((PdfName)value, DUPLEX_PREFERENCES)) {
				viewerPreferences.put(key, value);
			}
			break;
		case 15: // PRINTPAGERANGE
			if (value instanceof PdfArray) {
				viewerPreferences.put(key, value);
			}
			break;
		case 16: // NUMCOPIES
			if (value instanceof PdfNumber)  {
				viewerPreferences.put(key, value);
			}
			break;
		}
	}

	/**
	 * Adds the viewer preferences defined in the preferences parameter to a
	 * PdfDictionary (more specifically the root or catalog of a PDF file).
	 * 
	 * @param catalog
	 */
	public void addToCatalog(PdfDictionary catalog) {
		// Page Layout
		catalog.remove(PdfName.PAGELAYOUT);
		if ((pageLayoutAndMode & PdfWriter.PageLayoutSinglePage) != 0)
			catalog.put(PdfName.PAGELAYOUT, PdfName.SINGLEPAGE);
		else if ((pageLayoutAndMode & PdfWriter.PageLayoutOneColumn) != 0)
			catalog.put(PdfName.PAGELAYOUT, PdfName.ONECOLUMN);
		else if ((pageLayoutAndMode & PdfWriter.PageLayoutTwoColumnLeft) != 0)
			catalog.put(PdfName.PAGELAYOUT, PdfName.TWOCOLUMNLEFT);
		else if ((pageLayoutAndMode & PdfWriter.PageLayoutTwoColumnRight) != 0)
			catalog.put(PdfName.PAGELAYOUT, PdfName.TWOCOLUMNRIGHT);
		else if ((pageLayoutAndMode & PdfWriter.PageLayoutTwoPageLeft) != 0)
			catalog.put(PdfName.PAGELAYOUT, PdfName.TWOPAGELEFT);
		else if ((pageLayoutAndMode & PdfWriter.PageLayoutTwoPageRight) != 0)
			catalog.put(PdfName.PAGELAYOUT, PdfName.TWOPAGERIGHT);

		// Page Mode
		catalog.remove(PdfName.PAGEMODE);
		if ((pageLayoutAndMode & PdfWriter.PageModeUseNone) != 0)
			catalog.put(PdfName.PAGEMODE, PdfName.USENONE);
		else if ((pageLayoutAndMode & PdfWriter.PageModeUseOutlines) != 0)
			catalog.put(PdfName.PAGEMODE, PdfName.USEOUTLINES);
		else if ((pageLayoutAndMode & PdfWriter.PageModeUseThumbs) != 0)
			catalog.put(PdfName.PAGEMODE, PdfName.USETHUMBS);
		else if ((pageLayoutAndMode & PdfWriter.PageModeFullScreen) != 0)
			catalog.put(PdfName.PAGEMODE, PdfName.FULLSCREEN);
		else if ((pageLayoutAndMode & PdfWriter.PageModeUseOC) != 0)
			catalog.put(PdfName.PAGEMODE, PdfName.USEOC);
		else if ((pageLayoutAndMode & PdfWriter.PageModeUseAttachments) != 0)
			catalog.put(PdfName.PAGEMODE, PdfName.USEATTACHMENTS);

		// viewer preferences (Table 8.1 of the PDF Reference)
		catalog.remove(PdfName.VIEWERPREFERENCES);
		if (viewerPreferences.size() > 0) {
			catalog.put(PdfName.VIEWERPREFERENCES, viewerPreferences);
		}
	}

	public static PdfViewerPreferencesImp getViewerPreferences(PdfDictionary catalog) {
		PdfViewerPreferencesImp preferences = new PdfViewerPreferencesImp();
		int prefs = 0;
		PdfName name = null;
		// page layout
		PdfObject obj = PdfReader.getPdfObjectRelease(catalog.get(PdfName.PAGELAYOUT));
		if (obj != null && obj.isName()) {
			name = (PdfName) obj;
			if (name.equals(PdfName.SINGLEPAGE))
				prefs |= PdfWriter.PageLayoutSinglePage;
			else if (name.equals(PdfName.ONECOLUMN))
				prefs |= PdfWriter.PageLayoutOneColumn;
			else if (name.equals(PdfName.TWOCOLUMNLEFT))
				prefs |= PdfWriter.PageLayoutTwoColumnLeft;
			else if (name.equals(PdfName.TWOCOLUMNRIGHT))
				prefs |= PdfWriter.PageLayoutTwoColumnRight;
			else if (name.equals(PdfName.TWOPAGELEFT))
				prefs |= PdfWriter.PageLayoutTwoPageLeft;
			else if (name.equals(PdfName.TWOPAGERIGHT))
				prefs |= PdfWriter.PageLayoutTwoPageRight;
		}
		// page mode
		obj = PdfReader.getPdfObjectRelease(catalog.get(PdfName.PAGEMODE));
		if (obj != null && obj.isName()) {
			name = (PdfName) obj;
			if (name.equals(PdfName.USENONE))
				prefs |= PdfWriter.PageModeUseNone;
			else if (name.equals(PdfName.USEOUTLINES))
				prefs |= PdfWriter.PageModeUseOutlines;
			else if (name.equals(PdfName.USETHUMBS))
				prefs |= PdfWriter.PageModeUseThumbs;
			else if (name.equals(PdfName.FULLSCREEN))
				prefs |= PdfWriter.PageModeFullScreen;
			else if (name.equals(PdfName.USEOC))
				prefs |= PdfWriter.PageModeUseOC;
			else if (name.equals(PdfName.USEATTACHMENTS))
				prefs |= PdfWriter.PageModeUseAttachments;
		}
		// set page layout and page mode preferences
		preferences.setViewerPreferences(prefs);
		// other preferences
		obj = PdfReader.getPdfObjectRelease(catalog
				.get(PdfName.VIEWERPREFERENCES));
		if (obj != null && obj.isDictionary()) {
			PdfDictionary vp = (PdfDictionary) obj;
			for (int i = 0; i < VIEWER_PREFERENCES.length; i++) {
				obj = PdfReader.getPdfObjectRelease(vp.get(VIEWER_PREFERENCES[i]));
				preferences.addViewerPreference(VIEWER_PREFERENCES[i], obj);
			}
		}
		return preferences;
	}
} /* -*- Mode: Java; tab-width: 4; c-basic-offset: 4 -*- */
/*
 * Copyright 2003 by Paulo Soares.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */
package pdftk.com.lowagie.text.pdf;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Iterator;
import java.util.Comparator;
import java.util.Collections;
import pdftk.com.lowagie.text.Rectangle;
import pdftk.com.lowagie.text.Element;
import pdftk.com.lowagie.text.ExceptionConverter;
import pdftk.com.lowagie.text.DocumentException;
import java.io.IOException;
import java.io.InputStream;
import java.awt.Color;

/** Query and change fields in existing documents either by method
 * calls or by FDF merging.
 * @author Paulo Soares (psoares@consiste.pt)
 */
public class AcroFields {

    PdfReader reader;
    PdfWriter writer;
    HashMap fields;
    private int topFirst;
    private HashMap sigNames;
    private boolean append;
    static private final int DA_FONT = 0;
    static private final int DA_SIZE = 1;
    static private final int DA_COLOR = 2;
    /**
     * A field type invalid or not found.
     */    
    public static final int FIELD_TYPE_NONE = 0;
    /**
     * A field type.
     */    
    public static final int FIELD_TYPE_PUSHBUTTON = 1;
    /**
     * A field type.
     */    
    public static final int FIELD_TYPE_CHECKBOX = 2;
    /**
     * A field type.
     */    
    public static final int FIELD_TYPE_RADIOBUTTON = 3;
    /**
     * A field type.
     */    
    public static final int FIELD_TYPE_TEXT = 4;
    /**
     * A field type.
     */    
    public static final int FIELD_TYPE_LIST = 5;
    /**
     * A field type.
     */    
    public static final int FIELD_TYPE_COMBO = 6;
    /**
     * A field type.
     */    
    public static final int FIELD_TYPE_SIGNATURE = 7;
    
    private boolean lastWasString;
    
    /** Holds value of property generateAppearances. */
    private boolean generateAppearances = true;
    
    private HashMap localFonts = new HashMap();
    
    private float extraMarginLeft;
    private float extraMarginTop;
    
    AcroFields(PdfReader reader, PdfWriter writer) {
        this.reader = reader;
        this.writer = writer;
        if (writer instanceof PdfStamperImp) {
            append = ((PdfStamperImp)writer).isAppend();
        }
        fill();
    }

    void fill() {
        fields = new HashMap();
        PdfDictionary top = (PdfDictionary)PdfReader.getPdfObjectRelease(reader.getCatalog().get(PdfName.ACROFORM));
        if (top == null)
            return;
        PdfArray arrfds = (PdfArray)PdfReader.getPdfObjectRelease(top.get(PdfName.FIELDS));
        if (arrfds == null || arrfds.size() == 0)
            return;
        arrfds = null;
        for (int k = 1; k <= reader.getNumberOfPages(); ++k) {
            if ((k % 100) == 0)
                System.out.println(k);
            PdfDictionary page = reader.getPageNRelease(k);
            PdfArray annots = (PdfArray)PdfReader.getPdfObjectRelease(page.get(PdfName.ANNOTS), page);
            if (annots == null)
                continue;
            ArrayList arr = annots.getArrayList();
            for (int j = 0; j < arr.size(); ++j) {
                PdfObject annoto = PdfReader.getPdfObject((PdfObject)arr.get(j), annots);
                if ((annoto instanceof PdfIndirectReference) && !annoto.isIndirect()) {
                    PdfReader.releaseLastXrefPartial((PdfObject)arr.get(j));
                    continue;
                }
				// ssteward: because we've seen a PDF where an annot array item was null
				if( !annoto.isDictionary() )
					continue;
                PdfDictionary annot = (PdfDictionary)annoto;
                if (!PdfName.WIDGET.equals(annot.get(PdfName.SUBTYPE))) {
                    PdfReader.releaseLastXrefPartial((PdfObject)arr.get(j));
                    continue;
                }
                PdfDictionary widget = annot;
                PdfDictionary dic = new PdfDictionary();
                dic.putAll(annot);
                String name = "";
                PdfDictionary value = null;
                PdfObject lastV = null;
                while (annot != null) {
                    dic.mergeDifferent(annot);
                    PdfString t = (PdfString)PdfReader.getPdfObject(annot.get(PdfName.T));
                    if (t != null)
                        name = t.toUnicodeString() + "." + name;
                    if (lastV == null && annot.get(PdfName.V) != null)
                        lastV = PdfReader.getPdfObjectRelease(annot.get(PdfName.V));
                    if (value == null &&  t != null) {
                        value = annot;
                        if (annot.get(PdfName.V) == null && lastV  != null)
                            value.put(PdfName.V, lastV);
                    }
					annot = (PdfDictionary)PdfReader.getPdfObject(annot.get(PdfName.PARENT), annot);
                }
                if (name.length() > 0)
                    name = name.substring(0, name.length() - 1);
                Item item = (Item)fields.get(name);
                if (item == null) {
                    item = new Item();
                    fields.put(name, item);
                }
                if (value == null)
                    item.values.add(widget);
                else
                    item.values.add(value);
                item.widgets.add(widget);
                item.widget_refs.add(arr.get(j)); // must be a reference
                if (top != null)
                    dic.mergeDifferent(top);
                item.merged.add(dic);
                item.page.add(new Integer(k));
                item.tabOrder.add(new Integer(j));
            }
        }
    }
    
    /** Gets the list of appearance names. Use it to get the names allowed
     * with radio and checkbox fields. If the /Opt key exists the values will
     * also be included. The name 'Off' may also be valid
     * even if not returned in the list.
     * @param fieldName the fully qualified field name
     * @return the list of names or <CODE>null</CODE> if the field does not exist
     */    
    public String[] getAppearanceStates(String fieldName) {
        Item fd = (Item)fields.get(fieldName);
        if (fd == null)
            return null;
        HashMap names = new HashMap();
        PdfDictionary vals = (PdfDictionary)fd.values.get(0);
        PdfObject opts = PdfReader.getPdfObject(vals.get(PdfName.OPT));
        if (opts != null) {
            if (opts.isString())
                names.put(((PdfString)opts).toUnicodeString(), null);
            else if (opts.isArray()) {
                ArrayList list = ((PdfArray)opts).getArrayList();
                for (int k = 0; k < list.size(); ++k) {
                    PdfObject v = PdfReader.getPdfObject((PdfObject)list.get(k));
                    if (v != null && v.isString())
                        names.put(((PdfString)v).toUnicodeString(), null);
                }
            }
        }
        ArrayList wd = fd.widgets;
        for (int k = 0; k < wd.size(); ++k) {
            PdfDictionary dic = (PdfDictionary)wd.get(k);
            dic = (PdfDictionary)PdfReader.getPdfObject(dic.get(PdfName.AP));
            if (dic == null)
                continue;
            PdfObject ob = PdfReader.getPdfObject(dic.get(PdfName.N));
            if (ob == null || !ob.isDictionary())
                continue;
            dic = (PdfDictionary)ob;
            for (Iterator it = dic.getKeys().iterator(); it.hasNext();) {
                String name = PdfName.decodeName(((PdfName)it.next()).toString());
                names.put(name, null);
            }
        }
        String out[] = new String[names.size()];
        return (String[])names.keySet().toArray(out);
    }
    
    /**
     * Gets the field type. The type can be one of: <CODE>FIELD_TYPE_PUSHBUTTON</CODE>,
     * <CODE>FIELD_TYPE_CHECKBOX</CODE>, <CODE>FIELD_TYPE_RADIOBUTTON</CODE>,
     * <CODE>FIELD_TYPE_TEXT</CODE>, <CODE>FIELD_TYPE_LIST</CODE>,
     * <CODE>FIELD_TYPE_COMBO</CODE> or <CODE>FIELD_TYPE_SIGNATURE</CODE>.
     * <p>
     * If the field does not exist or is invalid it returns
     * <CODE>FIELD_TYPE_NONE</CODE>.
     * @param fieldName the field name
     * @return the field type
     */    
    public int getFieldType(String fieldName) {
        Item fd = (Item)fields.get(fieldName);
        if (fd == null)
            return FIELD_TYPE_NONE;
        PdfObject type = PdfReader.getPdfObject(((PdfDictionary)fd.merged.get(0)).get(PdfName.FT));
        if (type == null)
            return FIELD_TYPE_NONE;
        int ff = 0;
        PdfObject ffo = PdfReader.getPdfObject(((PdfDictionary)fd.merged.get(0)).get(PdfName.FF));
        if (ffo != null && ffo.type() == PdfObject.NUMBER)
            ff = ((PdfNumber)ffo).intValue();
        if (PdfName.BTN.equals(type)) {
            if ((ff & PdfFormField.FF_PUSHBUTTON) != 0)
                return FIELD_TYPE_PUSHBUTTON;
            if ((ff & PdfFormField.FF_RADIO) != 0)
                return FIELD_TYPE_RADIOBUTTON;
            else
                return FIELD_TYPE_CHECKBOX;
        }
        else if (PdfName.TX.equals(type)) {
            return FIELD_TYPE_TEXT;
        }
        else if (PdfName.CH.equals(type)) {
            if ((ff & PdfFormField.FF_COMBO) != 0)
                return FIELD_TYPE_COMBO;
            else
                return FIELD_TYPE_LIST;
        }
        else if (PdfName.SIG.equals(type)) {
            return FIELD_TYPE_SIGNATURE;
        }
        return FIELD_TYPE_NONE;
    }
    
    /**
     * Export the fields as a FDF.
     * @param writer the FDF writer
     */    
    public void exportAsFdf(FdfWriter writer) {
        for (Iterator it = fields.entrySet().iterator(); it.hasNext();) {
            Map.Entry entry = (Map.Entry)it.next();
            // ssteward omit: Item item = (Item)entry.getValue();
            String name = (String)entry.getKey();
            // PdfObject v = PdfReader.getPdfObject(((PdfDictionary)item.merged.get(0)).get(PdfName.V));
			// ssteward: moved this logic to getField, where lastWasString is set;
			// we also want to output empty fields, too;
            //if (v != null)
			String value = getField(name);
            if (lastWasString)
                writer.setFieldAsString(name, value);
            else /* ssteward: TODO: if (!value.isEmpty())*/
                writer.setFieldAsName(name, value);
        }
    }
    
    /**
     * Renames a field. Only the last part of the name can be renamed. For example,
     * if the original field is "ab.cd.ef" only the "ef" part can be renamed.
     * @param oldName the old field name
     * @param newName the new field name
     * @return <CODE>true</CODE> if the renaming was successful, <CODE>false</CODE>
     * otherwise
     */    
    public boolean renameField(String oldName, String newName) {
        int idx1 = oldName.lastIndexOf('.') + 1;
        int idx2 = newName.lastIndexOf('.') + 1;
        if (idx1 != idx2)
            return false;
        if (!oldName.substring(0, idx1).equals(newName.substring(0, idx2)))
            return false;
        if (fields.containsKey(newName))
            return false;
        Item item = (Item)fields.get(oldName);
        if (item == null)
            return false;
        newName = newName.substring(idx2);
        PdfString ss = new PdfString(newName, PdfObject.TEXT_UNICODE);
        for (int k = 0; k < item.merged.size(); ++k) {
            PdfDictionary dic = (PdfDictionary)item.values.get(k);
            dic.put(PdfName.T, ss);
            markUsed(dic);
            dic = (PdfDictionary)item.merged.get(k);
            dic.put(PdfName.T, ss);
        }
        fields.remove(oldName);
        fields.put(newName, item);
        return true;
    }
    
    static private Object[] splitDAelements(String da) {
        try {
            PRTokeniser tk = new PRTokeniser(PdfEncodings.convertToBytes(da, null));
            ArrayList stack = new ArrayList();
            Object ret[] = new Object[3];
            while (tk.nextToken()) {
                if (tk.getTokenType() == PRTokeniser.TK_COMMENT)
                    continue;
                if (tk.getTokenType() == PRTokeniser.TK_OTHER) {
                    String operator = tk.getStringValue();
                    if (operator.equals("Tf")) {
                        if (stack.size() >= 2) {
                            ret[DA_FONT] = stack.get(stack.size() - 2);
                            ret[DA_SIZE] = new Float((String)stack.get(stack.size() - 1));
                        }
                    }
                    else if (operator.equals("g")) {
                        if (stack.size() >= 1) {
                            float gray = new Float((String)stack.get(stack.size() - 1)).floatValue();
                            if (gray != 0)
                                ret[DA_COLOR] = new GrayColor(gray);
                        }
                    }
                    else if (operator.equals("rg")) {
                        if (stack.size() >= 3) {
                            float red = new Float((String)stack.get(stack.size() - 3)).floatValue();
                            float green = new Float((String)stack.get(stack.size() - 2)).floatValue();
                            float blue = new Float((String)stack.get(stack.size() - 1)).floatValue();
                            ret[DA_COLOR] = new Color(red, green, blue);
                        }
                    }
                    else if (operator.equals("k")) {
                        if (stack.size() >= 4) {
                            float cyan = new Float((String)stack.get(stack.size() - 4)).floatValue();
                            float magenta = new Float((String)stack.get(stack.size() - 3)).floatValue();
                            float yellow = new Float((String)stack.get(stack.size() - 2)).floatValue();
                            float black = new Float((String)stack.get(stack.size() - 1)).floatValue();
                            ret[DA_COLOR] = new CMYKColor(cyan, magenta, yellow, black);
                        }
                    }
                    stack.clear();
                }
                else
                    stack.add(tk.getStringValue());
            }
            return ret;
        }
        catch (IOException ioe) {
            throw new ExceptionConverter(ioe);
        }
    }
    
    PdfAppearance getAppearance(PdfDictionary merged, String text, String fieldName) throws IOException, DocumentException {
        topFirst = 0;
        int flags = 0;
        TextField tx = null;
        if (fieldCache == null || !fieldCache.containsKey(fieldName)) {
            tx = new TextField(writer, null, null);
            tx.setExtraMargin(extraMarginLeft, extraMarginTop);
            tx.setBorderWidth(0);
            // the text size and color
            PdfString da = (PdfString)PdfReader.getPdfObject(merged.get(PdfName.DA));
            if (da != null) {
                Object dab[] = splitDAelements(da.toUnicodeString());
                if (dab[DA_SIZE] != null)
                    tx.setFontSize(((Float)dab[DA_SIZE]).floatValue());
                if (dab[DA_COLOR] != null)
                    tx.setTextColor((Color)dab[DA_COLOR]);
                if (dab[DA_FONT] != null) {
                    PdfDictionary font = (PdfDictionary)PdfReader.getPdfObject(merged.get(PdfName.DR));
                    if (font != null) {
                        font = (PdfDictionary)PdfReader.getPdfObject(font.get(PdfName.FONT));
                        if (font != null) {
                            PdfObject po = font.get(new PdfName((String)dab[DA_FONT]));
                            if (po != null && po.type() == PdfObject.INDIRECT)
                                tx.setFont(new DocumentFont((PRIndirectReference)po));
                            else {
                                BaseFont bf = (BaseFont)localFonts.get(dab[DA_FONT]);
                                if (bf == null) {
                                    String fn[] = (String[])stdFieldFontNames.get(dab[DA_FONT]);
                                    if (fn != null) {
                                        try {
                                            String enc = "winansi";
                                            if (fn.length > 1)
                                                enc = fn[1];
                                            bf = BaseFont.createFont(fn[0], enc, false);
                                            tx.setFont(bf);
                                        }
                                        catch (Exception e) {
                                            // empty
                                        }
                                    }
                                }
                                else
                                    tx.setFont(bf);
                            }
                        }
                    }
                }
            }
            //rotation, border and backgound color
            PdfDictionary mk = (PdfDictionary)PdfReader.getPdfObject(merged.get(PdfName.MK));
            if (mk != null) {
                PdfArray ar = (PdfArray)PdfReader.getPdfObject(mk.get(PdfName.BC));
                Color border = getMKColor(ar);
                tx.setBorderColor(border);
                if (border != null)
                    tx.setBorderWidth(1);
                ar = (PdfArray)PdfReader.getPdfObject(mk.get(PdfName.BG));
                tx.setBackgroundColor(getMKColor(ar));
                PdfNumber rotation = (PdfNumber)PdfReader.getPdfObject(mk.get(PdfName.R));
                if (rotation != null)
                    tx.setRotation(rotation.intValue());
            }
            //multiline
            PdfNumber nfl = (PdfNumber)PdfReader.getPdfObject(merged.get(PdfName.FF));
            if (nfl != null)
                flags = nfl.intValue();
            tx.setOptions(((flags & PdfFormField.FF_MULTILINE) == 0 ? 0 : TextField.MULTILINE) | ((flags & PdfFormField.FF_COMB) == 0 ? 0 : TextField.COMB));
            if ((flags & PdfFormField.FF_COMB) != 0) {
                PdfNumber maxLen = (PdfNumber)PdfReader.getPdfObject(merged.get(PdfName.MAXLEN));
                int len = 0;
                if (maxLen != null)
                    len = maxLen.intValue();
                tx.setMaxCharacterLength(len);
            }
            //alignment
            nfl = (PdfNumber)PdfReader.getPdfObject(merged.get(PdfName.Q));
            if (nfl != null) {
                if (nfl.intValue() == PdfFormField.Q_CENTER)
                    tx.setAlignment(Element.ALIGN_CENTER);
                else if (nfl.intValue() == PdfFormField.Q_RIGHT)
                    tx.setAlignment(Element.ALIGN_RIGHT);
            }
            //border styles
            PdfDictionary bs = (PdfDictionary)PdfReader.getPdfObject(merged.get(PdfName.BS));
            if (bs != null) {
                PdfNumber w = (PdfNumber)PdfReader.getPdfObject(bs.get(PdfName.W));
                if (w != null)
                    tx.setBorderWidth(w.floatValue());
                PdfName s = (PdfName)PdfReader.getPdfObject(bs.get(PdfName.S));
                if (PdfName.D.equals(s))
                    tx.setBorderStyle(PdfBorderDictionary.STYLE_DASHED);
                else if (PdfName.B.equals(s))
                    tx.setBorderStyle(PdfBorderDictionary.STYLE_BEVELED);
                else if (PdfName.I.equals(s))
                    tx.setBorderStyle(PdfBorderDictionary.STYLE_INSET);
                else if (PdfName.U.equals(s))
                    tx.setBorderStyle(PdfBorderDictionary.STYLE_UNDERLINE);
            }
            else {
                PdfArray bd = (PdfArray)PdfReader.getPdfObject(merged.get(PdfName.BORDER));
                if (bd != null) {
                    ArrayList ar = bd.getArrayList();
                    if (ar.size() >= 3)
                        tx.setBorderWidth(((PdfNumber)ar.get(2)).floatValue());
                    if (ar.size() >= 4)
                        tx.setBorderStyle(PdfBorderDictionary.STYLE_DASHED);
                }
            }
            //rect
            PdfArray rect = (PdfArray)PdfReader.getPdfObject(merged.get(PdfName.RECT));
            Rectangle box = PdfReader.getNormalizedRectangle(rect);
            if (tx.getRotation() == 90 || tx.getRotation() == 270)
                box = box.rotate();
            tx.setBox(box);
            if (fieldCache != null)
                fieldCache.put(fieldName, tx);
        }
        else {
            tx = (TextField)fieldCache.get(fieldName);
            tx.setWriter(writer);
        }
        PdfName fieldType = (PdfName)PdfReader.getPdfObject(merged.get(PdfName.FT));
        if (PdfName.TX.equals(fieldType)) {
            tx.setText(text);
            return tx.getAppearance();
        }
        if (!PdfName.CH.equals(fieldType))
            throw new DocumentException("An appearance was requested without a variable text field.");
        PdfArray opt = (PdfArray)PdfReader.getPdfObject(merged.get(PdfName.OPT));
        if ((flags & PdfFormField.FF_COMBO) != 0 && opt == null) {
            tx.setText(text);
            return tx.getAppearance();
        }
        if (opt != null) {
            ArrayList op = opt.getArrayList();
            String choices[] = new String[op.size()];
            String choicesExp[] = new String[op.size()];
            for (int k = 0; k < op.size(); ++k) {
                PdfObject obj = (PdfObject)op.get(k);
                if (obj.isString()) {
                    choices[k] = choicesExp[k] = ((PdfString)obj).toUnicodeString();
                }
                else {
                    ArrayList opar = ((PdfArray)obj).getArrayList();
                    choicesExp[k] = ((PdfString)opar.get(0)).toUnicodeString();
                    choices[k] = ((PdfString)opar.get(1)).toUnicodeString();
                }
            }
            if ((flags & PdfFormField.FF_COMBO) != 0) {
                for (int k = 0; k < choices.length; ++k) {
                    if (text.equals(choicesExp[k])) {
                        text = choices[k];
                        break;
                    }
                }
                tx.setText(text);
                return tx.getAppearance();
            }
            int idx = 0;
            for (int k = 0; k < choicesExp.length; ++k) {
                if (text.equals(choicesExp[k])) {
                    idx = k;
                    break;
                }
            }
            tx.setChoices(choices);
            tx.setChoiceExports(choicesExp);
            tx.setChoiceSelection(idx);
        }
        PdfAppearance app = tx.getListAppearance();
        topFirst = tx.getTopFirst();
        return app;
    }
    
    Color getMKColor(PdfArray ar) {
        if (ar == null)
            return null;
        ArrayList cc = ar.getArrayList();
        switch (cc.size()) {
            case 1:
                return new GrayColor(((PdfNumber)cc.get(0)).floatValue());
            case 3:
                return new Color(((PdfNumber)cc.get(0)).floatValue(), ((PdfNumber)cc.get(1)).floatValue(), ((PdfNumber)cc.get(2)).floatValue());
            case 4:
                return new CMYKColor(((PdfNumber)cc.get(0)).floatValue(), ((PdfNumber)cc.get(1)).floatValue(), ((PdfNumber)cc.get(2)).floatValue(), ((PdfNumber)cc.get(3)).floatValue());
            default:
                return null;
        }
    }
    
    /** Gets the field value.
     * @param name the fully qualified field name
     * @return the field value
     */    
    public String getField(String name) {
        Item item = (Item)fields.get(name);
        if (item == null)
            return null;
        lastWasString = true; // ssteward: default was false
        PdfObject v = PdfReader.getPdfObject(((PdfDictionary)item.merged.get(0)).get(PdfName.V));
		// ssteward: test VT before returning
        //if (v == null)
        //    return "";
        PdfName type = (PdfName)PdfReader.getPdfObject(((PdfDictionary)item.merged.get(0)).get(PdfName.FT));
        if (PdfName.BTN.equals(type)) {
			lastWasString = false; // ssteward
            PdfNumber ff = (PdfNumber)PdfReader.getPdfObject(((PdfDictionary)item.merged.get(0)).get(PdfName.FF));
            int flags = 0;
            if (ff != null)
                flags = ff.intValue();
            if ((flags & PdfFormField.FF_PUSHBUTTON) != 0)
                return "";
            String value = "";
			if (v != null) { // ssteward
				if (v.isName())
					value = PdfName.decodeName(v.toString());
				else if (v.isString())
					value = ((PdfString)v).toUnicodeString();
			}
            PdfObject opts = PdfReader.getPdfObject(((PdfDictionary)item.values.get(0)).get(PdfName.OPT));
            if (opts != null && opts.isArray()) {
                ArrayList list = ((PdfArray)opts).getArrayList();
                int idx = 0;
                try {
                    idx = Integer.parseInt(value);
                    PdfString ps = (PdfString)list.get(idx);
                    value = ps.toUnicodeString();
                    lastWasString = true;
                }
                catch (Exception e) {
                }
            }
            return value;
        }

		if (v == null) { // ssteward
			return "";
		}
        if (v.isString()) {
            return ((PdfString)v).toUnicodeString();
        }
		lastWasString = false;
        return PdfName.decodeName(v.toString());
    }

    /**
     * Sets a field property. Valid property names are:
     * <p>
     * <ul>
     * <li>textfont - sets the text font. The value for this entry is a <CODE>BaseFont</CODE>.<br>
     * <li>textcolor - sets the text color. The value for this entry is a <CODE>java.awt.Color</CODE>.<br>
     * <li>textsize - sets the text size. The value for this entry is a <CODE>Float</CODE>.
     * <li>bgcolor - sets the background color. The value for this entry is a <CODE>java.awt.Color</CODE>.
     *     If <code>null</code> removes the background.<br>
     * <li>bordercolor - sets the border color. The value for this entry is a <CODE>java.awt.Color</CODE>.
     *     If <code>null</code> removes the border.<br>
     * </ul>
     * @param field the field name
     * @param name the property name
     * @param value the property value
     * @param inst an array of <CODE>int</CODE> indexing into <CODE>AcroField.Item.merged</CODE> elements to process.
     * Set to <CODE>null</CODE> to process all
     * @return <CODE>true</CODE> if the property exists, <CODE>false</CODE> otherwise
     */    
    public boolean setFieldProperty(String field, String name, Object value, int inst[]) {
        if (writer == null)
            throw new RuntimeException("This AcroFields instance is read-only.");
        try {
            Item item = (Item)fields.get(field);
            if (item == null)
                return false;
            InstHit hit = new InstHit(inst);
            if (name.equalsIgnoreCase("textfont")) {
                for (int k = 0; k < item.merged.size(); ++k) {
                    if (hit.isHit(k)) {
                        PdfString da = (PdfString)PdfReader.getPdfObject(((PdfDictionary)item.merged.get(k)).get(PdfName.DA));
                        PdfDictionary dr = (PdfDictionary)PdfReader.getPdfObject(((PdfDictionary)item.merged.get(k)).get(PdfName.DR));
                        if (da != null && dr != null) {
                            Object dao[] = splitDAelements(da.toUnicodeString());
                            PdfAppearance cb = new PdfAppearance();
                            if (dao[DA_FONT] != null) {
                                BaseFont bf = (BaseFont)value;
                                PdfName psn = (PdfName)PdfAppearance.stdFieldFontNames.get(bf.getPostscriptFontName());
                                if (psn == null) {
                                    psn = new PdfName(bf.getPostscriptFontName());
                                }
                                PdfDictionary fonts = (PdfDictionary)PdfReader.getPdfObject(dr.get(PdfName.FONT));
                                if (fonts == null) {
                                    fonts = new PdfDictionary();
                                    dr.put(PdfName.FONT, fonts);
                                }
                                PdfIndirectReference fref = (PdfIndirectReference)fonts.get(psn);
                                PdfDictionary top = (PdfDictionary)PdfReader.getPdfObject(reader.getCatalog().get(PdfName.ACROFORM));
                                markUsed(top);
                                dr = (PdfDictionary)PdfReader.getPdfObject(top.get(PdfName.DR));
                                if (dr == null) {
                                    dr = new PdfDictionary();
                                    top.put(PdfName.DR, dr);
                                }
                                markUsed(dr);
                                PdfDictionary fontsTop = (PdfDictionary)PdfReader.getPdfObject(dr.get(PdfName.FONT));
                                if (fontsTop == null) {
                                    fontsTop = new PdfDictionary();
                                    dr.put(PdfName.FONT, fontsTop);
                                }
                                markUsed(fontsTop);
                                PdfIndirectReference frefTop = (PdfIndirectReference)fontsTop.get(psn);
                                if (frefTop != null) {
                                    if (fref == null)
                                        fonts.put(psn, frefTop);
                                }
                                else if (fref == null) {
                                    FontDetails fd;
                                    if (bf.getFontType() == BaseFont.FONT_TYPE_DOCUMENT) {
                                        fd = new FontDetails(null, ((DocumentFont)bf).getIndirectReference(), bf);
                                    }
                                    else {
                                        bf.setSubset(false);
                                        fd = writer.addSimple(bf);
                                        localFonts.put(psn.toString().substring(1), bf);
                                    }
                                    fontsTop.put(psn, fd.getIndirectReference());
                                    fonts.put(psn, fd.getIndirectReference());
                                }
                                ByteBuffer buf = cb.getInternalBuffer();
                                buf.append(psn.getBytes()).append(' ').append(((Float)dao[DA_SIZE]).floatValue()).append(" Tf ");
                                if (dao[DA_COLOR] != null)
                                    cb.setColorFill((Color)dao[DA_COLOR]);
                                PdfString s = new PdfString(cb.toString());
                                ((PdfDictionary)item.merged.get(k)).put(PdfName.DA, s);
                                ((PdfDictionary)item.widgets.get(k)).put(PdfName.DA, s);
                                markUsed((PdfDictionary)item.widgets.get(k));
                            }
                        }
                    }
                }
            }
            else if (name.equalsIgnoreCase("textcolor")) {
                for (int k = 0; k < item.merged.size(); ++k) {
                    if (hit.isHit(k)) {
                        PdfString da = (PdfString)PdfReader.getPdfObject(((PdfDictionary)item.merged.get(k)).get(PdfName.DA));
                        if (da != null) {
                            Object dao[] = splitDAelements(da.toUnicodeString());
                            PdfAppearance cb = new PdfAppearance();
                            if (dao[DA_FONT] != null) {
                                ByteBuffer buf = cb.getInternalBuffer();
                                buf.append(new PdfName((String)dao[DA_FONT]).getBytes()).append(' ').append(((Float)dao[DA_SIZE]).floatValue()).append(" Tf ");
                                cb.setColorFill((Color)value);
                                PdfString s = new PdfString(cb.toString());
                                ((PdfDictionary)item.merged.get(k)).put(PdfName.DA, s);
                                ((PdfDictionary)item.widgets.get(k)).put(PdfName.DA, s);
                                markUsed((PdfDictionary)item.widgets.get(k));
                            }
                        }
                    }
                }
            }
            else if (name.equalsIgnoreCase("textsize")) {
                for (int k = 0; k < item.merged.size(); ++k) {
                    if (hit.isHit(k)) {
                        PdfString da = (PdfString)PdfReader.getPdfObject(((PdfDictionary)item.merged.get(k)).get(PdfName.DA));
                        if (da != null) {
                            Object dao[] = splitDAelements(da.toUnicodeString());
                            PdfAppearance cb = new PdfAppearance();
                            if (dao[DA_FONT] != null) {
                                ByteBuffer buf = cb.getInternalBuffer();
                                buf.append(new PdfName((String)dao[DA_FONT]).getBytes()).append(' ').append(((Float)value).floatValue()).append(" Tf ");
                                if (dao[DA_COLOR] != null)
                                    cb.setColorFill((Color)dao[DA_COLOR]);
                                PdfString s = new PdfString(cb.toString());
                                ((PdfDictionary)item.merged.get(k)).put(PdfName.DA, s);
                                ((PdfDictionary)item.widgets.get(k)).put(PdfName.DA, s);
                                markUsed((PdfDictionary)item.widgets.get(k));
                            }
                        }
                    }
                }
            }
            else if (name.equalsIgnoreCase("bgcolor") || name.equalsIgnoreCase("bordercolor")) {
                PdfName dname = (name.equalsIgnoreCase("bgcolor") ? PdfName.BG : PdfName.BC);
                for (int k = 0; k < item.merged.size(); ++k) {
                    if (hit.isHit(k)) {
                        PdfObject obj = PdfReader.getPdfObject(((PdfDictionary)item.merged.get(k)).get(PdfName.MK));
                        markUsed(obj);
                        PdfDictionary mk = (PdfDictionary)obj;
                        if (mk == null) {
                            if (value == null)
                                return true;
                            mk = new PdfDictionary();
                            ((PdfDictionary)item.merged.get(k)).put(PdfName.MK, mk);
                            ((PdfDictionary)item.widgets.get(k)).put(PdfName.MK, mk);
                            markUsed((PdfDictionary)item.widgets.get(k));
                        }
                        if (value == null)
                            mk.remove(dname);
                        else
                            mk.put(dname, PdfFormField.getMKColor((Color)value));
                    }
                }
            }
            else
                return false;
            return true;
        }
        catch (Exception e) {
            throw new ExceptionConverter(e);
        }
    }
    
    /**
     * Sets a field property. Valid property names are:
     * <p>
     * <ul>
     * <li>flags - a set of flags specifying various characteristics of the field's widget annotation.
	 * The value of this entry replaces that of the F entry in the form's corresponding annotation dictionary.<br>
     * <li>setflags - a set of flags to be set (turned on) in the F entry of the form's corresponding
     * widget annotation dictionary. Bits equal to 1 cause the corresponding bits in F to be set to 1.<br>
     * <li>clrflags - a set of flags to be cleared (turned off) in the F entry of the form's corresponding
     * widget annotation dictionary. Bits equal to 1 cause the corresponding
     * bits in F to be set to 0.<br>
     * <li>fflags - a set of flags specifying various characteristics of the field. The value
     * of this entry replaces that of the Ff entry in the form's corresponding field dictionary.<br>
     * <li>setfflags - a set of flags to be set (turned on) in the Ff entry of the form's corresponding
     * field dictionary. Bits equal to 1 cause the corresponding bits in Ff to be set to 1.<br>
     * <li>clrfflags - a set of flags to be cleared (turned off) in the Ff entry of the form's corresponding
     * field dictionary. Bits equal to 1 cause the corresponding bits in Ff
     * to be set to 0.<br>
     * </ul>
     * @param field the field name
     * @param name the property name
     * @param value the property value
     * @param inst an array of <CODE>int</CODE> indexing into <CODE>AcroField.Item.merged</CODE> elements to process.
     * Set to <CODE>null</CODE> to process all
     * @return <CODE>true</CODE> if the property exists, <CODE>false</CODE> otherwise
     */    
    public boolean setFieldProperty(String field, String name, int value, int inst[]) {
        if (writer == null)
            throw new RuntimeException("This AcroFields instance is read-only.");
        Item item = (Item)fields.get(field);
        if (item == null)
            return false;
        InstHit hit = new InstHit(inst);
        if (name.equalsIgnoreCase("flags")) {
            PdfNumber num = new PdfNumber(value);
            for (int k = 0; k < item.merged.size(); ++k) {
                if (hit.isHit(k)) {
                    ((PdfDictionary)item.merged.get(k)).put(PdfName.F, num);
                    ((PdfDictionary)item.widgets.get(k)).put(PdfName.F, num);
                    markUsed((PdfDictionary)item.widgets.get(k));
                }
            }
        }
        else if (name.equalsIgnoreCase("setflags")) {
            for (int k = 0; k < item.merged.size(); ++k) {
                if (hit.isHit(k)) {
                    PdfNumber num = (PdfNumber)PdfReader.getPdfObject(((PdfDictionary)item.widgets.get(k)).get(PdfName.F));
                    int val = 0;
                    if (num != null)
                        val = num.intValue();
                    num = new PdfNumber(val | value);
                    ((PdfDictionary)item.merged.get(k)).put(PdfName.F, num);
                    ((PdfDictionary)item.widgets.get(k)).put(PdfName.F, num);
                    markUsed((PdfDictionary)item.widgets.get(k));
                }
            }
        }
        else if (name.equalsIgnoreCase("clrflags")) {
            for (int k = 0; k < item.merged.size(); ++k) {
                if (hit.isHit(k)) {
                    PdfNumber num = (PdfNumber)PdfReader.getPdfObject(((PdfDictionary)item.widgets.get(k)).get(PdfName.F));
                    int val = 0;
                    if (num != null)
                        val = num.intValue();
                    num = new PdfNumber(val & (~value));
                    ((PdfDictionary)item.merged.get(k)).put(PdfName.F, num);
                    ((PdfDictionary)item.widgets.get(k)).put(PdfName.F, num);
                    markUsed((PdfDictionary)item.widgets.get(k));
                }
            }
        }
        else if (name.equalsIgnoreCase("fflags")) {
            PdfNumber num = new PdfNumber(value);
            for (int k = 0; k < item.merged.size(); ++k) {
                if (hit.isHit(k)) {
                    ((PdfDictionary)item.merged.get(k)).put(PdfName.FF, num);
                    ((PdfDictionary)item.values.get(k)).put(PdfName.FF, num);
                    markUsed((PdfDictionary)item.values.get(k));
                }
            }
        }
        else if (name.equalsIgnoreCase("setfflags")) {
            for (int k = 0; k < item.merged.size(); ++k) {
                if (hit.isHit(k)) {
                    PdfNumber num = (PdfNumber)PdfReader.getPdfObject(((PdfDictionary)item.values.get(k)).get(PdfName.FF));
                    int val = 0;
                    if (num != null)
                        val = num.intValue();
                    num = new PdfNumber(val | value);
                    ((PdfDictionary)item.merged.get(k)).put(PdfName.FF, num);
                    ((PdfDictionary)item.values.get(k)).put(PdfName.FF, num);
                    markUsed((PdfDictionary)item.values.get(k));
                }
            }
        }
        else if (name.equalsIgnoreCase("clrfflags")) {
            for (int k = 0; k < item.merged.size(); ++k) {
                if (hit.isHit(k)) {
                    PdfNumber num = (PdfNumber)PdfReader.getPdfObject(((PdfDictionary)item.values.get(k)).get(PdfName.FF));
                    int val = 0;
                    if (num != null)
                        val = num.intValue();
                    num = new PdfNumber(val & (~value));
                    ((PdfDictionary)item.merged.get(k)).put(PdfName.FF, num);
                    ((PdfDictionary)item.values.get(k)).put(PdfName.FF, num);
                    markUsed((PdfDictionary)item.values.get(k));
                }
            }
        }
        else
            return false;
        return true;
    }
    
    /** Sets the fields by FDF merging.
     * @param fdf the FDF form
     * @throws IOException on error
     * @throws DocumentException on error
     */    
    public boolean setFields(FdfReader fdf) throws IOException, DocumentException {
		boolean ret_val_b= false; // ssteward
        fdf.getFields();
        for (Iterator i = fields.keySet().iterator(); i.hasNext();) {
            String f = (String)i.next();
            String v = fdf.getFieldValue(f);
			String rv = fdf.getFieldRichValue(f); // ssteward
			if (rv != null)
				ret_val_b= true;
            if (v != null)
                setField(f, v, v, rv); // ssteward
        }
		return ret_val_b; // ssteward
    }
    
    /** Sets the fields by XFDF merging.
     * @param xfdf the XFDF form
     * @throws IOException on error
     * @throws DocumentException on error
     */
    public boolean setFields(XfdfReader xfdf) throws IOException, DocumentException {
		boolean ret_val_b= false; // ssteward
        xfdf.getFields();
        for (Iterator i = fields.keySet().iterator(); i.hasNext();) {
            String f = (String)i.next();
            String v = xfdf.getFieldValue(f);
			String rv = xfdf.getFieldRichValue(f); // ssteward
			if (rv != null)
				ret_val_b= true;
            if (v != null)
                setField(f, v, v, rv); // ssteward
        }
		return ret_val_b; // ssteward
    }

    /** Sets the field value.
     * @param name the fully qualified field name
     * @param value the field value
     * @throws IOException on error
     * @throws DocumentException on error
     * @return <CODE>true</CODE> if the field was found and changed,
     * <CODE>false</CODE> otherwise
     */    
    public boolean setField(String name, String value) throws IOException, DocumentException {
        return setField(name, value, value, null); // ssteward
    }
	// ssteward; added for backward compatibility
    public boolean setField(String name, String value, String display) throws IOException, DocumentException {
        return setField(name, value, display, null);
    }
    
    /** Sets the field value and the display string. The display string
     * is used to build the appearance in the cases where the value
     * is modified by Acrobat with JavaScript and the algorithm is
     * known.
     * @param name the fully qualified field name
     * @param value the field value
     * @param display the string that is used for the appearance
	 * @param rich_value (ssteward)
     * @return <CODE>true</CODE> if the field was found and changed,
     * <CODE>false</CODE> otherwise
     * @throws IOException on error
     * @throws DocumentException on error
     */    
    public boolean setField(String name, String value, String display, String rich_value) throws IOException, DocumentException {
        if (writer == null)
            throw new DocumentException("This AcroFields instance is read-only.");
        Item item = (Item)fields.get(name);
        if (item == null)
            return false;
        PdfName type = (PdfName)PdfReader.getPdfObject(((PdfDictionary)item.merged.get(0)).get(PdfName.FT));
        if (PdfName.TX.equals(type)) {
            PdfNumber maxLen = (PdfNumber)PdfReader.getPdfObject(((PdfDictionary)item.merged.get(0)).get(PdfName.MAXLEN));
            int len = 0;
            if (maxLen != null)
                len = maxLen.intValue();
            if (len > 0)
                value = value.substring(0, Math.min(len, value.length()));
        }
        if (PdfName.TX.equals(type) || PdfName.CH.equals(type)) {
            PdfString v = new PdfString(value, PdfObject.TEXT_UNICODE);
			// ssteward
			PdfString rv = null;
			if( rich_value != null )
				rv = new PdfString(rich_value, PdfObject.TEXT_UNICODE); // ssteward
            for (int idx = 0; idx < item.values.size(); ++idx) {

				PdfDictionary item_value= (PdfDictionary)item.values.get(idx);
                item_value.put(PdfName.V, v);
                markUsed(item_value);
				if( rich_value != null ) // ssteward
					item_value.put(PdfName.RV, rv);
				item_value.remove(PdfName.I); // ssteward; it might disagree w/ V in a Ch widget
				// PDF spec this shouldn't matter, but Reader 9 gives I precedence over V

                PdfDictionary merged = (PdfDictionary)item.merged.get(idx);
                merged.put(PdfName.V, v);
				if( rich_value != null ) // ssteward
					merged.put(PdfName.RV, rv);
				merged.remove(PdfName.I); // ssteward
				
                PdfDictionary widget = (PdfDictionary)item.widgets.get(idx);
                if (generateAppearances) {
                    PdfAppearance app = getAppearance(merged, display, name);
                    if (PdfName.CH.equals(type)) {
                        PdfNumber n = new PdfNumber(topFirst);
                        widget.put(PdfName.TI, n);
                        merged.put(PdfName.TI, n);
                    }
                    PdfDictionary appDic = (PdfDictionary)PdfReader.getPdfObject(widget.get(PdfName.AP));
                    if (appDic == null) {
                        appDic = new PdfDictionary();
                        widget.put(PdfName.AP, appDic);
                        merged.put(PdfName.AP, appDic);
                    }
                    appDic.put(PdfName.N, app.getIndirectReference());
                    writer.releaseTemplate(app);
                }
                else {
                    widget.remove(PdfName.AP);
                    merged.remove(PdfName.AP);
                }
                markUsed(widget);
            }
            return true;
        }
        else if (PdfName.BTN.equals(type)) {
            PdfNumber ff = (PdfNumber)PdfReader.getPdfObject(((PdfDictionary)item.merged.get(0)).get(PdfName.FF));
            int flags = 0;
            if (ff != null)
                flags = ff.intValue();
            if ((flags & PdfFormField.FF_PUSHBUTTON) != 0)
                return true;
            PdfName v = new PdfName(value);
            if ((flags & PdfFormField.FF_RADIO) == 0) {
                for (int idx = 0; idx < item.values.size(); ++idx) {
                    ((PdfDictionary)item.values.get(idx)).put(PdfName.V, v);
                    markUsed((PdfDictionary)item.values.get(idx));
                    PdfDictionary merged = (PdfDictionary)item.merged.get(idx);
                    merged.put(PdfName.V, v);
                    merged.put(PdfName.AS, v);
                    PdfDictionary widget = (PdfDictionary)item.widgets.get(idx);
                    if (isInAP(widget,  v))
                        widget.put(PdfName.AS, v);
                    else
                        widget.put(PdfName.AS, PdfName.Off);
                    markUsed(widget);
                }
            }
            else {
                ArrayList lopt = new ArrayList();
                PdfObject opts = PdfReader.getPdfObject(((PdfDictionary)item.values.get(0)).get(PdfName.OPT));
                if (opts != null && opts.isArray()) {
                    ArrayList list = ((PdfArray)opts).getArrayList();
                    for (int k = 0; k < list.size(); ++k) {
                        PdfObject vv = PdfReader.getPdfObject((PdfObject)list.get(k));
                        if (vv != null && vv.isString())
                            lopt.add(((PdfString)vv).toUnicodeString());
                        else
                            lopt.add(null);
                    }
                }
                int vidx = lopt.indexOf(value);
                PdfName valt = null;
                PdfName vt;
                if (vidx >= 0) {
                    vt = valt = new PdfName(String.valueOf(vidx));
                }
                else
                    vt = v;
                for (int idx = 0; idx < item.values.size(); ++idx) {
                    PdfDictionary merged = (PdfDictionary)item.merged.get(idx);
                    PdfDictionary widget = (PdfDictionary)item.widgets.get(idx);
                    markUsed((PdfDictionary)item.values.get(idx));
                    if (valt != null) {
                        PdfString ps = new PdfString(value, PdfObject.TEXT_UNICODE);
                        ((PdfDictionary)item.values.get(idx)).put(PdfName.V, ps);
                        merged.put(PdfName.V, ps);
                    }
                    else {
                        ((PdfDictionary)item.values.get(idx)).put(PdfName.V, v);
                        merged.put(PdfName.V, v);
                    }
                    markUsed(widget);
                    if (isInAP(widget,  vt)) {
                        merged.put(PdfName.AS, vt);
                        widget.put(PdfName.AS, vt);
                    }
                    else {
                        merged.put(PdfName.AS, PdfName.Off);
                        widget.put(PdfName.AS, PdfName.Off);
                    }
                }
            }
            return true;
        }
        return false;
    }
    
    boolean isInAP(PdfDictionary dic, PdfName check) {
        PdfDictionary appDic = (PdfDictionary)PdfReader.getPdfObject(dic.get(PdfName.AP));
        if (appDic == null)
            return false;
        PdfDictionary NDic = (PdfDictionary)PdfReader.getPdfObject(appDic.get(PdfName.N));
        return (NDic != null && NDic.get(check) != null);
    }
    
    /** Gets all the fields. The fields are keyed by the fully qualified field name and
     * the value is an instance of <CODE>AcroFields.Item</CODE>.
     * @return all the fields
     */    
    public HashMap getFields() {
        return fields;
    }
    
    /**
     * Gets the field structure.
     * @param name the name of the field
     * @return the field structure or <CODE>null</CODE> if the field
     * does not exist
     */    
    public Item getFieldItem(String name) {
        return (Item)fields.get(name);
    }
    
    /**
     * Gets the field box positions in the document. The return is an array of <CODE>float</CODE>
     * multiple of 5. For each of this groups the values are: [page, llx, lly, urx,
     * ury].
     * @param name the field name
     * @return the positions or <CODE>null</CODE> if field does not exist
     */    
    public float[] getFieldPositions(String name) {
        Item item = (Item)fields.get(name);
        if (item == null)
            return null;
        float ret[] = new float[item.page.size() * 5];
        int ptr = 0;
        for (int k = 0; k < item.page.size(); ++k) {
            try {
                PdfDictionary wd = (PdfDictionary)item.widgets.get(k);
                PdfArray rect = (PdfArray)wd.get(PdfName.RECT);
                if (rect == null)
                    continue;
                Rectangle r = PdfReader.getNormalizedRectangle(rect);
                ret[ptr] = ((Integer)item.page.get(k)).floatValue();
                ++ptr;
                ret[ptr++] = r.left();
                ret[ptr++] = r.bottom();
                ret[ptr++] = r.right();
                ret[ptr++] = r.top();
            }
            catch (Exception e) {
                // empty on purpose
            }
        }
        if (ptr < ret.length) {
            float ret2[] = new float[ptr];
            System.arraycopy(ret, 0, ret2, 0, ptr);
            return ret2;
        }
        return ret;
    }
    
    private int removeRefFromArray(PdfArray array, PdfObject refo) {
        ArrayList ar = array.getArrayList();
        if (refo == null || !refo.isIndirect())
            return ar.size();
        PdfIndirectReference ref = (PdfIndirectReference)refo;
        for (int j = 0; j < ar.size(); ++j) {
            PdfObject obj = (PdfObject)ar.get(j);
            if (!obj.isIndirect())
                continue;
            if (((PdfIndirectReference)obj).getNumber() == ref.getNumber())
                ar.remove(j--);
        }
        return ar.size();
    }
    
    /**
     * Removes all the fields from <CODE>page</CODE>.
     * @param page the page to remove the fields from
     * @return <CODE>true</CODE> if any field was removed, <CODE>false otherwise</CODE>
     */    
    public boolean removeFieldsFromPage(int page) {
        if (page < 1)
            return false;
        String names[] = new String[fields.size()];
        fields.keySet().toArray(names);
        boolean found = false;
        for (int k = 0; k < names.length; ++k) {
            boolean fr = removeField(names[k], page);
            found = (found || fr);
        }
        return found;
    }
    
    /**
     * Removes a field from the document. If page equals -1 all the fields with this
     * <CODE>name</CODE> are removed from the document otherwise only the fields in
     * that particular page are removed.
     * @param name the field name
     * @param page the page to remove the field from or -1 to remove it from all the pages
     * @return <CODE>true</CODE> if the field exists, <CODE>false otherwise</CODE>
     */    
    public boolean removeField(String name, int page) {
        Item item = (Item)fields.get(name);
        if (item == null)
            return false;
        PdfDictionary acroForm = (PdfDictionary)PdfReader.getPdfObject(reader.getCatalog().get(PdfName.ACROFORM), reader.getCatalog());
        
        if (acroForm == null)
            return false;
        PdfArray arrayf = (PdfArray)PdfReader.getPdfObject(acroForm.get(PdfName.FIELDS), acroForm);
        if (arrayf == null)
            return false;
        for (int k = 0; k < item.widget_refs.size(); ++k) {
            int pageV = ((Integer)item.page.get(k)).intValue();
            if (page != -1 && page != pageV)
                continue;
            PdfIndirectReference ref = (PdfIndirectReference)item.widget_refs.get(k);
            PdfDictionary wd = (PdfDictionary)PdfReader.getPdfObject(ref);
            PdfDictionary pageDic = reader.getPageN(pageV);
            PdfArray annots = (PdfArray)PdfReader.getPdfObject(pageDic.get(PdfName.ANNOTS), pageDic);
            if (annots != null) {
                if (removeRefFromArray(annots, ref) == 0) {
                    pageDic.remove(PdfName.ANNOTS);
                    markUsed(pageDic);
                }
                else
                    markUsed(annots);
            }
            PdfReader.killIndirect(ref);
            PdfIndirectReference kid = ref;
            while ((ref = (PdfIndirectReference)wd.get(PdfName.PARENT)) != null) {
                wd = (PdfDictionary)PdfReader.getPdfObject(ref);
                PdfArray kids = (PdfArray)PdfReader.getPdfObject(wd.get(PdfName.KIDS));
                if (removeRefFromArray(kids, kid) != 0)
                    break;
                kid = ref;
                PdfReader.killIndirect(ref);
            }
            if (ref == null) {
                removeRefFromArray(arrayf, kid);
                markUsed(arrayf);
            }
            if (page != -1) {
                item.merged.remove(k);
                item.page.remove(k);
                item.values.remove(k);
                item.widget_refs.remove(k);
                item.widgets.remove(k);
                --k;
            }
        }
        if (page == -1 || item.merged.size() == 0)
            fields.remove(name);
        return true;
    }
    
    /**
     * Removes a field from the document.
     * @param name the field name
     * @return <CODE>true</CODE> if the field exists, <CODE>false otherwise</CODE>
     */    
    public boolean removeField(String name) {
        return removeField(name, -1);
    }
    
    /** Gets the property generateAppearances.
     * @return the property generateAppearances
     */
    public boolean isGenerateAppearances() {
        return this.generateAppearances;
    }
    
    /** Sets the option to generate appearances. Not generating apperances
     * will speed-up form filling but the results can be
     * unexpected in Acrobat. Don't use it unless your environment is well
     * controlled. The default is <CODE>true</CODE>.
     * @param generateAppearances the option to generate appearances
     */
    public void setGenerateAppearances(boolean generateAppearances) {
        this.generateAppearances = generateAppearances;
        PdfDictionary top = (PdfDictionary)PdfReader.getPdfObject(reader.getCatalog().get(PdfName.ACROFORM));
        if (generateAppearances)
            top.remove(PdfName.NEEDAPPEARANCES);
        else
            top.put(PdfName.NEEDAPPEARANCES, PdfBoolean.PDFTRUE);
    }
    
    /** The field representations for retrieval and modification. */    
    public static class Item {
        /** An array of <CODE>PdfDictionary</CODE> where the value tag /V
         * is present.
         */        
        public ArrayList values = new ArrayList();
        /** An array of <CODE>PdfDictionary</CODE> with the widgets.
         */        
        public ArrayList widgets = new ArrayList();
        /** An array of <CODE>PdfDictionary</CODE> with the widget references.
         */
        public ArrayList widget_refs = new ArrayList();
        /** An array of <CODE>PdfDictionary</CODE> with all the field
         * and widget tags merged.
         */        
        public ArrayList merged = new ArrayList();
        /** An array of <CODE>Integer</CODE> with the page numbers where
         * the widgets are displayed.
         */        
        public ArrayList page = new ArrayList();
        /** An array of <CODE>Integer</CODE> with the tab order of the field in the page.
         */        
        public ArrayList tabOrder = new ArrayList();
    }
    
    private static class InstHit {
        IntHashtable hits;
        public InstHit(int inst[]) {
            if (inst == null)
                return;
            hits = new IntHashtable();
            for (int k = 0; k < inst.length; ++k)
                hits.put(inst[k], 1);
        }
        
        public boolean isHit(int n) {
            if (hits == null)
                return true;
            return hits.containsKey(n);
        }
    }
    
    /**
     * Gets the field names that have signatures and are signed.
     * @return the field names that have signatures and are signed
     */    
    public ArrayList getSignatureNames() {
        if (sigNames != null)
            return new ArrayList(sigNames.keySet());
        sigNames = new HashMap();
        ArrayList sorter = new ArrayList();
        for (Iterator it = fields.entrySet().iterator(); it.hasNext();) {
            Map.Entry entry = (Map.Entry)it.next();
            Item item = (Item)entry.getValue();
            PdfDictionary merged = (PdfDictionary)item.merged.get(0);
            if (!PdfName.SIG.equals(merged.get(PdfName.FT)))
                continue;
            PdfObject vo = PdfReader.getPdfObject(merged.get(PdfName.V));
            if (vo == null || vo.type() != PdfObject.DICTIONARY)
                continue;
            PdfDictionary v = (PdfDictionary)vo;
            PdfObject contents = v.get(PdfName.CONTENTS);
            if (contents == null || contents.type() != PdfObject.STRING)
                continue;
            PdfObject ro = v.get(PdfName.BYTERANGE);
            if (ro == null || ro.type() != PdfObject.ARRAY)
                continue;
            ArrayList ra = ((PdfArray)ro).getArrayList();
            if (ra.size() < 2)
                continue;
            int length = ((PdfNumber)ra.get(ra.size() - 1)).intValue() + ((PdfNumber)ra.get(ra.size() - 2)).intValue();
            sorter.add(new Object[]{entry.getKey(), new int[]{length, 0}});
        }
        Collections.sort(sorter, new AcroFields.SorterComparator());
        if (sorter.size() > 0) {
            if (((int[])((Object[])sorter.get(sorter.size() - 1))[1])[0] == reader.getFileLength())
                totalRevisions = sorter.size();
            else
                totalRevisions = sorter.size() + 1;
            for (int k = 0; k < sorter.size(); ++k) {
                Object objs[] = (Object[])sorter.get(k);
                String name = (String)objs[0];
                int p[] = (int[])objs[1];
                p[1] = k + 1;
                sigNames.put(name, p);
            }
        }
        return new ArrayList(sigNames.keySet());
    }
    
    /**
     * Gets the field names that have blank signatures.
     * @return the field names that have blank signatures
     */    
    public ArrayList getBlankSignatureNames() {
        getSignatureNames();
        ArrayList sigs = new ArrayList();
        for (Iterator it = fields.entrySet().iterator(); it.hasNext();) {
            Map.Entry entry = (Map.Entry)it.next();
            Item item = (Item)entry.getValue();
            PdfDictionary merged = (PdfDictionary)item.merged.get(0);
            if (!PdfName.SIG.equals(merged.get(PdfName.FT)))
                continue;
            if (sigNames.containsKey(entry.getKey()))
                continue;
            sigs.add(entry.getKey());
        }
        return sigs;
    }
    
    /**
     * Gets the signature dictionary, the one keyed by /V.
     * @param name the field name
     * @return the signature dictionary keyed by /V or <CODE>null</CODE> if the field is not
     * a signature
     */    
    public PdfDictionary getSignatureDictionary(String name) {
        getSignatureNames();
        if (!sigNames.containsKey(name))
            return null;
        Item item = (Item)fields.get(name);
        PdfDictionary merged = (PdfDictionary)item.merged.get(0);
        // PdfObject vo = PdfReader.getPdfObject(merged.get(PdfName.V));
        return (PdfDictionary)PdfReader.getPdfObject(merged.get(PdfName.V));
    }
    
    /**
     * Checks is the signature covers the entire document or just part of it.
     * @param name the signature field name
     * @return <CODE>true</CODE> if the signature covers the entire document,
     * <CODE>false</CODE> otherwise
     */    
    public boolean signatureCoversWholeDocument(String name) {
        getSignatureNames();
        if (!sigNames.containsKey(name))
            return false;
        return ((int[])sigNames.get(name))[0] == reader.getFileLength();
    }
    
    /**
     * Verifies a signature. An example usage is:
     * <p>
     * <pre>
     * KeyStore kall = PdfPKCS7.loadCacertsKeyStore();
     * PdfReader reader = new PdfReader("my_signed_doc.pdf");
     * AcroFields af = reader.getAcroFields();
     * ArrayList names = af.getSignatureNames();
     * for (int k = 0; k &lt; names.size(); ++k) {
     *    String name = (String)names.get(k);
     *    System.out.println("Signature name: " + name);
     *    System.out.println("Signature covers whole document: " + af.signatureCoversWholeDocument(name));
     *    PdfPKCS7 pk = af.verifySignature(name);
     *    Calendar cal = pk.getSignDate();
     *    Certificate pkc[] = pk.getCertificates();
     *    System.out.println("Subject: " + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));
     *    System.out.println("Document modified: " + !pk.verify());
     *    Object fails[] = PdfPKCS7.verifyCertificates(pkc, kall, null, cal);
     *    if (fails == null)
     *        System.out.println("Certificates verified against the KeyStore");
     *    else
     *        System.out.println("Certificate failed: " + fails[1]);
     * }
     * </pre>
     * @param name the signature field name
     * @return a <CODE>PdfPKCS7</CODE> class to continue the verification
     */    
    public PdfPKCS7 verifySignature(String name) {
        return verifySignature(name, null);
    }
    
    /**
     * Verifies a signature. An example usage is:
     * <p>
     * <pre>
     * KeyStore kall = PdfPKCS7.loadCacertsKeyStore();
     * PdfReader reader = new PdfReader("my_signed_doc.pdf");
     * AcroFields af = reader.getAcroFields();
     * ArrayList names = af.getSignatureNames();
     * for (int k = 0; k &lt; names.size(); ++k) {
     *    String name = (String)names.get(k);
     *    System.out.println("Signature name: " + name);
     *    System.out.println("Signature covers whole document: " + af.signatureCoversWholeDocument(name));
     *    PdfPKCS7 pk = af.verifySignature(name);
     *    Calendar cal = pk.getSignDate();
     *    Certificate pkc[] = pk.getCertificates();
     *    System.out.println("Subject: " + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));
     *    System.out.println("Document modified: " + !pk.verify());
     *    Object fails[] = PdfPKCS7.verifyCertificates(pkc, kall, null, cal);
     *    if (fails == null)
     *        System.out.println("Certificates verified against the KeyStore");
     *    else
     *        System.out.println("Certificate failed: " + fails[1]);
     * }
     * </pre>
     * @param name the signature field name
     * @param provider the provider or <code>null</code> for the default provider
     * @return a <CODE>PdfPKCS7</CODE> class to continue the verification
     */    
    public PdfPKCS7 verifySignature(String name, String provider) {
        PdfDictionary v = getSignatureDictionary(name);
        if (v == null)
            return null;
        try {
            PdfName sub = (PdfName)PdfReader.getPdfObject(v.get(PdfName.SUBFILTER));
            PdfString contents = (PdfString)PdfReader.getPdfObject(v.get(PdfName.CONTENTS));
            PdfPKCS7 pk = null;
            if (sub.equals(PdfName.ADBE_X509_RSA_SHA1)) {
                PdfString cert = (PdfString)PdfReader.getPdfObject(v.get(PdfName.CERT));
                pk = new PdfPKCS7(contents.getOriginalBytes(), cert.getBytes(), provider);
            }
            else
                pk = new PdfPKCS7(contents.getOriginalBytes(), provider);
            updateByteRange(pk, v);
            PdfString str = (PdfString)PdfReader.getPdfObject(v.get(PdfName.M));
            if (str != null)
                pk.setSignDate(PdfDate.decode(str.toString()));
            str = (PdfString)PdfReader.getPdfObject(v.get(PdfName.NAME));
            if (str != null)
                pk.setSignName(str.toUnicodeString());
            str = (PdfString)PdfReader.getPdfObject(v.get(PdfName.REASON));
            if (str != null)
                pk.setReason(str.toUnicodeString());
            str = (PdfString)PdfReader.getPdfObject(v.get(PdfName.LOCATION));
            if (str != null)
                pk.setLocation(str.toUnicodeString());
            return pk;
        }
        catch (Exception e) {
            throw new ExceptionConverter(e);
        }
    }
    
    private void updateByteRange(PdfPKCS7 pkcs7, PdfDictionary v) throws IOException {
        PdfArray b = (PdfArray)PdfReader.getPdfObject(v.get(PdfName.BYTERANGE));
        RandomAccessFileOrArray rf = reader.getSafeFile();
        try {
            rf.reOpen();
            byte buf[] = new byte[8192];
            ArrayList ar = b.getArrayList();
            for (int k = 0; k < ar.size(); ++k) {
                int start = ((PdfNumber)ar.get(k)).intValue();
                int length = ((PdfNumber)ar.get(++k)).intValue();
                rf.seek(start);
                while (length > 0) {
                    int rd = rf.read(buf, 0, Math.min(length, buf.length));
                    if (rd <= 0)
                        break;
                    length -= rd;
                    pkcs7.update(buf, 0, rd);
                }
            }
        }
        catch (Exception e) {
            throw new ExceptionConverter(e);
        }
        finally {
            try{rf.close();}catch(Exception e){}
        }
    }

    private void markUsed(PdfObject obj) {
        if (!append)
            return;
        ((PdfStamperImp)writer).markUsed(obj);
    }
    
    /**
     * Gets the total number of revisions this document has.
     * @return the total number of revisions
     */
    public int getTotalRevisions() {
        getSignatureNames();
        return this.totalRevisions;
    }
    
    /**
     * Gets this <CODE>field</CODE> revision.
     * @param field the signature field name
     * @return the revision or zero if it's not a signature field
     */    
    public int getRevision(String field) {
        getSignatureNames();
        if (!sigNames.containsKey(field))
            return 0;
        return ((int[])sigNames.get(field))[1];
    }
    
    /**
     * Extracts a revision from the document.
     * @param field the signature field name
     * @return an <CODE>InputStream</CODE> covering the revision. Returns <CODE>null</CODE> if
     * it's not a signature field
     * @throws IOException on error
     */    
    public InputStream extractRevision(String field) throws IOException {
        getSignatureNames();
        int length = ((int[])sigNames.get(field))[0];
        RandomAccessFileOrArray raf = reader.getSafeFile();
        raf.reOpen();
        raf.seek(0);
        return new RevisionStream(raf, length);
    }

    /**
     * Gets the appearances cache.
     * @return the appearances cache
     */
    public HashMap getFieldCache() {
        return this.fieldCache;
    }
    
    /**
     * Sets a cache for field appearances. Parsing the existing PDF to
     * create a new TextField is time expensive. For those tasks that repeatedly
     * fill the same PDF with different field values the use of the cache has dramatic
     * speed advantages. An example usage:
     * <p>
     * <pre>
     * String pdfFile = ...;// the pdf file used as template
     * ArrayList xfdfFiles = ...;// the xfdf file names
     * ArrayList pdfOutFiles = ...;// the output file names, one for each element in xpdfFiles
     * HashMap cache = new HashMap();// the appearances cache
     * PdfReader originalReader = new PdfReader(pdfFile);
     * for (int k = 0; k &lt; xfdfFiles.size(); ++k) {
     *    PdfReader reader = new PdfReader(originalReader);
     *    XfdfReader xfdf = new XfdfReader((String)xfdfFiles.get(k));
     *    PdfStamper stp = new PdfStamper(reader, new FileOutputStream((String)pdfOutFiles.get(k)));
     *    AcroFields af = stp.getAcroFields();
     *    af.setFieldCache(cache);
     *    af.setFields(xfdf);
     *    stp.close();
     * }
     * </pre>
     * @param fieldCache an HasMap that will carry the cached appearances
     */
    public void setFieldCache(HashMap fieldCache) {
        this.fieldCache = fieldCache;
    }
    
    /**
     * Sets extra margins in text fields to better mimic the Acrobat layout.
     * @param extraMarginLeft the extra marging left
     * @param extraMarginTop the extra margin top
     */    
    public void setExtraMargin(float extraMarginLeft, float extraMarginTop) {
        this.extraMarginLeft = extraMarginLeft;
        this.extraMarginTop = extraMarginTop;
    }

    private static final HashMap stdFieldFontNames = new HashMap();
    
    /**
     * Holds value of property totalRevisions.
     */
    private int totalRevisions;
    
    /**
     * Holds value of property fieldCache.
     */
    private HashMap fieldCache;
    
    static {
        stdFieldFontNames.put("CoBO", new String[]{"Courier-BoldOblique"});
        stdFieldFontNames.put("CoBo", new String[]{"Courier-Bold"});
        stdFieldFontNames.put("CoOb", new String[]{"Courier-Oblique"});
        stdFieldFontNames.put("Cour", new String[]{"Courier"});
        stdFieldFontNames.put("HeBO", new String[]{"Helvetica-BoldOblique"});
        stdFieldFontNames.put("HeBo", new String[]{"Helvetica-Bold"});
        stdFieldFontNames.put("HeOb", new String[]{"Helvetica-Oblique"});
        stdFieldFontNames.put("Helv", new String[]{"Helvetica"});
        stdFieldFontNames.put("Symb", new String[]{"Symbol"});
        stdFieldFontNames.put("TiBI", new String[]{"Times-BoldItalic"});
        stdFieldFontNames.put("TiBo", new String[]{"Times-Bold"});
        stdFieldFontNames.put("TiIt", new String[]{"Times-Italic"});
        stdFieldFontNames.put("TiRo", new String[]{"Times-Roman"});
        stdFieldFontNames.put("ZaDb", new String[]{"ZapfDingbats"});
        stdFieldFontNames.put("HySm", new String[]{"HYSMyeongJo-Medium", "UniKS-UCS2-H"});
        stdFieldFontNames.put("HyGo", new String[]{"HYGoThic-Medium", "UniKS-UCS2-H"});
        stdFieldFontNames.put("KaGo", new String[]{"HeiseiKakuGo-W5", "UniKS-UCS2-H"});
        stdFieldFontNames.put("KaMi", new String[]{"HeiseiMin-W3", "UniJIS-UCS2-H"});
        stdFieldFontNames.put("MHei", new String[]{"MHei-Medium", "UniCNS-UCS2-H"});
        stdFieldFontNames.put("MSun", new String[]{"MSung-Light", "UniCNS-UCS2-H"});
        stdFieldFontNames.put("STSo", new String[]{"STSong-Light", "UniGB-UCS2-H"});
    }

    private static class RevisionStream extends InputStream {
        private byte b[] = new byte[1];
        private RandomAccessFileOrArray raf;
        private int length;
        private int rangePosition = 0;
        private boolean closed;
        
        private RevisionStream(RandomAccessFileOrArray raf, int length) {
            this.raf = raf;
            this.length = length;
        }
        
        public int read() throws IOException {
            int n = read(b);
            if (n != 1)
                return -1;
            return b[0] & 0xff;
        }
        
        public int read(byte[] b, int off, int len) throws IOException {
            if (b == null) {
                throw new NullPointerException();
            } else if ((off < 0) || (off > b.length) || (len < 0) ||
            ((off + len) > b.length) || ((off + len) < 0)) {
                throw new IndexOutOfBoundsException();
            } else if (len == 0) {
                return 0;
            }
            if (rangePosition >= length) {
                close();
                return -1;
            }
            int elen = Math.min(len, length - rangePosition);
            raf.readFully(b, off, elen);
            rangePosition += elen;
            return elen;
        }
        
        public void close() throws IOException {
            if (!closed) {
                raf.close();
                closed = true;
            }
        }
    }
    
    private static class SorterComparator implements Comparator {        
        public int compare(Object o1, Object o2) {
            int n1 = ((int[])((Object[])o1)[1])[0];
            int n2 = ((int[])((Object[])o2)[1])[0];
            return n1 - n2;
        }        
    }
}
 /*
 * Copyright 2003 by Paulo Soares.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */
package pdftk.com.lowagie.text.pdf;

/** Shape arabic characters. This code was converted from a C version
 * at www.pango.org.
 *
 * @author Paulo Soares (psoares@consiste.pt)
 */
public class ArabicLigaturizer {
    
    static boolean isVowel(char s) {
        return ((s >= 0x064B) && (s <= 0x0655)) || (s == 0x0670);
    }

    static char charshape(char s, int which)
    /* which 0=isolated 1=final 2=initial 3=medial */
    {
        int l, r, m;
        if ((s >= 0x0621) && (s <= 0x06D3)) {
            l = 0;
            r = chartable.length - 1;
            while (l <= r) {
                m = (l + r) / 2;
                if (s == chartable[m][0]) {
                    return chartable[m][which + 1];
                }
                else if (s < chartable[m][0]) {
                    r = m - 1;
                }
                else {
                    l = m + 1;
                }
            }
        }
        else if (s >= 0xfef5 && s <= 0xfefb)
            return (char)(s + which);
        return s;
    }

    static int shapecount(char s) {
        int l, r, m;
        if ((s >= 0x0621) && (s <= 0x06D3) && !isVowel(s)) {
            l = 0;
            r = chartable.length - 1;
            while (l <= r) {
                m = (l + r) / 2;
                if (s == chartable[m][0]) {
                    return chartable[m].length - 1;
                }
                else if (s < chartable[m][0]) {
                    r = m - 1;
                }
                else {
                    l = m + 1;
                }
            }
        }
        else if (s == ZWJ) {
            return 4;
        }
        return 1;
    }
    
    static int ligature(char newchar, charstruct oldchar) {
    /* 0 == no ligature possible; 1 == vowel; 2 == two chars; 3 == Lam+Alef */
        int retval = 0;
        
        if (oldchar.basechar == 0)
            return 0;
        if (isVowel(newchar)) {
            retval = 1;
            if ((oldchar.vowel != 0) && (newchar != SHADDA)) {
                retval = 2;           /* we eliminate the old vowel .. */
            }
            switch (newchar) {
                case SHADDA:
                    if (oldchar.mark1 == 0) {
                        oldchar.mark1 = SHADDA;
                    }
                    else {
                        return 0;         /* no ligature possible */
                    }
                    break;
                case HAMZABELOW:
                    switch (oldchar.basechar) {
                        case ALEF:
                            oldchar.basechar = ALEFHAMZABELOW;
                            retval = 2;
                            break;
                        case LAM_ALEF:
                            oldchar.basechar = LAM_ALEFHAMZABELOW;
                            retval = 2;
                            break;
                        default:
                            oldchar.mark1 = HAMZABELOW;
                            break;
                    }
                    break;
                case HAMZAABOVE:
                    switch (oldchar.basechar) {
                        case ALEF:
                            oldchar.basechar = ALEFHAMZA;
                            retval = 2;
                            break;
                        case LAM_ALEF:
                            oldchar.basechar = LAM_ALEFHAMZA;
                            retval = 2;
                            break;
                        case WAW:
                            oldchar.basechar = WAWHAMZA;
                            retval = 2;
                            break;
                        case YEH:
                        case ALEFMAKSURA:
                        case FARSIYEH:
                            oldchar.basechar = YEHHAMZA;
                            retval = 2;
                            break;
                        default:           /* whatever sense this may make .. */
                            oldchar.mark1 = HAMZAABOVE;
                            break;
                    }
                    break;
                case MADDA:
                    switch (oldchar.basechar) {
                        case ALEF:
                            oldchar.basechar = ALEFMADDA;
                            retval = 2;
                            break;
                    }
                    break;
                default:
                    oldchar.vowel = newchar;
                    break;
            }
            if (retval == 1) {
                oldchar.lignum++;
            }
            return retval;
        }
        if (oldchar.vowel != 0) {  /* if we already joined a vowel, we can't join a Hamza */
            return 0;
        }
        
        switch (oldchar.basechar) {
            case LAM:
                switch (newchar) {
                    case ALEF:
                        oldchar.basechar = LAM_ALEF;
                        oldchar.numshapes = 2;
                        retval = 3;
                        break;
                    case ALEFHAMZA:
                        oldchar.basechar = LAM_ALEFHAMZA;
                        oldchar.numshapes = 2;
                        retval = 3;
                        break;
                    case ALEFHAMZABELOW:
                        oldchar.basechar = LAM_ALEFHAMZABELOW;
                        oldchar.numshapes = 2;
                        retval = 3;
                        break;
                    case ALEFMADDA:
                        oldchar.basechar = LAM_ALEFMADDA;
                        oldchar.numshapes = 2;
                        retval = 3;
                        break;
                }
                break;
            case 0:
                oldchar.basechar = newchar;
                oldchar.numshapes = shapecount(newchar);
                retval = 1;
                break;
        }
        return retval;
    }
    
    static void copycstostring(StringBuffer string, charstruct s, int level) {
    /* s is a shaped charstruct; i is the index into the string */
        if (s.basechar == 0)
            return;
        
        string.append(s.basechar);
        s.lignum--;
        if (s.mark1 != 0) {
            if ((level & ar_novowel) == 0) {
                string.append(s.mark1);
                s.lignum--;
            }
            else {
                s.lignum--;
            }
        }
        if (s.vowel != 0) {
            if ((level & ar_novowel) == 0) {
                string.append(s.vowel);
                s.lignum--;
            }
            else {                       /* vowel elimination */
                s.lignum--;
            }
        }
//        while (s.lignum > 0) {                           /* NULL-insertion for Langbox-font */
//            string[i] = 0;
//            i++;
//            (s.lignum)--;
//        }
//        return i;
    }

    // return len
    static void doublelig(StringBuffer string, int level)
    /* Ok. We have presentation ligatures in our font. */
    {
        int len;
        int olen = len = string.length();
        int j = 0, si = 1;
        char lapresult;
        
        while (si < olen) {
            lapresult = 0;
            if ((level & ar_composedtashkeel) != 0) {
                switch (string.charAt(j)) {
                    case SHADDA:
                        switch (string.charAt(si)) {
                            case KASRA:
                                lapresult = 0xFC62;
                                break;
                            case FATHA:
                                lapresult = 0xFC60;
                                break;
                            case DAMMA:
                                lapresult = 0xFC61;
                                break;
                            case 0x064C:
                                lapresult = 0xFC5E;
                                break;
                            case 0x064D:
                                lapresult = 0xFC5F;
                                break;
                        }
                        break;
                    case KASRA:
                        if (string.charAt(si) == SHADDA)
                            lapresult = 0xFC62;
                        break;
                    case FATHA:
                        if (string.charAt(si) == SHADDA)
                            lapresult = 0xFC60;
                        break;
                    case DAMMA:
                        if (string.charAt(si) == SHADDA)
                            lapresult = 0xFC61;
                        break;
                }
            }
            
            if ((level & ar_lig) != 0) {
                switch (string.charAt(j)) {
                    case 0xFEDF:       /* LAM initial */
                        switch (string.charAt(si)) {
                            case 0xFE9E:
                                lapresult = 0xFC3F;
                                break;        /* JEEM final */
                            case 0xFEA0:
                                lapresult = 0xFCC9;
                                break;        /* JEEM medial */
                            case 0xFEA2:
                                lapresult = 0xFC40;
                                break;        /* HAH final */
                            case 0xFEA4:
                                lapresult = 0xFCCA;
                                break;        /* HAH medial */
                            case 0xFEA6:
                                lapresult = 0xFC41;
                                break;        /* KHAH final */
                            case 0xFEA8:
                                lapresult = 0xFCCB;
                                break;        /* KHAH medial */
                            case 0xFEE2:
                                lapresult = 0xFC42;
                                break;        /* MEEM final */
                            case 0xFEE4:
                                lapresult = 0xFCCC;
                                break;        /* MEEM medial */
                        }
                        break;
                    case 0xFE97:       /* TEH inital */
                        switch (string.charAt(si)) {
                            case 0xFEA0:
                                lapresult = 0xFCA1;
                                break;        /* JEEM medial */
                            case 0xFEA4:
                                lapresult = 0xFCA2;
                                break;        /* HAH medial */
                            case 0xFEA8:
                                lapresult = 0xFCA3;
                                break;        /* KHAH medial */
                        }
                        break;
                    case 0xFE91:       /* BEH inital */
                        switch (string.charAt(si)) {
                            case 0xFEA0:
                                lapresult = 0xFC9C;
                                break;        /* JEEM medial */
                            case 0xFEA4:
                                lapresult = 0xFC9D;
                                break;        /* HAH medial */
                            case 0xFEA8:
                                lapresult = 0xFC9E;
                                break;        /* KHAH medial */
                        }
                        break;
                    case 0xFEE7:       /* NOON inital */
                        switch (string.charAt(si)) {
                            case 0xFEA0:
                                lapresult = 0xFCD2;
                                break;        /* JEEM initial */
                            case 0xFEA4:
                                lapresult = 0xFCD3;
                                break;        /* HAH medial */
                            case 0xFEA8:
                                lapresult = 0xFCD4;
                                break;        /* KHAH medial */
                        }
                        break;
                        
                    case 0xFEE8:       /* NOON medial */
                        switch (string.charAt(si)) {
                            case 0xFEAE:
                                lapresult = 0xFC8A;
                                break;        /* REH final  */
                            case 0xFEB0:
                                lapresult = 0xFC8B;
                                break;        /* ZAIN final */
                        }
                        break;
                    case 0xFEE3:       /* MEEM initial */
                        switch (string.charAt(si)) {
                            case 0xFEA0:
                                lapresult = 0xFCCE;
                                break;        /* JEEM medial */
                            case 0xFEA4:
                                lapresult = 0xFCCF;
                                break;        /* HAH medial */
                            case 0xFEA8:
                                lapresult = 0xFCD0;
                                break;        /* KHAH medial */
                            case 0xFEE4:
                                lapresult = 0xFCD1;
                                break;        /* MEEM medial */
                        }
                        break;
                        
                    case 0xFED3:       /* FEH initial */
                        switch (string.charAt(si)) {
                            case 0xFEF2:
                                lapresult = 0xFC32;
                                break;        /* YEH final */
                        }
                        break;
                        
                    default:
                        break;
                }                   /* end switch string[si] */
            }
            if (lapresult != 0) {
                string.setCharAt(j, lapresult);
                len--;
                si++;                 /* jump over one character */
                /* we'll have to change this, too. */
            }
            else {
                j++;
                string.setCharAt(j, string.charAt(si));
                si++;
            }
        }
        string.setLength(len);
    }

    static boolean connects_to_left(charstruct a) {
        return a.numshapes > 2;
    }
    
    static void shape(char text[], StringBuffer string, int level) {
  /* string is assumed to be empty and big enough.
   * text is the original text.
   * This routine does the basic arabic reshaping.
   * *len the number of non-null characters.
   *
   * Note: We have to unshape each character first!
   */
        int join;
        int which;
        char nextletter;
        
        int p = 0;                     /* initialize for output */
        charstruct oldchar = new charstruct();
        charstruct curchar = new charstruct();
        while (p < text.length) {
            nextletter = text[p++];
            //nextletter = unshape (nextletter);
            
            join = ligature(nextletter, curchar);
            if (join == 0) {                       /* shape curchar */
                int nc = shapecount(nextletter);
                //(*len)++;
                if (nc == 1) {
                    which = 0;        /* final or isolated */
                }
                else {
                    which = 2;        /* medial or initial */
                }
                if (connects_to_left(oldchar)) {
                    which++;
                }
                
                which = which % (curchar.numshapes);
                curchar.basechar = charshape(curchar.basechar, which);
                
                /* get rid of oldchar */
                copycstostring(string, oldchar, level);
                oldchar = curchar;    /* new values in oldchar */
                
                /* init new curchar */
                curchar = new charstruct();
                curchar.basechar = nextletter;
                curchar.numshapes = nc;
                curchar.lignum++;
                //          (*len) += unligature (&curchar, level);
            }
            else if (join == 1) {
            }
            //      else
            //        {
            //          (*len) += unligature (&curchar, level);
            //        }
            //      p = g_utf8_next_char (p);
        }
        
        /* Handle last char */
        if (connects_to_left(oldchar))
            which = 1;
        else
            which = 0;
        which = which % (curchar.numshapes);
        curchar.basechar = charshape(curchar.basechar, which);
        
        /* get rid of oldchar */
        copycstostring(string, oldchar, level);
        copycstostring(string, curchar, level);
    }

    static int arabic_shape(char src[], int srcoffset, int srclength, char dest[], int destoffset, int destlength, int level) {
        char str[] = new char[srclength];
        for (int k = srclength + srcoffset - 1; k >= srcoffset; --k)
            str[k - srcoffset] = src[k];
        StringBuffer string = new StringBuffer(srclength);
        shape(str, string, level);
        if ((level & (ar_composedtashkeel | ar_lig)) != 0)
            doublelig(string, level);
//        string.reverse();
        System.arraycopy(string.toString().toCharArray(), 0, dest, destoffset, string.length());
        return string.length();
    }

    static void processNumbers(char text[], int offset, int length, int options) {
        int limit = offset + length;
        if ((options & DIGITS_MASK) != 0) {
            char digitBase = '\u0030'; // European digits
            switch (options & DIGIT_TYPE_MASK) {
                case DIGIT_TYPE_AN:
                    digitBase = '\u0660';  // Arabic-Indic digits
                    break;
                    
                case DIGIT_TYPE_AN_EXTENDED:
                    digitBase = '\u06f0';  // Eastern Arabic-Indic digits (Persian and Urdu)
                    break;
                    
                default:
                    break;
            }
            
            switch (options & DIGITS_MASK) {
                case DIGITS_EN2AN: {
                    int digitDelta = digitBase - '\u0030';
                    for (int i = offset; i < limit; ++i) {
                        char ch = text[i];
                        if (ch <= '\u0039' && ch >= '\u0030') {
                            text[i] += digitDelta;
                        }
                    }
                }
                break;
                
                case DIGITS_AN2EN: {
                    char digitTop = (char)(digitBase + 9);
                    int digitDelta = '\u0030' - digitBase;
                    for (int i = offset; i < limit; ++i) {
                        char ch = text[i];
                        if (ch <= digitTop && ch >= digitBase) {
                            text[i] += digitDelta;
                        }
                    }
                }
                break;
                
                case DIGITS_EN2AN_INIT_LR:
                    shapeToArabicDigitsWithContext(text, 0, length, digitBase, false);
                    break;
                    
                case DIGITS_EN2AN_INIT_AL:
                    shapeToArabicDigitsWithContext(text, 0, length, digitBase, true);
                    break;
                    
                default:
                    break;
            }
        }
    }
    
    static void shapeToArabicDigitsWithContext(char[] dest, int start, int length, char digitBase,  boolean lastStrongWasAL) {
        digitBase -= '0'; // move common adjustment out of loop
 
        int limit = start + length;
        for(int i = start; i < limit; ++i) {
            char ch = dest[i];
            switch (BidiOrder.getDirection(ch)) {
            case BidiOrder.L:
            case BidiOrder.R:
                lastStrongWasAL = false;
                break;
            case BidiOrder.AL:
                lastStrongWasAL = true;
                break;
            case BidiOrder.EN:
                if (lastStrongWasAL && ch <= '\u0039') {
                    dest[i] = (char)(ch + digitBase);
                }
                break;
            default:
                break;
            }
        }
    }

    private static final char ALEF = 0x0627;
    private static final char ALEFHAMZA = 0x0623;
    private static final char ALEFHAMZABELOW = 0x0625;
    private static final char ALEFMADDA = 0x0622;
    private static final char LAM = 0x0644;
    private static final char HAMZA = 0x0621;
    private static final char TATWEEL = 0x0640;
    private static final char ZWJ = 0x200D;

    private static final char HAMZAABOVE = 0x0654;
    private static final char HAMZABELOW = 0x0655;

    private static final char WAWHAMZA = 0x0624;
    private static final char YEHHAMZA = 0x0626;
    private static final char WAW = 0x0648;
    private static final char ALEFMAKSURA = 0x0649;
    private static final char YEH = 0x064A;
    private static final char FARSIYEH = 0x06CC;

    private static final char SHADDA = 0x0651;
    private static final char KASRA = 0x0650;
    private static final char FATHA = 0x064E;
    private static final char DAMMA = 0x064F;
    private static final char MADDA = 0x0653;

    private static final char LAM_ALEF = 0xFEFB;
    private static final char LAM_ALEFHAMZA = 0xFEF7;
    private static final char LAM_ALEFHAMZABELOW = 0xFEF9;
    private static final char LAM_ALEFMADDA = 0xFEF5;

    private static final char chartable[][] = {
        {0x0621, 0xFE80}, /* HAMZA */
        {0x0622, 0xFE81, 0xFE82}, /* ALEF WITH MADDA ABOVE */
        {0x0623, 0xFE83, 0xFE84}, /* ALEF WITH HAMZA ABOVE */
        {0x0624, 0xFE85, 0xFE86}, /* WAW WITH HAMZA ABOVE */
        {0x0625, 0xFE87, 0xFE88}, /* ALEF WITH HAMZA BELOW */
        {0x0626, 0xFE89, 0xFE8A, 0xFE8B, 0xFE8C}, /* YEH WITH HAMZA ABOVE */
        {0x0627, 0xFE8D, 0xFE8E}, /* ALEF */
        {0x0628, 0xFE8F, 0xFE90, 0xFE91, 0xFE92}, /* BEH */
        {0x0629, 0xFE93, 0xFE94}, /* TEH MARBUTA */
        {0x062A, 0xFE95, 0xFE96, 0xFE97, 0xFE98}, /* TEH */
        {0x062B, 0xFE99, 0xFE9A, 0xFE9B, 0xFE9C}, /* THEH */
        {0x062C, 0xFE9D, 0xFE9E, 0xFE9F, 0xFEA0}, /* JEEM */
        {0x062D, 0xFEA1, 0xFEA2, 0xFEA3, 0xFEA4}, /* HAH */
        {0x062E, 0xFEA5, 0xFEA6, 0xFEA7, 0xFEA8}, /* KHAH */
        {0x062F, 0xFEA9, 0xFEAA}, /* DAL */
        {0x0630, 0xFEAB, 0xFEAC}, /* THAL */
        {0x0631, 0xFEAD, 0xFEAE}, /* REH */
        {0x0632, 0xFEAF, 0xFEB0}, /* ZAIN */
        {0x0633, 0xFEB1, 0xFEB2, 0xFEB3, 0xFEB4}, /* SEEN */
        {0x0634, 0xFEB5, 0xFEB6, 0xFEB7, 0xFEB8}, /* SHEEN */
        {0x0635, 0xFEB9, 0xFEBA, 0xFEBB, 0xFEBC}, /* SAD */
        {0x0636, 0xFEBD, 0xFEBE, 0xFEBF, 0xFEC0}, /* DAD */
        {0x0637, 0xFEC1, 0xFEC2, 0xFEC3, 0xFEC4}, /* TAH */
        {0x0638, 0xFEC5, 0xFEC6, 0xFEC7, 0xFEC8}, /* ZAH */
        {0x0639, 0xFEC9, 0xFECA, 0xFECB, 0xFECC}, /* AIN */
        {0x063A, 0xFECD, 0xFECE, 0xFECF, 0xFED0}, /* GHAIN */
        {0x0640, 0x0640, 0x0640, 0x0640, 0x0640}, /* TATWEEL */
        {0x0641, 0xFED1, 0xFED2, 0xFED3, 0xFED4}, /* FEH */
        {0x0642, 0xFED5, 0xFED6, 0xFED7, 0xFED8}, /* QAF */
        {0x0643, 0xFED9, 0xFEDA, 0xFEDB, 0xFEDC}, /* KAF */
        {0x0644, 0xFEDD, 0xFEDE, 0xFEDF, 0xFEE0}, /* LAM */
        {0x0645, 0xFEE1, 0xFEE2, 0xFEE3, 0xFEE4}, /* MEEM */
        {0x0646, 0xFEE5, 0xFEE6, 0xFEE7, 0xFEE8}, /* NOON */
        {0x0647, 0xFEE9, 0xFEEA, 0xFEEB, 0xFEEC}, /* HEH */
        {0x0648, 0xFEED, 0xFEEE}, /* WAW */
        {0x0649, 0xFEEF, 0xFEF0, 0xFBE8, 0xFBE9}, /* ALEF MAKSURA */
        {0x064A, 0xFEF1, 0xFEF2, 0xFEF3, 0xFEF4}, /* YEH */
        {0x0671, 0xFB50, 0xFB51}, /* ALEF WASLA */
        {0x0679, 0xFB66, 0xFB67, 0xFB68, 0xFB69}, /* TTEH */
        {0x067A, 0xFB5E, 0xFB5F, 0xFB60, 0xFB61}, /* TTEHEH */
        {0x067B, 0xFB52, 0xFB53, 0xFB54, 0xFB55}, /* BEEH */
        {0x067E, 0xFB56, 0xFB57, 0xFB58, 0xFB59}, /* PEH */
        {0x067F, 0xFB62, 0xFB63, 0xFB64, 0xFB65}, /* TEHEH */
        {0x0680, 0xFB5A, 0xFB5B, 0xFB5C, 0xFB5D}, /* BEHEH */
        {0x0683, 0xFB76, 0xFB77, 0xFB78, 0xFB79}, /* NYEH */
        {0x0684, 0xFB72, 0xFB73, 0xFB74, 0xFB75}, /* DYEH */
        {0x0686, 0xFB7A, 0xFB7B, 0xFB7C, 0xFB7D}, /* TCHEH */
        {0x0687, 0xFB7E, 0xFB7F, 0xFB80, 0xFB81}, /* TCHEHEH */
        {0x0688, 0xFB88, 0xFB89}, /* DDAL */
        {0x068C, 0xFB84, 0xFB85}, /* DAHAL */
        {0x068D, 0xFB82, 0xFB83}, /* DDAHAL */
        {0x068E, 0xFB86, 0xFB87}, /* DUL */
        {0x0691, 0xFB8C, 0xFB8D}, /* RREH */
        {0x0698, 0xFB8A, 0xFB8B}, /* JEH */
        {0x06A4, 0xFB6A, 0xFB6B, 0xFB6C, 0xFB6D}, /* VEH */
        {0x06A6, 0xFB6E, 0xFB6F, 0xFB70, 0xFB71}, /* PEHEH */
        {0x06A9, 0xFB8E, 0xFB8F, 0xFB90, 0xFB91}, /* KEHEH */
        {0x06AD, 0xFBD3, 0xFBD4, 0xFBD5, 0xFBD6}, /* NG */
        {0x06AF, 0xFB92, 0xFB93, 0xFB94, 0xFB95}, /* GAF */
        {0x06B1, 0xFB9A, 0xFB9B, 0xFB9C, 0xFB9D}, /* NGOEH */
        {0x06B3, 0xFB96, 0xFB97, 0xFB98, 0xFB99}, /* GUEH */
        {0x06BA, 0xFB9E, 0xFB9F}, /* NOON GHUNNA */
        {0x06BB, 0xFBA0, 0xFBA1, 0xFBA2, 0xFBA3}, /* RNOON */
        {0x06BE, 0xFBAA, 0xFBAB, 0xFBAC, 0xFBAD}, /* HEH DOACHASHMEE */
        {0x06C0, 0xFBA4, 0xFBA5}, /* HEH WITH YEH ABOVE */
        {0x06C1, 0xFBA6, 0xFBA7, 0xFBA8, 0xFBA9}, /* HEH GOAL */
        {0x06C5, 0xFBE0, 0xFBE1}, /* KIRGHIZ OE */
        {0x06C6, 0xFBD9, 0xFBDA}, /* OE */
        {0x06C7, 0xFBD7, 0xFBD8}, /* U */
        {0x06C8, 0xFBDB, 0xFBDC}, /* YU */
        {0x06C9, 0xFBE2, 0xFBE3}, /* KIRGHIZ YU */
        {0x06CB, 0xFBDE, 0xFBDF}, /* VE */
        {0x06CC, 0xFBFC, 0xFBFD, 0xFBFE, 0xFBFF}, /* FARSI YEH */
        {0x06D0, 0xFBE4, 0xFBE5, 0xFBE6, 0xFBE7}, /* E */
        {0x06D2, 0xFBAE, 0xFBAF}, /* YEH BARREE */
        {0x06D3, 0xFBB0, 0xFBB1} /* YEH BARREE WITH HAMZA ABOVE */
        };

        public static final int ar_nothing  = 0x0;
        public static final int ar_novowel = 0x1;
        public static final int ar_composedtashkeel = 0x4;
        public static final int ar_lig = 0x8;
        /**
         * Digit shaping option: Replace European digits (U+0030...U+0039) by Arabic-Indic digits.
         */
        public static final int DIGITS_EN2AN = 0x20;
        
        /**
         * Digit shaping option: Replace Arabic-Indic digits by European digits (U+0030...U+0039).
         */
        public static final int DIGITS_AN2EN = 0x40;
        
        /**
         * Digit shaping option:
         * Replace European digits (U+0030...U+0039) by Arabic-Indic digits
         * if the most recent strongly directional character
         * is an Arabic letter (its Bidi direction value is RIGHT_TO_LEFT_ARABIC).
         * The initial state at the start of the text is assumed to be not an Arabic,
         * letter, so European digits at the start of the text will not change.
         * Compare to DIGITS_ALEN2AN_INIT_AL.
         */
        public static final int DIGITS_EN2AN_INIT_LR = 0x60;
        
        /**
         * Digit shaping option:
         * Replace European digits (U+0030...U+0039) by Arabic-Indic digits
         * if the most recent strongly directional character
         * is an Arabic letter (its Bidi direction value is RIGHT_TO_LEFT_ARABIC).
         * The initial state at the start of the text is assumed to be an Arabic,
         * letter, so European digits at the start of the text will change.
         * Compare to DIGITS_ALEN2AN_INT_LR.
         */
        public static final int DIGITS_EN2AN_INIT_AL = 0x80;
        
        /** Not a valid option value. */
        private static final int DIGITS_RESERVED = 0xa0;
        
        /**
         * Bit mask for digit shaping options.
         */
        public static final int DIGITS_MASK = 0xe0;
        
        /**
         * Digit type option: Use Arabic-Indic digits (U+0660...U+0669).
         */
        public static final int DIGIT_TYPE_AN = 0;
        
        /**
         * Digit type option: Use Eastern (Extended) Arabic-Indic digits (U+06f0...U+06f9).
         */
        public static final int DIGIT_TYPE_AN_EXTENDED = 0x100;

        /**
         * Bit mask for digit type options.
         */
        public static final int DIGIT_TYPE_MASK = 0x0100; // 0x3f00?

        static class charstruct {
            char basechar;
            char mark1;               /* has to be initialized to zero */
            char vowel;
            int lignum;           /* is a ligature with lignum aditional characters */
            int numshapes = 1;
        };


}
 /*
 * Copyright 2004 by Takenori.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */
package pdftk.com.lowagie.text.pdf;

import java.awt.Font;

import pdftk.com.lowagie.text.pdf.BaseFont;
import pdftk.com.lowagie.text.pdf.DefaultFontMapper;

public class AsianFontMapper extends DefaultFontMapper {
	
	public static String ChineseSimplifiedFont = "STSong-Light";
	public static String ChineseSimplifiedEncoding_H = "UniGB-UCS2-H";
	public static String ChineseSimplifiedEncoding_V = "UniGB-UCS2-V";
	
	public static String ChineseTraditionalFont_MHei = "MHei-Medium";
	public static String ChineseTraditionalFont_MSung = "MSung-Light";
	public static String ChineseTraditionalEncoding_H = "UniCNS-UCS2-H";
	public static String ChineseTraditionalEncoding_V = "UniCNS-UCS2-V";
	
	public static String JapaneseFont_Go = "HeiseiKakuGo-W5";
	public static String JapaneseFont_Min = "HeiseiMin-W3";
	public static String JapaneseEncoding_H = "UniJIS-UCS2-H";
	public static String JapaneseEncoding_V = "UniJIS-UCS2-V";
	public static String JapaneseEncoding_HW_H = "UniJIS-UCS2-HW-H";
	public static String JapaneseEncoding_HW_V = "UniJIS-UCS2-HW-V";
	
	public static String KoreanFont_GoThic = "HYGoThic-Medium";
	public static String KoreanFont_SMyeongJo = "HYSMyeongJo-Medium";
	public static String KoreanEncoding_H = "UniKS-UCS2-H";
	public static String KoreanEncoding_V = "UniKS-UCS2-V";
	
	private String defaultFont;
	private String encoding;

	public AsianFontMapper(String font, String encoding) {
		super();
		
		this.defaultFont = font;
		this.encoding = encoding;
	}

	public BaseFont awtToPdf(Font font) {
		try {
			BaseFontParameters p = getBaseFontParameters(font.getFontName());
			if (p != null){
				return BaseFont.createFont(p.fontName, p.encoding, p.embedded, p.cached, p.ttfAfm, p.pfb);
			}else{
				return BaseFont.createFont(defaultFont, encoding, true);
			}
		}
		catch (Exception e) {
			e.printStackTrace();
		}
		return null;

	}

}
 /*
 * $Id: BadPdfFormatException.java,v 1.22 2002/06/18 13:59:39 blowagie Exp $
 * $Name:  $
 *
 * Copyright 1999, 2000, 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf;

/**
 * Signals that a bad PDF format has been used to construct a <CODE>PdfObject</CODE>.
 *
 * @see		PdfException
 * @see		PdfBoolean
 * @see		PdfNumber
 * @see		PdfString
 * @see		PdfName
 * @see		PdfDictionary
 * @see		PdfFont
 */

public class BadPdfFormatException extends PdfException {
    
    /** A serial version UID */
    private static final long serialVersionUID = 1802317735708833538L;

    // constructors
    
/**
 * Constructs a <CODE>BadPdfFormatException</CODE> whithout a message.
 */
    
    BadPdfFormatException() {
        super();
    }
    
/**
 * Constructs a <code>BadPdfFormatException</code> with a message.
 *
 * @param		message			a message describing the exception
 */
    
    BadPdfFormatException(String message) {
        super(message);
    }
} /*
 * Copyright 2005 by Paulo Soares.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf;

import java.awt.Color;
import pdftk.com.lowagie.text.Element;
import pdftk.com.lowagie.text.DocumentException;
import pdftk.com.lowagie.text.Rectangle;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.HashMap;

/** Common field variables.
 * @author Paulo Soares (psoares@consiste.pt)
 */
public abstract class BaseField {
    
    /** A thin border with 1 point width. */    
    public static final float BORDER_WIDTH_THIN = 1;
    /** A medium border with 2 point width. */    
    public static final float BORDER_WIDTH_MEDIUM = 2;
    /** A thick border with 3 point width. */    
    public static final float BORDER_WIDTH_THICK = 3;
    /** The field is visible. */    
    public static final int VISIBLE = 0;
    /** The field is hidden. */    
    public static final int HIDDEN = 1;
    /** The field is visible but does not print. */    
    public static final int VISIBLE_BUT_DOES_NOT_PRINT = 2;
    /** The field is hidden but is printable. */    
    public static final int HIDDEN_BUT_PRINTABLE = 3;
    /** The user may not change the value of the field. */    
    public static final int READ_ONLY = 1;
    /** The field must have a value at the time it is exported by a submit-form
     * action.
     */    
    public static final int REQUIRED = 2;
    /** The field may contain multiple lines of text.
     * This flag is only meaningful with text fields.
     */    
    public static final int MULTILINE = 4;
    /** The field will not scroll (horizontally for single-line
     * fields, vertically for multiple-line fields) to accommodate more text
     * than will fit within its annotation rectangle. Once the field is full, no
     * further text will be accepted.
     */    
    public static final int DO_NOT_SCROLL = 8;
    /** The field is intended for entering a secure password that should
     * not be echoed visibly to the screen.
     */    
    public static final int PASSWORD = 16;
    /** The text entered in the field represents the pathname of
     * a file whose contents are to be submitted as the value of the field.
     */    
    public static final int FILE_SELECTION = 32;
    /** The text entered in the field will not be spell-checked.
     * This flag is meaningful only in text fields and in combo
     * fields with the <CODE>EDIT</CODE> flag set.
     */    
    public static final int DO_NOT_SPELL_CHECK = 64;
    /** If set the combo box includes an editable text box as well as a drop list; if
     * clear, it includes only a drop list.
     * This flag is only meaningful with combo fields.
     */    
    public static final int EDIT = 128;

    /**
     * combo box flag.
     */
    public static final int COMB = 256;

    protected float borderWidth = BORDER_WIDTH_THIN;
    protected int borderStyle = PdfBorderDictionary.STYLE_SOLID;
    protected Color borderColor;
    protected Color backgroundColor;
    protected Color textColor;
    protected BaseFont font;
    protected float fontSize = 0;
    protected int alignment = Element.ALIGN_LEFT;
    protected PdfWriter writer;
    protected String text;
    protected Rectangle box;
    
    /** Holds value of property rotation. */
    protected int rotation = 0;
    
    /** Holds value of property visibility. */
    protected int visibility;
    
    /** Holds value of property fieldName. */
    protected String fieldName;
    
    /** Holds value of property options. */
    protected int options;
    
    /** Holds value of property maxCharacterLength. */
    protected int maxCharacterLength;
    
    private final static HashMap fieldKeys = new HashMap();
 
    static {
        fieldKeys.putAll(PdfCopyFieldsImp.fieldKeys);
        fieldKeys.put(PdfName.T, new Integer(1));
    }
    /** Creates a new <CODE>TextField</CODE>.
     * @param writer the document <CODE>PdfWriter</CODE>
     * @param box the field location and dimensions
     * @param fieldName the field name. If <CODE>null</CODE> only the widget keys
     * will be included in the field allowing it to be used as a kid field.
     */
    public BaseField(PdfWriter writer, Rectangle box, String fieldName) {
        this.writer = writer;
        this.box = box;
        this.fieldName = fieldName;
    }
    
    protected BaseFont getRealFont() throws IOException, DocumentException {
        if (font == null)
            return BaseFont.createFont(BaseFont.HELVETICA, BaseFont.WINANSI, false);
        else
            return font;
    }
    
    protected PdfAppearance getBorderAppearance() throws IOException, DocumentException {
        PdfAppearance app = writer.getDirectContent().createAppearance(box.width(), box.height());
        switch (rotation) {
            case 90:
                app.setMatrix(0, 1, -1, 0, box.height(), 0);
                break;
            case 180:
                app.setMatrix(-1, 0, 0, -1, box.width(), box.height());
                break;
            case 270:
                app.setMatrix(0, -1, 1, 0, 0, box.width());
                break;
        }
        // background
        if (backgroundColor != null) {
            app.setColorFill(backgroundColor);
            app.rectangle(0, 0, box.width(), box.height());
            app.fill();
        }
        // border
        if (borderStyle == PdfBorderDictionary.STYLE_UNDERLINE) {
            if (borderWidth != 0 && borderColor != null) {
                app.setColorStroke(borderColor);
                app.setLineWidth(borderWidth);
                app.moveTo(0, borderWidth / 2);
                app.lineTo(box.width(), borderWidth / 2);
                app.stroke();
            }
        }
        else if (borderStyle == PdfBorderDictionary.STYLE_BEVELED) {
            if (borderWidth != 0 && borderColor != null) {
                app.setColorStroke(borderColor);
                app.setLineWidth(borderWidth);
                app.rectangle(borderWidth / 2, borderWidth / 2, box.width() - borderWidth, box.height() - borderWidth);
                app.stroke();
            }
            // beveled
            Color actual = backgroundColor;
            if (actual == null)
                actual = Color.white;
            app.setGrayFill(1);
            drawTopFrame(app);
            app.setColorFill(actual.darker());
            drawBottomFrame(app);
        }
        else if (borderStyle == PdfBorderDictionary.STYLE_INSET) {
            if (borderWidth != 0 && borderColor != null) {
                app.setColorStroke(borderColor);
                app.setLineWidth(borderWidth);
                app.rectangle(borderWidth / 2, borderWidth / 2, box.width() - borderWidth, box.height() - borderWidth);
                app.stroke();
            }
            // inset
            app.setGrayFill(0.5f);
            drawTopFrame(app);
            app.setGrayFill(0.75f);
            drawBottomFrame(app);
        }
        else {
            if (borderWidth != 0 && borderColor != null) {
                if (borderStyle == PdfBorderDictionary.STYLE_DASHED)
                    app.setLineDash(3, 0);
                app.setColorStroke(borderColor);
                app.setLineWidth(borderWidth);
                app.rectangle(borderWidth / 2, borderWidth / 2, box.width() - borderWidth, box.height() - borderWidth);
                app.stroke();
                if ((options & COMB) != 0 && maxCharacterLength > 1) {
                    float step = box.width() / maxCharacterLength;
                    float yb = borderWidth / 2;
                    float yt = box.height() - borderWidth / 2;
                    for (int k = 1; k < maxCharacterLength; ++k) {
                        float x = step * k;
                        app.moveTo(x, yb);
                        app.lineTo(x, yt);
                    }
                    app.stroke();
                }
            }
        }
        return app;
    }
    
    protected static ArrayList getHardBreaks(String text) {
        ArrayList arr = new ArrayList();
        char cs[] = text.toCharArray();
        int len = cs.length;
        StringBuffer buf = new StringBuffer();
        for (int k = 0; k < len; ++k) {
            char c = cs[k];
            if (c == '\r') {
                if (k + 1 < len && cs[k + 1] == '\n')
                    ++k;
                arr.add(buf.toString());
                buf = new StringBuffer();
            }
            else if (c == '\n') {
                arr.add(buf.toString());
                buf = new StringBuffer();
            }
            else
                buf.append(c);
        }
        arr.add(buf.toString());
        return arr;
    }
    
    protected static void trimRight(StringBuffer buf) {
        int len = buf.length();
        while (true) {
            if (len == 0)
                return;
            if (buf.charAt(--len) != ' ')
                return;
            buf.setLength(len);
        }
    }
    
    protected static ArrayList breakLines(ArrayList breaks, BaseFont font, float fontSize, float width) {
        ArrayList lines = new ArrayList();
        StringBuffer buf = new StringBuffer();
        for (int ck = 0; ck < breaks.size(); ++ck) {
            buf.setLength(0);
            float w = 0;
            char cs[] = ((String)breaks.get(ck)).toCharArray();
            int len = cs.length;
            // 0 inline first, 1 inline, 2 spaces
            int state = 0;
            int lastspace = -1;
            char c = 0;
            int refk = 0;
            for (int k = 0; k < len; ++k) {
                c = cs[k];
                switch (state) {
                    case 0:
                        w += font.getWidthPoint(c, fontSize);
                        buf.append(c);
                        if (w > width) {
                            w = 0;
                            if (buf.length() > 1) {
                                --k;
                                buf.setLength(buf.length() - 1);
                            }
                            lines.add(buf.toString());
                            buf.setLength(0);
                            refk = k;
                            if (c == ' ')
                                state = 2;
                            else
                                state = 1;
                        }
                        else {
                            if (c != ' ')
                                state = 1;
                        }
                        break;
                    case 1:
                        w += font.getWidthPoint(c, fontSize);
                        buf.append(c);
                        if (c == ' ')
                            lastspace = k;
                        if (w > width) {
                            w = 0;
                            if (lastspace >= 0) {
                                k = lastspace;
                                buf.setLength(lastspace - refk);
                                trimRight(buf);
                                lines.add(buf.toString());
                                buf.setLength(0);
                                refk = k;
                                lastspace = -1;
                                state = 2;
                            }
                            else {
                                if (buf.length() > 1) {
                                    --k;
                                    buf.setLength(buf.length() - 1);
                                }
                                lines.add(buf.toString());
                                buf.setLength(0);
                                refk = k;
                                if (c == ' ')
                                    state = 2;
                            }
                        }
                        break;
                    case 2:
                        if (c != ' ') {
                            w = 0;
                            --k;
                            state = 1;
                        }
                        break;
                }
            }
            trimRight(buf);
            lines.add(buf.toString());
        }
        return lines;
    }
        
    private void drawTopFrame(PdfAppearance app) {
        app.moveTo(borderWidth, borderWidth);
        app.lineTo(borderWidth, box.height() - borderWidth);
        app.lineTo(box.width() - borderWidth, box.height() - borderWidth);
        app.lineTo(box.width() - 2 * borderWidth, box.height() - 2 * borderWidth);
        app.lineTo(2 * borderWidth, box.height() - 2 * borderWidth);
        app.lineTo(2 * borderWidth, 2 * borderWidth);
        app.lineTo(borderWidth, borderWidth);
        app.fill();
    }
    
    private void drawBottomFrame(PdfAppearance app) {
        app.moveTo(borderWidth, borderWidth);
        app.lineTo(box.width() - borderWidth, borderWidth);
        app.lineTo(box.width() - borderWidth, box.height() - borderWidth);
        app.lineTo(box.width() - 2 * borderWidth, box.height() - 2 * borderWidth);
        app.lineTo(box.width() - 2 * borderWidth, 2 * borderWidth);
        app.lineTo(2 * borderWidth, 2 * borderWidth);
        app.lineTo(borderWidth, borderWidth);
        app.fill();
    }
    /** Gets the border width in points.
     * @return the border width in points
     */
    public float getBorderWidth() {
        return this.borderWidth;
    }
    
    /** Sets the border width in points. To eliminate the border
     * set the border color to <CODE>null</CODE>.
     * @param borderWidth the border width in points
     */
    public void setBorderWidth(float borderWidth) {
        this.borderWidth = borderWidth;
    }
    
    /** Gets the border style.
     * @return the border style
     */
    public int getBorderStyle() {
        return this.borderStyle;
    }
    
    /** Sets the border style. The styles are found in <CODE>PdfBorderDictionary</CODE>
     * and can be <CODE>STYLE_SOLID</CODE>, <CODE>STYLE_DASHED</CODE>,
     * <CODE>STYLE_BEVELED</CODE>, <CODE>STYLE_INSET</CODE> and
     * <CODE>STYLE_UNDERLINE</CODE>.
     * @param borderStyle the border style
     */
    public void setBorderStyle(int borderStyle) {
        this.borderStyle = borderStyle;
    }
    
    /** Gets the border color.
     * @return the border color
     */
    public Color getBorderColor() {
        return this.borderColor;
    }
    
    /** Sets the border color. Set to <CODE>null</CODE> to remove
     * the border.
     * @param borderColor the border color
     */
    public void setBorderColor(Color borderColor) {
        this.borderColor = borderColor;
    }
    
    /** Gets the background color.
     * @return the background color
     */
    public Color getBackgroundColor() {
        return this.backgroundColor;
    }
    
    /** Sets the background color. Set to <CODE>null</CODE> for
     * transparent background.
     * @param backgroundColor the background color
     */
    public void setBackgroundColor(Color backgroundColor) {
        this.backgroundColor = backgroundColor;
    }
    
    /** Gets the text color.
     * @return the text color
     */
    public Color getTextColor() {
        return this.textColor;
    }
    
    /** Sets the text color. If <CODE>null</CODE> the color used
     * will be black.
     * @param textColor the text color
     */
    public void setTextColor(Color textColor) {
        this.textColor = textColor;
    }
    
    /** Gets the text font.
     * @return the text font
     */
    public BaseFont getFont() {
        return this.font;
    }
    
    /** Sets the text font. If <CODE>null</CODE> then Helvetica
     * will be used.
     * @param font the text font
     */
    public void setFont(BaseFont font) {
        this.font = font;
    }
    
    /** Gets the font size.
     * @return the font size
     */
    public float getFontSize() {
        return this.fontSize;
    }
    
    /** Sets the font size. If 0 then auto-sizing will be used but
     * only for text fields.
     * @param fontSize the font size
     */
    public void setFontSize(float fontSize) {
        this.fontSize = fontSize;
    }
    
    /** Gets the text horizontal alignment.
     * @return the text horizontal alignment
     */
    public int getAlignment() {
        return this.alignment;
    }
    
    /** Sets the text horizontal alignment. It can be <CODE>Element.ALIGN_LEFT</CODE>,
     * <CODE>Element.ALIGN_CENTER</CODE> and <CODE>Element.ALIGN_RIGHT</CODE>.
     * @param alignment the text horizontal alignment
     */
    public void setAlignment(int alignment) {
        this.alignment = alignment;
    }
    
    /** Gets the text.
     * @return the text
     */
    public String getText() {
        return this.text;
    }
    
    /** Sets the text for text fields.
     * @param text the text
     */
    public void setText(String text) {
        this.text = text;
    }
    
    /** Gets the field dimension and position.
     * @return the field dimension and position
     */
    public Rectangle getBox() {
        return this.box;
    }
    
    /** Sets the field dimension and position.
     * @param box the field dimension and position
     */
    public void setBox(Rectangle box) {
        this.box = box;
    }
    
    /** Gets the field rotation.
     * @return the field rotation
     */
    public int getRotation() {
        return this.rotation;
    }
    
    /** Sets the field rotation. This value should be the same as
     * the page rotation where the field will be shown.
     * @param rotation the field rotation
     */
    public void setRotation(int rotation) {
        if (rotation % 90 != 0)
            throw new IllegalArgumentException("Rotation must be a multiple of 90.");
        rotation %= 360;
        if (rotation < 0)
            rotation += 360;
        this.rotation = rotation;
    }
    
    /** Convenience method to set the field rotation the same as the
     * page rotation.
     * @param page the page
     */    
    public void setRotationFromPage(Rectangle page) {
        setRotation(page.getRotation());
    }
    
    /** Gets the field visibility flag.
     * @return the field visibility flag
     */
    public int getVisibility() {
        return this.visibility;
    }
    
    /** Sets the field visibility flag. This flags can be one of
     * <CODE>VISIBLE</CODE>, <CODE>HIDDEN</CODE>, <CODE>VISIBLE_BUT_DOES_NOT_PRINT</CODE>
     * and <CODE>HIDDEN_BUT_PRINTABLE</CODE>.
     * @param visibility field visibility flag
     */
    public void setVisibility(int visibility) {
        this.visibility = visibility;
    }
    
    /** Gets the field name.
     * @return the field name
     */
    public String getFieldName() {
        return this.fieldName;
    }
    
    /** Sets the field name.
     * @param fieldName the field name. If <CODE>null</CODE> only the widget keys
     * will be included in the field allowing it to be used as a kid field.
     */
    public void setFieldName(String fieldName) {
        this.fieldName = fieldName;
    }
    
    /** Gets the option flags.
     * @return the option flags
     */
    public int getOptions() {
        return this.options;
    }
    
    /** Sets the option flags. The option flags can be a combination by oring of
     * <CODE>READ_ONLY</CODE>, <CODE>REQUIRED</CODE>,
     * <CODE>MULTILINE</CODE>, <CODE>DO_NOT_SCROLL</CODE>,
     * <CODE>PASSWORD</CODE>, <CODE>FILE_SELECTION</CODE>,
     * <CODE>DO_NOT_SPELL_CHECK</CODE> and <CODE>EDIT</CODE>.
     * @param options the option flags
     */
    public void setOptions(int options) {
        this.options = options;
    }
    
    /** Gets the maximum length of the field's text, in characters.
     * @return the maximum length of the field's text, in characters.
     */
    public int getMaxCharacterLength() {
        return this.maxCharacterLength;
    }
    
    /** Sets the maximum length of the field's text, in characters.
     * It is only meaningful for text fields.
     * @param maxCharacterLength the maximum length of the field's text, in characters
     */
    public void setMaxCharacterLength(int maxCharacterLength) {
        this.maxCharacterLength = maxCharacterLength;
    }
    
    /**
     * Getter for property writer.
     * @return Value of property writer.
     */
    public PdfWriter getWriter() {
        return writer;
    }
    
    /**
     * Setter for property writer.
     * @param writer New value of property writer.
     */
    public void setWriter(PdfWriter writer) {
        this.writer = writer;
    }
    
    /**
     * Moves the field keys from <CODE>from</CODE> to <CODE>to</CODE>. The moved keys
     * are removed from <CODE>from</CODE>.
     * @param from the source
     * @param to the destination. It may be <CODE>null</CODE>
     */    
    public static void moveFields(PdfDictionary from, PdfDictionary to) {
        for (Iterator i = from.getKeys().iterator(); i.hasNext();) {
            PdfName key = (PdfName)i.next();
            if (fieldKeys.containsKey(key)) {
                if (to != null)
                    to.put(key, from.get(key));
                i.remove();
            }
        }
    }
} /*
 * $Id: BaseFont.java,v 1.67 2005/07/26 17:32:39 psoares33 Exp $
 * $Name:  $
 *
 * Copyright 2000, 2001, 2002 by Paulo Soares.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf;
import java.io.*;
import pdftk.com.lowagie.text.DocumentException;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;

/**
 * Base class for the several font types supported
 *
 * @author Paulo Soares (psoares@consiste.pt)
 */

public abstract class BaseFont {
    
    /** This is a possible value of a base 14 type 1 font */
    public static final String COURIER = "Courier";
    
    /** This is a possible value of a base 14 type 1 font */
    public static final String COURIER_BOLD = "Courier-Bold";
    
    /** This is a possible value of a base 14 type 1 font */
    public static final String COURIER_OBLIQUE = "Courier-Oblique";
    
    /** This is a possible value of a base 14 type 1 font */
    public static final String COURIER_BOLDOBLIQUE = "Courier-BoldOblique";
    
    /** This is a possible value of a base 14 type 1 font */
    public static final String HELVETICA = "Helvetica";
    
    /** This is a possible value of a base 14 type 1 font */
    public static final String HELVETICA_BOLD = "Helvetica-Bold";
    
    /** This is a possible value of a base 14 type 1 font */
    public static final String HELVETICA_OBLIQUE = "Helvetica-Oblique";
    
    /** This is a possible value of a base 14 type 1 font */
    public static final String HELVETICA_BOLDOBLIQUE = "Helvetica-BoldOblique";
    
    /** This is a possible value of a base 14 type 1 font */
    public static final String SYMBOL = "Symbol";
    
    /** This is a possible value of a base 14 type 1 font */
    public static final String TIMES_ROMAN = "Times-Roman";
    
    /** This is a possible value of a base 14 type 1 font */
    public static final String TIMES_BOLD = "Times-Bold";
    
    /** This is a possible value of a base 14 type 1 font */
    public static final String TIMES_ITALIC = "Times-Italic";
    
    /** This is a possible value of a base 14 type 1 font */
    public static final String TIMES_BOLDITALIC = "Times-BoldItalic";
    
    /** This is a possible value of a base 14 type 1 font */
    public static final String ZAPFDINGBATS = "ZapfDingbats";
    
    /** The maximum height above the baseline reached by glyphs in this
     * font, excluding the height of glyphs for accented characters.
     */    
    public static final int ASCENT = 1;    
    /** The y coordinate of the top of flat capital letters, measured from
     * the baseline.
     */    
    public static final int CAPHEIGHT = 2;
    /** The maximum depth below the baseline reached by glyphs in this
     * font. The value is a negative number.
     */    
    public static final int DESCENT = 3;
    /** The angle, expressed in degrees counterclockwise from the vertical,
     * of the dominant vertical strokes of the font. The value is
     * negative for fonts that slope to the right, as almost all italic fonts do.
     */    
    public static final int ITALICANGLE = 4;
    /** The lower left x glyph coordinate.
     */    
    public static final int BBOXLLX = 5;
    /** The lower left y glyph coordinate.
     */    
    public static final int BBOXLLY = 6;
    /** The upper right x glyph coordinate.
     */    
    public static final int BBOXURX = 7;
    /** The upper right y glyph coordinate.
     */    
    public static final int BBOXURY = 8;
    
    /** java.awt.Font property */
    public static final int AWT_ASCENT = 9;
    /** java.awt.Font property */
    public static final int AWT_DESCENT = 10;
    /** java.awt.Font property */
    public static final int AWT_LEADING = 11;
    /** java.awt.Font property */
    public static final int AWT_MAXADVANCE = 12;
    
    /** The font is Type 1.
     */    
    public static final int FONT_TYPE_T1 = 0;
    /** The font is True Type with a standard encoding.
     */    
    public static final int FONT_TYPE_TT = 1;
    /** The font is CJK.
     */    
    public static final int FONT_TYPE_CJK = 2;
    /** The font is True Type with a Unicode encoding.
     */    
    public static final int FONT_TYPE_TTUNI = 3;
    /** A font already inside the document.
     */    
    public static final int FONT_TYPE_DOCUMENT = 4;
    /** A Type3 font.
     */    
    public static final int FONT_TYPE_T3 = 5;
    /** The Unicode encoding with horizontal writing.
     */    
    public static final String IDENTITY_H = "Identity-H";
    /** The Unicode encoding with vertical writing.
     */    
    public static final String IDENTITY_V = "Identity-V";
    
    /** A possible encoding. */    
    public static final String CP1250 = "Cp1250";
    
    /** A possible encoding. */    
    public static final String CP1252 = "Cp1252";
    
    /** A possible encoding. */    
    public static final String CP1257 = "Cp1257";
    
    /** A possible encoding. */    
    public static final String WINANSI = "Cp1252";
    
    /** A possible encoding. */    
    public static final String MACROMAN = "MacRoman";
    
    
/** if the font has to be embedded */
    public static final boolean EMBEDDED = true;
    
/** if the font doesn't have to be embedded */
    public static final boolean NOT_EMBEDDED = false;
/** if the font has to be cached */
    public static final boolean CACHED = true;
/** if the font doesn't have to be cached */
    public static final boolean NOT_CACHED = false;
    
    /** The path to the font resources. */    
    public static final String RESOURCE_PATH = "pdftk/com/lowagie/text/pdf/fonts/";
    /** The fake CID code that represents a newline. */    
    public static final char CID_NEWLINE = '\u7fff';
    
    /** The font type.
     */    
    int fontType;
/** a not defined character in a custom PDF encoding */
    public static final String notdef = ".notdef";
    
/** table of characters widths for this encoding */
    protected int widths[] = new int[256];
    
/** encoding names */
    protected String differences[] = new String[256];
/** same as differences but with the unicode codes */
    protected char unicodeDifferences[] = new char[256];
    
    protected int charBBoxes[][] = new int[256][];
/** encoding used with this font */
    protected String encoding;
    
/** true if the font is to be embedded in the PDF */
    protected boolean embedded;
    
/**
 * true if the font must use it's built in encoding. In that case the
 * <CODE>encoding</CODE> is only used to map a char to the position inside
 * the font, not to the expected char name.
 */
    protected boolean fontSpecific = true;
    
/** cache for the fonts already used. */
    protected static HashMap fontCache = new HashMap();
    
/** list of the 14 built in fonts. */
    protected static final HashMap BuiltinFonts14 = new HashMap();
    
    /** Forces the output of the width array. Only matters for the 14
     * built-in fonts.
     */
    protected boolean forceWidthsOutput = false;
    
    /** Converts <CODE>char</CODE> directly to <CODE>byte</CODE>
     * by casting.
     */
    protected boolean directTextToByte = false;
    
    /** Indicates if all the glyphs and widths for that particular
     * encoding should be included in the document.
     */
    protected boolean subset = true;
    
    protected boolean fastWinansi = false;
    
    static {
        BuiltinFonts14.put(COURIER, PdfName.COURIER);
        BuiltinFonts14.put(COURIER_BOLD, PdfName.COURIER_BOLD);
        BuiltinFonts14.put(COURIER_BOLDOBLIQUE, PdfName.COURIER_BOLDOBLIQUE);
        BuiltinFonts14.put(COURIER_OBLIQUE, PdfName.COURIER_OBLIQUE);
        BuiltinFonts14.put(HELVETICA, PdfName.HELVETICA);
        BuiltinFonts14.put(HELVETICA_BOLD, PdfName.HELVETICA_BOLD);
        BuiltinFonts14.put(HELVETICA_BOLDOBLIQUE, PdfName.HELVETICA_BOLDOBLIQUE);
        BuiltinFonts14.put(HELVETICA_OBLIQUE, PdfName.HELVETICA_OBLIQUE);
        BuiltinFonts14.put(SYMBOL, PdfName.SYMBOL);
        BuiltinFonts14.put(TIMES_ROMAN, PdfName.TIMES_ROMAN);
        BuiltinFonts14.put(TIMES_BOLD, PdfName.TIMES_BOLD);
        BuiltinFonts14.put(TIMES_BOLDITALIC, PdfName.TIMES_BOLDITALIC);
        BuiltinFonts14.put(TIMES_ITALIC, PdfName.TIMES_ITALIC);
        BuiltinFonts14.put(ZAPFDINGBATS, PdfName.ZAPFDINGBATS);
    }
    
    /** Generates the PDF stream with the Type1 and Truetype fonts returning
     * a PdfStream.
     */
    static class StreamFont extends PdfStream {
        
        /** Generates the PDF stream with the Type1 and Truetype fonts returning
         * a PdfStream.
         * @param contents the content of the stream
         * @param lengths an array of int that describes the several lengths of each part of the font
         * @throws DocumentException error in the stream compression
         */
        public StreamFont(byte contents[], int lengths[]) throws DocumentException {
            try {
                bytes = contents;
                put(PdfName.LENGTH, new PdfNumber(bytes.length));
                for (int k = 0; k < lengths.length; ++k) {
                    put(new PdfName("Length" + (k + 1)), new PdfNumber(lengths[k]));
                }
                flateCompress();
            }
            catch (Exception e) {
                throw new DocumentException(e);
            }
        }
        
        /**
         * Generates the PDF stream for a font.
         * @param contents the content of a stream
         * @param subType the subtype of the font.
         * @throws DocumentException
         */
        public StreamFont(byte contents[], String subType) throws DocumentException {
            try {
                bytes = contents;
                put(PdfName.LENGTH, new PdfNumber(bytes.length));
                if (subType != null)
                    put(PdfName.SUBTYPE, new PdfName(subType));
                flateCompress();
            }
            catch (Exception e) {
                throw new DocumentException(e);
            }
        }
    }
    
    /**
     *Creates new BaseFont
     */
    protected BaseFont() {
    }
    
    /** Creates a new font. This font can be one of the 14 built in types,
     * a Type1 font referred by an AFM file, a TrueType font (simple or collection) or a CJK font from the
     * Adobe Asian Font Pack. TrueType fonts and CJK fonts can have an optional style modifier
     * appended to the name. These modifiers are: Bold, Italic and BoldItalic. An
     * example would be "STSong-Light,Bold". Note that this modifiers do not work if
     * the font is embedded. Fonts in TrueType collections are addressed by index such as "msgothic.ttc,1".
     * This would get the second font (indexes start at 0), in this case "MS PGothic".
     * <P>
     * The fonts are cached and if they already exist they are extracted from the cache,
     * not parsed again.
     * <P>
     * This method calls:<br>
     * <PRE>
     * createFont(name, encoding, embedded, true, null, null);
     * </PRE>
     * @param name the name of the font or it's location on file
     * @param encoding the encoding to be applied to this font
     * @param embedded true if the font is to be embedded in the PDF
     * @return returns a new font. This font may come from the cache
     * @throws DocumentException the font is invalid
     * @throws IOException the font file could not be read
     */
    public static BaseFont createFont(String name, String encoding, boolean embedded) throws DocumentException, IOException {
        return createFont(name, encoding, embedded, true, null, null);
    }
    
    /** Creates a new font. This font can be one of the 14 built in types,
     * a Type1 font referred by an AFM file, a TrueType font (simple or collection) or a CJK font from the
     * Adobe Asian Font Pack. TrueType fonts and CJK fonts can have an optional style modifier
     * appended to the name. These modifiers are: Bold, Italic and BoldItalic. An
     * example would be "STSong-Light,Bold". Note that this modifiers do not work if
     * the font is embedded. Fonts in TrueType collections are addressed by index such as "msgothic.ttc,1".
     * This would get the second font (indexes start at 0), in this case "MS PGothic".
     * <P>
     * The fonts may or may not be cached depending on the flag <CODE>cached</CODE>.
     * If the <CODE>byte</CODE> arrays are present the font will be
     * read from them instead of the name. The name is still required to identify
     * the font type.
     * @param name the name of the font or it's location on file
     * @param encoding the encoding to be applied to this font
     * @param embedded true if the font is to be embedded in the PDF
     * @param cached true if the font comes from the cache or is added to
     * the cache if new, false if the font is always created new
     * @param ttfAfm the true type font or the afm in a byte array
     * @param pfb the pfb in a byte array
     * @return returns a new font. This font may come from the cache but only if cached
     * is true, otherwise it will always be created new
     * @throws DocumentException the font is invalid
     * @throws IOException the font file could not be read
     */
    public static BaseFont createFont(String name, String encoding, boolean embedded, boolean cached, byte ttfAfm[], byte pfb[]) throws DocumentException, IOException {
        String nameBase = getBaseName(name);
        encoding = normalizeEncoding(encoding);
        boolean isBuiltinFonts14 = BuiltinFonts14.containsKey(name);
        boolean isCJKFont = isBuiltinFonts14 ? false : CJKFont.isCJKFont(nameBase, encoding);
        if (isBuiltinFonts14 || isCJKFont)
            embedded = false;
        else if (encoding.equals(IDENTITY_H) || encoding.equals(IDENTITY_V))
            embedded = true;
        BaseFont fontFound = null;
        BaseFont fontBuilt = null;
        String key = name + "\n" + encoding + "\n" + embedded;
        if (cached) {
            synchronized (fontCache) {
                fontFound = (BaseFont)fontCache.get(key);
            }
            if (fontFound != null)
                return fontFound;
        }
        if (isBuiltinFonts14 || name.toLowerCase().endsWith(".afm") || name.toLowerCase().endsWith(".pfm")) {
            fontBuilt = new Type1Font(name, encoding, embedded, ttfAfm, pfb);
            fontBuilt.fastWinansi = encoding.equals(CP1252);
        }
        else if (nameBase.toLowerCase().endsWith(".ttf") || nameBase.toLowerCase().endsWith(".otf") || nameBase.toLowerCase().indexOf(".ttc,") > 0) {
            if (encoding.equals(IDENTITY_H) || encoding.equals(IDENTITY_V))
                fontBuilt = new TrueTypeFontUnicode(name, encoding, embedded, ttfAfm);
            else {
                fontBuilt = new TrueTypeFont(name, encoding, embedded, ttfAfm);
                fontBuilt.fastWinansi = encoding.equals(CP1252);
            }
        }
        else if (isCJKFont)
            fontBuilt = new CJKFont(name, encoding, embedded);
        else
            throw new DocumentException("Font '" + name + "' with '" + encoding + "' is not recognized.");
        if (cached) {
            synchronized (fontCache) {
                fontFound = (BaseFont)fontCache.get(key);
                if (fontFound != null)
                    return fontFound;
                fontCache.put(key, fontBuilt);
            }
        }
        return fontBuilt;
    }
    
    /**
     * Creates a font based on an existing document font. The created font font may not
     * behave as expected, depending on the encoding or subset.
     * @param fontRef the reference to the document font
     * @return the font
     */    
    public static BaseFont createFont(PRIndirectReference fontRef) {
        return new DocumentFont(fontRef);
    }
    
    /**
     * Gets the name without the modifiers Bold, Italic or BoldItalic.
     * @param name the full name of the font
     * @return the name without the modifiers Bold, Italic or BoldItalic
     */
    protected static String getBaseName(String name) {
        if (name.endsWith(",Bold"))
            return name.substring(0, name.length() - 5);
        else if (name.endsWith(",Italic"))
            return name.substring(0, name.length() - 7);
        else if (name.endsWith(",BoldItalic"))
            return name.substring(0, name.length() - 11);
        else
            return name;
    }
    
    /**
     * Normalize the encoding names. "winansi" is changed to "Cp1252" and
     * "macroman" is changed to "MacRoman".
     * @param enc the encoding to be normalized
     * @return the normalized encoding
     */
    protected static String normalizeEncoding(String enc) {
        if (enc.equals("winansi") || enc.equals(""))
            return CP1252;
        else if (enc.equals("macroman"))
            return MACROMAN;
        else
            return enc;
    }
    
    /**
     * Creates the <CODE>widths</CODE> and the <CODE>differences</CODE> arrays
     */
    protected void createEncoding() {
        if (fontSpecific) {
            for (int k = 0; k < 256; ++k) {
                widths[k] = getRawWidth(k, null);
                charBBoxes[k] = getRawCharBBox(k, null);
            }
        }
        else {
            String s;
            String name;
            char c;
            byte b[] = new byte[1];
            for (int k = 0; k < 256; ++k) {
                b[0] = (byte)k;
                s = PdfEncodings.convertToString(b, encoding);
                if (s.length() > 0) {
                    c = s.charAt(0);
                }
                else {
                    c = '?';
                }
                name = GlyphList.unicodeToName(c);
                if (name == null)
                    name = notdef;
                differences[k] = name;
                unicodeDifferences[k] = c;
                widths[k] = getRawWidth(c, name);
                charBBoxes[k] = getRawCharBBox(c, name);
            }
        }
    }
    
    /**
     * Gets the width from the font according to the Unicode char <CODE>c</CODE>
     * or the <CODE>name</CODE>. If the <CODE>name</CODE> is null it's a symbolic font.
     * @param c the unicode char
     * @param name the glyph name
     * @return the width of the char
     */
    abstract int getRawWidth(int c, String name);
    
    /**
     * Gets the kerning between two Unicode chars.
     * @param char1 the first char
     * @param char2 the second char
     * @return the kerning to be applied in normalized 1000 units
     */
    public abstract int getKerning(char char1, char char2);

    /**
     * Sets the kerning between two Unicode chars.
     * @param char1 the first char
     * @param char2 the second char
     * @param kern the kerning to apply in normalized 1000 units
     * @return <code>true</code> if the kerning was applied, <code>false</code> otherwise
     */
    public abstract boolean setKerning(char char1, char char2, int kern);
    
    /**
     * Gets the width of a <CODE>char</CODE> in normalized 1000 units.
     * @param char1 the unicode <CODE>char</CODE> to get the width of
     * @return the width in normalized 1000 units
     */
    public int getWidth(char char1) {
        if (fastWinansi) {
            if (char1 < 128 || (char1 >= 160 && char1 <= 255))
                return widths[char1];
            return widths[PdfEncodings.winansi.get(char1)];
        }
        return getWidth(new String(new char[]{char1}));
    }
    
    /**
     * Gets the width of a <CODE>String</CODE> in normalized 1000 units.
     * @param text the <CODE>String</CODE> to get the witdth of
     * @return the width in normalized 1000 units
     */
    public int getWidth(String text) {
        int total = 0;
        if (fastWinansi) {
            int len = text.length();
            for (int k = 0; k < len; ++k) {
                char char1 = text.charAt(k);
                if (char1 < 128 || (char1 >= 160 && char1 <= 255))
                    total += widths[char1];
                else
                    total += widths[PdfEncodings.winansi.get(char1)];
            }
            return total;
        }
        else {
            byte mbytes[] = convertToBytes(text);
            for (int k = 0; k < mbytes.length; ++k)
                total += widths[0xff & mbytes[k]];
        }
        return total;
    }
    
/**
 * Gets the descent of a <CODE>String</CODE> in normalized 1000 units. The descent will always be
 * less than or equal to zero even if all the characters have an higher descent.
 * @param text the <CODE>String</CODE> to get the descent of
 * @return the dexcent in normalized 1000 units
 */
    public int getDescent(String text) {
        int min = 0;
        char chars[] = text.toCharArray();
        for (int k = 0; k < chars.length; ++k) {
            int bbox[] = getCharBBox(chars[k]);
            if (bbox != null && bbox[1] < min)
                min = bbox[1];
        }
        return min;
    }
    
/**
 * Gets the ascent of a <CODE>String</CODE> in normalized 1000 units. The ascent will always be
 * greater than or equal to zero even if all the characters have a lower ascent.
 * @param text the <CODE>String</CODE> to get the ascent of
 * @return the ascent in normalized 1000 units
 */
    public int getAscent(String text) {
        int max = 0;
        char chars[] = text.toCharArray();
        for (int k = 0; k < chars.length; ++k) {
            int bbox[] = getCharBBox(chars[k]);
            if (bbox != null && bbox[3] > max)
                max = bbox[3];
        }
        return max;
    }

/**
 * Gets the descent of a <CODE>String</CODE> in points. The descent will always be
 * less than or equal to zero even if all the characters have an higher descent.
 * @param text the <CODE>String</CODE> to get the descent of
 * @param fontSize the size of the font
 * @return the dexcent in points
 */
    public float getDescentPoint(String text, float fontSize)
    {
        return 0.001f * getDescent(text) * fontSize;
    }
    
/**
 * Gets the ascent of a <CODE>String</CODE> in points. The ascent will always be
 * greater than or equal to zero even if all the characters have a lower ascent.
 * @param text the <CODE>String</CODE> to get the ascent of
 * @param fontSize the size of the font
 * @return the ascent in points
 */
    public float getAscentPoint(String text, float fontSize)
    {
        return 0.001f * getAscent(text) * fontSize;
    }
// ia>    
    
    /**
     * Gets the width of a <CODE>String</CODE> in points taking kerning
     * into account.
     * @param text the <CODE>String</CODE> to get the witdth of
     * @param fontSize the font size
     * @return the width in points
     */
    public float getWidthPointKerned(String text, float fontSize) {
        float size = 0.001f * getWidth(text) * fontSize;
        if (!hasKernPairs())
            return size;
        int len = text.length() - 1;
        int kern = 0;
        char c[] = text.toCharArray();
        for (int k = 0; k < len; ++k) {
            kern += getKerning(c[k], c[k + 1]);
        }
        return size + kern * 0.001f * fontSize;
    }
    
    /**
     * Gets the width of a <CODE>String</CODE> in points.
     * @param text the <CODE>String</CODE> to get the witdth of
     * @param fontSize the font size
     * @return the width in points
     */
    public float getWidthPoint(String text, float fontSize) {
        return 0.001f * getWidth(text) * fontSize;
    }
    
    /**
     * Gets the width of a <CODE>char</CODE> in points.
     * @param char1 the <CODE>char</CODE> to get the witdth of
     * @param fontSize the font size
     * @return the width in points
     */
    public float getWidthPoint(char char1, float fontSize) {
        return getWidth(char1) * 0.001f * fontSize;
    }
    
    /**
     * Converts a <CODE>String</CODE> to a </CODE>byte</CODE> array according
     * to the font's encoding.
     * @param text the <CODE>String</CODE> to be converted
     * @return an array of <CODE>byte</CODE> representing the conversion according to the font's encoding
     */
    byte[] convertToBytes(String text) {
        if (directTextToByte)
            return PdfEncodings.convertToBytes(text, null);
        return PdfEncodings.convertToBytes(text, encoding);
    }
    
    /** Outputs to the writer the font dictionaries and streams.
     * @param writer the writer for this document
     * @param ref the font indirect reference
     * @param params several parameters that depend on the font type
     * @throws IOException on error
     * @throws DocumentException error in generating the object
     */
    abstract void writeFont(PdfWriter writer, PdfIndirectReference ref, Object params[]) throws DocumentException, IOException;
    
    /** Gets the encoding used to convert <CODE>String</CODE> into <CODE>byte[]</CODE>.
     * @return the encoding name
     */
    public String getEncoding() {
        return encoding;
    }
    
    /** Gets the font parameter identified by <CODE>key</CODE>. Valid values
     * for <CODE>key</CODE> are <CODE>ASCENT</CODE>, <CODE>AWT_ASCENT</CODE>, <CODE>CAPHEIGHT</CODE>, 
     * <CODE>DESCENT</CODE>, <CODE>AWT_DESCENT</CODE>,
     * <CODE>ITALICANGLE</CODE>, <CODE>BBOXLLX</CODE>, <CODE>BBOXLLY</CODE>, <CODE>BBOXURX</CODE>
     * and <CODE>BBOXURY</CODE>.
     * @param key the parameter to be extracted
     * @param fontSize the font size in points
     * @return the parameter in points
     */
    public abstract float getFontDescriptor(int key, float fontSize);
    
    /** Gets the font type. The font types can be: FONT_TYPE_T1,
     * FONT_TYPE_TT, FONT_TYPE_CJK and FONT_TYPE_TTUNI.
     * @return the font type
     */
    public int getFontType() {
        return fontType;
    }
    
    /** Gets the embedded flag.
     * @return <CODE>true</CODE> if the font is embedded.
     */
    public boolean isEmbedded() {
        return embedded;
    }
    
    /** Gets the symbolic flag of the font.
     * @return <CODE>true</CODE> if the font is symbolic
     */
    public boolean isFontSpecific() {
        return fontSpecific;
    }
    
    /** Creates a unique subset prefix to be added to the font name when the font is embedded and subset.
     * @return the subset prefix
     */
    public static String createSubsetPrefix() {
        String s = "";
        for (int k = 0; k < 6; ++k)
            s += (char)(Math.random() * 26 + 'A');
        return s + "+";
    }
    
    /** Gets the Unicode character corresponding to the byte output to the pdf stream.
     * @param index the byte index
     * @return the Unicode character
     */
    char getUnicodeDifferences(int index) {
        return unicodeDifferences[index];
    }
    
    /** Gets the postscript font name.
     * @return the postscript font name
     */
    public abstract String getPostscriptFontName();
    
    /**
     * Sets the font name that will appear in the pdf font dictionary.
     * Use with care as it can easily make a font unreadable if not embedded.
     * @param name the new font name
     */    
    public abstract void setPostscriptFontName(String name);
    
    /** Gets the full name of the font. If it is a True Type font
     * each array element will have {Platform ID, Platform Encoding ID,
     * Language ID, font name}. The interpretation of this values can be
     * found in the Open Type specification, chapter 2, in the 'name' table.<br>
     * For the other fonts the array has a single element with {"", "", "",
     * font name}.
     * @return the full name of the font
     */
    public abstract String[][] getFullFontName();
    
    /** Gets the full name of the font. If it is a True Type font
     * each array element will have {Platform ID, Platform Encoding ID,
     * Language ID, font name}. The interpretation of this values can be
     * found in the Open Type specification, chapter 2, in the 'name' table.<br>
     * For the other fonts the array has a single element with {"", "", "",
     * font name}.
     * @param name the name of the font
     * @param encoding the encoding of the font
     * @param ttfAfm the true type font or the afm in a byte array
     * @throws DocumentException on error
     * @throws IOException on error
     * @return the full name of the font
     */    
    public static String[][] getFullFontName(String name, String encoding, byte ttfAfm[]) throws DocumentException, IOException {
        String nameBase = getBaseName(name);
        BaseFont fontBuilt = null;
        if (nameBase.toLowerCase().endsWith(".ttf") || nameBase.toLowerCase().endsWith(".otf") || nameBase.toLowerCase().indexOf(".ttc,") > 0)
            fontBuilt = new TrueTypeFont(name, CP1252, false, ttfAfm, true);
        else
            fontBuilt = createFont(name, encoding, false, false, ttfAfm, null);
        return fontBuilt.getFullFontName();
    }
    
    /** Gets all the names from the font. Only the required tables are read.
     * @param name the name of the font
     * @param encoding the encoding of the font
     * @param ttfAfm the true type font or the afm in a byte array
     * @throws DocumentException on error
     * @throws IOException on error
     * @return an array of Object[] built with {getPostscriptFontName(), getFamilyFontName(), getFullFontName()}
     */    
    public static Object[] getAllFontNames(String name, String encoding, byte ttfAfm[]) throws DocumentException, IOException {
        String nameBase = getBaseName(name);
        BaseFont fontBuilt = null;
        if (nameBase.toLowerCase().endsWith(".ttf") || nameBase.toLowerCase().endsWith(".otf") || nameBase.toLowerCase().indexOf(".ttc,") > 0)
            fontBuilt = new TrueTypeFont(name, CP1252, false, ttfAfm, true);
        else
            fontBuilt = createFont(name, encoding, false, false, ttfAfm, null);
        return new Object[]{fontBuilt.getPostscriptFontName(), fontBuilt.getFamilyFontName(), fontBuilt.getFullFontName()};
    }
    
    /** Gets the family name of the font. If it is a True Type font
     * each array element will have {Platform ID, Platform Encoding ID,
     * Language ID, font name}. The interpretation of this values can be
     * found in the Open Type specification, chapter 2, in the 'name' table.<br>
     * For the other fonts the array has a single element with {"", "", "",
     * font name}.
     * @return the family name of the font
     */
    public abstract String[][] getFamilyFontName();
    
    /** Gets the code pages supported by the font. This has only meaning
     * with True Type fonts.
     * @return the code pages supported by the font
     */
    public String[] getCodePagesSupported() {
        return new String[0];
    }
    
    /** Enumerates the postscript font names present inside a
     * True Type Collection.
     * @param ttcFile the file name of the font
     * @throws DocumentException on error
     * @throws IOException on error
     * @return the postscript font names
     */    
    public static String[] enumerateTTCNames(String ttcFile) throws DocumentException, IOException {
        return new EnumerateTTC(ttcFile).getNames();
    }

    /** Enumerates the postscript font names present inside a
     * True Type Collection.
     * @param ttcArray the font as a <CODE>byte</CODE> array
     * @throws DocumentException on error
     * @throws IOException on error
     * @return the postscript font names
     */    
    public static String[] enumerateTTCNames(byte ttcArray[]) throws DocumentException, IOException {
        return new EnumerateTTC(ttcArray).getNames();
    }
    
    /** Gets the font width array.
     * @return the font width array
     */    
    public int[] getWidths() {
        return widths;
    }

    /** Gets the array with the names of the characters.
     * @return the array with the names of the characters
     */    
    public String[] getDifferences() {
        return differences;
    }

    /** Gets the array with the unicode characters.
     * @return the array with the unicode characters
     */    
    public char[] getUnicodeDifferences() {
        return unicodeDifferences;
    }
    
    /** Gets the state of the property.
     * @return value of property forceWidthsOutput
     */
    public boolean isForceWidthsOutput() {
        return forceWidthsOutput;
    }
    
    /** Set to <CODE>true</CODE> to force the generation of the
     * widths array.
     * @param forceWidthsOutput <CODE>true</CODE> to force the generation of the
     * widths array
     */
    public void setForceWidthsOutput(boolean forceWidthsOutput) {
        this.forceWidthsOutput = forceWidthsOutput;
    }
    
    /** Gets the direct conversion of <CODE>char</CODE> to <CODE>byte</CODE>.
     * @return value of property directTextToByte.
     * @see #setDirectTextToByte(boolean directTextToByte)
     */
    public boolean isDirectTextToByte() {
        return directTextToByte;
    }
    
    /** Sets the conversion of <CODE>char</CODE> directly to <CODE>byte</CODE>
     * by casting. This is a low level feature to put the bytes directly in
     * the content stream without passing through String.getBytes().
     * @param directTextToByte New value of property directTextToByte.
     */
    public void setDirectTextToByte(boolean directTextToByte) {
        this.directTextToByte = directTextToByte;
    }
    
    /** Indicates if all the glyphs and widths for that particular
     * encoding should be included in the document.
     * @return <CODE>false</CODE> to include all the glyphs and widths.
     */
    public boolean isSubset() {
        return subset;
    }
    
    /** Indicates if all the glyphs and widths for that particular
     * encoding should be included in the document. Set to <CODE>false</CODE>
     * to include all.
     * @param subset new value of property subset
     */
    public void setSubset(boolean subset) {
        this.subset = subset;
    }

    /** Gets the font resources.
     * @param key the full name of the resource
     * @return the <CODE>InputStream</CODE> to get the resource or
     * <CODE>null</CODE> if not found
     */    
    public static InputStream getResourceStream(String key) {
        return getResourceStream(key, null);
    }
    
    /** Gets the font resources.
     * @param key the full name of the resource
     * @param loader the ClassLoader to load the resource or null to try the ones available
     * @return the <CODE>InputStream</CODE> to get the resource or
     * <CODE>null</CODE> if not found
     */    
    public static InputStream getResourceStream(String key, ClassLoader loader) {
        if (key.startsWith("/"))
            key = key.substring(1);
        InputStream is = null;
        if (loader != null) {
            is = loader.getResourceAsStream(key);
            if (is != null)
                return is;
        }
        // Try to use Context Class Loader to load the properties file.
        try {
            java.lang.reflect.Method getCCL =
                Thread.class.getMethod("getContextClassLoader", new Class[0]);
            if (getCCL != null) {
                ClassLoader contextClassLoader =
                    (ClassLoader)getCCL.invoke(Thread.currentThread(),
                                               new Object[0]);
                if (contextClassLoader != null)
                    is = contextClassLoader.getResourceAsStream(key);
            }
        } catch (Throwable e) {}

        if (is == null) {
            is = BaseFont.class.getResourceAsStream("/" + key);
        }
        if (is == null) {
            is = ClassLoader.getSystemResourceAsStream(key);
        }
        return is;
    }
    
    /** Gets the Unicode equivalent to a CID.
     * The (inexistent) CID <FF00> is translated as '\n'. 
     * It has only meaning with CJK fonts with Identity encoding.
     * @param c the CID code
     * @return the Unicode equivalent
     */    
    public char getUnicodeEquivalent(char c) {
        return c;
    }
    
    /** Gets the CID code given an Unicode.
     * It has only meaning with CJK fonts.
     * @param c the Unicode
     * @return the CID equivalent
     */    
    public char getCidCode(char c) {
        return c;
    }

    /** Checks if the font has any kerning pairs.
     * @return <CODE>true</CODE> if the font has any kerning pairs
     */    
    public abstract boolean hasKernPairs();
    
    /**
     * Checks if a character exists in this font.
     * @param c the character to check
     * @return <CODE>true</CODE> if the character has a glyph,
     * <CODE>false</CODE> otherwise
     */    
    public boolean charExists(char c) {
        byte b[] = convertToBytes(new String(new char[]{c}));
        return b.length > 0;
    }
    
    /**
     * Sets the character advance.
     * @param c the character
     * @param advance the character advance normalized to 1000 units
     * @return <CODE>true</CODE> if the advance was set,
     * <CODE>false</CODE> otherwise
     */    
    public boolean setCharAdvance(char c, int advance) {
        byte b[] = convertToBytes(new String(new char[]{c}));
        if (b.length == 0)
            return false;
        widths[0xff & b[0]] = advance;
        return true;
    }
    
    private static void addFont(PRIndirectReference fontRef, IntHashtable hits, ArrayList fonts) {
        PdfObject obj = PdfReader.getPdfObject(fontRef);
        if (!obj.isDictionary())
            return;
        PdfDictionary font = (PdfDictionary)obj;
        PdfName subtype = (PdfName)PdfReader.getPdfObject(font.get(PdfName.SUBTYPE));
        if (!PdfName.TYPE1.equals(subtype) && !PdfName.TRUETYPE.equals(subtype))
            return;
        PdfName name = (PdfName)PdfReader.getPdfObject(font.get(PdfName.BASEFONT));
        fonts.add(new Object[]{PdfName.decodeName(name.toString()), fontRef});
        hits.put(fontRef.getNumber(), 1);
    }
    
    private static void recourseFonts(PdfDictionary page, IntHashtable hits, ArrayList fonts, int level) {
        ++level;
        if (level > 50) // in case we have an endless loop
            return;
        PdfDictionary resources = (PdfDictionary)PdfReader.getPdfObject(page.get(PdfName.RESOURCES));
        if (resources == null)
            return;
        PdfDictionary font = (PdfDictionary)PdfReader.getPdfObject(resources.get(PdfName.FONT));
        if (font != null) {
            for (Iterator it = font.getKeys().iterator(); it.hasNext();) {
                PdfObject ft = font.get((PdfName)it.next());        
                if (ft == null || !ft.isIndirect())
                    continue;
                int hit = ((PRIndirectReference)ft).getNumber();
                if (hits.containsKey(hit))
                    continue;
                addFont((PRIndirectReference)ft, hits, fonts);
            }
        }
        PdfDictionary xobj = (PdfDictionary)PdfReader.getPdfObject(resources.get(PdfName.XOBJECT));
        if (xobj != null) {
            for (Iterator it = xobj.getKeys().iterator(); it.hasNext();) {
                recourseFonts((PdfDictionary)PdfReader.getPdfObject(xobj.get((PdfName)it.next())), hits, fonts, level);
            }
        }
    }
    
    /**
     * Gets a list of all document fonts. Each element of the <CODE>ArrayList</CODE>
     * contains a <CODE>Object[]{String,PRIndirectReference}</CODE> with the font name
     * and the indirect reference to it.
     * @param reader the document where the fonts are to be listed from
     * @return the list of fonts and references
     */    
    public static ArrayList getDocumentFonts(PdfReader reader) {
        IntHashtable hits = new IntHashtable();
        ArrayList fonts = new ArrayList();
        int npages = reader.getNumberOfPages();
        for (int k = 1; k <= npages; ++k)
            recourseFonts(reader.getPageN(k), hits, fonts, 1);
        return fonts;
    }
    
    /**
     * Gets a list of the document fonts in a particular page. Each element of the <CODE>ArrayList</CODE>
     * contains a <CODE>Object[]{String,PRIndirectReference}</CODE> with the font name
     * and the indirect reference to it.
     * @param reader the document where the fonts are to be listed from
     * @param page the page to list the fonts from
     * @return the list of fonts and references
     */    
    public static ArrayList getDocumentFonts(PdfReader reader, int page) {
        IntHashtable hits = new IntHashtable();
        ArrayList fonts = new ArrayList();
        recourseFonts(reader.getPageN(page), hits, fonts, 1);
        return fonts;
    }
    
    /**
     * Gets the smallest box enclosing the character contours. It will return
     * <CODE>null</CODE> if the font has not the information or the character has no
     * contours, as in the case of the space, for example. Characters with no contours may
     * also return [0,0,0,0].
     * @param c the character to get the contour bounding box from
     * @return an array of four floats with the bounding box in the format [llx,lly,urx,ury] or
     * <code>null</code>
     */    
    public int[] getCharBBox(char c) {
        byte b[] = convertToBytes(new String(new char[]{c}));
        if (b.length == 0)
            return null;
        else
            return charBBoxes[b[0] & 0xff];
    }
    
    protected abstract int[] getRawCharBBox(int c, String name);

    /**
     * iText expects Arabic Diactrics (tashkeel) to have zero advance but some fonts,
     * most notably those that come with Windows, like times.ttf, have non-zero
     * advance for those characters. This method makes those character to have zero
     * width advance and work correctly in the iText Arabic shaping and reordering
     * context.
     */    
    public void correctArabicAdvance() {
        for (char c = '\u064b'; c <= '\u0658'; ++c)
            setCharAdvance(c, 0);
        setCharAdvance('\u0670', 0);
        for (char c = '\u06d6'; c <= '\u06dc'; ++c)
            setCharAdvance(c, 0);
        for (char c = '\u06df'; c <= '\u06e4'; ++c)
            setCharAdvance(c, 0);
        for (char c = '\u06e7'; c <= '\u06e8'; ++c)
            setCharAdvance(c, 0);
        for (char c = '\u06ea'; c <= '\u06ed'; ++c)
            setCharAdvance(c, 0);
    }
}
 /*
 *
 * Copyright 2002 Paulo Soares
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf;

import java.util.ArrayList;

import pdftk.com.lowagie.text.Chunk;

/** Does all the line bidirectional processing with PdfChunk assembly.
 *
 * @author Paulo Soares (psoares@consiste.pt)
 */
public class BidiLine {
    
    protected int runDirection;
    protected int pieceSize = 2048;
    protected char text[] = new char[pieceSize];
    protected PdfChunk detailChunks[] = new PdfChunk[pieceSize];
    protected int totalTextLength = 0;
    
    protected byte orderLevels[] = new byte[pieceSize];
    protected int indexChars[] = new int[pieceSize];
    
    protected ArrayList chunks = new ArrayList();
    protected int indexChunk = 0;
    protected int indexChunkChar = 0;
    protected int currentChar = 0;
    
    protected int storedRunDirection;
    protected char storedText[] = new char[0];
    protected PdfChunk storedDetailChunks[] = new PdfChunk[0];
    protected int storedTotalTextLength = 0;
    
    protected byte storedOrderLevels[] = new byte[0];
    protected int storedIndexChars[] = new int[0];
    
    protected int storedIndexChunk = 0;
    protected int storedIndexChunkChar = 0;
    protected int storedCurrentChar = 0;
    
    protected boolean shortStore;
//    protected ArabicShaping arabic = new ArabicShaping(ArabicShaping.LETTERS_SHAPE | ArabicShaping.LENGTH_GROW_SHRINK | ArabicShaping.TEXT_DIRECTION_LOGICAL);
    protected static final IntHashtable mirrorChars = new IntHashtable();
    protected int arabicOptions;

    /** Creates new BidiLine */
    public BidiLine() {
    }
    
    public BidiLine(BidiLine org) {
        runDirection = org.runDirection;
        pieceSize = org.pieceSize;
        text = (char[])org.text.clone();
        detailChunks = (PdfChunk[])org.detailChunks.clone();
        totalTextLength = org.totalTextLength;

        orderLevels = (byte[])org.orderLevels.clone();
        indexChars = (int[])org.indexChars.clone();

        chunks = new ArrayList(org.chunks);
        indexChunk = org.indexChunk;
        indexChunkChar = org.indexChunkChar;
        currentChar = org.currentChar;

        storedRunDirection = org.storedRunDirection;
        storedText = (char[])org.storedText.clone();
        storedDetailChunks = (PdfChunk[])org.storedDetailChunks.clone();
        storedTotalTextLength = org.storedTotalTextLength;

        storedOrderLevels = (byte[])org.storedOrderLevels.clone();
        storedIndexChars = (int[])org.storedIndexChars.clone();

        storedIndexChunk = org.storedIndexChunk;
        storedIndexChunkChar = org.storedIndexChunkChar;
        storedCurrentChar = org.storedCurrentChar;

        shortStore = org.shortStore;
        arabicOptions = org.arabicOptions;
    }
    
    public boolean isEmpty() {
        return (currentChar >= totalTextLength && indexChunk >= chunks.size());
    }
    
    public void clearChunks() {
        chunks.clear();
        totalTextLength = 0;
        currentChar = 0;
    }

    public boolean getParagraph(int runDirection) {
        this.runDirection = runDirection;
        currentChar = 0;
        totalTextLength = 0;
        boolean hasText = false;
        char c;
        char uniC;
        BaseFont bf;
        for (; indexChunk < chunks.size(); ++indexChunk) {
            PdfChunk ck = (PdfChunk)chunks.get(indexChunk);
            bf = ck.font().getFont();
            String s = ck.toString();
            int len = s.length();
            for (; indexChunkChar < len; ++indexChunkChar) {
                c = s.charAt(indexChunkChar);
                uniC = bf.getUnicodeEquivalent(c);
                if (uniC == '\r' || uniC == '\n') {
                    // next condition is never true for CID
                    if (uniC == '\r' && indexChunkChar + 1 < len && s.charAt(indexChunkChar + 1) == '\n')
                        ++indexChunkChar;
                    ++indexChunkChar;
                    if (indexChunkChar >= len) {
                        indexChunkChar = 0;
                        ++indexChunk;
                    }
                    hasText = true;
                    if (totalTextLength == 0)
                        detailChunks[0] = ck;
                    break;
                }
                addPiece(c, ck);
            }
            if (hasText)
                break;
            indexChunkChar = 0;
        }
        if (totalTextLength == 0)
            return hasText;

        // remove trailing WS
        totalTextLength = trimRight(0, totalTextLength - 1) + 1;
        if (totalTextLength == 0)
            return true;
        
        if (runDirection == PdfWriter.RUN_DIRECTION_LTR || runDirection == PdfWriter.RUN_DIRECTION_RTL) {
            if (orderLevels.length < totalTextLength) {
                orderLevels = new byte[pieceSize];
                indexChars = new int[pieceSize];
            }
            ArabicLigaturizer.processNumbers(text, 0, totalTextLength, arabicOptions);
            BidiOrder order = new BidiOrder(text, 0, totalTextLength, (byte)(runDirection == PdfWriter.RUN_DIRECTION_RTL ? 1 : 0));
            byte od[] = order.getLevels();
            for (int k = 0; k < totalTextLength; ++k) {
                orderLevels[k] = od[k];
                indexChars[k] = k;
            }
            doArabicShapping();
            mirrorGlyphs();
        }
        totalTextLength = trimRightEx(0, totalTextLength - 1) + 1;
        return true;
    }
    
    public void addChunk(PdfChunk chunk) {
        chunks.add(chunk);
    }
    
    public void addChunks(ArrayList chunks) {
        this.chunks.addAll(chunks);
    }
    
    public void addPiece(char c, PdfChunk chunk) {
        if (totalTextLength >= pieceSize) {
            char tempText[] = text;
            PdfChunk tempDetailChunks[] = detailChunks;
            pieceSize *= 2;
            text = new char[pieceSize];
            detailChunks = new PdfChunk[pieceSize];
            System.arraycopy(tempText, 0, text, 0, totalTextLength);
            System.arraycopy(tempDetailChunks, 0, detailChunks, 0, totalTextLength);
        }
        text[totalTextLength] = c;
        detailChunks[totalTextLength++] = chunk;
    }
    
    public void save() {
        if (indexChunk > 0) {
            if (indexChunk >= chunks.size())
                chunks.clear();
            else {
                for (--indexChunk; indexChunk >= 0; --indexChunk)
                    chunks.remove(indexChunk);
            }
            indexChunk = 0;
        }
        storedRunDirection = runDirection;
        storedTotalTextLength = totalTextLength;
        storedIndexChunk = indexChunk;
        storedIndexChunkChar = indexChunkChar;
        storedCurrentChar = currentChar;
        shortStore = (currentChar < totalTextLength);
        if (!shortStore) {
            // long save
            if (storedText.length < totalTextLength) {
                storedText = new char[totalTextLength];
                storedDetailChunks = new PdfChunk[totalTextLength];
            }
            System.arraycopy(text, 0, storedText, 0, totalTextLength);
            System.arraycopy(detailChunks, 0, storedDetailChunks, 0, totalTextLength);
        }
        if (runDirection == PdfWriter.RUN_DIRECTION_LTR || runDirection == PdfWriter.RUN_DIRECTION_RTL) {
            if (storedOrderLevels.length < totalTextLength) {
                storedOrderLevels = new byte[totalTextLength];
                storedIndexChars = new int[totalTextLength];
            }
            System.arraycopy(orderLevels, currentChar, storedOrderLevels, currentChar, totalTextLength - currentChar);
            System.arraycopy(indexChars, currentChar, storedIndexChars, currentChar, totalTextLength - currentChar);
        }
    }
    
    public void restore() {
        runDirection = storedRunDirection;
        totalTextLength = storedTotalTextLength;
        indexChunk = storedIndexChunk;
        indexChunkChar = storedIndexChunkChar;
        currentChar = storedCurrentChar;
        if (!shortStore) {
            // long restore
            System.arraycopy(storedText, 0, text, 0, totalTextLength);
            System.arraycopy(storedDetailChunks, 0, detailChunks, 0, totalTextLength);
        }
        if (runDirection == PdfWriter.RUN_DIRECTION_LTR || runDirection == PdfWriter.RUN_DIRECTION_RTL) {
            System.arraycopy(storedOrderLevels, currentChar, orderLevels, currentChar, totalTextLength - currentChar);
            System.arraycopy(storedIndexChars, currentChar, indexChars, currentChar, totalTextLength - currentChar);
        }
    }
    
    public void mirrorGlyphs() {
        for (int k = 0; k < totalTextLength; ++k) {
            if ((orderLevels[k] & 1) == 1) {
                int mirror = mirrorChars.get(text[k]);
                if (mirror != 0)
                    text[k] = (char)mirror;
            }
        }
    }
    
    public void doArabicShapping() {
        int src = 0;
        int dest = 0;
        for (;;) {
            while (src < totalTextLength) {
                char c = text[src];
                if (c >= 0x0600 && c <= 0x06ff)
                    break;
                if (src != dest) {
                    text[dest] = text[src];
                    detailChunks[dest] = detailChunks[src];
                    orderLevels[dest] = orderLevels[src];
                }
                ++src;
                ++dest;
            }
            if (src >= totalTextLength) {
                totalTextLength = dest;
                return;
            }
            int startArabicIdx = src;
            ++src;
            while (src < totalTextLength) {
                char c = text[src];
                if (c < 0x0600 || c > 0x06ff)
                    break;
                ++src;
            }
            int arabicWordSize = src - startArabicIdx;
            int size = ArabicLigaturizer.arabic_shape(text, startArabicIdx, arabicWordSize, text, dest, arabicWordSize, arabicOptions /*PangoArabicShapping.ar_novowel PangoArabicShapping.ar_lig | PangoArabicShapping.ar_composedtashkeel*/);
            if (startArabicIdx != dest) {
                for (int k = 0; k < size; ++k) {
                    detailChunks[dest] = detailChunks[startArabicIdx];
                    orderLevels[dest++] = orderLevels[startArabicIdx++];
                }
            }
            else
                dest += size;
        }
    }
       
    public PdfLine processLine(float width, int alignment, int runDirection, int arabicOptions) {
        this.arabicOptions = arabicOptions;
        save();
        boolean isRTL = (runDirection == PdfWriter.RUN_DIRECTION_RTL);
        if (currentChar >= totalTextLength) {
            boolean hasText = getParagraph(runDirection);
            if (!hasText)
                return null;
            if (totalTextLength == 0) {
                ArrayList ar = new ArrayList();
                PdfChunk ck = new PdfChunk("", detailChunks[0]);
                ar.add(ck);
                return new PdfLine(0, 0, alignment, true, ar, isRTL);
            }
        }
        float originalWidth = width;
        int lastSplit = -1;
        if (currentChar != 0)
            currentChar = trimLeftEx(currentChar, totalTextLength - 1);
        int oldCurrentChar = currentChar;
        char c = 0;
        char uniC = 0;
        PdfChunk ck = null;
        float charWidth = 0;
        PdfChunk lastValidChunk = null;
        for (; currentChar < totalTextLength; ++currentChar) {
            c = text[currentChar];
            ck = detailChunks[currentChar];
            uniC = ck.getUnicodeEquivalent(c);
            if (PdfChunk.noPrint(uniC))
                continue;
            charWidth = ck.getCharWidth(c);
            if (ck.isExtSplitCharacter(oldCurrentChar, currentChar, totalTextLength, text, detailChunks))
                lastSplit = currentChar;
            if (width - charWidth < 0)
                break;
            width -= charWidth;
            lastValidChunk = ck;
        }
        if (lastValidChunk == null) {
            // not even a single char fit; must output the first char
            ++currentChar;
            return new PdfLine(0, 0, alignment, false, createArrayOfPdfChunks(currentChar - 1, currentChar - 1), isRTL);
        }
        if (currentChar >= totalTextLength) {
            // there was more line than text
            return new PdfLine(0, width, alignment, true, createArrayOfPdfChunks(oldCurrentChar, totalTextLength - 1), isRTL);
        }
        int newCurrentChar = trimRightEx(oldCurrentChar, currentChar - 1);
        if (newCurrentChar < oldCurrentChar) {
            // only WS
            return new PdfLine(0, width, alignment, false, createArrayOfPdfChunks(oldCurrentChar, currentChar - 1), isRTL);
        }
        if (newCurrentChar == currentChar - 1) { // middle of word
            HyphenationEvent he = (HyphenationEvent)lastValidChunk.getAttribute(Chunk.HYPHENATION);
            if (he != null) {
                int word[] = getWord(oldCurrentChar, newCurrentChar);
                if (word != null) {
                    float testWidth = width + getWidth(word[0], currentChar - 1);
                    String pre = he.getHyphenatedWordPre(new String(text, word[0], word[1] - word[0]), lastValidChunk.font().getFont(), lastValidChunk.font().size(), testWidth);
                    String post = he.getHyphenatedWordPost();
                    if (pre.length() > 0) {
                        PdfChunk extra = new PdfChunk(pre, lastValidChunk);
                        currentChar = word[1] - post.length();
                        return new PdfLine(0, testWidth - lastValidChunk.font().width(pre), alignment, false, createArrayOfPdfChunks(oldCurrentChar, word[0] - 1, extra), isRTL);
                    }
                }
            }
        }
        if (lastSplit == -1 || lastSplit >= newCurrentChar) {
            // no split point or split point ahead of end
            return new PdfLine(0, width + getWidth(newCurrentChar + 1, currentChar - 1), alignment, false, createArrayOfPdfChunks(oldCurrentChar, newCurrentChar), isRTL);
        }
        // standard split
        currentChar = lastSplit + 1;
        newCurrentChar = trimRightEx(oldCurrentChar, lastSplit);
        if (newCurrentChar < oldCurrentChar) {
            // only WS again
            newCurrentChar = currentChar - 1;
        }
        return new PdfLine(0, originalWidth - getWidth(oldCurrentChar, newCurrentChar), alignment, false, createArrayOfPdfChunks(oldCurrentChar, newCurrentChar), isRTL);
    }
    
    /** Gets the width of a range of characters.
     * @param startIdx the first index to calculate
     * @param lastIdx the last inclusive index to calculate
     * @return the sum of all widths
     */    
    public float getWidth(int startIdx, int lastIdx) {
        char c = 0;
        char uniC;
        PdfChunk ck = null;
        float width = 0;
        for (; startIdx <= lastIdx; ++startIdx) {
            c = text[startIdx];
            ck = detailChunks[startIdx];
            uniC = ck.getUnicodeEquivalent(c);
            if (PdfChunk.noPrint(uniC))
                continue;
            width += detailChunks[startIdx].getCharWidth(c);
        }
        return width;
    }
    
    public ArrayList createArrayOfPdfChunks(int startIdx, int endIdx) {
        return createArrayOfPdfChunks(startIdx, endIdx, null);
    }
    
    public ArrayList createArrayOfPdfChunks(int startIdx, int endIdx, PdfChunk extraPdfChunk) {
        boolean bidi = (runDirection == PdfWriter.RUN_DIRECTION_LTR || runDirection == PdfWriter.RUN_DIRECTION_RTL);
        if (bidi)
            reorder(startIdx, endIdx);
        ArrayList ar = new ArrayList();
        PdfChunk refCk = detailChunks[startIdx];
        PdfChunk ck = null;
        StringBuffer buf = new StringBuffer();
        char c;
        int idx = 0;
        for (; startIdx <= endIdx; ++startIdx) {
            idx = bidi ? indexChars[startIdx] : startIdx;
            c = text[idx];
            ck = detailChunks[idx];
            if (PdfChunk.noPrint(ck.getUnicodeEquivalent(c)))
                continue;
	    /* ssteward: dropped in 1.44
            if (ck.isImage()) {
                if (buf.length() > 0) {
                    ar.add(new PdfChunk(buf.toString(), refCk));
                    buf = new StringBuffer();
                }
                ar.add(ck);
            }
            else */
	    if (ck == refCk) {
                buf.append(c);
            }
            else {
                if (buf.length() > 0) {
                    ar.add(new PdfChunk(buf.toString(), refCk));
                    buf = new StringBuffer();
                }
		/* ssteward: dropped in 1.44
                if (!ck.isImage())
                    buf.append(c);
                refCk = ck;
		*/
            }
        }
        if (buf.length() > 0) {
            ar.add(new PdfChunk(buf.toString(), refCk));
        }
        if (extraPdfChunk != null)
            ar.add(extraPdfChunk);
        return ar;
    }
    
    public int[] getWord(int startIdx, int idx) {
        int last = idx;
        int first = idx;
        // forward
        for (; last < totalTextLength; ++last) {
            if (!Character.isLetter(text[last]))
                break;            
        }
        if (last == idx)
            return null;
        // backward
        for (; first >= startIdx; --first) {
            if (!Character.isLetter(text[first]))
                break;            
        }
        ++first;
        return new int[]{first, last};
    }
    
    public int trimRight(int startIdx, int endIdx) {
        int idx = endIdx;
        char c;
        for (; idx >= startIdx; --idx) {
            c = detailChunks[idx].getUnicodeEquivalent(text[idx]);
            if (!isWS(c))
                break;
        }
        return idx;
    }
    
    public int trimLeft(int startIdx, int endIdx) {
        int idx = startIdx;
        char c;
        for (; idx <= endIdx; ++idx) {
            c = detailChunks[idx].getUnicodeEquivalent(text[idx]);
            if (!isWS(c))
                break;
        }
        return idx;
    }
    
    public int trimRightEx(int startIdx, int endIdx) {
        int idx = endIdx;
        char c = 0;
        for (; idx >= startIdx; --idx) {
            c = detailChunks[idx].getUnicodeEquivalent(text[idx]);
            if (!isWS(c) && !PdfChunk.noPrint(c))
                break;
        }
        return idx;
    }
    
    public int trimLeftEx(int startIdx, int endIdx) {
        int idx = startIdx;
        char c = 0;
        for (; idx <= endIdx; ++idx) {
            c = detailChunks[idx].getUnicodeEquivalent(text[idx]);
            if (!isWS(c) && !PdfChunk.noPrint(c))
                break;
        }
        return idx;
    }
    
    public void reorder(int start, int end) {
        byte maxLevel = orderLevels[start];
        byte minLevel = maxLevel;
        byte onlyOddLevels = maxLevel;
        byte onlyEvenLevels = maxLevel;
        for (int k = start + 1; k <= end; ++k) {
            byte b = orderLevels[k];
            if (b > maxLevel)
                maxLevel = b;
            else if (b < minLevel)
                minLevel = b;
            onlyOddLevels &= b;
            onlyEvenLevels |= b;
        }
        if ((onlyEvenLevels & 1) == 0) // nothing to do
            return;
        if ((onlyOddLevels & 1) == 1) { // single inversion
            flip(start, end + 1);
            return;
        }
        minLevel |= 1;
        for (; maxLevel >= minLevel; --maxLevel) {
            int pstart = start;
            for (;;) {
                for (;pstart <= end; ++pstart) {
                    if (orderLevels[pstart] >= maxLevel)
                        break;
                }
                if (pstart > end)
                    break;
                int pend = pstart + 1;
                for (; pend <= end; ++pend) {
                    if (orderLevels[pend] < maxLevel)
                        break;
                }
                flip(pstart, pend);
                pstart = pend + 1;
            }
        }
    }
    
    public void flip(int start, int end) {
        int mid = (start + end) / 2;
        --end;
        for (; start < mid; ++start, --end) {
            int temp = indexChars[start];
            indexChars[start] = indexChars[end];
            indexChars[end] = temp;
        }
    }
    
    public static boolean isWS(char c) {
        return (c <= ' ');
    }

    static {
        mirrorChars.put(0x0028, 0x0029); // LEFT PARENTHESIS
        mirrorChars.put(0x0029, 0x0028); // RIGHT PARENTHESIS
        mirrorChars.put(0x003C, 0x003E); // LESS-THAN SIGN
        mirrorChars.put(0x003E, 0x003C); // GREATER-THAN SIGN
        mirrorChars.put(0x005B, 0x005D); // LEFT SQUARE BRACKET
        mirrorChars.put(0x005D, 0x005B); // RIGHT SQUARE BRACKET
        mirrorChars.put(0x007B, 0x007D); // LEFT CURLY BRACKET
        mirrorChars.put(0x007D, 0x007B); // RIGHT CURLY BRACKET
        mirrorChars.put(0x00AB, 0x00BB); // LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
        mirrorChars.put(0x00BB, 0x00AB); // RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
        mirrorChars.put(0x2039, 0x203A); // SINGLE LEFT-POINTING ANGLE QUOTATION MARK
        mirrorChars.put(0x203A, 0x2039); // SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
        mirrorChars.put(0x2045, 0x2046); // LEFT SQUARE BRACKET WITH QUILL
        mirrorChars.put(0x2046, 0x2045); // RIGHT SQUARE BRACKET WITH QUILL
        mirrorChars.put(0x207D, 0x207E); // SUPERSCRIPT LEFT PARENTHESIS
        mirrorChars.put(0x207E, 0x207D); // SUPERSCRIPT RIGHT PARENTHESIS
        mirrorChars.put(0x208D, 0x208E); // SUBSCRIPT LEFT PARENTHESIS
        mirrorChars.put(0x208E, 0x208D); // SUBSCRIPT RIGHT PARENTHESIS
        mirrorChars.put(0x2208, 0x220B); // ELEMENT OF
        mirrorChars.put(0x2209, 0x220C); // NOT AN ELEMENT OF
        mirrorChars.put(0x220A, 0x220D); // SMALL ELEMENT OF
        mirrorChars.put(0x220B, 0x2208); // CONTAINS AS MEMBER
        mirrorChars.put(0x220C, 0x2209); // DOES NOT CONTAIN AS MEMBER
        mirrorChars.put(0x220D, 0x220A); // SMALL CONTAINS AS MEMBER
        mirrorChars.put(0x2215, 0x29F5); // DIVISION SLASH
        mirrorChars.put(0x223C, 0x223D); // TILDE OPERATOR
        mirrorChars.put(0x223D, 0x223C); // REVERSED TILDE
        mirrorChars.put(0x2243, 0x22CD); // ASYMPTOTICALLY EQUAL TO
        mirrorChars.put(0x2252, 0x2253); // APPROXIMATELY EQUAL TO OR THE IMAGE OF
        mirrorChars.put(0x2253, 0x2252); // IMAGE OF OR APPROXIMATELY EQUAL TO
        mirrorChars.put(0x2254, 0x2255); // COLON EQUALS
        mirrorChars.put(0x2255, 0x2254); // EQUALS COLON
        mirrorChars.put(0x2264, 0x2265); // LESS-THAN OR EQUAL TO
        mirrorChars.put(0x2265, 0x2264); // GREATER-THAN OR EQUAL TO
        mirrorChars.put(0x2266, 0x2267); // LESS-THAN OVER EQUAL TO
        mirrorChars.put(0x2267, 0x2266); // GREATER-THAN OVER EQUAL TO
        mirrorChars.put(0x2268, 0x2269); // [BEST FIT] LESS-THAN BUT NOT EQUAL TO
        mirrorChars.put(0x2269, 0x2268); // [BEST FIT] GREATER-THAN BUT NOT EQUAL TO
        mirrorChars.put(0x226A, 0x226B); // MUCH LESS-THAN
        mirrorChars.put(0x226B, 0x226A); // MUCH GREATER-THAN
        mirrorChars.put(0x226E, 0x226F); // [BEST FIT] NOT LESS-THAN
        mirrorChars.put(0x226F, 0x226E); // [BEST FIT] NOT GREATER-THAN
        mirrorChars.put(0x2270, 0x2271); // [BEST FIT] NEITHER LESS-THAN NOR EQUAL TO
        mirrorChars.put(0x2271, 0x2270); // [BEST FIT] NEITHER GREATER-THAN NOR EQUAL TO
        mirrorChars.put(0x2272, 0x2273); // [BEST FIT] LESS-THAN OR EQUIVALENT TO
        mirrorChars.put(0x2273, 0x2272); // [BEST FIT] GREATER-THAN OR EQUIVALENT TO
        mirrorChars.put(0x2274, 0x2275); // [BEST FIT] NEITHER LESS-THAN NOR EQUIVALENT TO
        mirrorChars.put(0x2275, 0x2274); // [BEST FIT] NEITHER GREATER-THAN NOR EQUIVALENT TO
        mirrorChars.put(0x2276, 0x2277); // LESS-THAN OR GREATER-THAN
        mirrorChars.put(0x2277, 0x2276); // GREATER-THAN OR LESS-THAN
        mirrorChars.put(0x2278, 0x2279); // NEITHER LESS-THAN NOR GREATER-THAN
        mirrorChars.put(0x2279, 0x2278); // NEITHER GREATER-THAN NOR LESS-THAN
        mirrorChars.put(0x227A, 0x227B); // PRECEDES
        mirrorChars.put(0x227B, 0x227A); // SUCCEEDS
        mirrorChars.put(0x227C, 0x227D); // PRECEDES OR EQUAL TO
        mirrorChars.put(0x227D, 0x227C); // SUCCEEDS OR EQUAL TO
        mirrorChars.put(0x227E, 0x227F); // [BEST FIT] PRECEDES OR EQUIVALENT TO
        mirrorChars.put(0x227F, 0x227E); // [BEST FIT] SUCCEEDS OR EQUIVALENT TO
        mirrorChars.put(0x2280, 0x2281); // [BEST FIT] DOES NOT PRECEDE
        mirrorChars.put(0x2281, 0x2280); // [BEST FIT] DOES NOT SUCCEED
        mirrorChars.put(0x2282, 0x2283); // SUBSET OF
        mirrorChars.put(0x2283, 0x2282); // SUPERSET OF
        mirrorChars.put(0x2284, 0x2285); // [BEST FIT] NOT A SUBSET OF
        mirrorChars.put(0x2285, 0x2284); // [BEST FIT] NOT A SUPERSET OF
        mirrorChars.put(0x2286, 0x2287); // SUBSET OF OR EQUAL TO
        mirrorChars.put(0x2287, 0x2286); // SUPERSET OF OR EQUAL TO
        mirrorChars.put(0x2288, 0x2289); // [BEST FIT] NEITHER A SUBSET OF NOR EQUAL TO
        mirrorChars.put(0x2289, 0x2288); // [BEST FIT] NEITHER A SUPERSET OF NOR EQUAL TO
        mirrorChars.put(0x228A, 0x228B); // [BEST FIT] SUBSET OF WITH NOT EQUAL TO
        mirrorChars.put(0x228B, 0x228A); // [BEST FIT] SUPERSET OF WITH NOT EQUAL TO
        mirrorChars.put(0x228F, 0x2290); // SQUARE IMAGE OF
        mirrorChars.put(0x2290, 0x228F); // SQUARE ORIGINAL OF
        mirrorChars.put(0x2291, 0x2292); // SQUARE IMAGE OF OR EQUAL TO
        mirrorChars.put(0x2292, 0x2291); // SQUARE ORIGINAL OF OR EQUAL TO
        mirrorChars.put(0x2298, 0x29B8); // CIRCLED DIVISION SLASH
        mirrorChars.put(0x22A2, 0x22A3); // RIGHT TACK
        mirrorChars.put(0x22A3, 0x22A2); // LEFT TACK
        mirrorChars.put(0x22A6, 0x2ADE); // ASSERTION
        mirrorChars.put(0x22A8, 0x2AE4); // TRUE
        mirrorChars.put(0x22A9, 0x2AE3); // FORCES
        mirrorChars.put(0x22AB, 0x2AE5); // DOUBLE VERTICAL BAR DOUBLE RIGHT TURNSTILE
        mirrorChars.put(0x22B0, 0x22B1); // PRECEDES UNDER RELATION
        mirrorChars.put(0x22B1, 0x22B0); // SUCCEEDS UNDER RELATION
        mirrorChars.put(0x22B2, 0x22B3); // NORMAL SUBGROUP OF
        mirrorChars.put(0x22B3, 0x22B2); // CONTAINS AS NORMAL SUBGROUP
        mirrorChars.put(0x22B4, 0x22B5); // NORMAL SUBGROUP OF OR EQUAL TO
        mirrorChars.put(0x22B5, 0x22B4); // CONTAINS AS NORMAL SUBGROUP OR EQUAL TO
        mirrorChars.put(0x22B6, 0x22B7); // ORIGINAL OF
        mirrorChars.put(0x22B7, 0x22B6); // IMAGE OF
        mirrorChars.put(0x22C9, 0x22CA); // LEFT NORMAL FACTOR SEMIDIRECT PRODUCT
        mirrorChars.put(0x22CA, 0x22C9); // RIGHT NORMAL FACTOR SEMIDIRECT PRODUCT
        mirrorChars.put(0x22CB, 0x22CC); // LEFT SEMIDIRECT PRODUCT
        mirrorChars.put(0x22CC, 0x22CB); // RIGHT SEMIDIRECT PRODUCT
        mirrorChars.put(0x22CD, 0x2243); // REVERSED TILDE EQUALS
        mirrorChars.put(0x22D0, 0x22D1); // DOUBLE SUBSET
        mirrorChars.put(0x22D1, 0x22D0); // DOUBLE SUPERSET
        mirrorChars.put(0x22D6, 0x22D7); // LESS-THAN WITH DOT
        mirrorChars.put(0x22D7, 0x22D6); // GREATER-THAN WITH DOT
        mirrorChars.put(0x22D8, 0x22D9); // VERY MUCH LESS-THAN
        mirrorChars.put(0x22D9, 0x22D8); // VERY MUCH GREATER-THAN
        mirrorChars.put(0x22DA, 0x22DB); // LESS-THAN EQUAL TO OR GREATER-THAN
        mirrorChars.put(0x22DB, 0x22DA); // GREATER-THAN EQUAL TO OR LESS-THAN
        mirrorChars.put(0x22DC, 0x22DD); // EQUAL TO OR LESS-THAN
        mirrorChars.put(0x22DD, 0x22DC); // EQUAL TO OR GREATER-THAN
        mirrorChars.put(0x22DE, 0x22DF); // EQUAL TO OR PRECEDES
        mirrorChars.put(0x22DF, 0x22DE); // EQUAL TO OR SUCCEEDS
        mirrorChars.put(0x22E0, 0x22E1); // [BEST FIT] DOES NOT PRECEDE OR EQUAL
        mirrorChars.put(0x22E1, 0x22E0); // [BEST FIT] DOES NOT SUCCEED OR EQUAL
        mirrorChars.put(0x22E2, 0x22E3); // [BEST FIT] NOT SQUARE IMAGE OF OR EQUAL TO
        mirrorChars.put(0x22E3, 0x22E2); // [BEST FIT] NOT SQUARE ORIGINAL OF OR EQUAL TO
        mirrorChars.put(0x22E4, 0x22E5); // [BEST FIT] SQUARE IMAGE OF OR NOT EQUAL TO
        mirrorChars.put(0x22E5, 0x22E4); // [BEST FIT] SQUARE ORIGINAL OF OR NOT EQUAL TO
        mirrorChars.put(0x22E6, 0x22E7); // [BEST FIT] LESS-THAN BUT NOT EQUIVALENT TO
        mirrorChars.put(0x22E7, 0x22E6); // [BEST FIT] GREATER-THAN BUT NOT EQUIVALENT TO
        mirrorChars.put(0x22E8, 0x22E9); // [BEST FIT] PRECEDES BUT NOT EQUIVALENT TO
        mirrorChars.put(0x22E9, 0x22E8); // [BEST FIT] SUCCEEDS BUT NOT EQUIVALENT TO
        mirrorChars.put(0x22EA, 0x22EB); // [BEST FIT] NOT NORMAL SUBGROUP OF
        mirrorChars.put(0x22EB, 0x22EA); // [BEST FIT] DOES NOT CONTAIN AS NORMAL SUBGROUP
        mirrorChars.put(0x22EC, 0x22ED); // [BEST FIT] NOT NORMAL SUBGROUP OF OR EQUAL TO
        mirrorChars.put(0x22ED, 0x22EC); // [BEST FIT] DOES NOT CONTAIN AS NORMAL SUBGROUP OR EQUAL
        mirrorChars.put(0x22F0, 0x22F1); // UP RIGHT DIAGONAL ELLIPSIS
        mirrorChars.put(0x22F1, 0x22F0); // DOWN RIGHT DIAGONAL ELLIPSIS
        mirrorChars.put(0x22F2, 0x22FA); // ELEMENT OF WITH LONG HORIZONTAL STROKE
        mirrorChars.put(0x22F3, 0x22FB); // ELEMENT OF WITH VERTICAL BAR AT END OF HORIZONTAL STROKE
        mirrorChars.put(0x22F4, 0x22FC); // SMALL ELEMENT OF WITH VERTICAL BAR AT END OF HORIZONTAL STROKE
        mirrorChars.put(0x22F6, 0x22FD); // ELEMENT OF WITH OVERBAR
        mirrorChars.put(0x22F7, 0x22FE); // SMALL ELEMENT OF WITH OVERBAR
        mirrorChars.put(0x22FA, 0x22F2); // CONTAINS WITH LONG HORIZONTAL STROKE
        mirrorChars.put(0x22FB, 0x22F3); // CONTAINS WITH VERTICAL BAR AT END OF HORIZONTAL STROKE
        mirrorChars.put(0x22FC, 0x22F4); // SMALL CONTAINS WITH VERTICAL BAR AT END OF HORIZONTAL STROKE
        mirrorChars.put(0x22FD, 0x22F6); // CONTAINS WITH OVERBAR
        mirrorChars.put(0x22FE, 0x22F7); // SMALL CONTAINS WITH OVERBAR
        mirrorChars.put(0x2308, 0x2309); // LEFT CEILING
        mirrorChars.put(0x2309, 0x2308); // RIGHT CEILING
        mirrorChars.put(0x230A, 0x230B); // LEFT FLOOR
        mirrorChars.put(0x230B, 0x230A); // RIGHT FLOOR
        mirrorChars.put(0x2329, 0x232A); // LEFT-POINTING ANGLE BRACKET
        mirrorChars.put(0x232A, 0x2329); // RIGHT-POINTING ANGLE BRACKET
        mirrorChars.put(0x2768, 0x2769); // MEDIUM LEFT PARENTHESIS ORNAMENT
        mirrorChars.put(0x2769, 0x2768); // MEDIUM RIGHT PARENTHESIS ORNAMENT
        mirrorChars.put(0x276A, 0x276B); // MEDIUM FLATTENED LEFT PARENTHESIS ORNAMENT
        mirrorChars.put(0x276B, 0x276A); // MEDIUM FLATTENED RIGHT PARENTHESIS ORNAMENT
        mirrorChars.put(0x276C, 0x276D); // MEDIUM LEFT-POINTING ANGLE BRACKET ORNAMENT
        mirrorChars.put(0x276D, 0x276C); // MEDIUM RIGHT-POINTING ANGLE BRACKET ORNAMENT
        mirrorChars.put(0x276E, 0x276F); // HEAVY LEFT-POINTING ANGLE QUOTATION MARK ORNAMENT
        mirrorChars.put(0x276F, 0x276E); // HEAVY RIGHT-POINTING ANGLE QUOTATION MARK ORNAMENT
        mirrorChars.put(0x2770, 0x2771); // HEAVY LEFT-POINTING ANGLE BRACKET ORNAMENT
        mirrorChars.put(0x2771, 0x2770); // HEAVY RIGHT-POINTING ANGLE BRACKET ORNAMENT
        mirrorChars.put(0x2772, 0x2773); // LIGHT LEFT TORTOISE SHELL BRACKET
        mirrorChars.put(0x2773, 0x2772); // LIGHT RIGHT TORTOISE SHELL BRACKET
        mirrorChars.put(0x2774, 0x2775); // MEDIUM LEFT CURLY BRACKET ORNAMENT
        mirrorChars.put(0x2775, 0x2774); // MEDIUM RIGHT CURLY BRACKET ORNAMENT
        mirrorChars.put(0x27D5, 0x27D6); // LEFT OUTER JOIN
        mirrorChars.put(0x27D6, 0x27D5); // RIGHT OUTER JOIN
        mirrorChars.put(0x27DD, 0x27DE); // LONG RIGHT TACK
        mirrorChars.put(0x27DE, 0x27DD); // LONG LEFT TACK
        mirrorChars.put(0x27E2, 0x27E3); // WHITE CONCAVE-SIDED DIAMOND WITH LEFTWARDS TICK
        mirrorChars.put(0x27E3, 0x27E2); // WHITE CONCAVE-SIDED DIAMOND WITH RIGHTWARDS TICK
        mirrorChars.put(0x27E4, 0x27E5); // WHITE SQUARE WITH LEFTWARDS TICK
        mirrorChars.put(0x27E5, 0x27E4); // WHITE SQUARE WITH RIGHTWARDS TICK
        mirrorChars.put(0x27E6, 0x27E7); // MATHEMATICAL LEFT WHITE SQUARE BRACKET
        mirrorChars.put(0x27E7, 0x27E6); // MATHEMATICAL RIGHT WHITE SQUARE BRACKET
        mirrorChars.put(0x27E8, 0x27E9); // MATHEMATICAL LEFT ANGLE BRACKET
        mirrorChars.put(0x27E9, 0x27E8); // MATHEMATICAL RIGHT ANGLE BRACKET
        mirrorChars.put(0x27EA, 0x27EB); // MATHEMATICAL LEFT DOUBLE ANGLE BRACKET
        mirrorChars.put(0x27EB, 0x27EA); // MATHEMATICAL RIGHT DOUBLE ANGLE BRACKET
        mirrorChars.put(0x2983, 0x2984); // LEFT WHITE CURLY BRACKET
        mirrorChars.put(0x2984, 0x2983); // RIGHT WHITE CURLY BRACKET
        mirrorChars.put(0x2985, 0x2986); // LEFT WHITE PARENTHESIS
        mirrorChars.put(0x2986, 0x2985); // RIGHT WHITE PARENTHESIS
        mirrorChars.put(0x2987, 0x2988); // Z NOTATION LEFT IMAGE BRACKET
        mirrorChars.put(0x2988, 0x2987); // Z NOTATION RIGHT IMAGE BRACKET
        mirrorChars.put(0x2989, 0x298A); // Z NOTATION LEFT BINDING BRACKET
        mirrorChars.put(0x298A, 0x2989); // Z NOTATION RIGHT BINDING BRACKET
        mirrorChars.put(0x298B, 0x298C); // LEFT SQUARE BRACKET WITH UNDERBAR
        mirrorChars.put(0x298C, 0x298B); // RIGHT SQUARE BRACKET WITH UNDERBAR
        mirrorChars.put(0x298D, 0x2990); // LEFT SQUARE BRACKET WITH TICK IN TOP CORNER
        mirrorChars.put(0x298E, 0x298F); // RIGHT SQUARE BRACKET WITH TICK IN BOTTOM CORNER
        mirrorChars.put(0x298F, 0x298E); // LEFT SQUARE BRACKET WITH TICK IN BOTTOM CORNER
        mirrorChars.put(0x2990, 0x298D); // RIGHT SQUARE BRACKET WITH TICK IN TOP CORNER
        mirrorChars.put(0x2991, 0x2992); // LEFT ANGLE BRACKET WITH DOT
        mirrorChars.put(0x2992, 0x2991); // RIGHT ANGLE BRACKET WITH DOT
        mirrorChars.put(0x2993, 0x2994); // LEFT ARC LESS-THAN BRACKET
        mirrorChars.put(0x2994, 0x2993); // RIGHT ARC GREATER-THAN BRACKET
        mirrorChars.put(0x2995, 0x2996); // DOUBLE LEFT ARC GREATER-THAN BRACKET
        mirrorChars.put(0x2996, 0x2995); // DOUBLE RIGHT ARC LESS-THAN BRACKET
        mirrorChars.put(0x2997, 0x2998); // LEFT BLACK TORTOISE SHELL BRACKET
        mirrorChars.put(0x2998, 0x2997); // RIGHT BLACK TORTOISE SHELL BRACKET
        mirrorChars.put(0x29B8, 0x2298); // CIRCLED REVERSE SOLIDUS
        mirrorChars.put(0x29C0, 0x29C1); // CIRCLED LESS-THAN
        mirrorChars.put(0x29C1, 0x29C0); // CIRCLED GREATER-THAN
        mirrorChars.put(0x29C4, 0x29C5); // SQUARED RISING DIAGONAL SLASH
        mirrorChars.put(0x29C5, 0x29C4); // SQUARED FALLING DIAGONAL SLASH
        mirrorChars.put(0x29CF, 0x29D0); // LEFT TRIANGLE BESIDE VERTICAL BAR
        mirrorChars.put(0x29D0, 0x29CF); // VERTICAL BAR BESIDE RIGHT TRIANGLE
        mirrorChars.put(0x29D1, 0x29D2); // BOWTIE WITH LEFT HALF BLACK
        mirrorChars.put(0x29D2, 0x29D1); // BOWTIE WITH RIGHT HALF BLACK
        mirrorChars.put(0x29D4, 0x29D5); // TIMES WITH LEFT HALF BLACK
        mirrorChars.put(0x29D5, 0x29D4); // TIMES WITH RIGHT HALF BLACK
        mirrorChars.put(0x29D8, 0x29D9); // LEFT WIGGLY FENCE
        mirrorChars.put(0x29D9, 0x29D8); // RIGHT WIGGLY FENCE
        mirrorChars.put(0x29DA, 0x29DB); // LEFT DOUBLE WIGGLY FENCE
        mirrorChars.put(0x29DB, 0x29DA); // RIGHT DOUBLE WIGGLY FENCE
        mirrorChars.put(0x29F5, 0x2215); // REVERSE SOLIDUS OPERATOR
        mirrorChars.put(0x29F8, 0x29F9); // BIG SOLIDUS
        mirrorChars.put(0x29F9, 0x29F8); // BIG REVERSE SOLIDUS
        mirrorChars.put(0x29FC, 0x29FD); // LEFT-POINTING CURVED ANGLE BRACKET
        mirrorChars.put(0x29FD, 0x29FC); // RIGHT-POINTING CURVED ANGLE BRACKET
        mirrorChars.put(0x2A2B, 0x2A2C); // MINUS SIGN WITH FALLING DOTS
        mirrorChars.put(0x2A2C, 0x2A2B); // MINUS SIGN WITH RISING DOTS
        mirrorChars.put(0x2A2D, 0x2A2C); // PLUS SIGN IN LEFT HALF CIRCLE
        mirrorChars.put(0x2A2E, 0x2A2D); // PLUS SIGN IN RIGHT HALF CIRCLE
        mirrorChars.put(0x2A34, 0x2A35); // MULTIPLICATION SIGN IN LEFT HALF CIRCLE
        mirrorChars.put(0x2A35, 0x2A34); // MULTIPLICATION SIGN IN RIGHT HALF CIRCLE
        mirrorChars.put(0x2A3C, 0x2A3D); // INTERIOR PRODUCT
        mirrorChars.put(0x2A3D, 0x2A3C); // RIGHTHAND INTERIOR PRODUCT
        mirrorChars.put(0x2A64, 0x2A65); // Z NOTATION DOMAIN ANTIRESTRICTION
        mirrorChars.put(0x2A65, 0x2A64); // Z NOTATION RANGE ANTIRESTRICTION
        mirrorChars.put(0x2A79, 0x2A7A); // LESS-THAN WITH CIRCLE INSIDE
        mirrorChars.put(0x2A7A, 0x2A79); // GREATER-THAN WITH CIRCLE INSIDE
        mirrorChars.put(0x2A7D, 0x2A7E); // LESS-THAN OR SLANTED EQUAL TO
        mirrorChars.put(0x2A7E, 0x2A7D); // GREATER-THAN OR SLANTED EQUAL TO
        mirrorChars.put(0x2A7F, 0x2A80); // LESS-THAN OR SLANTED EQUAL TO WITH DOT INSIDE
        mirrorChars.put(0x2A80, 0x2A7F); // GREATER-THAN OR SLANTED EQUAL TO WITH DOT INSIDE
        mirrorChars.put(0x2A81, 0x2A82); // LESS-THAN OR SLANTED EQUAL TO WITH DOT ABOVE
        mirrorChars.put(0x2A82, 0x2A81); // GREATER-THAN OR SLANTED EQUAL TO WITH DOT ABOVE
        mirrorChars.put(0x2A83, 0x2A84); // LESS-THAN OR SLANTED EQUAL TO WITH DOT ABOVE RIGHT
        mirrorChars.put(0x2A84, 0x2A83); // GREATER-THAN OR SLANTED EQUAL TO WITH DOT ABOVE LEFT
        mirrorChars.put(0x2A8B, 0x2A8C); // LESS-THAN ABOVE DOUBLE-LINE EQUAL ABOVE GREATER-THAN
        mirrorChars.put(0x2A8C, 0x2A8B); // GREATER-THAN ABOVE DOUBLE-LINE EQUAL ABOVE LESS-THAN
        mirrorChars.put(0x2A91, 0x2A92); // LESS-THAN ABOVE GREATER-THAN ABOVE DOUBLE-LINE EQUAL
        mirrorChars.put(0x2A92, 0x2A91); // GREATER-THAN ABOVE LESS-THAN ABOVE DOUBLE-LINE EQUAL
        mirrorChars.put(0x2A93, 0x2A94); // LESS-THAN ABOVE SLANTED EQUAL ABOVE GREATER-THAN ABOVE SLANTED EQUAL
        mirrorChars.put(0x2A94, 0x2A93); // GREATER-THAN ABOVE SLANTED EQUAL ABOVE LESS-THAN ABOVE SLANTED EQUAL
        mirrorChars.put(0x2A95, 0x2A96); // SLANTED EQUAL TO OR LESS-THAN
        mirrorChars.put(0x2A96, 0x2A95); // SLANTED EQUAL TO OR GREATER-THAN
        mirrorChars.put(0x2A97, 0x2A98); // SLANTED EQUAL TO OR LESS-THAN WITH DOT INSIDE
        mirrorChars.put(0x2A98, 0x2A97); // SLANTED EQUAL TO OR GREATER-THAN WITH DOT INSIDE
        mirrorChars.put(0x2A99, 0x2A9A); // DOUBLE-LINE EQUAL TO OR LESS-THAN
        mirrorChars.put(0x2A9A, 0x2A99); // DOUBLE-LINE EQUAL TO OR GREATER-THAN
        mirrorChars.put(0x2A9B, 0x2A9C); // DOUBLE-LINE SLANTED EQUAL TO OR LESS-THAN
        mirrorChars.put(0x2A9C, 0x2A9B); // DOUBLE-LINE SLANTED EQUAL TO OR GREATER-THAN
        mirrorChars.put(0x2AA1, 0x2AA2); // DOUBLE NESTED LESS-THAN
        mirrorChars.put(0x2AA2, 0x2AA1); // DOUBLE NESTED GREATER-THAN
        mirrorChars.put(0x2AA6, 0x2AA7); // LESS-THAN CLOSED BY CURVE
        mirrorChars.put(0x2AA7, 0x2AA6); // GREATER-THAN CLOSED BY CURVE
        mirrorChars.put(0x2AA8, 0x2AA9); // LESS-THAN CLOSED BY CURVE ABOVE SLANTED EQUAL
        mirrorChars.put(0x2AA9, 0x2AA8); // GREATER-THAN CLOSED BY CURVE ABOVE SLANTED EQUAL
        mirrorChars.put(0x2AAA, 0x2AAB); // SMALLER THAN
        mirrorChars.put(0x2AAB, 0x2AAA); // LARGER THAN
        mirrorChars.put(0x2AAC, 0x2AAD); // SMALLER THAN OR EQUAL TO
        mirrorChars.put(0x2AAD, 0x2AAC); // LARGER THAN OR EQUAL TO
        mirrorChars.put(0x2AAF, 0x2AB0); // PRECEDES ABOVE SINGLE-LINE EQUALS SIGN
        mirrorChars.put(0x2AB0, 0x2AAF); // SUCCEEDS ABOVE SINGLE-LINE EQUALS SIGN
        mirrorChars.put(0x2AB3, 0x2AB4); // PRECEDES ABOVE EQUALS SIGN
        mirrorChars.put(0x2AB4, 0x2AB3); // SUCCEEDS ABOVE EQUALS SIGN
        mirrorChars.put(0x2ABB, 0x2ABC); // DOUBLE PRECEDES
        mirrorChars.put(0x2ABC, 0x2ABB); // DOUBLE SUCCEEDS
        mirrorChars.put(0x2ABD, 0x2ABE); // SUBSET WITH DOT
        mirrorChars.put(0x2ABE, 0x2ABD); // SUPERSET WITH DOT
        mirrorChars.put(0x2ABF, 0x2AC0); // SUBSET WITH PLUS SIGN BELOW
        mirrorChars.put(0x2AC0, 0x2ABF); // SUPERSET WITH PLUS SIGN BELOW
        mirrorChars.put(0x2AC1, 0x2AC2); // SUBSET WITH MULTIPLICATION SIGN BELOW
        mirrorChars.put(0x2AC2, 0x2AC1); // SUPERSET WITH MULTIPLICATION SIGN BELOW
        mirrorChars.put(0x2AC3, 0x2AC4); // SUBSET OF OR EQUAL TO WITH DOT ABOVE
        mirrorChars.put(0x2AC4, 0x2AC3); // SUPERSET OF OR EQUAL TO WITH DOT ABOVE
        mirrorChars.put(0x2AC5, 0x2AC6); // SUBSET OF ABOVE EQUALS SIGN
        mirrorChars.put(0x2AC6, 0x2AC5); // SUPERSET OF ABOVE EQUALS SIGN
        mirrorChars.put(0x2ACD, 0x2ACE); // SQUARE LEFT OPEN BOX OPERATOR
        mirrorChars.put(0x2ACE, 0x2ACD); // SQUARE RIGHT OPEN BOX OPERATOR
        mirrorChars.put(0x2ACF, 0x2AD0); // CLOSED SUBSET
        mirrorChars.put(0x2AD0, 0x2ACF); // CLOSED SUPERSET
        mirrorChars.put(0x2AD1, 0x2AD2); // CLOSED SUBSET OR EQUAL TO
        mirrorChars.put(0x2AD2, 0x2AD1); // CLOSED SUPERSET OR EQUAL TO
        mirrorChars.put(0x2AD3, 0x2AD4); // SUBSET ABOVE SUPERSET
        mirrorChars.put(0x2AD4, 0x2AD3); // SUPERSET ABOVE SUBSET
        mirrorChars.put(0x2AD5, 0x2AD6); // SUBSET ABOVE SUBSET
        mirrorChars.put(0x2AD6, 0x2AD5); // SUPERSET ABOVE SUPERSET
        mirrorChars.put(0x2ADE, 0x22A6); // SHORT LEFT TACK
        mirrorChars.put(0x2AE3, 0x22A9); // DOUBLE VERTICAL BAR LEFT TURNSTILE
        mirrorChars.put(0x2AE4, 0x22A8); // VERTICAL BAR DOUBLE LEFT TURNSTILE
        mirrorChars.put(0x2AE5, 0x22AB); // DOUBLE VERTICAL BAR DOUBLE LEFT TURNSTILE
        mirrorChars.put(0x2AEC, 0x2AED); // DOUBLE STROKE NOT SIGN
        mirrorChars.put(0x2AED, 0x2AEC); // REVERSED DOUBLE STROKE NOT SIGN
        mirrorChars.put(0x2AF7, 0x2AF8); // TRIPLE NESTED LESS-THAN
        mirrorChars.put(0x2AF8, 0x2AF7); // TRIPLE NESTED GREATER-THAN
        mirrorChars.put(0x2AF9, 0x2AFA); // DOUBLE-LINE SLANTED LESS-THAN OR EQUAL TO
        mirrorChars.put(0x2AFA, 0x2AF9); // DOUBLE-LINE SLANTED GREATER-THAN OR EQUAL TO
        mirrorChars.put(0x3008, 0x3009); // LEFT ANGLE BRACKET
        mirrorChars.put(0x3009, 0x3008); // RIGHT ANGLE BRACKET
        mirrorChars.put(0x300A, 0x300B); // LEFT DOUBLE ANGLE BRACKET
        mirrorChars.put(0x300B, 0x300A); // RIGHT DOUBLE ANGLE BRACKET
        mirrorChars.put(0x300C, 0x300D); // [BEST FIT] LEFT CORNER BRACKET
        mirrorChars.put(0x300D, 0x300C); // [BEST FIT] RIGHT CORNER BRACKET
        mirrorChars.put(0x300E, 0x300F); // [BEST FIT] LEFT WHITE CORNER BRACKET
        mirrorChars.put(0x300F, 0x300E); // [BEST FIT] RIGHT WHITE CORNER BRACKET
        mirrorChars.put(0x3010, 0x3011); // LEFT BLACK LENTICULAR BRACKET
        mirrorChars.put(0x3011, 0x3010); // RIGHT BLACK LENTICULAR BRACKET
        mirrorChars.put(0x3014, 0x3015); // LEFT TORTOISE SHELL BRACKET
        mirrorChars.put(0x3015, 0x3014); // RIGHT TORTOISE SHELL BRACKET
        mirrorChars.put(0x3016, 0x3017); // LEFT WHITE LENTICULAR BRACKET
        mirrorChars.put(0x3017, 0x3016); // RIGHT WHITE LENTICULAR BRACKET
        mirrorChars.put(0x3018, 0x3019); // LEFT WHITE TORTOISE SHELL BRACKET
        mirrorChars.put(0x3019, 0x3018); // RIGHT WHITE TORTOISE SHELL BRACKET
        mirrorChars.put(0x301A, 0x301B); // LEFT WHITE SQUARE BRACKET
        mirrorChars.put(0x301B, 0x301A); // RIGHT WHITE SQUARE BRACKET
        mirrorChars.put(0xFF08, 0xFF09); // FULLWIDTH LEFT PARENTHESIS
        mirrorChars.put(0xFF09, 0xFF08); // FULLWIDTH RIGHT PARENTHESIS
        mirrorChars.put(0xFF1C, 0xFF1E); // FULLWIDTH LESS-THAN SIGN
        mirrorChars.put(0xFF1E, 0xFF1C); // FULLWIDTH GREATER-THAN SIGN
        mirrorChars.put(0xFF3B, 0xFF3D); // FULLWIDTH LEFT SQUARE BRACKET
        mirrorChars.put(0xFF3D, 0xFF3B); // FULLWIDTH RIGHT SQUARE BRACKET
        mirrorChars.put(0xFF5B, 0xFF5D); // FULLWIDTH LEFT CURLY BRACKET
        mirrorChars.put(0xFF5D, 0xFF5B); // FULLWIDTH RIGHT CURLY BRACKET
        mirrorChars.put(0xFF5F, 0xFF60); // FULLWIDTH LEFT WHITE PARENTHESIS
        mirrorChars.put(0xFF60, 0xFF5F); // FULLWIDTH RIGHT WHITE PARENTHESIS
        mirrorChars.put(0xFF62, 0xFF63); // [BEST FIT] HALFWIDTH LEFT CORNER BRACKET
        mirrorChars.put(0xFF63, 0xFF62); // [BEST FIT] HALFWIDTH RIGHT CORNER BRACKET
    }
} package pdftk.com.lowagie.text.pdf;

/*
 *
 * Copyright 2003 Paulo Soares
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */
/*
 * (C) Copyright IBM Corp. 1999, All Rights Reserved
 *
 * version 1.1
 */

/**
 * Reference implementation of the Unicode 3.0 Bidi algorithm.
 *
 * <p>
 * This implementation is not optimized for performance.  It is intended
 * as a reference implementation that closely follows the specification
 * of the Bidirectional Algorithm in The Unicode Standard version 3.0.
 * <p>
 * <b>Input:</b><br>
 * There are two levels of input to the algorithm, since clients may prefer
 * to supply some information from out-of-band sources rather than relying on
 * the default behavior.
 * <ol>
 * <li>unicode type array
 * <li>unicode type array, with externally supplied base line direction
 * </ol>
 * <p><b>Output:</b><br>
 * Output is separated into several stages as well, to better enable clients
 * to evaluate various aspects of implementation conformance.
 * <ol>
 * <li>levels array over entire paragraph
 * <li>reordering array over entire paragraph
 * <li>levels array over line
 * <li>reordering array over line
 * </ol>
 * Note that for conformance, algorithms are only required to generate correct
 * reordering and character directionality (odd or even levels) over a line.
 * Generating identical level arrays over a line is not required.  Bidi
 * explicit format codes (LRE, RLE, LRO, RLO, PDF) and BN can be assigned
 * arbitrary levels and positions as long as the other text matches.
 * <p>
 * As the algorithm is defined to operate on a single paragraph at a time,
 * this implementation is written to handle single paragraphs.  Thus
 * rule P1 is presumed by this implementation-- the data provided to the
 * implementation is assumed to be a single paragraph, and either contains no
 * 'B' codes, or a single 'B' code at the end of the input.  'B' is allowed
 * as input to illustrate how the algorithm assigns it a level.
 * <p>
 * Also note that rules L3 and L4 depend on the rendering engine that uses
 * the result of the bidi algorithm.  This implementation assumes that the
 * rendering engine expects combining marks in visual order (e.g. to the
 * left of their base character in RTL runs) and that it adjust the glyphs
 * used to render mirrored characters that are in RTL runs so that they
 * render appropriately.
 *
 * @author Doug Felt
 */

public final class BidiOrder {
    private byte[] initialTypes;
    private byte[] embeddings; // generated from processing format codes
    private byte paragraphEmbeddingLevel = -1; // undefined
    
    private int textLength; // for convenience
    private byte[] resultTypes; // for paragraph, not lines
    private byte[] resultLevels; // for paragraph, not lines
    
    // The bidi types
    
    /** Left-to-right*/
    public static final byte L = 0;
    
    /** Left-to-Right Embedding */
    public static final byte LRE = 1;
    
    /** Left-to-Right Override */
    public static final byte LRO = 2;
    
    /** Right-to-Left */
    public static final byte R = 3;
    
    /** Right-to-Left Arabic */
    public static final byte AL = 4;
    
    /** Right-to-Left Embedding */
    public static final byte RLE = 5;
    
    /** Right-to-Left Override */
    public static final byte RLO = 6;
    
    /** Pop Directional Format */
    public static final byte PDF = 7;
    
    /** European Number */
    public static final byte EN = 8;
    
    /** European Number Separator */
    public static final byte ES = 9;
    
    /** European Number Terminator */
    public static final byte ET = 10;
    
    /** Arabic Number */
    public static final byte AN = 11;
    
    /** Common Number Separator */
    public static final byte CS = 12;
    
    /** Non-Spacing Mark */
    public static final byte NSM = 13;
    
    /** Boundary Neutral */
    public static final byte BN = 14;
    
    /** Paragraph Separator */
    public static final byte B = 15;
    
    /** Segment Separator */
    public static final byte S = 16;
    
    /** Whitespace */
    public static final byte WS = 17;
    
    /** Other Neutrals */
    public static final byte ON = 18;
    
    /** Minimum bidi type value. */
    public static final byte TYPE_MIN = 0;
    
    /** Maximum bidi type value. */
    public static final byte TYPE_MAX = 18;
    
    //
    // Input
    //
    
    /**
     * Initialize using an array of direction types.  Types range from TYPE_MIN to TYPE_MAX inclusive
     * and represent the direction codes of the characters in the text.
     *
     * @param types the types array
     */
    public BidiOrder(byte[] types) {
        validateTypes(types);
        
        this.initialTypes = (byte[])types.clone(); // client type array remains unchanged
        
        runAlgorithm();
    }
    
    /**
     * Initialize using an array of direction types and an externally supplied paragraph embedding level.
     * The embedding level may be -1, 0, or 1.  -1 means to apply the default algorithm (rules P2 and P3),
     * 0 is for LTR paragraphs, and 1 is for RTL paragraphs.
     *
     * @param types the types array
     * @param paragraphEmbeddingLevel the externally supplied paragraph embedding level.
     */
    public BidiOrder(byte[] types, byte paragraphEmbeddingLevel) {
        validateTypes(types);
        validateParagraphEmbeddingLevel(paragraphEmbeddingLevel);
        
        this.initialTypes = (byte[])types.clone(); // client type array remains unchanged
        this.paragraphEmbeddingLevel = paragraphEmbeddingLevel;
        
        runAlgorithm();
    }
    
    public BidiOrder(char text[], int offset, int length, byte paragraphEmbeddingLevel) {
        initialTypes = new byte[length];
        for (int k = 0; k < length; ++k) {
            initialTypes[k] = rtypes[text[offset + k]];
        }
        validateParagraphEmbeddingLevel(paragraphEmbeddingLevel);
        
        this.paragraphEmbeddingLevel = paragraphEmbeddingLevel;
        
        runAlgorithm();
    }
    
    public final static byte getDirection(char c) {
        return rtypes[c];
    }
    
    /**
     * The algorithm.
     * Does not include line-based processing (Rules L1, L2).
     * These are applied later in the line-based phase of the algorithm.
     */
    private void runAlgorithm() {
        textLength = initialTypes.length;
        
        // Initialize output types.
        // Result types initialized to input types.
        resultTypes = (byte[])initialTypes.clone();
        
        
        // 1) determining the paragraph level
        // Rule P1 is the requirement for entering this algorithm.
        // Rules P2, P3.
        // If no externally supplied paragraph embedding level, use default.
        if (paragraphEmbeddingLevel == -1) {
            determineParagraphEmbeddingLevel();
        }
        
        // Initialize result levels to paragraph embedding level.
        resultLevels = new byte[textLength];
        setLevels(0, textLength, paragraphEmbeddingLevel);
        
        // 2) Explicit levels and directions
        // Rules X1-X8.
        determineExplicitEmbeddingLevels();
        
        // Rule X9.
        textLength = removeExplicitCodes();
        
        // Rule X10.
        // Run remainder of algorithm one level run at a time
        byte prevLevel = paragraphEmbeddingLevel;
        int start = 0;
        while (start < textLength) {
            byte level = resultLevels[start];
            byte prevType = typeForLevel(Math.max(prevLevel, level));
            
            int limit = start + 1;
            while (limit < textLength && resultLevels[limit] == level) {
                ++limit;
            }
            
            byte succLevel = limit < textLength ? resultLevels[limit] : paragraphEmbeddingLevel;
            byte succType = typeForLevel(Math.max(succLevel, level));
            
            // 3) resolving weak types
            // Rules W1-W7.
            resolveWeakTypes(start, limit, level, prevType, succType);
            
            // 4) resolving neutral types
            // Rules N1-N3.
            resolveNeutralTypes(start, limit, level, prevType, succType);
            
            // 5) resolving implicit embedding levels
            // Rules I1, I2.
            resolveImplicitLevels(start, limit, level, prevType, succType);
            
            prevLevel = level;
            start = limit;
        }
        
        // Reinsert explicit codes and assign appropriate levels to 'hide' them.
        // This is for convenience, so the resulting level array maps 1-1
        // with the initial array.
        // See the implementation suggestions section of TR#9 for guidelines on
        // how to implement the algorithm without removing and reinserting the codes.
        textLength = reinsertExplicitCodes(textLength);
    }
    
    /**
     * 1) determining the paragraph level.
     * <p>
     * Rules P2, P3.
     * <p>
     * At the end of this function, the member variable paragraphEmbeddingLevel is set to either 0 or 1.
     */
    private void determineParagraphEmbeddingLevel() {
        byte strongType = -1; // unknown
        
        // Rule P2.
        for (int i = 0; i < textLength; ++i) {
            byte t = resultTypes[i];
            if (t == L || t == AL || t == R) {
                strongType = t;
                break;
            }
        }
        
        // Rule P3.
        if (strongType == -1) { // none found
            // default embedding level when no strong types found is 0.
            paragraphEmbeddingLevel = 0;
        } else if (strongType == L) {
            paragraphEmbeddingLevel = 0;
        } else { // AL, R
            paragraphEmbeddingLevel = 1;
        }
    }
    
    /**
     * Process embedding format codes.
     * <p>
     * Calls processEmbeddings to generate an embedding array from the explicit format codes.  The
     * embedding overrides in the array are then applied to the result types, and the result levels are
     * initialized.
     * @see #processEmbeddings
     */
    private void determineExplicitEmbeddingLevels() {
        embeddings = processEmbeddings(resultTypes, paragraphEmbeddingLevel);
        
        for (int i = 0; i < textLength; ++i) {
            byte level = embeddings[i];
            if ((level & 0x80) != 0) {
                level &= 0x7f;
                resultTypes[i] = typeForLevel(level);
            }
            resultLevels[i] = level;
        }
    }
    
    /**
     * Rules X9.
     * Remove explicit codes so that they may be ignored during the remainder
     * of the main portion of the algorithm.  The length of the resulting text
     * is returned.
     * @return the length of the data excluding explicit codes and BN.
     */
    private int removeExplicitCodes() {
        int w = 0;
        for (int i = 0; i < textLength; ++i) {
            byte t = initialTypes[i];
            if (!(t == LRE || t == RLE || t == LRO || t == RLO || t == PDF || t == BN)) {
                embeddings[w] = embeddings[i];
                resultTypes[w] = resultTypes[i];
                resultLevels[w] = resultLevels[i];
                w++;
            }
        }
        return w; // new textLength while explicit levels are removed
    }
    
    /**
     * Reinsert levels information for explicit codes.
     * This is for ease of relating the level information
     * to the original input data.  Note that the levels
     * assigned to these codes are arbitrary, they're
     * chosen so as to avoid breaking level runs.
     * @param textLength the length of the data after compression
     * @return the length of the data (original length of
     * types array supplied to constructor)
     */
    private int reinsertExplicitCodes(int textLength) {
        for (int i = initialTypes.length; --i >= 0;) {
            byte t = initialTypes[i];
            if (t == LRE || t == RLE || t == LRO || t == RLO || t == PDF || t == BN) {
                embeddings[i] = 0;
                resultTypes[i] = t;
                resultLevels[i] = -1;
            } else {
                --textLength;
                embeddings[i] = embeddings[textLength];
                resultTypes[i] = resultTypes[textLength];
                resultLevels[i] = resultLevels[textLength];
            }
        }
        
        // now propagate forward the levels information (could have
        // propagated backward, the main thing is not to introduce a level
        // break where one doesn't already exist).
        
        if (resultLevels[0] == -1) {
            resultLevels[0] = paragraphEmbeddingLevel;
        }
        for (int i = 1; i < initialTypes.length; ++i) {
            if (resultLevels[i] == -1) {
                resultLevels[i] = resultLevels[i-1];
            }
        }
        
        // Embedding information is for informational purposes only
        // so need not be adjusted.
        
        return initialTypes.length;
    }
    
    /**
     * 2) determining explicit levels
     * Rules X1 - X8
     *
     * The interaction of these rules makes handling them a bit complex.
     * This examines resultTypes but does not modify it.  It returns embedding and
     * override information in the result array.  The low 7 bits are the level, the high
     * bit is set if the level is an override, and clear if it is an embedding.
     */
    private static byte[] processEmbeddings(byte[] resultTypes, byte paragraphEmbeddingLevel) {
        final int EXPLICIT_LEVEL_LIMIT = 62;
        
        int textLength = resultTypes.length;
        byte[] embeddings = new byte[textLength];
        
        // This stack will store the embedding levels and override status in a single byte
        // as described above.
        byte[] embeddingValueStack = new byte[EXPLICIT_LEVEL_LIMIT];
        int stackCounter = 0;
        
        // An LRE or LRO at level 60 is invalid, since the new level 62 is invalid.  But
        // an RLE at level 60 is valid, since the new level 61 is valid.  The current wording
        // of the rules requires that the RLE remain valid even if a previous LRE is invalid.
        // This keeps track of ignored LRE or LRO codes at level 60, so that the matching PDFs
        // will not try to pop the stack.
        int overflowAlmostCounter = 0;
        
        // This keeps track of ignored pushes at level 61 or higher, so that matching PDFs will
        // not try to pop the stack.
        int overflowCounter = 0;
        
        // Rule X1.
        
        // Keep the level separate from the value (level | override status flag) for ease of access.
        byte currentEmbeddingLevel = paragraphEmbeddingLevel;
        byte currentEmbeddingValue = paragraphEmbeddingLevel;
        
        // Loop through types, handling all remaining rules
        for (int i = 0; i < textLength; ++i) {
            
            embeddings[i] = currentEmbeddingValue;
            
            byte t = resultTypes[i];
            
            // Rules X2, X3, X4, X5
            switch (t) {
                case RLE:
                case LRE:
                case RLO:
                case LRO:
                    // Only need to compute new level if current level is valid
                    if (overflowCounter == 0) {
                        byte newLevel;
                        if (t == RLE || t == RLO) {
                            newLevel = (byte)((currentEmbeddingLevel + 1) | 1); // least greater odd
                        } else { // t == LRE || t == LRO
                            newLevel = (byte)((currentEmbeddingLevel + 2) & ~1); // least greater even
                        }
                        
                        // If the new level is valid, push old embedding level and override status
                        // No check for valid stack counter, since the level check suffices.
                        if (newLevel < EXPLICIT_LEVEL_LIMIT) {
                            embeddingValueStack[stackCounter] = currentEmbeddingValue;
                            stackCounter++;
                            
                            currentEmbeddingLevel = newLevel;
                            if (t == LRO || t == RLO) { // override
                                currentEmbeddingValue = (byte)(newLevel | 0x80);
                            } else {
                                currentEmbeddingValue = newLevel;
                            }
                            
                            // Adjust level of format mark (for expositional purposes only, this gets
                            // removed later).
                            embeddings[i] = currentEmbeddingValue;
                            break;
                        }
                        
                        // Otherwise new level is invalid, but a valid level can still be achieved if this
                        // level is 60 and we encounter an RLE or RLO further on.  So record that we
                        // 'almost' overflowed.
                        if (currentEmbeddingLevel == 60) {
                            overflowAlmostCounter++;
                            break;
                        }
                    }
                    
                    // Otherwise old or new level is invalid.
                    overflowCounter++;
                    break;
                    
                case PDF:
                    // The only case where this did not actually overflow but may have almost overflowed
                    // is when there was an RLE or RLO on level 60, which would result in level 61.  So we
                    // only test the almost overflow condition in that case.
                    //
                    // Also note that there may be a PDF without any pushes at all.
                    
                    if (overflowCounter > 0) {
                        --overflowCounter;
                    } else if (overflowAlmostCounter > 0 && currentEmbeddingLevel != 61) {
                        --overflowAlmostCounter;
                    } else if (stackCounter > 0) {
                        --stackCounter;
                        currentEmbeddingValue = embeddingValueStack[stackCounter];
                        currentEmbeddingLevel = (byte)(currentEmbeddingValue & 0x7f);
                    }
                    break;
                    
                case B:
                    // Rule X8.
                    
                    // These values are reset for clarity, in this implementation B can only
                    // occur as the last code in the array.
                    stackCounter = 0;
                    overflowCounter = 0;
                    overflowAlmostCounter = 0;
                    currentEmbeddingLevel = paragraphEmbeddingLevel;
                    currentEmbeddingValue = paragraphEmbeddingLevel;
                    
                    embeddings[i] = paragraphEmbeddingLevel;
                    break;
                    
                default:
                    break;
            }
        }
        
        return embeddings;
    }
    
    
    /**
     * 3) resolving weak types
     * Rules W1-W7.
     *
     * Note that some weak types (EN, AN) remain after this processing is complete.
     */
    private void resolveWeakTypes(int start, int limit, byte level, byte sor, byte eor) {
        
        // Rule W1.
        // Changes all NSMs.
        byte preceedingCharacterType = sor;
        for (int i = start; i < limit; ++i) {
            byte t = resultTypes[i];
            if (t == NSM) {
                resultTypes[i] = preceedingCharacterType;
            } else {
                preceedingCharacterType = t;
            }
        }
        
        // Rule W2.
        // EN does not change at the start of the run, because sor != AL.
        for (int i = start; i < limit; ++i) {
            if (resultTypes[i] == EN) {
                for (int j = i - 1; j >= start; --j) {
                    byte t = resultTypes[j];
                    if (t == L || t == R || t == AL) {
                        if (t == AL) {
                            resultTypes[i] = AN;
                        }
                        break;
                    }
                }
            }
        }
        
        // Rule W3.
        for (int i = start; i < limit; ++i) {
            if (resultTypes[i] == AL) {
                resultTypes[i] = R;
            }
        }
        
        // Rule W4.
        // Since there must be values on both sides for this rule to have an
        // effect, the scan skips the first and last value.
        //
        // Although the scan proceeds left to right, and changes the type values
        // in a way that would appear to affect the computations later in the scan,
        // there is actually no problem.  A change in the current value can only
        // affect the value to its immediate right, and only affect it if it is
        // ES or CS.  But the current value can only change if the value to its
        // right is not ES or CS.  Thus either the current value will not change,
        // or its change will have no effect on the remainder of the analysis.
        
        for (int i = start + 1; i < limit - 1; ++i) {
            if (resultTypes[i] == ES || resultTypes[i] == CS) {
                byte prevSepType = resultTypes[i-1];
                byte succSepType = resultTypes[i+1];
                if (prevSepType == EN && succSepType == EN) {
                    resultTypes[i] = EN;
                } else if (resultTypes[i] == CS && prevSepType == AN && succSepType == AN) {
                    resultTypes[i] = AN;
                }
            }
        }
        
        // Rule W5.
        for (int i = start; i < limit; ++i) {
            if (resultTypes[i] == ET) {
                // locate end of sequence
                int runstart = i;
                int runlimit = findRunLimit(runstart, limit, new byte[] { ET });
                
                // check values at ends of sequence
                byte t = runstart == start ? sor : resultTypes[runstart - 1];
                
                if (t != EN) {
                    t = runlimit == limit ? eor : resultTypes[runlimit];
                }
                
                if (t == EN) {
                    setTypes(runstart, runlimit, EN);
                }
                
                // continue at end of sequence
                i = runlimit;
            }
        }
        
        // Rule W6.
        for (int i = start; i < limit; ++i) {
            byte t = resultTypes[i];
            if (t == ES || t == ET || t == CS) {
                resultTypes[i] = ON;
            }
        }
        
        // Rule W7.
        for (int i = start; i < limit; ++i) {
            if (resultTypes[i] == EN) {
                // set default if we reach start of run
                byte prevStrongType = sor;
                for (int j = i - 1; j >= start; --j) {
                    byte t = resultTypes[j];
                    if (t == L || t == R) { // AL's have been removed
                        prevStrongType = t;
                        break;
                    }
                }
                if (prevStrongType == L) {
                    resultTypes[i] = L;
                }
            }
        }
    }
    
    /**
     * 6) resolving neutral types
     * Rules N1-N2.
     */
    private void resolveNeutralTypes(int start, int limit, byte level, byte sor, byte eor) {
        
        for (int i = start; i < limit; ++i) {
            byte t = resultTypes[i];
            if (t == WS || t == ON || t == B || t == S) {
                // find bounds of run of neutrals
                int runstart = i;
                int runlimit = findRunLimit(runstart, limit, new byte[] {B, S, WS, ON});
                
                // determine effective types at ends of run
                byte leadingType;
                byte trailingType;
                
                if (runstart == start) {
                    leadingType = sor;
                } else {
                    leadingType = resultTypes[runstart - 1];
                    if (leadingType == L || leadingType == R) {
                        // found the strong type
                    } else if (leadingType == AN) {
                        leadingType = R;
                    } else if (leadingType == EN) {
                        // Since EN's with previous strong L types have been changed
                        // to L in W7, the leadingType must be R.
                        leadingType = R;
                    }
                }
                
                if (runlimit == limit) {
                    trailingType = eor;
                } else {
                    trailingType = resultTypes[runlimit];
                    if (trailingType == L || trailingType == R) {
                        // found the strong type
                    } else if (trailingType == AN) {
                        trailingType = R;
                    } else if (trailingType == EN) {
                        trailingType = R;
                    }
                }
                
                byte resolvedType;
                if (leadingType == trailingType) {
                    // Rule N1.
                    resolvedType = leadingType;
                } else {
                    // Rule N2.
                    // Notice the embedding level of the run is used, not
                    // the paragraph embedding level.
                    resolvedType = typeForLevel(level);
                }
                
                setTypes(runstart, runlimit, resolvedType);
                
                // skip over run of (former) neutrals
                i = runlimit;
            }
        }
    }
    
    /**
     * 7) resolving implicit embedding levels
     * Rules I1, I2.
     */
    private void resolveImplicitLevels(int start, int limit, byte level, byte sor, byte eor) {
        if ((level & 1) == 0) { // even level
            for (int i = start; i < limit; ++i) {
                byte t = resultTypes[i];
                // Rule I1.
                if (t == L ) {
                    // no change
                } else if (t == R) {
                    resultLevels[i] += 1;
                } else { // t == AN || t == EN
                    resultLevels[i] += 2;
                }
            }
        } else { // odd level
            for (int i = start; i < limit; ++i) {
                byte t = resultTypes[i];
                // Rule I2.
                if (t == R) {
                    // no change
                } else { // t == L || t == AN || t == EN
                    resultLevels[i] += 1;
                }
            }
        }
    }
    
    //
    // Output
    //
    
    public byte[] getLevels() {
        return getLevels(new int[]{textLength});
    }
    
    /**
     * Return levels array breaking lines at offsets in linebreaks. <br>
     * Rule L1.
     * <p>
     * The returned levels array contains the resolved level for each
     * bidi code passed to the constructor.
     * <p>
     * The linebreaks array must include at least one value.
     * The values must be in strictly increasing order (no duplicates)
     * between 1 and the length of the text, inclusive.  The last value
     * must be the length of the text.
     *
     * @param linebreaks the offsets at which to break the paragraph
     * @return the resolved levels of the text
     */
    public byte[] getLevels(int[] linebreaks) {
        
        // Note that since the previous processing has removed all
        // P, S, and WS values from resultTypes, the values referred to
        // in these rules are the initial types, before any processing
        // has been applied (including processing of overrides).
        //
        // This example implementation has reinserted explicit format codes
        // and BN, in order that the levels array correspond to the
        // initial text.  Their final placement is not normative.
        // These codes are treated like WS in this implementation,
        // so they don't interrupt sequences of WS.
        
        validateLineBreaks(linebreaks, textLength);
        
        byte[] result = (byte[])resultLevels.clone(); // will be returned to caller
        
        // don't worry about linebreaks since if there is a break within
        // a series of WS values preceeding S, the linebreak itself
        // causes the reset.
        for (int i = 0; i < result.length; ++i) {
            byte t = initialTypes[i];
            if (t == B || t == S) {
                // Rule L1, clauses one and two.
                result[i] = paragraphEmbeddingLevel;
                
                // Rule L1, clause three.
                for (int j = i - 1; j >= 0; --j) {
                    if (isWhitespace(initialTypes[j])) { // including format codes
                        result[j] = paragraphEmbeddingLevel;
                    } else {
                        break;
                    }
                }
            }
        }
        
        // Rule L1, clause four.
        int start = 0;
        for (int i = 0; i < linebreaks.length; ++i) {
            int limit = linebreaks[i];
            for (int j = limit - 1; j >= start; --j) {
                if (isWhitespace(initialTypes[j])) { // including format codes
                    result[j] = paragraphEmbeddingLevel;
                } else {
                    break;
                }
            }
            
            start = limit;
        }
        
        return result;
    }
    
    /**
     * Return reordering array breaking lines at offsets in linebreaks.
     * <p>
     * The reordering array maps from a visual index to a logical index.
     * Lines are concatenated from left to right.  So for example, the
     * fifth character from the left on the third line is
     * <pre> getReordering(linebreaks)[linebreaks[1] + 4]</pre>
     * (linebreaks[1] is the position after the last character of the
     * second line, which is also the index of the first character on the
     * third line, and adding four gets the fifth character from the left).
     * <p>
     * The linebreaks array must include at least one value.
     * The values must be in strictly increasing order (no duplicates)
     * between 1 and the length of the text, inclusive.  The last value
     * must be the length of the text.
     *
     * @param linebreaks the offsets at which to break the paragraph.
     */
    public int[] getReordering(int[] linebreaks) {
        validateLineBreaks(linebreaks, textLength);
        
        byte[] levels = getLevels(linebreaks);
        
        return computeMultilineReordering(levels, linebreaks);
    }
    
    /**
     * Return multiline reordering array for a given level array.
     * Reordering does not occur across a line break.
     */
    private static int[] computeMultilineReordering(byte[] levels, int[] linebreaks) {
        int[] result = new int[levels.length];
        
        int start = 0;
        for (int i = 0; i < linebreaks.length; ++i) {
            int limit = linebreaks[i];
            
            byte[] templevels = new byte[limit - start];
            System.arraycopy(levels, start, templevels, 0, templevels.length);
            
            int[] temporder = computeReordering(templevels);
            for (int j = 0; j < temporder.length; ++j) {
                result[start + j] = temporder[j] + start;
            }
            
            start = limit;
        }
        
        return result;
    }
    
    /**
     * Return reordering array for a given level array.  This reorders a single line.
     * The reordering is a visual to logical map.  For example,
     * the leftmost char is string.charAt(order[0]).
     * Rule L2.
     */
    private static int[] computeReordering(byte[] levels) {
        int lineLength = levels.length;
        
        int[] result = new int[lineLength];
        
        // initialize order
        for (int i = 0; i < lineLength; ++i) {
            result[i] = i;
        }
        
        // locate highest level found on line.
        // Note the rules say text, but no reordering across line bounds is performed,
        // so this is sufficient.
        byte highestLevel = 0;
        byte lowestOddLevel = 63;
        for (int i = 0; i < lineLength; ++i) {
            byte level = levels[i];
            if (level > highestLevel) {
                highestLevel = level;
            }
            if (((level & 1) != 0) && level < lowestOddLevel) {
                lowestOddLevel = level;
            }
        }
        
        for (int level = highestLevel; level >= lowestOddLevel; --level) {
            for (int i = 0; i < lineLength; ++i) {
                if (levels[i] >= level) {
                    // find range of text at or above this level
                    int start = i;
                    int limit = i + 1;
                    while (limit < lineLength && levels[limit] >= level) {
                        ++limit;
                    }
                    
                    // reverse run
                    for (int j = start, k = limit - 1; j < k; ++j, --k) {
                        int temp = result[j];
                        result[j] = result[k];
                        result[k] = temp;
                    }
                    
                    // skip to end of level run
                    i = limit;
                }
            }
        }
        
        return result;
    }
    
    /**
     * Return the base level of the paragraph.
     */
    public byte getBaseLevel() {
        return paragraphEmbeddingLevel;
    }
    
    // --- internal utilities -------------------------------------------------
    
    /**
     * Return true if the type is considered a whitespace type for the line break rules.
     */
    private static boolean isWhitespace(byte biditype) {
        switch (biditype) {
            case LRE:
            case RLE:
            case LRO:
            case RLO:
            case PDF:
            case BN:
            case WS:
                return true;
            default:
                return false;
        }
    }
    
    /**
     * Return the strong type (L or R) corresponding to the level.
     */
    private static byte typeForLevel(int level) {
        return ((level & 0x1) == 0) ? L : R;
    }
    
    /**
     * Return the limit of the run starting at index that includes only resultTypes in validSet.
     * This checks the value at index, and will return index if that value is not in validSet.
     */
    private int findRunLimit(int index, int limit, byte[] validSet) {
        --index;
        loop:
            while (++index < limit) {
                byte t = resultTypes[index];
                for (int i = 0; i < validSet.length; ++i) {
                    if (t == validSet[i]) {
                        continue loop;
                    }
                }
                // didn't find a match in validSet
                return index;
            }
            return limit;
    }
    
    /**
     * Return the start of the run including index that includes only resultTypes in validSet.
     * This assumes the value at index is valid, and does not check it.
     */
    private int findRunStart(int index, byte[] validSet) {
        loop:
            while (--index >= 0) {
                byte t = resultTypes[index];
                for (int i = 0; i < validSet.length; ++i) {
                    if (t == validSet[i]) {
                        continue loop;
                    }
                }
                return index + 1;
            }
            return 0;
    }
    
    /**
     * Set resultTypes from start up to (but not including) limit to newType.
     */
    private void setTypes(int start, int limit, byte newType) {
        for (int i = start; i < limit; ++i) {
            resultTypes[i] = newType;
        }
    }
    
    /**
     * Set resultLevels from start up to (but not including) limit to newLevel.
     */
    private void setLevels(int start, int limit, byte newLevel) {
        for (int i = start; i < limit; ++i) {
            resultLevels[i] = newLevel;
        }
    }
    
    // --- input validation ---------------------------------------------------
    
    /**
     * Throw exception if type array is invalid.
     */
    private static void validateTypes(byte[] types) {
        if (types == null) {
            throw new IllegalArgumentException("types is null");
        }
        for (int i = 0; i < types.length; ++i) {
            if (types[i] < TYPE_MIN || types[i] > TYPE_MAX) {
                throw new IllegalArgumentException("illegal type value at " + i + ": " + types[i]);
            }
        }
        for (int i = 0; i < types.length - 1; ++i) {
            if (types[i] == B) {
                throw new IllegalArgumentException("B type before end of paragraph at index: " + i);
            }
        }
    }
    
    /**
     * Throw exception if paragraph embedding level is invalid. Special allowance for -1 so that
     * default processing can still be performed when using this API.
     */
    private static void validateParagraphEmbeddingLevel(byte paragraphEmbeddingLevel) {
        if (paragraphEmbeddingLevel != -1 &&
        paragraphEmbeddingLevel != 0 &&
        paragraphEmbeddingLevel != 1) {
            throw new IllegalArgumentException("illegal paragraph embedding level: " + paragraphEmbeddingLevel);
        }
    }
    
    /**
     * Throw exception if line breaks array is invalid.
     */
    private static void validateLineBreaks(int[] linebreaks, int textLength) {
        int prev = 0;
        for (int i = 0; i < linebreaks.length; ++i) {
            int next = linebreaks[i];
            if (next <= prev) {
                throw new IllegalArgumentException("bad linebreak: " + next + " at index: " + i);
            }
            prev = next;
        }
        if (prev != textLength) {
            throw new IllegalArgumentException("last linebreak must be at " + textLength);
        }
    }
    
    private static final byte rtypes[] = new byte[0x10000];
    
    private static char baseTypes[] = {
        0, 8, (char)BN, 9, 9, (char)S, 10, 10, (char)B, 11, 11, (char)S, 12, 12, (char)WS, 13, 13, (char)B,
        14, 27, (char)BN, 28, 30, (char)B, 31, 31, (char)S, 32, 32, (char)WS, 33, 34, (char)ON, 35, 37, (char)ET,
        38, 42, (char)ON, 43, 43, (char)ET, 44, 44, (char)CS, 45, 45, (char)ET, 46, 46, (char)CS, 47, 47, (char)ES,
        48, 57, (char)EN, 58, 58, (char)CS, 59, 64, (char)ON, 65, 90, (char)L, 91, 96, (char)ON, 97, 122, (char)L,
        123, 126, (char)ON, 127, 132, (char)BN, 133, 133, (char)B, 134, 159, (char)BN, 160, 160, (char)CS,
        161, 161, (char)ON, 162, 165, (char)ET, 166, 169, (char)ON, 170, 170, (char)L, 171, 175, (char)ON,
        176, 177, (char)ET, 178, 179, (char)EN, 180, 180, (char)ON, 181, 181, (char)L, 182, 184, (char)ON,
        185, 185, (char)EN, 186, 186, (char)L, 187, 191, (char)ON, 192, 214, (char)L, 215, 215, (char)ON,
        216, 246, (char)L, 247, 247, (char)ON, 248, 696, (char)L, 697, 698, (char)ON, 699, 705, (char)L,
        706, 719, (char)ON, 720, 721, (char)L, 722, 735, (char)ON, 736, 740, (char)L, 741, 749, (char)ON,
        750, 750, (char)L, 751, 767, (char)ON, 768, 855, (char)NSM, 856, 860, (char)L, 861, 879, (char)NSM,
        880, 883, (char)L, 884, 885, (char)ON, 886, 893, (char)L, 894, 894, (char)ON, 895, 899, (char)L,
        900, 901, (char)ON, 902, 902, (char)L, 903, 903, (char)ON, 904, 1013, (char)L, 1014, 1014, (char)ON,
        1015, 1154, (char)L, 1155, 1158, (char)NSM, 1159, 1159, (char)L, 1160, 1161, (char)NSM,
        1162, 1417, (char)L, 1418, 1418, (char)ON, 1419, 1424, (char)L, 1425, 1441, (char)NSM,
        1442, 1442, (char)L, 1443, 1465, (char)NSM, 1466, 1466, (char)L, 1467, 1469, (char)NSM,
        1470, 1470, (char)R, 1471, 1471, (char)NSM, 1472, 1472, (char)R, 1473, 1474, (char)NSM,
        1475, 1475, (char)R, 1476, 1476, (char)NSM, 1477, 1487, (char)L, 1488, 1514, (char)R,
        1515, 1519, (char)L, 1520, 1524, (char)R, 1525, 1535, (char)L, 1536, 1539, (char)AL,
        1540, 1547, (char)L, 1548, 1548, (char)CS, 1549, 1549, (char)AL, 1550, 1551, (char)ON,
        1552, 1557, (char)NSM, 1558, 1562, (char)L, 1563, 1563, (char)AL, 1564, 1566, (char)L,
        1567, 1567, (char)AL, 1568, 1568, (char)L, 1569, 1594, (char)AL, 1595, 1599, (char)L,
        1600, 1610, (char)AL, 1611, 1624, (char)NSM, 1625, 1631, (char)L, 1632, 1641, (char)AN,
        1642, 1642, (char)ET, 1643, 1644, (char)AN, 1645, 1647, (char)AL, 1648, 1648, (char)NSM,
        1649, 1749, (char)AL, 1750, 1756, (char)NSM, 1757, 1757, (char)AL, 1758, 1764, (char)NSM,
        1765, 1766, (char)AL, 1767, 1768, (char)NSM, 1769, 1769, (char)ON, 1770, 1773, (char)NSM,
        1774, 1775, (char)AL, 1776, 1785, (char)EN, 1786, 1805, (char)AL, 1806, 1806, (char)L,
        1807, 1807, (char)BN, 1808, 1808, (char)AL, 1809, 1809, (char)NSM, 1810, 1839, (char)AL,
        1840, 1866, (char)NSM, 1867, 1868, (char)L, 1869, 1871, (char)AL, 1872, 1919, (char)L,
        1920, 1957, (char)AL, 1958, 1968, (char)NSM, 1969, 1969, (char)AL, 1970, 2304, (char)L,
        2305, 2306, (char)NSM, 2307, 2363, (char)L, 2364, 2364, (char)NSM, 2365, 2368, (char)L,
        2369, 2376, (char)NSM, 2377, 2380, (char)L, 2381, 2381, (char)NSM, 2382, 2384, (char)L,
        2385, 2388, (char)NSM, 2389, 2401, (char)L, 2402, 2403, (char)NSM, 2404, 2432, (char)L,
        2433, 2433, (char)NSM, 2434, 2491, (char)L, 2492, 2492, (char)NSM, 2493, 2496, (char)L,
        2497, 2500, (char)NSM, 2501, 2508, (char)L, 2509, 2509, (char)NSM, 2510, 2529, (char)L,
        2530, 2531, (char)NSM, 2532, 2545, (char)L, 2546, 2547, (char)ET, 2548, 2560, (char)L,
        2561, 2562, (char)NSM, 2563, 2619, (char)L, 2620, 2620, (char)NSM, 2621, 2624, (char)L,
        2625, 2626, (char)NSM, 2627, 2630, (char)L, 2631, 2632, (char)NSM, 2633, 2634, (char)L,
        2635, 2637, (char)NSM, 2638, 2671, (char)L, 2672, 2673, (char)NSM, 2674, 2688, (char)L,
        2689, 2690, (char)NSM, 2691, 2747, (char)L, 2748, 2748, (char)NSM, 2749, 2752, (char)L,
        2753, 2757, (char)NSM, 2758, 2758, (char)L, 2759, 2760, (char)NSM, 2761, 2764, (char)L,
        2765, 2765, (char)NSM, 2766, 2785, (char)L, 2786, 2787, (char)NSM, 2788, 2800, (char)L,
        2801, 2801, (char)ET, 2802, 2816, (char)L, 2817, 2817, (char)NSM, 2818, 2875, (char)L,
        2876, 2876, (char)NSM, 2877, 2878, (char)L, 2879, 2879, (char)NSM, 2880, 2880, (char)L,
        2881, 2883, (char)NSM, 2884, 2892, (char)L, 2893, 2893, (char)NSM, 2894, 2901, (char)L,
        2902, 2902, (char)NSM, 2903, 2945, (char)L, 2946, 2946, (char)NSM, 2947, 3007, (char)L,
        3008, 3008, (char)NSM, 3009, 3020, (char)L, 3021, 3021, (char)NSM, 3022, 3058, (char)L,
        3059, 3064, (char)ON, 3065, 3065, (char)ET, 3066, 3066, (char)ON, 3067, 3133, (char)L,
        3134, 3136, (char)NSM, 3137, 3141, (char)L, 3142, 3144, (char)NSM, 3145, 3145, (char)L,
        3146, 3149, (char)NSM, 3150, 3156, (char)L, 3157, 3158, (char)NSM, 3159, 3259, (char)L,
        3260, 3260, (char)NSM, 3261, 3275, (char)L, 3276, 3277, (char)NSM, 3278, 3392, (char)L,
        3393, 3395, (char)NSM, 3396, 3404, (char)L, 3405, 3405, (char)NSM, 3406, 3529, (char)L,
        3530, 3530, (char)NSM, 3531, 3537, (char)L, 3538, 3540, (char)NSM, 3541, 3541, (char)L,
        3542, 3542, (char)NSM, 3543, 3632, (char)L, 3633, 3633, (char)NSM, 3634, 3635, (char)L,
        3636, 3642, (char)NSM, 3643, 3646, (char)L, 3647, 3647, (char)ET, 3648, 3654, (char)L,
        3655, 3662, (char)NSM, 3663, 3760, (char)L, 3761, 3761, (char)NSM, 3762, 3763, (char)L,
        3764, 3769, (char)NSM, 3770, 3770, (char)L, 3771, 3772, (char)NSM, 3773, 3783, (char)L,
        3784, 3789, (char)NSM, 3790, 3863, (char)L, 3864, 3865, (char)NSM, 3866, 3892, (char)L,
        3893, 3893, (char)NSM, 3894, 3894, (char)L, 3895, 3895, (char)NSM, 3896, 3896, (char)L,
        3897, 3897, (char)NSM, 3898, 3901, (char)ON, 3902, 3952, (char)L, 3953, 3966, (char)NSM,
        3967, 3967, (char)L, 3968, 3972, (char)NSM, 3973, 3973, (char)L, 3974, 3975, (char)NSM,
        3976, 3983, (char)L, 3984, 3991, (char)NSM, 3992, 3992, (char)L, 3993, 4028, (char)NSM,
        4029, 4037, (char)L, 4038, 4038, (char)NSM, 4039, 4140, (char)L, 4141, 4144, (char)NSM,
        4145, 4145, (char)L, 4146, 4146, (char)NSM, 4147, 4149, (char)L, 4150, 4151, (char)NSM,
        4152, 4152, (char)L, 4153, 4153, (char)NSM, 4154, 4183, (char)L, 4184, 4185, (char)NSM,
        4186, 5759, (char)L, 5760, 5760, (char)WS, 5761, 5786, (char)L, 5787, 5788, (char)ON,
        5789, 5905, (char)L, 5906, 5908, (char)NSM, 5909, 5937, (char)L, 5938, 5940, (char)NSM,
        5941, 5969, (char)L, 5970, 5971, (char)NSM, 5972, 6001, (char)L, 6002, 6003, (char)NSM,
        6004, 6070, (char)L, 6071, 6077, (char)NSM, 6078, 6085, (char)L, 6086, 6086, (char)NSM,
        6087, 6088, (char)L, 6089, 6099, (char)NSM, 6100, 6106, (char)L, 6107, 6107, (char)ET,
        6108, 6108, (char)L, 6109, 6109, (char)NSM, 6110, 6127, (char)L, 6128, 6137, (char)ON,
        6138, 6143, (char)L, 6144, 6154, (char)ON, 6155, 6157, (char)NSM, 6158, 6158, (char)WS,
        6159, 6312, (char)L, 6313, 6313, (char)NSM, 6314, 6431, (char)L, 6432, 6434, (char)NSM,
        6435, 6438, (char)L, 6439, 6443, (char)NSM, 6444, 6449, (char)L, 6450, 6450, (char)NSM,
        6451, 6456, (char)L, 6457, 6459, (char)NSM, 6460, 6463, (char)L, 6464, 6464, (char)ON,
        6465, 6467, (char)L, 6468, 6469, (char)ON, 6470, 6623, (char)L, 6624, 6655, (char)ON,
        6656, 8124, (char)L, 8125, 8125, (char)ON, 8126, 8126, (char)L, 8127, 8129, (char)ON,
        8130, 8140, (char)L, 8141, 8143, (char)ON, 8144, 8156, (char)L, 8157, 8159, (char)ON,
        8160, 8172, (char)L, 8173, 8175, (char)ON, 8176, 8188, (char)L, 8189, 8190, (char)ON,
        8191, 8191, (char)L, 8192, 8202, (char)WS, 8203, 8205, (char)BN, 8206, 8206, (char)L,
        8207, 8207, (char)R, 8208, 8231, (char)ON, 8232, 8232, (char)WS, 8233, 8233, (char)B,
        8234, 8234, (char)LRE, 8235, 8235, (char)RLE, 8236, 8236, (char)PDF, 8237, 8237, (char)LRO,
        8238, 8238, (char)RLO, 8239, 8239, (char)WS, 8240, 8244, (char)ET, 8245, 8276, (char)ON,
        8277, 8278, (char)L, 8279, 8279, (char)ON, 8280, 8286, (char)L, 8287, 8287, (char)WS,
        8288, 8291, (char)BN, 8292, 8297, (char)L, 8298, 8303, (char)BN, 8304, 8304, (char)EN,
        8305, 8307, (char)L, 8308, 8313, (char)EN, 8314, 8315, (char)ET, 8316, 8318, (char)ON,
        8319, 8319, (char)L, 8320, 8329, (char)EN, 8330, 8331, (char)ET, 8332, 8334, (char)ON,
        8335, 8351, (char)L, 8352, 8369, (char)ET, 8370, 8399, (char)L, 8400, 8426, (char)NSM,
        8427, 8447, (char)L, 8448, 8449, (char)ON, 8450, 8450, (char)L, 8451, 8454, (char)ON,
        8455, 8455, (char)L, 8456, 8457, (char)ON, 8458, 8467, (char)L, 8468, 8468, (char)ON,
        8469, 8469, (char)L, 8470, 8472, (char)ON, 8473, 8477, (char)L, 8478, 8483, (char)ON,
        8484, 8484, (char)L, 8485, 8485, (char)ON, 8486, 8486, (char)L, 8487, 8487, (char)ON,
        8488, 8488, (char)L, 8489, 8489, (char)ON, 8490, 8493, (char)L, 8494, 8494, (char)ET,
        8495, 8497, (char)L, 8498, 8498, (char)ON, 8499, 8505, (char)L, 8506, 8507, (char)ON,
        8508, 8511, (char)L, 8512, 8516, (char)ON, 8517, 8521, (char)L, 8522, 8523, (char)ON,
        8524, 8530, (char)L, 8531, 8543, (char)ON, 8544, 8591, (char)L, 8592, 8721, (char)ON,
        8722, 8723, (char)ET, 8724, 9013, (char)ON, 9014, 9082, (char)L, 9083, 9108, (char)ON,
        9109, 9109, (char)L, 9110, 9168, (char)ON, 9169, 9215, (char)L, 9216, 9254, (char)ON,
        9255, 9279, (char)L, 9280, 9290, (char)ON, 9291, 9311, (char)L, 9312, 9371, (char)EN,
        9372, 9449, (char)L, 9450, 9450, (char)EN, 9451, 9751, (char)ON, 9752, 9752, (char)L,
        9753, 9853, (char)ON, 9854, 9855, (char)L, 9856, 9873, (char)ON, 9874, 9887, (char)L,
        9888, 9889, (char)ON, 9890, 9984, (char)L, 9985, 9988, (char)ON, 9989, 9989, (char)L,
        9990, 9993, (char)ON, 9994, 9995, (char)L, 9996, 10023, (char)ON, 10024, 10024, (char)L,
        10025, 10059, (char)ON, 10060, 10060, (char)L, 10061, 10061, (char)ON, 10062, 10062, (char)L,
        10063, 10066, (char)ON, 10067, 10069, (char)L, 10070, 10070, (char)ON, 10071, 10071, (char)L,
        10072, 10078, (char)ON, 10079, 10080, (char)L, 10081, 10132, (char)ON, 10133, 10135, (char)L,
        10136, 10159, (char)ON, 10160, 10160, (char)L, 10161, 10174, (char)ON, 10175, 10191, (char)L,
        10192, 10219, (char)ON, 10220, 10223, (char)L, 10224, 11021, (char)ON, 11022, 11903, (char)L,
        11904, 11929, (char)ON, 11930, 11930, (char)L, 11931, 12019, (char)ON, 12020, 12031, (char)L,
        12032, 12245, (char)ON, 12246, 12271, (char)L, 12272, 12283, (char)ON, 12284, 12287, (char)L,
        12288, 12288, (char)WS, 12289, 12292, (char)ON, 12293, 12295, (char)L, 12296, 12320, (char)ON,
        12321, 12329, (char)L, 12330, 12335, (char)NSM, 12336, 12336, (char)ON, 12337, 12341, (char)L,
        12342, 12343, (char)ON, 12344, 12348, (char)L, 12349, 12351, (char)ON, 12352, 12440, (char)L,
        12441, 12442, (char)NSM, 12443, 12444, (char)ON, 12445, 12447, (char)L, 12448, 12448, (char)ON,
        12449, 12538, (char)L, 12539, 12539, (char)ON, 12540, 12828, (char)L, 12829, 12830, (char)ON,
        12831, 12879, (char)L, 12880, 12895, (char)ON, 12896, 12923, (char)L, 12924, 12925, (char)ON,
        12926, 12976, (char)L, 12977, 12991, (char)ON, 12992, 13003, (char)L, 13004, 13007, (char)ON,
        13008, 13174, (char)L, 13175, 13178, (char)ON, 13179, 13277, (char)L, 13278, 13279, (char)ON,
        13280, 13310, (char)L, 13311, 13311, (char)ON, 13312, 19903, (char)L, 19904, 19967, (char)ON,
        19968, 42127, (char)L, 42128, 42182, (char)ON, 42183, 64284, (char)L, 64285, 64285, (char)R,
        64286, 64286, (char)NSM, 64287, 64296, (char)R, 64297, 64297, (char)ET, 64298, 64310, (char)R,
        64311, 64311, (char)L, 64312, 64316, (char)R, 64317, 64317, (char)L, 64318, 64318, (char)R,
        64319, 64319, (char)L, 64320, 64321, (char)R, 64322, 64322, (char)L, 64323, 64324, (char)R,
        64325, 64325, (char)L, 64326, 64335, (char)R, 64336, 64433, (char)AL, 64434, 64466, (char)L,
        64467, 64829, (char)AL, 64830, 64831, (char)ON, 64832, 64847, (char)L, 64848, 64911, (char)AL,
        64912, 64913, (char)L, 64914, 64967, (char)AL, 64968, 65007, (char)L, 65008, 65020, (char)AL,
        65021, 65021, (char)ON, 65022, 65023, (char)L, 65024, 65039, (char)NSM, 65040, 65055, (char)L,
        65056, 65059, (char)NSM, 65060, 65071, (char)L, 65072, 65103, (char)ON, 65104, 65104, (char)CS,
        65105, 65105, (char)ON, 65106, 65106, (char)CS, 65107, 65107, (char)L, 65108, 65108, (char)ON,
        65109, 65109, (char)CS, 65110, 65118, (char)ON, 65119, 65119, (char)ET, 65120, 65121, (char)ON,
        65122, 65123, (char)ET, 65124, 65126, (char)ON, 65127, 65127, (char)L, 65128, 65128, (char)ON,
        65129, 65130, (char)ET, 65131, 65131, (char)ON, 65132, 65135, (char)L, 65136, 65140, (char)AL,
        65141, 65141, (char)L, 65142, 65276, (char)AL, 65277, 65278, (char)L, 65279, 65279, (char)BN,
        65280, 65280, (char)L, 65281, 65282, (char)ON, 65283, 65285, (char)ET, 65286, 65290, (char)ON,
        65291, 65291, (char)ET, 65292, 65292, (char)CS, 65293, 65293, (char)ET, 65294, 65294, (char)CS,
        65295, 65295, (char)ES, 65296, 65305, (char)EN, 65306, 65306, (char)CS, 65307, 65312, (char)ON,
        65313, 65338, (char)L, 65339, 65344, (char)ON, 65345, 65370, (char)L, 65371, 65381, (char)ON,
        65382, 65503, (char)L, 65504, 65505, (char)ET, 65506, 65508, (char)ON, 65509, 65510, (char)ET,
        65511, 65511, (char)L, 65512, 65518, (char)ON, 65519, 65528, (char)L, 65529, 65531, (char)BN,
        65532, 65533, (char)ON, 65534, 65535, (char)L};
        
    static {
        for (int k = 0; k < baseTypes.length; ++k) {
            int start = baseTypes[k];
            int end = baseTypes[++k];
            byte b = (byte)baseTypes[++k];
            while (start <= end)
                rtypes[start++] = b;
        }
    }        
} /*
 * $Id: ByteBuffer.java,v 1.34 2002/06/18 13:59:39 blowagie Exp $
 * $Name:  $
 *
 * Copyright 2000, 2001, 2002 by Paulo Soares.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf;
import java.io.UnsupportedEncodingException;
import java.io.OutputStream;
import java.io.IOException;
import pdftk.com.lowagie.text.DocWriter;

/**
 * Acts like a <CODE>StringBuffer</CODE> but works with <CODE>byte</CODE> arrays.
 * Floating point is converted to a format suitable to the PDF.
 * @author Paulo Soares (psoares@consiste.pt)
 */

public class ByteBuffer extends OutputStream {
    /** The count of bytes in the buffer. */
    protected int count;
    
    /** The buffer where the bytes are stored. */
    protected byte buf[];
    
    private static int byteCacheSize = 0;
    
    private static byte[][] byteCache = new byte[byteCacheSize][];
    public static byte ZERO = (byte)'0';
    private static final char[] chars = new char[] {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};
    private static final byte[] bytes = new byte[] {48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102};
    
    /** Creates new ByteBuffer with capacity 128 */
    public ByteBuffer() {
        this(128);
    }
    
    /**
     * Creates a byte buffer with a certain capacity.
     * @param size the initial capacity
     */
    public ByteBuffer(int size) {
        if (size < 1)
            size = 128;
        buf = new byte[size];
    }
    
    /**
     * Sets the cache size.
     * <P>
     * This can only be used to increment the size.
     * If the size that is passed through is smaller than the current size, nothing happens.
     *
     * @param   size    the size of the cache
     */
    
    public static void setCacheSize(int size) {
        if (size > 3276700) size = 3276700;
        if (size <= byteCacheSize) return;
        byte[][] tmpCache = new byte[size][];
        for (int i = 0; i < byteCacheSize; i++) {
            tmpCache[i] = byteCache[i];
        }
        byteCache = tmpCache;
        byteCacheSize = size;
    }
    
    /**
     * You can fill the cache in advance if you want to.
     *
     * @param   decimals
     */
    
    public static void fillCache(int decimals) {
        int step = 1;
        switch(decimals) {
            case 0:
                step = 100;
                break;
            case 1:
                step = 10;
                break;
        }
        for (int i = 1; i < byteCacheSize; i += step) {
            if (byteCache[i] != null) continue;
            byteCache[i] = convertToBytes(i);
        }
    }
    
    /**
     * Converts an double (multiplied by 100 and cast to an int) into an array of bytes.
     *
     * @param   i   the int
     * @return  a bytearray
     */
    
    private static byte[] convertToBytes(int i) {
        int size = (int)Math.floor(Math.log(i) / Math.log(10));
        if (i % 100 != 0) {
            size += 2;
        }
        if (i % 10 != 0) {
            size++;
        }
        if (i < 100) {
            size++;
            if (i < 10) {
                size++;
            }
        }
        size--;
        byte[] cache = new byte[size];
        size --;
        if (i < 100) {
            cache[0] = (byte)'0';
        }
        if (i % 10 != 0) {
            cache[size--] = bytes[i % 10];
        }
        if (i % 100 != 0) {
            cache[size--] = bytes[(i / 10) % 10];
            cache[size--] = (byte)'.';
        }
        size = (int)Math.floor(Math.log(i) / Math.log(10)) - 1;
        int add = 0;
        while (add < size) {
            cache[add] = bytes[(i / (int)Math.pow(10, size - add + 1)) % 10];
            add++;
        }
        return cache;
    }
    
    /**
     * Appends an <CODE>int</CODE>. The size of the array will grow by one.
     * @param b the int to be appended
     * @return a reference to this <CODE>ByteBuffer</CODE> object
     */
    public ByteBuffer append_i(int b) {
        int newcount = count + 1;
        if (newcount > buf.length) {
            byte newbuf[] = new byte[Math.max(buf.length << 1, newcount)];
            System.arraycopy(buf, 0, newbuf, 0, count);
            buf = newbuf;
        }
        buf[count] = (byte)b;
        count = newcount;
        return this;
    }
    
    /**
     * Appends the subarray of the <CODE>byte</CODE> array. The buffer will grow by
     * <CODE>len</CODE> bytes.
     * @param b the array to be appended
     * @param off the offset to the start of the array
     * @param len the length of bytes to append
     * @return a reference to this <CODE>ByteBuffer</CODE> object
     */
    public ByteBuffer append(byte b[], int off, int len) {
        if ((off < 0) || (off > b.length) || (len < 0) ||
        ((off + len) > b.length) || ((off + len) < 0) || len == 0)
            return this;
        int newcount = count + len;
        if (newcount > buf.length) {
            byte newbuf[] = new byte[Math.max(buf.length << 1, newcount)];
            System.arraycopy(buf, 0, newbuf, 0, count);
            buf = newbuf;
        }
        System.arraycopy(b, off, buf, count, len);
        count = newcount;
        return this;
    }
    
    /**
     * Appends an array of bytes.
     * @param b the array to be appended
     * @return a reference to this <CODE>ByteBuffer</CODE> object
     */
    public ByteBuffer append(byte b[]) {
        return append(b, 0, b.length);
    }
    
    /**
     * Appends a <CODE>String</CODE> to the buffer. The <CODE>String</CODE> is
     * converted according to the encoding ISO-8859-1.
     * @param str the <CODE>String</CODE> to be appended
     * @return a reference to this <CODE>ByteBuffer</CODE> object
     */
    public ByteBuffer append(String str) {
        if (str != null)
            return append(DocWriter.getISOBytes(str));
        return this;
    }
    
    /**
     * Appends a <CODE>char</CODE> to the buffer. The <CODE>char</CODE> is
     * converted according to the encoding ISO-8859-1.
     * @param c the <CODE>char</CODE> to be appended
     * @return a reference to this <CODE>ByteBuffer</CODE> object
     */
    public ByteBuffer append(char c) {
        return append_i(c);
    }
    
    /**
     * Appends another <CODE>ByteBuffer</CODE> to this buffer.
     * @param buf the <CODE>ByteBuffer</CODE> to be appended
     * @return a reference to this <CODE>ByteBuffer</CODE> object
     */
    public ByteBuffer append(ByteBuffer buf) {
        return append(buf.buf, 0, buf.count);
    }
    
    /**
     * Appends the string representation of an <CODE>int</CODE>.
     * @param i the <CODE>int</CODE> to be appended
     * @return a reference to this <CODE>ByteBuffer</CODE> object
     */
    public ByteBuffer append(int i) {
        return append((double)i);
    }
    
    public ByteBuffer append(byte b) {
        return append_i(b);
    }
    
    public ByteBuffer appendHex(byte b) {
        append(bytes[(b >> 4) & 0x0f]);
        return append(bytes[b & 0x0f]);
    }
    
    /**
     * Appends a string representation of a <CODE>float</CODE> according
     * to the Pdf conventions.
     * @param i the <CODE>float</CODE> to be appended
     * @return a reference to this <CODE>ByteBuffer</CODE> object
     */
    public ByteBuffer append(float i) {
        return append((double)i);
    }
    
    /**
     * Appends a string representation of a <CODE>double</CODE> according
     * to the Pdf conventions.
     * @param d the <CODE>double</CODE> to be appended
     * @return a reference to this <CODE>ByteBuffer</CODE> object
     */
    public ByteBuffer append(double d) {
        append(formatDouble(d, this));
        return this;
    }
    
    /**
     * Outputs a <CODE>double</CODE> into a format suitable for the PDF.
     * @param d a double
     * @return the <CODE>String</CODE> representation of the <CODE>double</CODE>
     */
    public static String formatDouble(double d) {
        return formatDouble(d, null);
    }
    
    /**
     * Outputs a <CODE>double</CODE> into a format suitable for the PDF.
     * @param d a double
     * @return the <CODE>String</CODE> representation of the <CODE>double</CODE> if
     * <CODE>d</CODE> is <CODE>null</CODE>. If <CODE>d</CODE> is <B>not</B> <CODE>null</CODE>,
     * then the double is appended directly to the buffer and this methods returns <CODE>null</CODE>.
     */
    public static String formatDouble(double d, ByteBuffer buf) {
        boolean negative = false;
        if (Math.abs(d) < 0.000015) {
            if (buf != null) {
                buf.append((byte)ZERO);
                return null;
            } else {
                return "0";
            }
        }
        if (d < 0) {
            negative = true;
            d = -d;
        }
        if (d < 1.0) {
            d += 0.000005;
            if (d >= 1) {
                if (negative) {
                    if (buf != null) {
                        buf.append((byte)'-');
                        buf.append((byte)'1');
                        return null;
                    } else {
                        return "-1";
                    }
                } else {
                    if (buf != null) {
                        buf.append((byte)'1');
                        return null;
                    } else {
                        return "1";
                    }
                }
            }
            if (buf != null) {
                int v = (int) (d * 100000);
                
                if (negative) buf.append((byte)'-');
                buf.append((byte)'0');
                buf.append((byte)'.');
                
                buf.append( (byte)(v / 10000 + ZERO) );
                if (v % 10000 != 0) {
                    buf.append( (byte)((v / 1000) % 10 + ZERO) );
                    if (v % 1000 != 0) {
                        buf.append( (byte)((v / 100) % 10 + ZERO) );
                        if (v % 100 != 0) {
                            buf.append((byte)((v / 10) % 10 + ZERO) );
                            if (v % 10 != 0) {
                                buf.append((byte)((v) % 10 + ZERO) );
                            }
                        }
                    }
                }
                return null;
            } else {
                int x = 100000;
                int v = (int) (d * x);
                
                StringBuffer res = new StringBuffer();
                if (negative) res.append('-');
                res.append("0.");
                
                while( v < x/10 ) {
                    res.append('0');
                    x /= 10;
                }
                res.append(v);
                int cut = res.length() - 1;
                while (res.charAt(cut) == '0') {
                    --cut;
                }
                res.setLength(cut + 1);
                return res.toString();
            }
        } else if (d <= 32767) {
            d += 0.005;
            int v = (int) (d * 100);
            
            if (v < byteCacheSize && byteCache[v] != null) {
                if (buf != null) {
                    if (negative) buf.append((byte)'-');
                    buf.append(byteCache[v]);
                    return null;
                } else {
                    String tmp = PdfEncodings.convertToString(byteCache[v], null);
                    if (negative) tmp = "-" + tmp;
                    return tmp;
                }
            }
            if (buf != null) {
                if (v < byteCacheSize) {
                    //create the cachebyte[]
                    byte[] cache;
                    int size = 0;
                    if (v >= 1000000) {
                        //the original number is >=10000, we need 5 more bytes
                        size += 5;
                    } else if (v >= 100000) {
                        //the original number is >=1000, we need 4 more bytes
                        size += 4;
                    } else if (v >= 10000) {
                        //the original number is >=100, we need 3 more bytes
                        size += 3;
                    } else if (v >= 1000) {
                        //the original number is >=10, we need 2 more bytes
                        size += 2;
                    } else if (v >= 100) {
                        //the original number is >=1, we need 1 more bytes
                        size += 1;
                    }
                    
                    //now we must check if we have a decimal number
                    if (v % 100 != 0) {
                        //yes, do not forget the "."
                        size += 2;
                    }
                    if (v % 10 != 0) {
                        size++;
                    }
                    cache = new byte[size];
                    int add = 0;
                    if (v >= 1000000) {
                        cache[add++] = bytes[(v / 1000000)];
                    }
                    if (v >= 100000) {
                        cache[add++] = bytes[(v / 100000) % 10];
                    }
                    if (v >= 10000) {
                        cache[add++] = bytes[(v / 10000) % 10];
                    }
                    if (v >= 1000) {
                        cache[add++] = bytes[(v / 1000) % 10];
                    }
                    if (v >= 100) {
                        cache[add++] = bytes[(v / 100) % 10];
                    }
                    
                    if (v % 100 != 0) {
                        cache[add++] = (byte)'.';
                        cache[add++] = bytes[(v / 10) % 10];
                        if (v % 10 != 0) {
                            cache[add++] = bytes[v % 10];
                        }
                    }
                    byteCache[v] = cache;
                }
                
                if (negative) buf.append((byte)'-');
                if (v >= 1000000) {
                    buf.append( bytes[(v / 1000000)] );
                }
                if (v >= 100000) {
                    buf.append( bytes[(v / 100000) % 10] );
                }
                if (v >= 10000) {
                    buf.append( bytes[(v / 10000) % 10] );
                }
                if (v >= 1000) {
                    buf.append( bytes[(v / 1000) % 10] );
                }
                if (v >= 100) {
                    buf.append( bytes[(v / 100) % 10] );
                }
                
                if (v % 100 != 0) {
                    buf.append((byte)'.');
                    buf.append( bytes[(v / 10) % 10] );
                    if (v % 10 != 0) {
                        buf.append( bytes[v % 10] );
                    }
                }
                return null;
            } else {
                StringBuffer res = new StringBuffer();
                if (negative) res.append((char)'-');
                if (v >= 1000000) {
                    res.append( chars[(v / 1000000)] );
                }
                if (v >= 100000) {
                    res.append( chars[(v / 100000) % 10] );
                }
                if (v >= 10000) {
                    res.append( chars[(v / 10000) % 10] );
                }
                if (v >= 1000) {
                    res.append( chars[(v / 1000) % 10] );
                }
                if (v >= 100) {
                    res.append( chars[(v / 100) % 10] );
                }
                
                if (v % 100 != 0) {
                    res.append((char)'.');
                    res.append( chars[(v / 10) % 10] );
                    if (v % 10 != 0) {
                        res.append( chars[v % 10] );
                    }
                }
                return res.toString();
            }
        } else {
            StringBuffer res = new StringBuffer();
            if (negative) res.append('-');
            d += 0.5;
            long v = (long) d;
            return res.append(v).toString();
        }
    }
    
    /**
     * Sets the size to zero.
     */
    public void reset() {
        count = 0;
    }
    
    /**
     * Creates a newly allocated byte array. Its size is the current
     * size of this output stream and the valid contents of the buffer
     * have been copied into it.
     *
     * @return  the current contents of this output stream, as a byte array.
     */
    public byte[] toByteArray() {
        byte newbuf[] = new byte[count];
        System.arraycopy(buf, 0, newbuf, 0, count);
        return newbuf;
    }
    
    /**
     * Returns the current size of the buffer.
     *
     * @return the value of the <code>count</code> field, which is the number of valid bytes in this byte buffer.
     */
    public int size() {
        return count;
    }
    
    /**
     * Converts the buffer's contents into a string, translating bytes into
     * characters according to the platform's default character encoding.
     *
     * @return String translated from the buffer's contents.
     */
    public String toString() {
        return new String(buf, 0, count);
    }
    
    /**
     * Converts the buffer's contents into a string, translating bytes into
     * characters according to the specified character encoding.
     *
     * @param   enc  a character-encoding name.
     * @return String translated from the buffer's contents.
     * @throws UnsupportedEncodingException
     *         If the named encoding is not supported.
     */
    public String toString(String enc) throws UnsupportedEncodingException {
        return new String(buf, 0, count, enc);
    }
    
    /**
     * Writes the complete contents of this byte buffer output to
     * the specified output stream argument, as if by calling the output
     * stream's write method using <code>out.write(buf, 0, count)</code>.
     *
     * @param      out   the output stream to which to write the data.
     * @exception  IOException  if an I/O error occurs.
     */
    public void writeTo(OutputStream out) throws IOException {
        out.write(buf, 0, count);
    }
    
    public void write(int b) throws IOException {
        append((byte)b);
    }
    
    public void write(byte[] b, int off, int len) {
        append(b, off, len);
    }
    
    public byte[] getBuffer() {
        return buf;
    }
} /*
 *
 * Copyright 2003 Sivan Toledo
 *
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 */

/*
 * Comments by Sivan Toledo:
 * I created this class in order to add to iText the ability to utilize
 * OpenType fonts with CFF glyphs (these usually have an .otf extension).
 * The CFF font within the CFF table of the OT font might be either a CID
 * or a Type1 font. (CFF fonts may also contain multiple fonts; I do not
 * know if this is allowed in an OT table). The PDF spec, however, only
 * allow a CID font with an Identity-H or Identity-V encoding. Otherwise,
 * you are limited to an 8-bit encoding.
 * Adobe fonts come in both flavors. That is, the OTFs sometimes have
 * a CID CFF inside (for Japanese fonts), and sometimes a Type1 CFF
 * (virtually all the others, Latin/Greek/Cyrillic). So to easily use
 * all the glyphs in the latter, without creating multiple 8-bit encoding,
 * I wrote this class, whose main purpose is to convert a Type1 font inside
 * a CFF container (which might include other fonts) into a CID CFF font
 * that can be directly embeded in the PDF.
 *
 * Limitations of the current version:
 * 1. It does not extract a single CID font from a CFF that contains that
 *    particular CID along with other fonts. The Adobe Japanese OTF's that
 *    I have only have one font in the CFF table, so these can be
 *    embeded in the PDF as is.
 * 2. It does not yet subset fonts.
 * 3. It may or may not work on CFF fonts that are not within OTF's.
 *    I didn't try that. In any case, that would probably only be
 *    useful for subsetting CID fonts, not for CFF Type1 fonts (I don't
 *    think there are any available.
 * I plan to extend the class to support these three features at some
 * future time.
 */

package pdftk.com.lowagie.text.pdf;

/**
 * @author stoledo
 */

import java.util.Iterator;
import java.util.LinkedList;
import pdftk.com.lowagie.text.ExceptionConverter;

public class CFFFont {
    
    static final String operatorNames[] = {
        "version", "Notice", "FullName", "FamilyName",
        "Weight", "FontBBox", "BlueValues", "OtherBlues",
        "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW",
        "UNKNOWN_12", "UniqueID", "XUID", "charset",
        "Encoding", "CharStrings", "Private", "Subrs",
        "defaultWidthX", "nominalWidthX", "UNKNOWN_22", "UNKNOWN_23",
        "UNKNOWN_24", "UNKNOWN_25", "UNKNOWN_26", "UNKNOWN_27",
        "UNKNOWN_28", "UNKNOWN_29", "UNKNOWN_30", "UNKNOWN_31",
        "Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition",
        "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix",
        "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz",
        "StemSnapH", "StemSnapV", "ForceBold", "UNKNOWN_12_15",
        "UNKNOWN_12_16", "LanguageGroup", "ExpansionFactor", "initialRandomSeed",
        "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend",
        "UNKNOWN_12_24", "UNKNOWN_12_25", "UNKNOWN_12_26", "UNKNOWN_12_27",
        "UNKNOWN_12_28", "UNKNOWN_12_29", "ROS", "CIDFontVersion",
        "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase",
        "FDArray", "FDSelect", "FontName"
    };
    
    static final String standardStrings[] = {
        // Automatically generated from Appendix A of the CFF specification; do
        // not edit. Size should be 391.
        ".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar",
        "percent", "ampersand", "quoteright", "parenleft", "parenright",
        "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one",
        "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon",
        "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C",
        "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R",
        "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash",
        "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c",
        "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r",
        "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright",
        "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen",
        "florin", "section", "currency", "quotesingle", "quotedblleft",
        "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash",
        "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet",
        "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright",
        "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex",
        "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla",
        "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash",
        "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe",
        "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth",
        "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar",
        "degree", "thorn", "threequarters", "twosuperior", "registered", "minus",
        "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex",
        "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute",
        "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis",
        "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve",
        "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave",
        "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis",
        "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex",
        "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave",
        "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde",
        "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute",
        "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall",
        "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall",
        "parenleftsuperior", "parenrightsuperior", "twodotenleader",
        "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle",
        "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle",
        "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior",
        "threequartersemdash", "periodsuperior", "questionsmall", "asuperior",
        "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior",
        "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior",
        "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior",
        "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall",
        "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall",
        "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall",
        "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall",
        "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary",
        "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle",
        "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall",
        "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash",
        "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall",
        "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths",
        "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior",
        "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior",
        "ninesuperior", "zeroinferior", "oneinferior", "twoinferior",
        "threeinferior", "fourinferior", "fiveinferior", "sixinferior",
        "seveninferior", "eightinferior", "nineinferior", "centinferior",
        "dollarinferior", "periodinferior", "commainferior", "Agravesmall",
        "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall",
        "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall",
        "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall",
        "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall",
        "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall",
        "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall",
        "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall",
        "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black",
        "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"
    };
    
    //private String[] strings;
    public String getString(char sid) {
        if (sid < standardStrings.length) return standardStrings[sid];
        if (sid >= standardStrings.length+(stringOffsets.length-1)) return null;
        int j = sid - standardStrings.length;
        //java.lang.System.err.println("going for "+j);
        int p = getPosition();
        seek(stringOffsets[j]);
        StringBuffer s = new StringBuffer();
        for (int k=stringOffsets[j]; k<stringOffsets[j+1]; k++) {
            s.append(getCard8());
        }
        seek(p);
        return s.toString();
    }
    
    char getCard8() {
        try {
            byte i = buf.readByte();
            return (char)(i & 0xff);
        }
        catch (Exception e) {
            throw new ExceptionConverter(e);
        }
    }
    
    char getCard16() {
        try {
            return buf.readChar();
        }
        catch (Exception e) {
            throw new ExceptionConverter(e);
        }
    }
    
    int getOffset(int offSize) {
        int offset = 0;
        for (int i=0; i<offSize; i++) {
            offset *= 256;
            offset += getCard8();
        }
        return offset;
    }
    
    void seek(int offset) {
        try {
            buf.seek(offset);
        }
        catch (Exception e) {
            throw new ExceptionConverter(e);
        }
    }
    
    short getShort() {
        try {
            return buf.readShort();
        }
        catch (Exception e) {
            throw new ExceptionConverter(e);
        }
    }
    
    int getInt() {
        try {
            return buf.readInt();
        }
        catch (Exception e) {
            throw new ExceptionConverter(e);
        }
    }
    
    int getPosition() {
        try {
            return buf.getFilePointer();
        }
        catch (Exception e) {
            throw new ExceptionConverter(e);
        }
    }
    int nextIndexOffset;
    // read the offsets in the next index
    // data structure, convert to global
    // offsets, and return them.
    // Sets the nextIndexOffset.
    int[] getIndex(int nextIndexOffset) {
        int count, indexOffSize;
        
        seek(nextIndexOffset);
        count = getCard16();
        int[] offsets = new int[count+1];
        
        if (count==0) {
            offsets[0] = -1;
            nextIndexOffset += 2;
            return offsets;
        }
        
        indexOffSize = getCard8();
        
        for (int j=0; j<=count; j++) {
        	//nextIndexOffset = ofset to relative segment
            offsets[j] = nextIndexOffset
			//2-> count in the index header. 1->offset size in index header
            + 2+1
			//offset array size * offset size 
            + (count+1)*indexOffSize
			//???zero <-> one base
            - 1
			// read object offset relative to object array base 
            + getOffset(indexOffSize);
        }
        //nextIndexOffset = offsets[count];
        return offsets;
    }
    
    protected String   key;
    protected Object[] args      = new Object[48];
    protected int      arg_count = 0;
    
    protected void getDictItem() {
        for (int i=0; i<arg_count; i++) args[i]=null;
        arg_count = 0;
        key = null;
        boolean gotKey = false;
        
        while (!gotKey) {
            char b0 = getCard8();
            if (b0 == 29) {
                int item = getInt();
                args[arg_count] = new Integer(item);
                arg_count++;
                //System.err.println(item+" ");
                continue;
            }
            if (b0 == 28) {
                short item = getShort();
                args[arg_count] = new Integer(item);
                arg_count++;
                //System.err.println(item+" ");
                continue;
            }
            if (b0 >= 32 && b0 <= 246) {
                byte item = (byte) (b0-139);
                args[arg_count] = new Integer(item);
                arg_count++;
                //System.err.println(item+" ");
                continue;
            }
            if (b0 >= 247 && b0 <= 250) {
                char b1 = getCard8();
                short item = (short) ((b0-247)*256+b1+108);
                args[arg_count] = new Integer(item);
                arg_count++;
                //System.err.println(item+" ");
                continue;
            }
            if (b0 >= 251 && b0 <= 254) {
                char b1 = getCard8();
                short item = (short) (-(b0-251)*256-b1-108);
                args[arg_count] = new Integer(item);
                arg_count++;
                //System.err.println(item+" ");
                continue;
            }
            if (b0 == 30) {
                String item = "";
                boolean done = false;
                char buffer = 0;
                byte avail = 0;
                int  nibble = 0;
                while (!done) {
                    // get a nibble
                    if (avail==0) { buffer = getCard8(); avail=2; }
                    if (avail==1) { nibble = (buffer / 16); avail--; }
                    if (avail==2) { nibble = (buffer % 16); avail--; }
                    switch (nibble) {
                        case 0xa: item += "." ; break;
                        case 0xb: item += "E" ; break;
                        case 0xc: item += "E-"; break;
                        case 0xe: item += "-" ; break;
                        case 0xf: done=true   ; break;
                        default:
                            if (nibble >= 0 && nibble <= 9)
                                item += String.valueOf(nibble);
                            else {
                                item += "<NIBBLE ERROR: "+String.valueOf(nibble)+">";
                                done = true;
                            }
                            break;
                    }
                }
                args[arg_count] = item;
                arg_count++;
                //System.err.println(" real=["+item+"]");
                continue;
            }
            if (b0 <= 21) {
                gotKey=true;
                if (b0 != 12) key = operatorNames[b0];
                else key = operatorNames[32 + getCard8()];
                //for (int i=0; i<arg_count; i++)
                //  System.err.print(args[i].toString()+" ");
                //System.err.println(key+" ;");
                continue;
            }
        }
    }
    
    /** List items for the linked list that builds the new CID font.
     */
    
    protected static abstract class Item {
        protected int myOffset = -1;
        /** remember the current offset and increment by item's size in bytes. */
        public void increment(int[] currentOffset) {
            myOffset = currentOffset[0];
        }
        /** Emit the byte stream for this item. */
        public void emit(byte[] buffer) {}
        /** Fix up cross references to this item (applies only to markers). */
        public void xref() {}
    }
    
    protected static abstract class OffsetItem extends Item {
        public int value;
        /** set the value of an offset item that was initially unknown.
         * It will be fixed up latex by a call to xref on some marker.
         */
        public void set(int offset) { this.value = offset; }
    }
    
    
    /** A range item.
     */
    
    protected static final class RangeItem extends Item {
        public int offset, length;
        private RandomAccessFileOrArray buf;
        public RangeItem(RandomAccessFileOrArray buf, int offset, int length) {
            this.offset = offset;
            this.length = length;
            this.buf = buf;
        }
        public void increment(int[] currentOffset) {
            super.increment(currentOffset);
            currentOffset[0] += length;
        }
        public void emit(byte[] buffer) {
            //System.err.println("range emit offset "+offset+" size="+length);
            try {
                buf.seek(offset);
                for (int i=myOffset; i<myOffset+length; i++)
                    buffer[i] = buf.readByte();
            }
            catch (Exception e) {
                throw new ExceptionConverter(e);
            }
            //System.err.println("finished range emit");
        }
    }
    
    /** An index-offset item for the list.
     * The size denotes the required size in the CFF. A positive
     * value means that we need a specific size in bytes (for offset arrays)
     * and a negative value means that this is a dict item that uses a
     * variable-size representation.
     */
    static protected final class IndexOffsetItem extends OffsetItem {
        public final int size;
        public IndexOffsetItem(int size, int value) {this.size=size; this.value=value;}
        public IndexOffsetItem(int size) {this.size=size; }
        
        public void increment(int[] currentOffset) {
            super.increment(currentOffset);
            currentOffset[0] += size;
        }
        public void emit(byte[] buffer) {
            int i=0;
            switch (size) {
                case 4:
                    buffer[myOffset+i] = (byte) ((value >>> 24) & 0xff);
                    i++;
                case 3:
                    buffer[myOffset+i] = (byte) ((value >>> 16) & 0xff);
                    i++;
                case 2:
                    buffer[myOffset+i] = (byte) ((value >>>  8) & 0xff);
                    i++;
                case 1:
                    buffer[myOffset+i] = (byte) ((value >>>  0) & 0xff);
                    i++;
            }
            /*
            int mask = 0xff;
            for (int i=size-1; i>=0; i--) {
                buffer[myOffset+i] = (byte) (value & mask);
                mask <<= 8;
            }
             */
        }
    }
    
    static protected final class IndexBaseItem extends Item {
        public IndexBaseItem() {}
    }
    
    static protected final class IndexMarkerItem extends Item {
        private OffsetItem offItem;
        private IndexBaseItem indexBase;
        public IndexMarkerItem(OffsetItem offItem, IndexBaseItem indexBase) {
            this.offItem   = offItem;
            this.indexBase = indexBase;
        }
        public void xref() {
            //System.err.println("index marker item, base="+indexBase.myOffset+" my="+this.myOffset);
            offItem.set(this.myOffset-indexBase.myOffset+1);
        }
    }
    /**
     * 
     * @author orly manor
     *
     * TODO To change the template for this generated type comment go to
     * Window - Preferences - Java - Code Generation - Code and Comments
     */
    static protected final class SubrMarkerItem extends Item {
        private OffsetItem offItem;
        private IndexBaseItem indexBase;
        public SubrMarkerItem(OffsetItem offItem, IndexBaseItem indexBase) {
            this.offItem   = offItem;
            this.indexBase = indexBase;
        }
        public void xref() {
            //System.err.println("index marker item, base="+indexBase.myOffset+" my="+this.myOffset);
            offItem.set(this.myOffset-indexBase.myOffset);
        }
    }
    
    
    /** an unknown offset in a dictionary for the list.
     * We will fix up the offset later; for now, assume it's large.
     */
    static protected final class DictOffsetItem extends OffsetItem {
        public final int size;
        public DictOffsetItem() {this.size=5; }
        
        public void increment(int[] currentOffset) {
            super.increment(currentOffset);
            currentOffset[0] += size;
        }
        // this is incomplete!
        public void emit(byte[] buffer) {
            if (size==5) {
                buffer[myOffset]   = 29;
                buffer[myOffset+1] = (byte) ((value >>> 24) & 0xff);
                buffer[myOffset+2] = (byte) ((value >>> 16) & 0xff);
                buffer[myOffset+3] = (byte) ((value >>>  8) & 0xff);
                buffer[myOffset+4] = (byte) ((value >>>  0) & 0xff);
            }
        }
    }
    
	/** Card24 item.
     */
    
    static protected final class UInt24Item extends Item {
        public int value;
        public UInt24Item(int value) {this.value=value;}
        
        public void increment(int[] currentOffset) {
            super.increment(currentOffset);
            currentOffset[0] += 3;
        }
        // this is incomplete!
        public void emit(byte[] buffer) {
        	buffer[myOffset+0] = (byte) ((value >>> 16) & 0xff);
            buffer[myOffset+1] = (byte) ((value >>> 8) & 0xff);
            buffer[myOffset+2] = (byte) ((value >>> 0) & 0xff);
        }
    }
    
    /** Card32 item.
     */
    
    static protected final class UInt32Item extends Item {
        public int value;
        public UInt32Item(int value) {this.value=value;}
        
        public void increment(int[] currentOffset) {
            super.increment(currentOffset);
            currentOffset[0] += 4;
        }
        // this is incomplete!
        public void emit(byte[] buffer) {
        	buffer[myOffset+0] = (byte) ((value >>> 24) & 0xff);
        	buffer[myOffset+1] = (byte) ((value >>> 16) & 0xff);
            buffer[myOffset+2] = (byte) ((value >>> 8) & 0xff);
            buffer[myOffset+3] = (byte) ((value >>> 0) & 0xff);
        }
    }

    /** A SID or Card16 item.
     */
    
    static protected final class UInt16Item extends Item {
        public char value;
        public UInt16Item(char value) {this.value=value;}
        
        public void increment(int[] currentOffset) {
            super.increment(currentOffset);
            currentOffset[0] += 2;
        }
        // this is incomplete!
        public void emit(byte[] buffer) {
            buffer[myOffset+0] = (byte) ((value >>> 8) & 0xff);
            buffer[myOffset+1] = (byte) ((value >>> 0) & 0xff);
        }
    }
    
    /** A Card8 item.
     */
    
    static protected final class UInt8Item extends Item {
        public char value;
        public UInt8Item(char value) {this.value=value;}
        
        public void increment(int[] currentOffset) {
            super.increment(currentOffset);
            currentOffset[0] += 1;
        }
        // this is incomplete!
        public void emit(byte[] buffer) {
            buffer[myOffset+0] = (byte) ((value >>> 0) & 0xff);
        }
    }
    
    static protected final class StringItem extends Item {
        public String s;
        public StringItem(String s) {this.s=s;}
        
        public void increment(int[] currentOffset) {
            super.increment(currentOffset);
            currentOffset[0] += s.length();
        }
        public void emit(byte[] buffer) {
            for (int i=0; i<s.length(); i++)
                buffer[myOffset+i] = (byte) (s.charAt(i) & 0xff);
        }
    }
    
    
    /** A dictionary number on the list.
     * This implementation is inefficient: it doesn't use the variable-length
     * representation.
     */
    
    static protected final class DictNumberItem extends Item {
        public final int value;
        public int size = 5;
        public DictNumberItem(int value) {this.value=value;}
        public void increment(int[] currentOffset) {
            super.increment(currentOffset);
            currentOffset[0] += size;
        }
        // this is imcomplete!
        public void emit(byte[] buffer) {
            if (size==5) {
                buffer[myOffset]   = 29;
                buffer[myOffset+1] = (byte) ((value >>> 24) & 0xff);
                buffer[myOffset+2] = (byte) ((value >>> 16) & 0xff);
                buffer[myOffset+3] = (byte) ((value >>>  8) & 0xff);
                buffer[myOffset+4] = (byte) ((value >>>  0) & 0xff);
            }
        }
    }
    
    /** An offset-marker item for the list.
     * It is used to mark an offset and to set the offset list item.
     */
    
    static protected final class MarkerItem extends Item {
        OffsetItem p;
        public MarkerItem(OffsetItem pointerToMarker) {p=pointerToMarker;}
        public void xref() {
            p.set(this.myOffset);
        }
    }
    
    /** a utility that creates a range item for an entire index
     *
     * @param indexOffset where the index is
     * @return a range item representing the entire index
     */
    
    protected RangeItem getEntireIndexRange(int indexOffset) {
        seek(indexOffset);
        int count = getCard16();
        if (count==0) {
            return new RangeItem(buf,indexOffset,2);
        } else {
            int indexOffSize = getCard8();
            seek(indexOffset+2+1+count*indexOffSize);
            int size = getOffset(indexOffSize)-1;
            return new RangeItem(buf,indexOffset,
            2+1+(count+1)*indexOffSize+size);
        }
    }
    
    
    /** get a single CID font. The PDF architecture (1.4)
     * supports 16-bit strings only with CID CFF fonts, not
     * in Type-1 CFF fonts, so we convert the font to CID if
     * it is in the Type-1 format.
     * Two other tasks that we need to do are to select
     * only a single font from the CFF package (this again is
     * a PDF restriction) and to subset the CharStrings glyph
     * description.
     */
    
    
    public byte[] getCID(String fontName)
    //throws java.io.FileNotFoundException
    {
        int j;
        for (j=0; j<fonts.length; j++)
            if (fontName.equals(fonts[j].name)) break;
        if (j==fonts.length) return null;
        
        LinkedList l = new LinkedList();
        
        // copy the header
        
        seek(0);
        
        // ssteward omit: int major = getCard8();
        // ssteward omit: int minor = getCard8();
        int hdrSize = getCard8();
        // ssteward omit: int offSize = getCard8();
        nextIndexOffset = hdrSize;
        
        l.addLast(new RangeItem(buf,0,hdrSize));
        
        int nglyphs=-1, nstrings=-1;
        if ( ! fonts[j].isCID ) {
            // count the glyphs
            seek(fonts[j].charstringsOffset);
            nglyphs = getCard16();
            seek(stringIndexOffset);
            nstrings = getCard16()+standardStrings.length;
            //System.err.println("number of glyphs = "+nglyphs);
        }
        
        // create a name index
        
        l.addLast(new UInt16Item((char)1)); // count
        l.addLast(new UInt8Item((char)1)); // offSize
        l.addLast(new UInt8Item((char)1)); // first offset
        l.addLast(new UInt8Item((char)( 1+fonts[j].name.length() )));
        l.addLast(new StringItem(fonts[j].name));
        
        // create the topdict Index
        
        
        l.addLast(new UInt16Item((char)1)); // count
        l.addLast(new UInt8Item((char)2)); // offSize
        l.addLast(new UInt16Item((char)1)); // first offset
        OffsetItem topdictIndex1Ref = new IndexOffsetItem(2);
        l.addLast(topdictIndex1Ref);
        IndexBaseItem topdictBase = new IndexBaseItem();
        l.addLast(topdictBase);
        
        /*
        int maxTopdictLen = (topdictOffsets[j+1]-topdictOffsets[j])
                            + 9*2 // at most 9 new keys
                            + 8*5 // 8 new integer arguments
                            + 3*2;// 3 new SID arguments
         */
        
        //int    topdictNext = 0;
        //byte[] topdict = new byte[maxTopdictLen];
        
        OffsetItem charsetRef     = new DictOffsetItem();
        OffsetItem charstringsRef = new DictOffsetItem();
        OffsetItem fdarrayRef     = new DictOffsetItem();
        OffsetItem fdselectRef    = new DictOffsetItem();
        
        if ( !fonts[j].isCID ) {
            // create a ROS key
            l.addLast(new DictNumberItem(nstrings));
            l.addLast(new DictNumberItem(nstrings+1));
            l.addLast(new DictNumberItem(0));
            l.addLast(new UInt8Item((char)12));
            l.addLast(new UInt8Item((char)30));
            // create a CIDCount key
            l.addLast(new DictNumberItem(nglyphs));
            l.addLast(new UInt8Item((char)12));
            l.addLast(new UInt8Item((char)34));
            // What about UIDBase (12,35)? Don't know what is it.
            // I don't think we need FontName; the font I looked at didn't have it.
        }
        
        // create an FDArray key
        l.addLast(fdarrayRef);
        l.addLast(new UInt8Item((char)12));
        l.addLast(new UInt8Item((char)36));
        // create an FDSelect key
        l.addLast(fdselectRef);
        l.addLast(new UInt8Item((char)12));
        l.addLast(new UInt8Item((char)37));
        // create an charset key
        l.addLast(charsetRef);
        l.addLast(new UInt8Item((char)15));
        // create a CharStrings key
        l.addLast(charstringsRef);
        l.addLast(new UInt8Item((char)17));
        
        seek(topdictOffsets[j]);
        while (getPosition() < topdictOffsets[j+1]) {
            int p1 = getPosition();
            getDictItem();
            int p2 = getPosition();
            if (key=="Encoding"
            || key=="Private"
            || key=="FDSelect"
            || key=="FDArray"
            || key=="charset"
            || key=="CharStrings"
            ) {
                // just drop them
            } else {
                l.add(new RangeItem(buf,p1,p2-p1));
            }
        }
        
        l.addLast(new IndexMarkerItem(topdictIndex1Ref,topdictBase));
        
        // Copy the string index and append new strings.
        // We need 3 more strings: Registry, Ordering, and a FontName for one FD.
        // The total length is at most "Adobe"+"Identity"+63 = 76
        
        if (fonts[j].isCID) {
            l.addLast(getEntireIndexRange(stringIndexOffset));
        } else {
            String fdFontName = fonts[j].name+"-OneRange";
            if (fdFontName.length() > 127)
                fdFontName = fdFontName.substring(0,127);
            String extraStrings = "Adobe"+"Identity"+fdFontName;
            
            int origStringsLen = stringOffsets[stringOffsets.length-1]
            - stringOffsets[0];
            int stringsBaseOffset = stringOffsets[0]-1;
            
            byte stringsIndexOffSize;
            if (origStringsLen+extraStrings.length() <= 0xff) stringsIndexOffSize = 1;
            else if (origStringsLen+extraStrings.length() <= 0xffff) stringsIndexOffSize = 2;
            else if (origStringsLen+extraStrings.length() <= 0xffffff) stringsIndexOffSize = 3;
            else stringsIndexOffSize = 4;
            
            l.addLast(new UInt16Item((char)((stringOffsets.length-1)+3))); // count
            l.addLast(new UInt8Item((char)stringsIndexOffSize)); // offSize
            for (int i=0; i<stringOffsets.length; i++)
                l.addLast(new IndexOffsetItem(stringsIndexOffSize,
                stringOffsets[i]-stringsBaseOffset));
            int currentStringsOffset = stringOffsets[stringOffsets.length-1]
            - stringsBaseOffset;
            //l.addLast(new IndexOffsetItem(stringsIndexOffSize,currentStringsOffset));
            currentStringsOffset += ("Adobe").length();
            l.addLast(new IndexOffsetItem(stringsIndexOffSize,currentStringsOffset));
            currentStringsOffset += ("Identity").length();
            l.addLast(new IndexOffsetItem(stringsIndexOffSize,currentStringsOffset));
            currentStringsOffset += fdFontName.length();
            l.addLast(new IndexOffsetItem(stringsIndexOffSize,currentStringsOffset));
            
            l.addLast(new RangeItem(buf,stringOffsets[0],origStringsLen));
            l.addLast(new StringItem(extraStrings));
        }
        
        // copy the global subroutine index
        
        l.addLast(getEntireIndexRange(gsubrIndexOffset));
        
        // deal with fdarray, fdselect, and the font descriptors
        
        if (fonts[j].isCID) {
            // copy the FDArray, FDSelect, charset
        } else {
            // create FDSelect
            l.addLast(new MarkerItem(fdselectRef));
            l.addLast(new UInt8Item((char)3)); // format identifier
            l.addLast(new UInt16Item((char)1)); // nRanges
            
            l.addLast(new UInt16Item((char)0)); // Range[0].firstGlyph
            l.addLast(new UInt8Item((char)0)); // Range[0].fd
            
            l.addLast(new UInt16Item((char)nglyphs)); // sentinel
            
            // recreate a new charset
            // This format is suitable only for fonts without subsetting
            
            l.addLast(new MarkerItem(charsetRef));
            l.addLast(new UInt8Item((char)2)); // format identifier
            
            l.addLast(new UInt16Item((char)1)); // first glyph in range (ignore .notdef)
            l.addLast(new UInt16Item((char)(nglyphs-1))); // nLeft
            // now all are covered, the data structure is complete.
            
            // create a font dict index (fdarray)
            
            l.addLast(new MarkerItem(fdarrayRef));
            l.addLast(new UInt16Item((char)1));
            l.addLast(new UInt8Item((char)1)); // offSize
            l.addLast(new UInt8Item((char)1)); // first offset
            
            OffsetItem privateIndex1Ref = new IndexOffsetItem(1);
            l.addLast(privateIndex1Ref);
            IndexBaseItem privateBase = new IndexBaseItem();
            l.addLast(privateBase);
            
            // looking at the PS that acrobat generates from a PDF with
            // a CFF opentype font embeded with an identity-H encoding,
            // it seems that it does not need a FontName.
            //l.addLast(new DictNumberItem((standardStrings.length+(stringOffsets.length-1)+2)));
            //l.addLast(new UInt8Item((char)12));
            //l.addLast(new UInt8Item((char)38)); // FontName
            
            l.addLast(new DictNumberItem(fonts[j].privateLength));
            OffsetItem privateRef = new DictOffsetItem();
            l.addLast(privateRef);
            l.addLast(new UInt8Item((char)18)); // Private
            
            l.addLast(new IndexMarkerItem(privateIndex1Ref,privateBase));
            
            // copy the private index & local subroutines
            
            l.addLast(new MarkerItem(privateRef));
            // copy the private dict and the local subroutines.
            // the length of the private dict seems to NOT include
            // the local subroutines.
            l.addLast(new RangeItem(buf,fonts[j].privateOffset,fonts[j].privateLength));
            if (fonts[j].privateSubrs >= 0) {
                //System.err.println("has subrs="+fonts[j].privateSubrs+" ,len="+fonts[j].privateLength);
                l.addLast(getEntireIndexRange(fonts[j].privateSubrs));
            }
        }
        
        // copy the charstring index
        
        l.addLast(new MarkerItem(charstringsRef));
        l.addLast(getEntireIndexRange(fonts[j].charstringsOffset));
        
        // now create the new CFF font
        
        int[] currentOffset = new int[1];
        currentOffset[0] = 0;
        
        Iterator listIter = l.iterator();
        while ( listIter.hasNext() ) {
            Item item = (Item) listIter.next();
            item.increment(currentOffset);
        }
        
        listIter = l.iterator();
        while ( listIter.hasNext() ) {
            Item item = (Item) listIter.next();
            item.xref();
        }
        
        int size = currentOffset[0];
        byte[] b = new byte[size];
        
        listIter = l.iterator();
        while ( listIter.hasNext() ) {
            Item item = (Item) listIter.next();
            item.emit(b);
        }
        
        return b;
    }
    
    
    public boolean isCID(String fontName) {
        int j;
        for (j=0; j<fonts.length; j++)
            if (fontName.equals(fonts[j].name)) return fonts[j].isCID;
        return false;
    }
    
    public boolean exists(String fontName) {
        int j;
        for (j=0; j<fonts.length; j++)
            if (fontName.equals(fonts[j].name)) return true;
        return false;
    }
    
    
    public String[] getNames() {
        String[] names = new String[ fonts.length ];
        for (int i=0; i<fonts.length; i++)
            names[i] = fonts[i].name;
        return names;
    }
    /**
     * A random Access File or an array
     * (contributed by orly manor)
     */
    protected RandomAccessFileOrArray buf;
    
    protected int nameIndexOffset;
    protected int topdictIndexOffset;
    protected int stringIndexOffset;
    protected int gsubrIndexOffset;
    protected int[] nameOffsets;
    protected int[] topdictOffsets;
    protected int[] stringOffsets;
    protected int[] gsubrOffsets;
    
    /**
     * @author orly manor
     * TODO Changed from private to protected by Ygal&Oren
     */
    protected final class Font {
        public String    name;
        public String    fullName;
        public boolean   isCID = false;
        public int       privateOffset     = -1; // only if not CID
        public int       privateLength     = -1; // only if not CID
        public int       privateSubrs      = -1;
        public int       charstringsOffset = -1;
        public int       encodingOffset    = -1;
        public int       charsetOffset     = -1;
        public int       fdarrayOffset     = -1; // only if CID
        public int       fdselectOffset    = -1; // only if CID
        public int[]     fdprivateOffsets;
        public int[]     fdprivateLengths;
        public int[]     fdprivateSubrs;
        
        // Added by Oren & Ygal
        public int nglyphs;
        public int nstrings;
        public int CharsetLength;
        public int[]    charstringsOffsets;
        public int[]    charset;
        public int[] 	FDSelect;
        public int FDSelectLength;
        public int FDSelectFormat;
        public int 		CharstringType = 2;
        public int FDArrayCount;
        public int FDArrayOffsize;
        public int[] FDArrayOffsets;
        public int[] PrivateSubrsOffset;
        public int[][] PrivateSubrsOffsetsArray;
        public int[]       SubrsOffsets;
    }
    // Changed from private to protected by Ygal&Oren
    protected Font[] fonts;
    
    public CFFFont(RandomAccessFileOrArray inputbuffer) {
        
        //System.err.println("CFF: nStdString = "+standardStrings.length);
        buf = inputbuffer;
        seek(0);
        
        // ssteward omit: int major = getCard8();
        // ssteward omit: int minor = getCard8();
        
        //System.err.println("CFF Major-Minor = "+major+"-"+minor);
        
        int hdrSize = getCard8();
	// ssteward omit: int offSize = getCard8();
        
        //System.err.println("offSize = "+offSize);
        
        //int count, indexOffSize, indexOffset, nextOffset;
        
        nameIndexOffset    = hdrSize;
        nameOffsets        = getIndex(nameIndexOffset);
        topdictIndexOffset = nameOffsets[nameOffsets.length-1];
        topdictOffsets     = getIndex(topdictIndexOffset);
        stringIndexOffset  = topdictOffsets[topdictOffsets.length-1];
        stringOffsets      = getIndex(stringIndexOffset);
        gsubrIndexOffset   = stringOffsets[stringOffsets.length-1];
        gsubrOffsets       = getIndex(gsubrIndexOffset);
        
        fonts = new Font[nameOffsets.length-1];
        
        // now get the name index
        
        /*
        names             = new String[nfonts];
        privateOffset     = new int[nfonts];
        charsetOffset     = new int[nfonts];
        encodingOffset    = new int[nfonts];
        charstringsOffset = new int[nfonts];
        fdarrayOffset     = new int[nfonts];
        fdselectOffset    = new int[nfonts];
         */
        
        for (int j=0; j<nameOffsets.length-1; j++) {
            fonts[j] = new Font();
            seek(nameOffsets[j]);
            fonts[j].name = "";
            for (int k=nameOffsets[j]; k<nameOffsets[j+1]; k++) {
                fonts[j].name += (char)getCard8();
            }
            //System.err.println("name["+j+"]=<"+fonts[j].name+">");
        }
        
        // string index
        
        //strings = new String[stringOffsets.length-1];
        /*
        System.err.println("std strings = "+standardStrings.length);
        System.err.println("fnt strings = "+(stringOffsets.length-1));
        for (char j=0; j<standardStrings.length+(stringOffsets.length-1); j++) {
            //seek(stringOffsets[j]);
            //strings[j] = "";
            //for (int k=stringOffsets[j]; k<stringOffsets[j+1]; k++) {
            //	strings[j] += (char)getCard8();
            //}
            System.err.println("j="+(int)j+" <? "+(standardStrings.length+(stringOffsets.length-1)));
            System.err.println("strings["+(int)j+"]=<"+getString(j)+">");
        }
         */
        
        // top dict
        
        for (int j=0; j<topdictOffsets.length-1; j++) {
            seek(topdictOffsets[j]);
            while (getPosition() < topdictOffsets[j+1]) {            	
                getDictItem();
                if (key=="FullName") {
                    //System.err.println("getting fullname sid = "+((Integer)args[0]).intValue());
                    fonts[j].fullName = getString((char)((Integer)args[0]).intValue());
                    //System.err.println("got it");
                } else if (key=="ROS")
                    fonts[j].isCID = true;
                else if (key=="Private") {
                    fonts[j].privateLength  = ((Integer)args[0]).intValue();
                    fonts[j].privateOffset  = ((Integer)args[1]).intValue();
                }
                else if (key=="charset"){
                    fonts[j].charsetOffset = ((Integer)args[0]).intValue();
                    
                }
                else if (key=="Encoding"){
                    fonts[j].encodingOffset = ((Integer)args[0]).intValue();
                    ReadEncoding(fonts[j].encodingOffset);
                }
                else if (key=="CharStrings") {
                    fonts[j].charstringsOffset = ((Integer)args[0]).intValue();
                    //System.err.println("charstrings "+fonts[j].charstringsOffset);
                    // Added by Oren & Ygal
                    int p = getPosition();
                    fonts[j].charstringsOffsets = getIndex(fonts[j].charstringsOffset);
                    seek(p);
                } else if (key=="FDArray")
                    fonts[j].fdarrayOffset = ((Integer)args[0]).intValue();
                else if (key=="FDSelect")
                    fonts[j].fdselectOffset = ((Integer)args[0]).intValue();
                else if (key=="CharstringType")
                	fonts[j].CharstringType = ((Integer)args[0]).intValue();
            }
            
            // private dict
            if (fonts[j].privateOffset >= 0) {
                //System.err.println("PRIVATE::");
                seek(fonts[j].privateOffset);
                while (getPosition() < fonts[j].privateOffset+fonts[j].privateLength) {
                    getDictItem();
                    if (key=="Subrs")
                    	//Add the private offset to the lsubrs since the offset is 
                    	// relative to the begining of the PrivateDict
                        fonts[j].privateSubrs = ((Integer)args[0]).intValue()+fonts[j].privateOffset;
                }
            }
            
            // fdarray index
            if (fonts[j].fdarrayOffset >= 0) {
                int[] fdarrayOffsets = getIndex(fonts[j].fdarrayOffset);
                
                fonts[j].fdprivateOffsets = new int[fdarrayOffsets.length-1];
                fonts[j].fdprivateLengths = new int[fdarrayOffsets.length-1];
                
                //System.err.println("FD Font::");
                
                for (int k=0; k<fdarrayOffsets.length-1; k++) {
                    seek(fdarrayOffsets[k]);
                    while (getPosition() < fdarrayOffsets[k+1])
                        getDictItem();
                    if (key=="Private") {
                        fonts[j].fdprivateLengths[k]  = ((Integer)args[0]).intValue();
                        fonts[j].fdprivateOffsets[k]  = ((Integer)args[1]).intValue();
                    }
                    
                }
            }
        }
        //System.err.println("CFF: done");
    }
    
    // ADDED BY Oren & Ygal
    
    void ReadEncoding(int nextIndexOffset){
    	seek(nextIndexOffset);
    	// ssteward omit: int format = getCard8();
    }    
} /*
 * $Id: CFFFontSubset.java,v 1.3 2005/02/17 09:20:54 blowagie Exp $
 * $Name:  $
 *
 * Copyright 2004 Oren Manor and Ygal Blum
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999-2005 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000-2005 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */
package pdftk.com.lowagie.text.pdf;

import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.ArrayList;
import java.io.*;

/**
 * This Class subsets a CFF Type Font. The subset is preformed for CID fonts and NON CID fonts.
 * The Charstring is subseted for both types. For CID fonts only the FDArray which are used are embedded. 
 * The Lsubroutines of the FDArrays used are subsetted as well. The Subroutine subset supports both Type1 and Type2
 * formatting altough only tested on Type2 Format.
 * For Non CID the Lsubroutines are subsetted. On both types the Gsubroutines is subsetted. 
 * A font which was not of CID type is transformed into CID as a part of the subset process. 
 * The CID synthetic creation was written by Sivan Toledo <sivan@math.tau.ac.il> 
 * @author Oren Manor <manorore@post.tau.ac.il> & Ygal Blum <blumygal@post.tau.ac.il>
 */
public class CFFFontSubset extends CFFFont {
	
	/**
	 *  The Strings in this array represent Type1/Type2 operator names
	 */
	static final String SubrsFunctions[] = {
			"RESERVED_0","hstem","RESERVED_2","vstem","vmoveto","rlineto","hlineto","vlineto",
			"rrcurveto","RESERVED_9","callsubr","return","escape","RESERVED_13",
			"endchar","RESERVED_15","RESERVED_16","RESERVED_17","hstemhm","hintmask",
			"cntrmask","rmoveto","hmoveto","vstemhm","rcurveline","rlinecurve","vvcurveto",
			"hhcurveto","shortint","callgsubr","vhcurveto","hvcurveto"
			};
	/**
	 * The Strings in this array represent Type1/Type2 escape operator names
	 */
	static final String SubrsEscapeFuncs[] = {
			"RESERVED_0","RESERVED_1","RESERVED_2","and","or","not","RESERVED_6",
			"RESERVED_7","RESERVED_8","abs","add","sub","div","RESERVED_13","neg",
			"eq","RESERVED_16","RESERVED_17","drop","RESERVED_19","put","get","ifelse",
			"random","mul","RESERVED_25","sqrt","dup","exch","index","roll","RESERVED_31",
			"RESERVED_32","RESERVED_33","hflex","flex","hflex1","flex1","RESERVED_REST"
	};
	
	/**
	 * A HashMap containing the glyphs used in the text after being converted
	 * to glyph number by the CMap 
	 */
	HashMap GlyphsUsed = null;
	/**
	 * The GlyphsUsed keys as an ArrayList
	 */
	ArrayList glyphsInList = null;
	/**
	 * A HashMap for keeping the FDArrays being used by the font
	 */
	HashMap FDArrayUsed = new HashMap();
	/**
	 * A HashMaps array for keeping the subroutines used in each FontDict
	 */
	HashMap[] hSubrsUsed = null;
	/**
	 * The SubroutinesUsed HashMaps as ArrayLists
	 */
	ArrayList[] lSubrsUsed = null;
	/**
	 * A HashMap for keeping the Global subroutines used in the font
	 */
	HashMap hGSubrsUsed  = new HashMap();
	/**
	 * The Global SubroutinesUsed HashMaps as ArrayLists
	 */
	ArrayList lGSubrsUsed = new ArrayList();
	/**
	 * A HashMap for keeping the subroutines used in a non-cid font
	 */
	HashMap hSubrsUsedNonCID  = new HashMap();
	/**
	 * The SubroutinesUsed HashMap as ArrayList
	 */
	ArrayList lSubrsUsedNonCID = new ArrayList();
	/**
	 * An array of the new Indexs for the local Subr. One index for each FontDict
	 */
	byte[][] NewLSubrsIndex = null;
	/**
	 * The new subroutines index for a non-cid font
	 */
	byte[] NewSubrsIndexNonCID = null;
	/**
	 * The new global subroutines index of the font
	 */
	byte[] NewGSubrsIndex = null;
	/**
	 * The new CharString of the font
	 */
	byte[] NewCharStringsIndex = null;
	
	/**
	 * The bias for the global subroutines
	 */
	int GBias = 0;
	
	/**
	 * The linked list for generating the new font stream
	 */
	LinkedList OutputList = null;
	
	/**
	 * Number of arguments to the stem operators in a subroutine calculated recursivly
	 */
	int NumOfHints = 0;

	
	/**	 
	 * C'tor for CFFFontSubset
	 * @param rf - The font file
	 * @param GlyphsUsed - a HashMap that contains the glyph used in the subset 
	 */
    public CFFFontSubset(RandomAccessFileOrArray rf,HashMap GlyphsUsed){
		// Use CFFFont c'tor in order to parse the font file.
    	super(rf);
		this.GlyphsUsed = GlyphsUsed;
		//Put the glyphs into a list
		glyphsInList = new ArrayList(GlyphsUsed.keySet());
		
		
		for (int i=0;i<fonts.length;++i)
		{
			// Read the number of glyphs in the font
			seek(fonts[i].charstringsOffset);
	        fonts[i].nglyphs = getCard16();
	        
	    	// Jump to the count field of the String Index
	        seek(stringIndexOffset);
	        fonts[i].nstrings = getCard16()+standardStrings.length;
	        
	        // For each font save the offset array of the charstring
			fonts[i].charstringsOffsets = getIndex(fonts[i].charstringsOffset);
			
			// Proces the FDSelect if exist 
			if (fonts[i].fdselectOffset>=0)
			{
				// Proces the FDSelect
	            readFDSelect(i);
	            // Build the FDArrayUsed hashmap
            	BuildFDArrayUsed(i);
			}
			if (fonts[i].isCID)
				// Build the FD Array used Hash Map
				ReadFDArray(i);
			// compute the charset length 
			fonts[i].CharsetLength = CountCharset(fonts[i].charsetOffset,fonts[i].nglyphs);
		}
	}

    /**
     * Calculates the length of the charset according to its format
     * @param Offset The Charset Offset
     * @param NumofGlyphs Number of glyphs in the font
     * @return the length of the Charset
     */
    int CountCharset(int Offset,int NumofGlyphs){
    	int format;
    	int Length=0;
    	seek(Offset);
    	// Read the format
    	format = getCard8();
    	// Calc according to format
    	switch (format){
    		case 0:
    			Length = 1+2*NumofGlyphs;
    			break;
    		case 1:
    			Length = 1+3*CountRange(NumofGlyphs,1);
    			break;
    		case 2:
    			Length = 1+4*CountRange(NumofGlyphs,2);
    			break;
    		default:
    			break;
    	}
    	return Length;
    }
    
    /**
     * Function calculates the number of ranges in the Charset
     * @param NumofGlyphs The number of glyphs in the font
     * @param Type The format of the Charset
     * @return The number of ranges in the Charset data structure
     */
    int CountRange(int NumofGlyphs,int Type){
    	int num=0;
    	// ssteward: int i=1,Sid,nLeft;
    	int i=1,nLeft;
    	while (i<NumofGlyphs){
    		num++;
    		// ssteward omit: Sid = getCard16();
    		if (Type==1)
    			nLeft = getCard8();
    		else
    			nLeft = getCard16();
    		i += nLeft+1;
    	}
    	return num;
    }


	/**
	 * Read the FDSelect of the font and compute the array and its length
	 * @param Font The index of the font being processed
	 * @return The Processed FDSelect of the font
	 */
	protected void readFDSelect(int Font)
	{
		// Restore the number of glyphs
		int NumOfGlyphs = fonts[Font].nglyphs;
		int[] FDSelect = new int[NumOfGlyphs];
		// Go to the beginning of the FDSelect
		seek(fonts[Font].fdselectOffset);
		// Read the FDSelect's format
		fonts[Font].FDSelectFormat = getCard8();
		
		switch(fonts[Font].FDSelectFormat){
			// Format==0 means each glyph has an entry that indicated
			// its FD.
			case 0:
				for (int i=0;i<NumOfGlyphs;i++)
				{
					FDSelect[i] = getCard8();
				}
				// The FDSelect's Length is one for each glyph + the format
				// for later use
				fonts[Font].FDSelectLength = fonts[Font].nglyphs+1;
				break;
			case 3:
				// Format==3 means the ranges version
				// The number of ranges
				int nRanges = getCard16();
				int l=0;
				// Read the first in the first range
				int first = getCard16();
				for (int i=0;i<nRanges;i++)
				{
					// Read the FD index
					int fd = getCard8();
					// Read the first of the next range
					int last = getCard16();
					// Calc the steps and write to the array
					int steps = last-first;
					for (int k=0;k<steps;k++)
					{
						FDSelect[l] = fd;
						l++;
					}
					// The last from this iteration is the first of the next
					first = last;
				}
				// Store the length for later use
				fonts[Font].FDSelectLength = 1+2+nRanges*3+2;
				break;
			default:
				break;
		}
		// Save the FDSelect of the font 
		fonts[Font].FDSelect = FDSelect; 
	}
	
	/**
	 * Function reads the FDSelect and builds the FDArrayUsed HashMap According to the glyphs used
	 * @param Font the Number of font being processed
	 */
	protected void BuildFDArrayUsed(int Font)
	{
		int[] FDSelect = fonts[Font].FDSelect;
		// For each glyph used
		for (int i=0;i<glyphsInList.size();i++)
		{
			// Pop the glyphs index
			int glyph = ((Integer)glyphsInList.get(i)).intValue();
			// Pop the glyph's FD
			int FD = FDSelect[glyph];
			// Put the FD index into the FDArrayUsed HashMap
			FDArrayUsed.put(new Integer(FD),null);
		}
	}

	/**
	 * Read the FDArray count, offsize and Offset array
	 * @param Font
	 */
	protected void ReadFDArray(int Font)
	{
		seek(fonts[Font].fdarrayOffset);
		fonts[Font].FDArrayCount = getCard16();
		fonts[Font].FDArrayOffsize = getCard8();
		// Since we will change values inside the FDArray objects
		// We increase its offsize to prevent errors 
		if (fonts[Font].FDArrayOffsize < 4)
			fonts[Font].FDArrayOffsize++;
		fonts[Font].FDArrayOffsets = getIndex(fonts[Font].fdarrayOffset);
	}

    
	/**
	 * The Process function extracts one font out of the CFF file and returns a
	 * subset version of the original.
	 * @param fontName - The name of the font to be taken out of the CFF
	 * @return The new font stream
	 * @throws IOException
	 */
	public byte[] Process(String fontName)throws IOException{
		try
		{	
			// Verify that the file is open
			buf.reOpen();
			// Find the Font that we will be dealing with
			int j;
	        for (j=0; j<fonts.length; j++)
	            if (fontName.equals(fonts[j].name)) break;
	        if (j==fonts.length) return null;
	        
			// Calc the bias for the global subrs
			if (gsubrIndexOffset >= 0)
				GBias = CalcBias(gsubrIndexOffset,j);

	        // Prepare the new CharStrings Index
			BuildNewCharString(j);
			 // Prepare the new Global and Local Subrs Indices
			BuildNewLGSubrs(j);
			// Build the new file 
			byte[] Ret = BuildNewFile(j);
			return Ret;
		}
		finally {
            try {
                buf.close();
            }
            catch (Exception e) {
                // empty on purpose
            }
		}
	}

	/**
	 * Function calcs bias according to the CharString type and the count
	 * of the subrs
	 * @param Offset The offset to the relevent subrs index
	 * @param Font the font
	 * @return The calculated Bias
	 */
	protected int CalcBias(int Offset,int Font)
	{
		seek(Offset);
		int nSubrs = getCard16();
		// If type==1 -> bias=0 
		if (fonts[Font].CharstringType == 1)
			return 0;
		// else calc according to the count
		else if (nSubrs < 1240)
			return 107;
		else if (nSubrs < 33900)
			return 1131;
		else
			return 32768;
	}

	/**
	 *Function uses BuildNewIndex to create the new index of the subset charstrings
	 * @param FontIndex the font
	 * @throws IOException
	 */
	protected void BuildNewCharString(int FontIndex) throws IOException 
	{
		NewCharStringsIndex = BuildNewIndex(fonts[FontIndex].charstringsOffsets,GlyphsUsed);
	}
	
	/**
	 * Function builds the new local & global subsrs indices. IF CID then All of 
	 * the FD Array lsubrs will be subsetted. 
	 * @param Font the font
	 * @throws IOException
	 */
	protected void BuildNewLGSubrs(int Font)throws IOException
	{
		// If the font is CID then the lsubrs are divided into FontDicts.
		// for each FD array the lsubrs will be subsetted.
		if(fonts[Font].isCID)
		{
			// Init the hasmap-array and the arraylist-array to hold the subrs used
			// in each private dict.
			hSubrsUsed = new HashMap[fonts[Font].fdprivateOffsets.length];
			lSubrsUsed = new ArrayList[fonts[Font].fdprivateOffsets.length];
			// A [][] which will store the byte array for each new FD Array lsubs index
			NewLSubrsIndex = new byte[fonts[Font].fdprivateOffsets.length][];
			// An array to hold the offset for each Lsubr index 
			fonts[Font].PrivateSubrsOffset = new int[fonts[Font].fdprivateOffsets.length];
			// A [][] which will store the offset array for each lsubr index			
			fonts[Font].PrivateSubrsOffsetsArray = new int[fonts[Font].fdprivateOffsets.length][];
			
			// Put the FDarrayUsed into a list
			ArrayList FDInList = new ArrayList(FDArrayUsed.keySet());
			// For each FD array which is used subset the lsubr 
			for (int j=0;j<FDInList.size();j++)
			{
				// The FDArray index, Hash Map, Arrat List to work on
				int FD = ((Integer)FDInList.get(j)).intValue();
				hSubrsUsed[FD] = new HashMap();
				lSubrsUsed[FD] = new ArrayList();
				//Reads the private dicts looking for the subr operator and 
				// store both the offest for the index and its offset array
				BuildFDSubrsOffsets(Font,FD);
				// Verify that FDPrivate has a LSubrs index
				if(fonts[Font].PrivateSubrsOffset[FD]>=0)
				{
					//Scans the Charsting data storing the used Local and Global subroutines 
					// by the glyphs. Scans the Subrs recursivley. 
					BuildSubrUsed(Font,FD,fonts[Font].PrivateSubrsOffset[FD],fonts[Font].PrivateSubrsOffsetsArray[FD],hSubrsUsed[FD],lSubrsUsed[FD]);
					// Builds the New Local Subrs index
					NewLSubrsIndex[FD] = BuildNewIndex(fonts[Font].PrivateSubrsOffsetsArray[FD],hSubrsUsed[FD]);
				}
			}
		}
		// If the font is not CID && the Private Subr exists then subset:
		else if (fonts[Font].privateSubrs>=0)
		{
			// Build the subrs offsets;
			fonts[Font].SubrsOffsets = getIndex(fonts[Font].privateSubrs);
			//Scans the Charsting data storing the used Local and Global subroutines 
			// by the glyphs. Scans the Subrs recursivley.
			BuildSubrUsed(Font,-1,fonts[Font].privateSubrs,fonts[Font].SubrsOffsets,hSubrsUsedNonCID,lSubrsUsedNonCID);
		}
		// For all fonts susbset the Global Subroutines
		// Scan the Global Subr Hashmap recursivly on the Gsubrs
		BuildGSubrsUsed(Font);
		if (fonts[Font].privateSubrs>=0)
			// Builds the New Local Subrs index
			NewSubrsIndexNonCID = BuildNewIndex(fonts[Font].SubrsOffsets,hSubrsUsedNonCID);
		//Builds the New Global Subrs index
		NewGSubrsIndex = BuildNewIndex(gsubrOffsets,hGSubrsUsed);
	}

	/**
	 * The function finds for the FD array processed the local subr offset and its 
	 * offset array.  
	 * @param Font the font
	 * @param FD The FDARRAY processed
	 */
	protected void BuildFDSubrsOffsets(int Font,int FD)
	{
		// Initiate to -1 to indicate lsubr operator present
		fonts[Font].PrivateSubrsOffset[FD] = -1;
		// Goto begining of objects
        seek(fonts[Font].fdprivateOffsets[FD]);
        // While in the same object:
        while (getPosition() < fonts[Font].fdprivateOffsets[FD]+fonts[Font].fdprivateLengths[FD])
        {
        	getDictItem();
        	// If the dictItem is the "Subrs" then find and store offset, 
        	if (key=="Subrs")
        		fonts[Font].PrivateSubrsOffset[FD] = ((Integer)args[0]).intValue()+fonts[Font].fdprivateOffsets[FD];
        }
        //Read the lsub index if the lsubr was found
        if (fonts[Font].PrivateSubrsOffset[FD] >= 0)
        	fonts[Font].PrivateSubrsOffsetsArray[FD] = getIndex(fonts[Font].PrivateSubrsOffset[FD]); 
	}

	/**
	 * Function uses ReadAsubr on the glyph used to build the LSubr & Gsubr HashMap.
	 * The HashMap (of the lsub only) is then scaned recursivly for Lsubr & Gsubrs
	 * calls.  
	 * @param Font the font
	 * @param FD FD array processed. 0 indicates function was called by non CID font
	 * @param SubrOffset the offset to the subr index to calc the bias
	 * @param SubrsOffsets the offset array of the subr index
	 * @param hSubr HashMap of the subrs used
	 * @param lSubr ArrayList of the subrs used
	 */
	protected void BuildSubrUsed(int Font,int FD,int SubrOffset,int[] SubrsOffsets,HashMap hSubr,ArrayList lSubr)
	{

		// Calc the Bias for the subr index
		int LBias = CalcBias(SubrOffset,Font);
		
		// For each glyph used find its GID, start & end pos
		for (int i=0;i<glyphsInList.size();i++)
		{
			int glyph = ((Integer)glyphsInList.get(i)).intValue();
			int Start = fonts[Font].charstringsOffsets[glyph];
			int End = fonts[Font].charstringsOffsets[glyph+1];
			
			// IF CID:
			if (FD >= 0)
			{
				EmptyStack();
				NumOfHints=0;
				// Using FDSELECT find the FD Array the glyph belongs to.
				int GlyphFD = fonts[Font].FDSelect[glyph];
				// If the Glyph is part of the FD being processed 
				if (GlyphFD == FD)
					// Find the Subrs called by the glyph and insert to hash:
					ReadASubr(Start,End,GBias,LBias,hSubr,lSubr,SubrsOffsets);
			}
			else
				// If the font is not CID 
				//Find the Subrs called by the glyph and insert to hash:
				ReadASubr(Start,End,GBias,LBias,hSubr,lSubr,SubrsOffsets);
		}
		// For all Lsubrs used, check recusrivly for Lsubr & Gsubr used
		for (int i=0;i<lSubr.size();i++)
		{
			// Pop the subr value from the hash
			int Subr = ((Integer)lSubr.get(i)).intValue();
			// Ensure the Lsubr call is valid
			if (Subr < SubrsOffsets.length-1 && Subr>=0)
			{
				// Read and process the subr
				int Start = SubrsOffsets[Subr];
				int End = SubrsOffsets[Subr+1];
				ReadASubr(Start,End,GBias,LBias,hSubr,lSubr,SubrsOffsets);
			}
		}
	}
	
	/**
	 * Function scans the Glsubr used ArrayList to find recursive calls 
	 * to Gsubrs and adds to Hashmap & ArrayList
	 * @param Font the font
	 */
	protected void BuildGSubrsUsed(int Font)
	{
		int LBias = 0;
		int SizeOfNonCIDSubrsUsed = 0;
		if (fonts[Font].privateSubrs>=0)
		{
			LBias = CalcBias(fonts[Font].privateSubrs,Font);
			SizeOfNonCIDSubrsUsed = lSubrsUsedNonCID.size();
		}
		
		// For each global subr used 
		for (int i=0;i<lGSubrsUsed.size();i++)
		{
			//Pop the value + check valid 
			int Subr = ((Integer)lGSubrsUsed.get(i)).intValue();
			if (Subr < gsubrOffsets.length-1 && Subr>=0)
			{
				// Read the subr and process
				int Start = gsubrOffsets[Subr];
				int End = gsubrOffsets[Subr+1];
				
				if (fonts[Font].isCID)
					ReadASubr(Start,End,GBias,0,hGSubrsUsed,lGSubrsUsed,null);
				else
				{
					ReadASubr(Start,End,GBias,LBias,hSubrsUsedNonCID,lSubrsUsedNonCID,fonts[Font].SubrsOffsets);
					if (SizeOfNonCIDSubrsUsed < lSubrsUsedNonCID.size())
					{
						for (int j=SizeOfNonCIDSubrsUsed;j<lSubrsUsedNonCID.size();j++)
						{
							//Pop the value + check valid 
							int LSubr = ((Integer)lSubrsUsedNonCID.get(j)).intValue();
							if (LSubr < fonts[Font].SubrsOffsets.length-1 && LSubr>=0)
							{
								// Read the subr and process
								int LStart = fonts[Font].SubrsOffsets[LSubr];
								int LEnd = fonts[Font].SubrsOffsets[LSubr+1];
								ReadASubr(LStart,LEnd,GBias,LBias,hSubrsUsedNonCID,lSubrsUsedNonCID,fonts[Font].SubrsOffsets);
							}
						}
						SizeOfNonCIDSubrsUsed = lSubrsUsedNonCID.size();
					}
				}
			}
		}
	}

	/**
	 * The function reads a subrs (glyph info) between begin and end.
	 * Adds calls to a Lsubr to the hSubr and lSubrs.
	 * Adds calls to a Gsubr to the hGSubr and lGSubrs.
	 * @param begin the start point of the subr
	 * @param end the end point of the subr
	 * @param GBias the bias of the Global Subrs
	 * @param LBias the bias of the Local Subrs
	 * @param hSubr the HashMap for the lSubrs
	 * @param lSubr the ArrayList for the lSubrs
	 */
	protected void ReadASubr(int begin,int end,int GBias,int LBias,HashMap hSubr,ArrayList lSubr,int[] LSubrsOffsets)
	{
		// Clear the stack for the subrs
		EmptyStack();
		NumOfHints = 0;
		// Goto begining of the subr
        seek(begin);
        while (getPosition() < end)
        {
        	// Read the next command
        	ReadCommand();
        	int pos = getPosition();
        	Object TopElement=null;
        	if (arg_count > 0)
        		TopElement = args[arg_count-1];
        	int NumOfArgs = arg_count;
        	// Check the modification needed on the Argument Stack according to key;
        	HandelStack();
        	// a call to a Lsubr
        	if (key=="callsubr") 
        	{
        		// Verify that arguments are passed 
        		if (NumOfArgs > 0)
        		{
            		// Calc the index of the Subrs
            		int Subr = ((Integer)TopElement).intValue() + LBias;
            		// If the subr isn't in the HashMap -> Put in
        			if (!hSubr.containsKey(new Integer (Subr)))
            		{
            			hSubr.put(new Integer(Subr),null);
            			lSubr.add(new Integer(Subr));
            		}
        			CalcHints(LSubrsOffsets[Subr],LSubrsOffsets[Subr+1],LBias,GBias,LSubrsOffsets);
        			seek(pos);
        		}        		
        	}
        	// a call to a Gsubr
        	else if (key=="callgsubr")
        	{
        		// Verify that arguments are passed 
        		if (NumOfArgs > 0)
        		{
	        		// Calc the index of the Subrs
	        		int Subr = ((Integer)TopElement).intValue() + GBias;
	        		// If the subr isn't in the HashMap -> Put in
	        		if (!hGSubrsUsed.containsKey(new Integer (Subr)))
	        		{
	        			hGSubrsUsed.put(new Integer(Subr),null);
	        			lGSubrsUsed.add(new Integer(Subr));
	        		}
	        		CalcHints(gsubrOffsets[Subr],gsubrOffsets[Subr+1],LBias,GBias,LSubrsOffsets);
	        		seek(pos);
        		}
        	}
        	// A call to "stem"
        	else if (key == "hstem" || key == "vstem" || key == "hstemhm" || key == "vstemhm")
        		// Increment the NumOfHints by the number couples of of arguments
        		NumOfHints += NumOfArgs/2;
        	// A call to "mask"
        	else if (key == "hintmask" || key == "cntrmask")
        	{
        		// Compute the size of the mask
        		int SizeOfMask = NumOfHints/8;
        		if (NumOfHints%8 != 0 || SizeOfMask == 0)
        			SizeOfMask++;
        		// Continue the pointer in SizeOfMask steps
        		for (int i=0;i<SizeOfMask;i++)
        			getCard8();
        	}
        }
	}

	/**
	 * Function Checks how the current operator effects the run time stack after being run 
	 * An operator may increase or decrease the stack size
	 */
	protected void HandelStack()
	{
    	// Findout what the operator does to the stack
    	int StackHandel = StackOpp();
    	if (StackHandel < 2)
    	{
    		// The operators that enlarge the stack by one
    		if (StackHandel==1)
    			PushStack();
    		// The operators that pop the stack
    		else
    		{
    			// Abs value for the for loop
    			StackHandel *= -1;
    			for (int i=0;i<StackHandel;i++)
    				PopStack();
    		}
    		
    	}
    	// All other flush the stack
    	else
    		EmptyStack();		
	}
	
	/**
	 * Function checks the key and return the change to the stack after the operator
	 * @return The change in the stack. 2-> flush the stack
	 */
	protected int StackOpp()
	{
		if (key == "ifelse")
			return -3;
		if (key == "roll" || key == "put")
			return -2;
		if (key == "callsubr" || key == "callgsubr" || key == "add" || key == "sub" ||
			key == "div" || key == "mul" || key == "drop" || key == "and" || 
			key == "or" || key == "eq")
			return -1;
		if (key == "abs" || key == "neg" || key == "sqrt" || key == "exch" || 
			key == "index" || key == "get" || key == "not" || key == "return")
			return 0;
		if (key == "random" || key == "dup")
			return 1;
		return 2;
	}
	
	/**
	 * Empty the Type2 Stack
	 *
	 */
	protected void EmptyStack()
	{
		// Null the arguments
    	for (int i=0; i<arg_count; i++) args[i]=null;
        arg_count = 0;		
	}
	
	/**
	 * Pop one element from the stack 
	 *
	 */
	protected void PopStack()
	{
		if (arg_count>0)
		{
			args[arg_count-1]=null;
			arg_count--;
		}
	}
	
	/**
	 * Add an item to the stack
	 *
	 */
	protected void PushStack()
	{
		arg_count++;
	}
	
	/**
	 * The function reads the next command after the file pointer is set
	 */
	protected void ReadCommand()
	{
        key = null;
        boolean gotKey = false;
        // Until a key is found
        while (!gotKey) {
        	// Read the first Char
            char b0 = getCard8();
            // decode according to the type1/type2 format
            if (b0 == 28) // the two next bytes represent a short int;
            {
            	int first = getCard8();
            	int second = getCard8();
            	args[arg_count] = new Integer(first<<8 | second);
            	arg_count++;
            	continue;
            }
            if (b0 >= 32 && b0 <= 246) // The byte read is the byte;
            {
            	args[arg_count] = new Integer(b0 - 139);
            	arg_count++;
            	continue;
            }
            if (b0 >= 247 && b0 <= 250) // The byte read and the next byte constetute a short int
            {
            	int w = getCard8();
            	args[arg_count] = new Integer((b0-247)*256 + w + 108);
            	arg_count++;
            	continue;
            }
            if (b0 >= 251 && b0 <= 254)// Same as above except negative
            {
            	int w = getCard8();
            	args[arg_count] = new Integer(-(b0-251)*256 - w - 108);
            	arg_count++;
            	continue;
            }
            if (b0 == 255)// The next for bytes represent a double.
            {
            	int first = getCard8();
            	int second = getCard8();
            	int third = getCard8();
            	int fourth = getCard8();
            	args[arg_count] = new Integer(first<<24 | second<<16 | third<<8 | fourth);
            	arg_count++;
            	continue;
            }
            if (b0<=31 && b0 != 28) // An operator was found.. Set Key.
            {
            	gotKey=true;
            	// 12 is an escape command therefor the next byte is a part
            	// of this command
            	if (b0 == 12)
            	{
            		int b1 = getCard8();
            		if (b1>SubrsEscapeFuncs.length-1)
            			b1 = SubrsEscapeFuncs.length-1;
            		key = SubrsEscapeFuncs[b1];
            	}
            	else
            		key = SubrsFunctions[b0];
                continue;
            }
        }		
	}
	
	/**
	 * The function reads the subroutine and returns the number of the hint in it.
	 * If a call to another subroutine is found the function calls recursively.
	 * @param begin the start point of the subr
	 * @param end the end point of the subr
	 * @param LBias the bias of the Local Subrs
	 * @param GBias the bias of the Global Subrs
	 * @param LSubrsOffsets The Offsets array of the subroutines
	 * @return The number of hints in the subroutine read.
	 */
	protected int CalcHints(int begin,int end,int LBias,int GBias,int[] LSubrsOffsets)
	{
		// Goto begining of the subr
        seek(begin);
        while (getPosition() < end)
        {
        	// Read the next command
        	ReadCommand();
        	int pos = getPosition();
        	Object TopElement = null;
        	if (arg_count>0)
        		TopElement = args[arg_count-1];
        	int NumOfArgs = arg_count;
            //Check the modification needed on the Argument Stack according to key;
        	HandelStack();
        	// a call to a Lsubr
        	if (key=="callsubr") 
        	{
        		if (NumOfArgs>0)
        		{
            		int Subr = ((Integer)TopElement).intValue() + LBias;
            		CalcHints(LSubrsOffsets[Subr],LSubrsOffsets[Subr+1],LBias,GBias,LSubrsOffsets);
            		seek(pos);        			
        		}
        	}
        	// a call to a Gsubr
        	else if (key=="callgsubr")
        	{
        		if (NumOfArgs>0)
        		{
            		int Subr = ((Integer)TopElement).intValue() + GBias;
            		CalcHints(gsubrOffsets[Subr],gsubrOffsets[Subr+1],LBias,GBias,LSubrsOffsets);
            		seek(pos);        			
        		}
        	}
        	// A call to "stem"
        	else if (key == "hstem" || key == "vstem" || key == "hstemhm" || key == "vstemhm")
        		// Increment the NumOfHints by the number couples of of arguments
        		NumOfHints += NumOfArgs/2;
        	// A call to "mask"
        	else if (key == "hintmask" || key == "cntrmask")
        	{
        		// Compute the size of the mask
        		int SizeOfMask = NumOfHints/8;
        		if (NumOfHints%8 != 0 || SizeOfMask == 0)
        			SizeOfMask++;
        		// Continue the pointer in SizeOfMask steps
        		for (int i=0;i<SizeOfMask;i++)
        			getCard8();
        	}
        }
        return NumOfHints;
	}


	/**
	 * Function builds the new offset array, object array and assembles the index.
	 * used for creating the glyph and subrs subsetted index 
	 * @param Offsets the offset array of the original index  
	 * @param Used the hashmap of the used objects
	 * @return the new index subset version 
	 * @throws IOException
	 */
	protected byte[] BuildNewIndex(int[] Offsets,HashMap Used) throws IOException 
	{
		int Offset=0;
		int[] NewOffsets = new int[Offsets.length];
		// Build the Offsets Array for the Subset
		for (int i=0;i<Offsets.length;++i)
		{
			NewOffsets[i] = Offset;
			// If the object in the offset is also present in the used
			// HashMap then increment the offset var by its size
			if (Used.containsKey(new Integer(i)))
				Offset += Offsets[i+1] - Offsets[i];
				// Else the same offset is kept in i+1.
		}
		// Offset var determines the size of the object array
		byte[] NewObjects = new byte[Offset];
		// Build the new Object array
		for (int i=0;i<Offsets.length-1;++i)
		{
			int start = NewOffsets[i];
			int end = NewOffsets[i+1];
			// If start != End then the Object is used
			// So, we will copy the object data from the font file
			if (start != end)
			{
				// All offsets are Global Offsets relative to the begining of the font file.
				// Jump the file pointer to the start address to read from.
				buf.seek(Offsets[i]);
				// Read from the buffer and write into the array at start.  
                buf.readFully(NewObjects, start, end-start);
			}
		}
		// Use AssembleIndex to build the index from the offset & object arrays
		return AssembleIndex(NewOffsets,NewObjects);
	}

	/**
	 * Function creates the new index, inserting the count,offsetsize,offset array
	 * and object array.
	 * @param NewOffsets the subsetted offset array
	 * @param NewObjects the subsetted object array
	 * @return the new index created
	 */
	protected byte[] AssembleIndex(int[] NewOffsets,byte[] NewObjects)
	{
		// Calc the index' count field
		char Count = (char)(NewOffsets.length-1);
		// Calc the size of the object array
		int Size = NewOffsets[NewOffsets.length-1];
		// Calc the Offsize
		byte Offsize;
        if (Size <= 0xff) Offsize = 1;
        else if (Size <= 0xffff) Offsize = 2;
        else if (Size <= 0xffffff) Offsize = 3;
        else Offsize = 4;
        // The byte array for the new index. The size is calc by
        // Count=2, Offsize=1, OffsetArray = Offsize*(Count+1), The object array
        byte[] NewIndex = new byte[2+1+Offsize*(Count+1)+NewObjects.length];
        // The counter for writing
        int Place = 0;
        // Write the count field
        NewIndex[Place++] = (byte) ((Count >>> 8) & 0xff);
        NewIndex[Place++] = (byte) ((Count >>> 0) & 0xff);
        // Write the offsize field
        NewIndex[Place++] = Offsize;
        // Write the offset array according to the offsize
        for (int i=0;i<NewOffsets.length;i++)
        {
        	// The value to be written
        	int Num = NewOffsets[i]-NewOffsets[0]+1;
        	// Write in bytes according to the offsize
        	switch (Offsize) {
                case 4:
                	NewIndex[Place++] = (byte) ((Num >>> 24) & 0xff);
                case 3:
                	NewIndex[Place++] = (byte) ((Num >>> 16) & 0xff);
                case 2:
                	NewIndex[Place++] = (byte) ((Num >>>  8) & 0xff);
                case 1:
                	NewIndex[Place++] = (byte) ((Num >>>  0) & 0xff);
        	}                	
        }
        // Write the new object array one by one
        for (int i=0;i<NewObjects.length;i++)
        {
        	NewIndex[Place++] = NewObjects[i];
        }
        // Return the new index
        return NewIndex;
	}
	
	/**
	 * The function builds the new output stream according to the subset process
	 * @param Font the font
	 * @return the subseted font stream
	 * @throws IOException
	 */
	protected byte[] BuildNewFile(int Font)throws IOException
    {
		// Prepare linked list for new font components
		OutputList = new LinkedList();

        // copy the header of the font
        CopyHeader();
                
        // create a name index
        BuildIndexHeader(1,1,1);
        OutputList.addLast(new UInt8Item((char)( 1+fonts[Font].name.length() )));
        OutputList.addLast(new StringItem(fonts[Font].name));
        
        // create the topdict Index
        BuildIndexHeader(1,2,1);
        OffsetItem topdictIndex1Ref = new IndexOffsetItem(2);
        OutputList.addLast(topdictIndex1Ref);
        IndexBaseItem topdictBase = new IndexBaseItem();
        OutputList.addLast(topdictBase);
                
        // Initialise the Dict Items for later use
        OffsetItem charsetRef     = new DictOffsetItem();
        OffsetItem charstringsRef = new DictOffsetItem();
        OffsetItem fdarrayRef     = new DictOffsetItem();
        OffsetItem fdselectRef    = new DictOffsetItem();
        OffsetItem privateRef     = new DictOffsetItem();
        
        // If the font is not CID create the following keys
        if ( !fonts[Font].isCID ) {
            // create a ROS key
        	OutputList.addLast(new DictNumberItem(fonts[Font].nstrings));
        	OutputList.addLast(new DictNumberItem(fonts[Font].nstrings+1));
        	OutputList.addLast(new DictNumberItem(0));
        	OutputList.addLast(new UInt8Item((char)12));
        	OutputList.addLast(new UInt8Item((char)30));
            // create a CIDCount key
        	OutputList.addLast(new DictNumberItem(fonts[Font].nglyphs));
        	OutputList.addLast(new UInt8Item((char)12));
            OutputList.addLast(new UInt8Item((char)34));
            // Sivan's comments
            // What about UIDBase (12,35)? Don't know what is it.
            // I don't think we need FontName; the font I looked at didn't have it.
        }
        // Go to the TopDict of the font being processed
        seek(topdictOffsets[Font]);
        // Run untill the end of the TopDict
        while (getPosition() < topdictOffsets[Font+1]) {
            int p1 = getPosition();
            getDictItem();
            int p2 = getPosition();
            // The encoding key is disregarded since CID has no encoding
            if (key=="Encoding"
            // These keys will be added manualy by the process.
            || key=="Private" 
            || key=="FDSelect"
            || key=="FDArray" 
            || key=="charset" 
            || key=="CharStrings"
            ) {
            }else {
            //OtherWise copy key "as is" to the output list
                OutputList.add(new RangeItem(buf,p1,p2-p1));
            }
        }
        // Create the FDArray, FDSelect, Charset and CharStrings Keys
        CreateKeys(fdarrayRef,fdselectRef,charsetRef,charstringsRef);
        
        // Mark the end of the top dict area
        OutputList.addLast(new IndexMarkerItem(topdictIndex1Ref,topdictBase));
        
        // Copy the string index

        if (fonts[Font].isCID) 
            OutputList.addLast(getEntireIndexRange(stringIndexOffset));
        // If the font is not CID we need to append new strings.
        // We need 3 more strings: Registry, Ordering, and a FontName for one FD.
        // The total length is at most "Adobe"+"Identity"+63 = 76
        else
        	CreateNewStringIndex(Font);
        
        // copy the new subsetted global subroutine index       
        OutputList.addLast(new RangeItem(new RandomAccessFileOrArray(NewGSubrsIndex),0,NewGSubrsIndex.length));
        
        // deal with fdarray, fdselect, and the font descriptors
        // If the font is CID:
        if (fonts[Font].isCID) {
            // copy the FDArray, FDSelect, charset
       
            // Copy FDSelect
        	// Mark the beginning
            OutputList.addLast(new MarkerItem(fdselectRef));
            // If an FDSelect exists copy it
            if (fonts[Font].fdselectOffset>=0)
        		OutputList.addLast(new RangeItem(buf,fonts[Font].fdselectOffset,fonts[Font].FDSelectLength));
            // Else create a new one
            else
            	CreateFDSelect(fdselectRef,fonts[Font].nglyphs);
            	           
          	// Copy the Charset
            // Mark the beginning and copy entirly 
            OutputList.addLast(new MarkerItem(charsetRef));
            OutputList.addLast(new RangeItem(buf,fonts[Font].charsetOffset,fonts[Font].CharsetLength));
            
            // Copy the FDArray
            // If an FDArray exists
            if (fonts[Font].fdarrayOffset>=0)
            {
                // Mark the beginning
	            OutputList.addLast(new MarkerItem(fdarrayRef));
	            // Build a new FDArray with its private dicts and their LSubrs
	            Reconstruct(Font);
            }
            else
            	// Else create a new one
            	CreateFDArray(fdarrayRef,privateRef,Font);
           
        }
        // If the font is not CID
        else 
        {
            // create FDSelect
        	CreateFDSelect(fdselectRef,fonts[Font].nglyphs);            
            // recreate a new charset
        	CreateCharset(charsetRef,fonts[Font].nglyphs);            
            // create a font dict index (fdarray)
        	CreateFDArray(fdarrayRef,privateRef,Font);            
        }
        
        // if a private dict exists insert its subsetted version
        if (fonts[Font].privateOffset>=0)
        {
        	// Mark the beginning of the private dict
        	IndexBaseItem PrivateBase = new IndexBaseItem();
	        OutputList.addLast(PrivateBase);
        	OutputList.addLast(new MarkerItem(privateRef));

        	OffsetItem Subr = new DictOffsetItem();
        	// Build and copy the new private dict
        	CreateNonCIDPrivate(Font,Subr);
        	// Copy the new LSubrs index
        	CreateNonCIDSubrs(Font,PrivateBase,Subr);
        }
        
        // copy the charstring index
        OutputList.addLast(new MarkerItem(charstringsRef));

        // Add the subsetted charstring
        OutputList.addLast(new RangeItem(new RandomAccessFileOrArray(NewCharStringsIndex),0,NewCharStringsIndex.length));
        
        // now create the new CFF font        
        int[] currentOffset = new int[1];
        currentOffset[0] = 0;
        // Count and save the offset for each item
        Iterator listIter = OutputList.iterator();
        while ( listIter.hasNext() ) {
            Item item = (Item) listIter.next();
            item.increment(currentOffset);
        }
        // Compute the Xref for each of the offset items
        listIter = OutputList.iterator();
        while ( listIter.hasNext() ) {
            Item item = (Item) listIter.next();
            item.xref();
        }
        
        int size = currentOffset[0];
        byte[] b = new byte[size];
        
        // Emit all the items into the new byte array
        listIter = OutputList.iterator();
        while ( listIter.hasNext() ) {
            Item item = (Item) listIter.next();
            item.emit(b);
        }
        // Return the new stream
        return b;
    }

	/**
	 * Function Copies the header from the original fileto the output list
	 */
	protected void CopyHeader()
	{
		seek(0);
        // ssteward omit: int major = getCard8();
        // ssteward omit: int minor = getCard8();
        int hdrSize = getCard8();
        // ssteward omit: int offSize = getCard8();
        nextIndexOffset = hdrSize;
        OutputList.addLast(new RangeItem(buf,0,hdrSize));
	}

	/**
	 * Function Build the header of an index
	 * @param Count the count field of the index
	 * @param Offsize the offsize field of the index
	 * @param First the first offset of the index
	 */
	protected void BuildIndexHeader(int Count,int Offsize,int First)
	{
		// Add the count field
		OutputList.addLast(new UInt16Item((char)Count)); // count
		// Add the offsize field
		OutputList.addLast(new UInt8Item((char)Offsize)); // offSize
		// Add the first offset according to the offsize
        switch(Offsize){
        	case 1:
        		OutputList.addLast(new UInt8Item((char)First)); // first offset
        		break;
        	case 2:
        		OutputList.addLast(new UInt16Item((char)First)); // first offset
        		break;
        	case 3:
        		OutputList.addLast(new UInt24Item((char)First)); // first offset
        		break;
        	case 4:
        		OutputList.addLast(new UInt32Item((char)First)); // first offset
        		break;
    		default:
    			break;	
        }
	}
	
	/**
	 * Function adds the keys into the TopDict
	 * @param fdarrayRef OffsetItem for the FDArray
	 * @param fdselectRef OffsetItem for the FDSelect
	 * @param charsetRef OffsetItem for the CharSet
	 * @param charstringsRef OffsetItem for the CharString
	 */
	protected void CreateKeys(OffsetItem fdarrayRef,OffsetItem fdselectRef,OffsetItem charsetRef,OffsetItem charstringsRef)
	{
	    // create an FDArray key
        OutputList.addLast(fdarrayRef);
        OutputList.addLast(new UInt8Item((char)12));
        OutputList.addLast(new UInt8Item((char)36));
        // create an FDSelect key
        OutputList.addLast(fdselectRef);
        OutputList.addLast(new UInt8Item((char)12));
        OutputList.addLast(new UInt8Item((char)37));
        // create an charset key
        OutputList.addLast(charsetRef);
        OutputList.addLast(new UInt8Item((char)15));
        // create a CharStrings key
        OutputList.addLast(charstringsRef);
        OutputList.addLast(new UInt8Item((char)17));
	}
	
	/**
	 * Function takes the original string item and adds the new strings
	 * to accomodate the CID rules
	 * @param Font the font
	 */
	protected void CreateNewStringIndex(int Font)
	{
        String fdFontName = fonts[Font].name+"-OneRange";
        if (fdFontName.length() > 127)
            fdFontName = fdFontName.substring(0,127);
        String extraStrings = "Adobe"+"Identity"+fdFontName;
        
        int origStringsLen = stringOffsets[stringOffsets.length-1]
        - stringOffsets[0];
        int stringsBaseOffset = stringOffsets[0]-1;
        
        byte stringsIndexOffSize;
        if (origStringsLen+extraStrings.length() <= 0xff) stringsIndexOffSize = 1;
        else if (origStringsLen+extraStrings.length() <= 0xffff) stringsIndexOffSize = 2;
        else if (origStringsLen+extraStrings.length() <= 0xffffff) stringsIndexOffSize = 3;
        else stringsIndexOffSize = 4;
        
        OutputList.addLast(new UInt16Item((char)((stringOffsets.length-1)+3))); // count
        OutputList.addLast(new UInt8Item((char)stringsIndexOffSize)); // offSize
        for (int i=0; i<stringOffsets.length; i++)
            OutputList.addLast(new IndexOffsetItem(stringsIndexOffSize,
            stringOffsets[i]-stringsBaseOffset));
        int currentStringsOffset = stringOffsets[stringOffsets.length-1]
        - stringsBaseOffset;
        //l.addLast(new IndexOffsetItem(stringsIndexOffSize,currentStringsOffset));
        currentStringsOffset += ("Adobe").length();
        OutputList.addLast(new IndexOffsetItem(stringsIndexOffSize,currentStringsOffset));
        currentStringsOffset += ("Identity").length();
        OutputList.addLast(new IndexOffsetItem(stringsIndexOffSize,currentStringsOffset));
        currentStringsOffset += fdFontName.length();
        OutputList.addLast(new IndexOffsetItem(stringsIndexOffSize,currentStringsOffset));
        
        OutputList.addLast(new RangeItem(buf,stringOffsets[0],origStringsLen));
        OutputList.addLast(new StringItem(extraStrings));
    }
     
	/**
	 * Function creates new FDSelect for non-CID fonts.
	 * The FDSelect built uses a single range for all glyphs
	 * @param fdselectRef OffsetItem for the FDSelect
	 * @param nglyphs the number of glyphs in the font
	 */
	protected void CreateFDSelect(OffsetItem fdselectRef,int nglyphs)
	{
		OutputList.addLast(new MarkerItem(fdselectRef));
	    OutputList.addLast(new UInt8Item((char)3)); // format identifier
	    OutputList.addLast(new UInt16Item((char)1)); // nRanges
	    
	    OutputList.addLast(new UInt16Item((char)0)); // Range[0].firstGlyph
	    OutputList.addLast(new UInt8Item((char)0)); // Range[0].fd
	    
	    OutputList.addLast(new UInt16Item((char)nglyphs)); // sentinel
	}

	/**
	 * Function creates new CharSet for non-CID fonts.
	 * The CharSet built uses a single range for all glyphs
	 * @param charsetRef OffsetItem for the CharSet
	 * @param nglyphs the number of glyphs in the font
	 */
	protected void CreateCharset(OffsetItem charsetRef,int nglyphs)
	{
		OutputList.addLast(new MarkerItem(charsetRef));
	    OutputList.addLast(new UInt8Item((char)2)); // format identifier
	    OutputList.addLast(new UInt16Item((char)1)); // first glyph in range (ignore .notdef)
	    OutputList.addLast(new UInt16Item((char)(nglyphs-1))); // nLeft
	}
    
	/**
	 * Function creates new FDArray for non-CID fonts.
	 * The FDArray built has only the "Private" operator that points to the font's
	 * original private dict 
	 * @param fdarrayRef OffsetItem for the FDArray
	 * @param privateRef OffsetItem for the Private Dict
	 * @param Font the font
	 */
	protected void CreateFDArray(OffsetItem fdarrayRef,OffsetItem privateRef,int Font)
	{
		OutputList.addLast(new MarkerItem(fdarrayRef));
		// Build the header (count=offsize=first=1)
		BuildIndexHeader(1,1,1);
	    
		// Mark
	    OffsetItem privateIndex1Ref = new IndexOffsetItem(1);
	    OutputList.addLast(privateIndex1Ref);
	    IndexBaseItem privateBase = new IndexBaseItem();
	    // Insert the private operands and operator
	    OutputList.addLast(privateBase);
	    // Calc the new size of the private after subsetting
	    // Origianl size
	    int NewSize = fonts[Font].privateLength;
	    // Calc the original size of the Subr offset in the private
		int OrgSubrsOffsetSize = CalcSubrOffsetSize(fonts[Font].privateOffset,fonts[Font].privateLength);
		// Increase the ptivate's size
		if (OrgSubrsOffsetSize != 0)
			NewSize += 5-OrgSubrsOffsetSize;
	    OutputList.addLast(new DictNumberItem(NewSize));
	    OutputList.addLast(privateRef);
	    OutputList.addLast(new UInt8Item((char)18)); // Private
	    
	    OutputList.addLast(new IndexMarkerItem(privateIndex1Ref,privateBase));
	}
    
	/**
	 * Function reconstructs the FDArray, PrivateDict and LSubr for CID fonts
	 * @param Font the font
	 * @throws IOException
	 */
	void Reconstruct(int Font)throws IOException
	{
		// Init for later use
		OffsetItem[] fdPrivate = new DictOffsetItem[fonts[Font].FDArrayOffsets.length-1];
		IndexBaseItem[] fdPrivateBase = new IndexBaseItem[fonts[Font].fdprivateOffsets.length]; 
		OffsetItem[] fdSubrs = new DictOffsetItem[fonts[Font].fdprivateOffsets.length];
		// Reconstruct each type
		ReconstructFDArray(Font,fdPrivate);
		ReconstructPrivateDict(Font,fdPrivate,fdPrivateBase,fdSubrs);
		ReconstructPrivateSubrs(Font,fdPrivateBase,fdSubrs);
	}

	/**
	 * Function subsets the FDArray and builds the new one with new offsets
	 * @param Font The font
	 * @param fdPrivate OffsetItem Array (one for each FDArray)
	 * @throws IOException
	 */
	void ReconstructFDArray(int Font,OffsetItem[] fdPrivate)throws IOException
	{
		// Build the header of the index
		BuildIndexHeader(fonts[Font].FDArrayCount,fonts[Font].FDArrayOffsize,1);

		// For each offset create an Offset Item
		OffsetItem[] fdOffsets = new IndexOffsetItem[fonts[Font].FDArrayOffsets.length-1];
		for (int i=0;i<fonts[Font].FDArrayOffsets.length-1;i++)
		{
			fdOffsets[i] = new IndexOffsetItem(fonts[Font].FDArrayOffsize);
			OutputList.addLast(fdOffsets[i]);
		}
		
		// Declare beginning of the object array
		IndexBaseItem fdArrayBase = new IndexBaseItem();
	    OutputList.addLast(fdArrayBase);
	    
		// For each object check if that FD is used.
	    // if is used build a new one by changing the private object
	    // Else do nothing
	    // At the end of each object mark its ending (Even if wasn't written)
		for (int k=0; k<fonts[Font].FDArrayOffsets.length-1; k++) {
			if (FDArrayUsed.containsKey(new Integer (k)))
			{
				// Goto begining of objects
	            seek(fonts[Font].FDArrayOffsets[k]);
	            while (getPosition() < fonts[Font].FDArrayOffsets[k+1])
	            {
	            	int p1 = getPosition();
	            	getDictItem();
	            	int p2 = getPosition();
	            	// If the dictItem is the "Private" then compute and copy length, 
	            	// use marker for offset and write operator number
	            	if (key=="Private") {
	            		// Save the original length of the private dict
	            		int NewSize = ((Integer)args[0]).intValue();
	            		// Save the size of the offset to the subrs in that private
	            		int OrgSubrsOffsetSize = CalcSubrOffsetSize(fonts[Font].fdprivateOffsets[k],fonts[Font].fdprivateLengths[k]);
	            		// Increase the private's length accordingly
	            		if (OrgSubrsOffsetSize != 0)
	            			NewSize += 5-OrgSubrsOffsetSize;
	            		// Insert the new size, OffsetItem and operator key number
	            		OutputList.addLast(new DictNumberItem(NewSize));
	            		fdPrivate[k] = new DictOffsetItem();
	            		OutputList.addLast(fdPrivate[k]);
	            	    OutputList.addLast(new UInt8Item((char)18)); // Private
	            	    // Go back to place 
	            	    seek(p2);
	            	}
	            	// Else copy the entire range
	            	else  // other than private
	            		OutputList.addLast(new RangeItem(buf,p1,p2-p1));
	            }
			}
            // Mark the ending of the object (even if wasn't written)
            OutputList.addLast(new IndexMarkerItem(fdOffsets[k],fdArrayBase));
        }
	}
	/**
	 * Function Adds the new private dicts (only for the FDs used) to the list
	 * @param Font the font
	 * @param fdPrivate OffsetItem array one element for each private
	 * @param fdPrivateBase IndexBaseItem array one element for each private
	 * @param fdSubrs OffsetItem array one element for each private
	 * @throws IOException
	 */
	void ReconstructPrivateDict(int Font,OffsetItem[] fdPrivate,IndexBaseItem[] fdPrivateBase,
			OffsetItem[] fdSubrs)throws IOException
	{
		
		// For each fdarray private dict check if that FD is used.
	    // if is used build a new one by changing the subrs offset
	    // Else do nothing
		for (int i=0;i<fonts[Font].fdprivateOffsets.length;i++)
		{
			if (FDArrayUsed.containsKey(new Integer (i)))
			{
				// Mark beginning
		        OutputList.addLast(new MarkerItem(fdPrivate[i]));
		        fdPrivateBase[i] = new IndexBaseItem();
		        OutputList.addLast(fdPrivateBase[i]);
				// Goto begining of objects
	            seek(fonts[Font].fdprivateOffsets[i]);
	            while (getPosition() < fonts[Font].fdprivateOffsets[i]+fonts[Font].fdprivateLengths[i])
	            {
	            	int p1 = getPosition();
	            	getDictItem();
	            	int p2 = getPosition();
	            	// If the dictItem is the "Subrs" then, 
	            	// use marker for offset and write operator number
	            	if (key=="Subrs") {
	            		fdSubrs[i] = new DictOffsetItem();
	            		OutputList.addLast(fdSubrs[i]);
	            	    OutputList.addLast(new UInt8Item((char)19)); // Subrs
	            	}
	            	// Else copy the entire range
	            	else
	            		OutputList.addLast(new RangeItem(buf,p1,p2-p1));
	            }
			}
		}
	}
	
	/**
	 * Function Adds the new LSubrs dicts (only for the FDs used) to the list
	 * @param Font  The index of the font
	 * @param fdPrivateBase The IndexBaseItem array for the linked list
	 * @param fdSubrs OffsetItem array for the linked list
	 * @throws IOException
	 */
	
	void ReconstructPrivateSubrs(int Font,IndexBaseItem[] fdPrivateBase,
			OffsetItem[] fdSubrs)throws IOException
	{
		// For each private dict
        for (int i=0;i<fonts[Font].fdprivateLengths.length;i++)
        {
        	// If that private dict's Subrs are used insert the new LSubrs
        	// computed earlier
        	if (fdSubrs[i]!= null && fonts[Font].PrivateSubrsOffset[i] >= 0)
        	{        		
        		OutputList.addLast(new SubrMarkerItem(fdSubrs[i],fdPrivateBase[i]));
        		OutputList.addLast(new RangeItem(new RandomAccessFileOrArray(NewLSubrsIndex[i]),0,NewLSubrsIndex[i].length));
        	}
        }
    }

	/**
	 * Calculates how many byte it took to write the offset for the subrs in a specific
	 * private dict.
	 * @param Offset The Offset for the private dict
	 * @param Size The size of the private dict
	 * @return The size of the offset of the subrs in the private dict
	 */
	int CalcSubrOffsetSize(int Offset,int Size)
	{
		// Set the size to 0
		int OffsetSize = 0;
		// Go to the beginning of the private dict
		seek(Offset);
		// Go until the end of the private dict 
		while (getPosition() < Offset+Size)
        {
        	int p1 = getPosition();
        	getDictItem();
        	int p2 = getPosition();
        	// When reached to the subrs offset
        	if (key=="Subrs") {
        		// The Offsize (minus the subrs key)
        		OffsetSize = p2-p1-1;
        	}
        	// All other keys are ignored
        }
		// return the size
		return OffsetSize;
	}
	
	/**
	 * Function computes the size of an index
	 * @param indexOffset The offset for the computed index
	 * @return The size of the index
	 */
	protected int countEntireIndexRange(int indexOffset) 
	{
		// Go to the beginning of the index 
	    seek(indexOffset);
	    // Read the count field
	    int count = getCard16();
	    // If count==0 -> size=2
	    if (count==0) 
	        return 2;
	    else 
	    {
	    	// Read the offsize field
	        int indexOffSize = getCard8();
	        // Go to the last element of the offset array
	        seek(indexOffset+2+1+count*indexOffSize);
	        // The size of the object array is the value of the last element-1
	        int size = getOffset(indexOffSize)-1;
	        // Return the size of the entire index
	        return 2+1+(count+1)*indexOffSize+size;
	    }
	}
	
	/**
	 * The function creates a private dict for a font that was not CID
	 * All the keys are copied as is except for the subrs key 
	 * @param Font the font
	 * @param Subr The OffsetItem for the subrs of the private 
	 */
	void CreateNonCIDPrivate(int Font,OffsetItem Subr)
	{
		// Go to the beginning of the private dict and read untill the end
		seek(fonts[Font].privateOffset);
        while (getPosition() < fonts[Font].privateOffset+fonts[Font].privateLength)
        {
        	int p1 = getPosition();
        	getDictItem();
        	int p2 = getPosition();
        	// If the dictItem is the "Subrs" then, 
        	// use marker for offset and write operator number
        	if (key=="Subrs") {
        		OutputList.addLast(Subr);
        	    OutputList.addLast(new UInt8Item((char)19)); // Subrs
        	}
        	// Else copy the entire range
        	else
        		OutputList.addLast(new RangeItem(buf,p1,p2-p1));
        }
	}
	
	/**
	 * the function marks the beginning of the subrs index and adds the subsetted subrs
	 * index to the output list. 
	 * @param Font the font
	 * @param PrivateBase IndexBaseItem for the private that's referencing to the subrs
	 * @param Subrs OffsetItem for the subrs
	 * @throws IOException
	 */
	void CreateNonCIDSubrs(int Font,IndexBaseItem PrivateBase,OffsetItem Subrs)throws IOException
	{
		// Mark the beginning of the Subrs index
		OutputList.addLast(new SubrMarkerItem(Subrs,PrivateBase));
		// Put the subsetted new subrs index
		OutputList.addLast(new RangeItem(new RandomAccessFileOrArray(NewSubrsIndexNonCID),0,NewSubrsIndexNonCID.length));
    }	
} /*
 * $Id: CJKFont.java,v 1.29 2002/07/09 11:28:22 blowagie Exp $
 * $Name:  $
 *
 * Copyright 2000, 2001, 2002 by Paulo Soares.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf;

import pdftk.com.lowagie.text.DocumentException;
import java.io.*;
import java.util.HashMap;
import java.util.Properties;
import java.util.Hashtable;
import java.util.StringTokenizer;
import java.util.Enumeration;

/**
 * Creates a CJK font compatible with the fonts in the Adobe Asian font Pack.
 *
 * @author  Paulo Soares (psoares@consiste.pt)
 */

class CJKFont extends BaseFont {
    /** The encoding used in the PDF document for CJK fonts
     */
    static final String CJK_ENCODING = "UnicodeBigUnmarked";
    private static final int FIRST = 0;
    private static final int BRACKET = 1;
    private static final int SERIAL = 2;
    private static final int V1Y = 880;
        
    static Properties cjkFonts = new Properties();
    static Properties cjkEncodings = new Properties();
    static Hashtable allCMaps = new Hashtable();
    static Hashtable allFonts = new Hashtable();
    private static boolean propertiesLoaded = false;
    
    /** The font name */
    private String fontName;
    /** The style modifier */
    private String style = "";
    /** The CMap name associated with this font */
    private String CMap;
    
    private boolean cidDirect = false;
    
    private char[] translationMap;
    private IntHashtable vMetrics;
    private IntHashtable hMetrics;
    private HashMap fontDesc;
    private boolean vertical = false;
    
    private static void loadProperties() {
        if (propertiesLoaded)
            return;
        synchronized (allFonts) {
            if (propertiesLoaded)
                return;
            try {
                InputStream is = getResourceStream(RESOURCE_PATH + "cjkfonts.properties");
                cjkFonts.load(is);
                is.close();
                is = getResourceStream(RESOURCE_PATH + "cjkencodings.properties");
                cjkEncodings.load(is);
                is.close();
            }
            catch (Exception e) {
                cjkFonts = new Properties();
                cjkEncodings = new Properties();
            }
            propertiesLoaded = true;
        }
    }
    
    /** Creates a CJK font.
     * @param fontName the name of the font
     * @param enc the encoding of the font
     * @param emb always <CODE>false</CODE>. CJK font and not embedded
     * @throws DocumentException on error
     * @throws IOException on error
     */
    CJKFont(String fontName, String enc, boolean emb) throws DocumentException, IOException {
        loadProperties();
        fontType = FONT_TYPE_CJK;
        String nameBase = getBaseName(fontName);
        if (!isCJKFont(nameBase, enc))
            throw new DocumentException("Font '" + fontName + "' with '" + enc + "' encoding is not a CJK font.");
        if (nameBase.length() < fontName.length()) {
            style = fontName.substring(nameBase.length());
            fontName = nameBase;
        }
        this.fontName = fontName;
        encoding = CJK_ENCODING;
        vertical = enc.endsWith("V");
        CMap = enc;
        if (enc.startsWith("Identity-")) {
            cidDirect = true;
            String s = cjkFonts.getProperty(fontName);
            s = s.substring(0, s.indexOf('_'));
            char c[] = (char[])allCMaps.get(s);
            if (c == null) {
                c = readCMap(s);
                if (c == null)
                    throw new DocumentException("The cmap " + s + " does not exist as a resource.");
                c[CID_NEWLINE] = '\n';
                allCMaps.put(s, c);
            }
            translationMap = c;
        }
        else {
            char c[] = (char[])allCMaps.get(enc);
            if (c == null) {
                String s = cjkEncodings.getProperty(enc);
                if (s == null)
                    throw new DocumentException("The resource cjkencodings.properties does not contain the encoding " + enc);
                StringTokenizer tk = new StringTokenizer(s);
                String nt = tk.nextToken();
                c = (char[])allCMaps.get(nt);
                if (c == null) {
                    c = readCMap(nt);
                    allCMaps.put(nt, c);
                }
                if (tk.hasMoreTokens()) {
                    String nt2 = tk.nextToken();
                    char m2[] = readCMap(nt2);
                    for (int k = 0; k < 0x10000; ++k) {
                        if (m2[k] == 0)
                            m2[k] = c[k];
                    }
                    allCMaps.put(enc, m2);
                    c = m2;
                }
            }
            translationMap = c;
        }
        fontDesc = (HashMap)allFonts.get(fontName);
        if (fontDesc == null) {
            fontDesc = readFontProperties(fontName);
            allFonts.put(fontName, fontDesc);
        }
        hMetrics = (IntHashtable)fontDesc.get("W");
        vMetrics = (IntHashtable)fontDesc.get("W2");
    }
    
    /** Checks if its a valid CJK font.
     * @param fontName the font name
     * @param enc the encoding
     * @return <CODE>true</CODE> if it is CJK font
     */
    public static boolean isCJKFont(String fontName, String enc) {
        loadProperties();
        String encodings = cjkFonts.getProperty(fontName);
        return (encodings != null && (enc.equals("Identity-H") || enc.equals("Identity-V") || encodings.indexOf("_" + enc + "_") >= 0));
    }
        
    public int getWidth(String text) {
        int total = 0;
        for (int k = 0; k < text.length(); ++k) {
            int c = text.charAt(k);
            if (!cidDirect)
                c = translationMap[c];
            int v;
            if (vertical)
                v = vMetrics.get(c);
            else
                v = hMetrics.get(c);
            if (v > 0)
                total += v;
            else
                total += 1000;
        }
        return total;
    }
    
    int getRawWidth(int c, String name) {
        return 0;
    }
  
    public int getKerning(char char1, char char2) {
        return 0;
    }

    private PdfDictionary getFontDescriptor() {
        PdfDictionary dic = new PdfDictionary(PdfName.FONTDESCRIPTOR);
        dic.put(PdfName.ASCENT, new PdfLiteral((String)fontDesc.get("Ascent")));
        dic.put(PdfName.CAPHEIGHT, new PdfLiteral((String)fontDesc.get("CapHeight")));
        dic.put(PdfName.DESCENT, new PdfLiteral((String)fontDesc.get("Descent")));
        dic.put(PdfName.FLAGS, new PdfLiteral((String)fontDesc.get("Flags")));
        dic.put(PdfName.FONTBBOX, new PdfLiteral((String)fontDesc.get("FontBBox")));
        dic.put(PdfName.FONTNAME, new PdfName(fontName + style));
        dic.put(PdfName.ITALICANGLE, new PdfLiteral((String)fontDesc.get("ItalicAngle")));
        dic.put(PdfName.STEMV, new PdfLiteral((String)fontDesc.get("StemV")));
        PdfDictionary pdic = new PdfDictionary();
        pdic.put(PdfName.PANOSE, new PdfString((String)fontDesc.get("Panose"), null));
        dic.put(PdfName.STYLE, pdic);
        return dic;
    }
    
    private PdfDictionary getCIDFont(PdfIndirectReference fontDescriptor, IntHashtable cjkTag) {
        PdfDictionary dic = new PdfDictionary(PdfName.FONT);
        dic.put(PdfName.SUBTYPE, PdfName.CIDFONTTYPE0);
        dic.put(PdfName.BASEFONT, new PdfName(fontName + style));
        dic.put(PdfName.FONTDESCRIPTOR, fontDescriptor);
        int keys[] = cjkTag.toOrderedKeys();
        String w = convertToHCIDMetrics(keys, hMetrics);
        if (w != null)
            dic.put(PdfName.W, new PdfLiteral(w));
        if (vertical) {
            w = convertToVCIDMetrics(keys, vMetrics, hMetrics);;
            if (w != null)
                dic.put(PdfName.W2, new PdfLiteral(w));
        }
        else
            dic.put(PdfName.DW, new PdfNumber(1000));
        PdfDictionary cdic = new PdfDictionary();
        cdic.put(PdfName.REGISTRY, new PdfString((String)fontDesc.get("Registry"), null));
        cdic.put(PdfName.ORDERING, new PdfString((String)fontDesc.get("Ordering"), null));
        cdic.put(PdfName.SUPPLEMENT, new PdfLiteral((String)fontDesc.get("Supplement")));
        dic.put(PdfName.CIDSYSTEMINFO, cdic);
        return dic;
    }
    
    private PdfDictionary getFontBaseType(PdfIndirectReference CIDFont) {
        PdfDictionary dic = new PdfDictionary(PdfName.FONT);
        dic.put(PdfName.SUBTYPE, PdfName.TYPE0);
        String name = fontName;
        if (style.length() > 0)
            name += "-" + style.substring(1);
        name += "-" + CMap;
        dic.put(PdfName.BASEFONT, new PdfName(name));
        dic.put(PdfName.ENCODING, new PdfName(CMap));
        dic.put(PdfName.DESCENDANTFONTS, new PdfArray(CIDFont));
        return dic;
    }
    
    void writeFont(PdfWriter writer, PdfIndirectReference ref, Object params[]) throws DocumentException, IOException {
        IntHashtable cjkTag = (IntHashtable)params[0];
        PdfIndirectReference ind_font = null;
        PdfObject pobj = null;
        PdfIndirectObject obj = null;
        pobj = getFontDescriptor();
        if (pobj != null){
            obj = writer.addToBody(pobj);
            ind_font = obj.getIndirectReference();
        }
        pobj = getCIDFont(ind_font, cjkTag);
        if (pobj != null){
            obj = writer.addToBody(pobj);
            ind_font = obj.getIndirectReference();
        }
        pobj = getFontBaseType(ind_font);
        writer.addToBody(pobj, ref);
    }
    
    private float getDescNumber(String name) {
        return Integer.parseInt((String)fontDesc.get(name));
    }
    
    private float getBBox(int idx) {
        String s = (String)fontDesc.get("FontBBox");
        StringTokenizer tk = new StringTokenizer(s, " []\r\n\t\f");
        String ret = tk.nextToken();
        for (int k = 0; k < idx; ++k)
            ret = tk.nextToken();
        return Integer.parseInt(ret);
    }
    
    /** Gets the font parameter identified by <CODE>key</CODE>. Valid values
     * for <CODE>key</CODE> are <CODE>ASCENT</CODE>, <CODE>CAPHEIGHT</CODE>, <CODE>DESCENT</CODE>
     * and <CODE>ITALICANGLE</CODE>.
     * @param key the parameter to be extracted
     * @param fontSize the font size in points
     * @return the parameter in points
     */
    public float getFontDescriptor(int key, float fontSize) {
        switch (key) {
            case AWT_ASCENT:
            case ASCENT:
                return getDescNumber("Ascent") * fontSize / 1000;
            case CAPHEIGHT:
                return getDescNumber("CapHeight") * fontSize / 1000;
            case AWT_DESCENT:
            case DESCENT:
                return getDescNumber("Descent") * fontSize / 1000;
            case ITALICANGLE:
                return getDescNumber("ItalicAngle");
            case BBOXLLX:
                return fontSize * getBBox(0) / 1000;
            case BBOXLLY:
                return fontSize * getBBox(1) / 1000;
            case BBOXURX:
                return fontSize * getBBox(2) / 1000;
            case BBOXURY:
                return fontSize * getBBox(3) / 1000;
            case AWT_LEADING:
                return 0;
            case AWT_MAXADVANCE:
                return fontSize * (getBBox(2) - getBBox(0)) / 1000;
        }
        return 0;
    }
    
    public String getPostscriptFontName() {
        return fontName;
    }
    
    /** Gets the full name of the font. If it is a True Type font
     * each array element will have {Platform ID, Platform Encoding ID,
     * Language ID, font name}. The interpretation of this values can be
     * found in the Open Type specification, chapter 2, in the 'name' table.<br>
     * For the other fonts the array has a single element with {"", "", "",
     * font name}.
     * @return the full name of the font
     */
    public String[][] getFullFontName() {
        return new String[][]{{"", "", "", fontName}};
    }
    
    /** Gets the family name of the font. If it is a True Type font
     * each array element will have {Platform ID, Platform Encoding ID,
     * Language ID, font name}. The interpretation of this values can be
     * found in the Open Type specification, chapter 2, in the 'name' table.<br>
     * For the other fonts the array has a single element with {"", "", "",
     * font name}.
     * @return the family name of the font
     */
    public String[][] getFamilyFontName() {
        return getFullFontName();
    }
    
    static char[] readCMap(String name) {
        try {
            name = name + ".cmap";
            InputStream is = getResourceStream(RESOURCE_PATH + name);
            char c[] = new char[0x10000];
            for (int k = 0; k < 0x10000; ++k)
                c[k] = (char)((is.read() << 8) + is.read());
            return c;
        }
        catch (Exception e) {
            // empty on purpose
        }
        return null;
    }
    
    static IntHashtable createMetric(String s) {
        IntHashtable h = new IntHashtable();
        StringTokenizer tk = new StringTokenizer(s);
        while (tk.hasMoreTokens()) {
            int n1 = Integer.parseInt(tk.nextToken());
            h.put(n1, Integer.parseInt(tk.nextToken()));
        }
        return h;
    }
    
    static String convertToHCIDMetrics(int keys[], IntHashtable h) {
        if (keys.length == 0)
            return null;
        int lastCid = 0;
        int lastValue = 0;
        int start;
        for (start = 0; start < keys.length; ++start) {
            lastCid = keys[start];
            lastValue = h.get(lastCid);
            if (lastValue != 0) {
                ++start;
                break;
            }
        }
        if (lastValue == 0)
            return null;
        StringBuffer buf = new StringBuffer();
        buf.append('[');
        buf.append(lastCid);
        int state = FIRST;
        for (int k = start; k < keys.length; ++k) {
            int cid = keys[k];
            int value = h.get(cid);
            if (value == 0)
                continue;
            switch (state) {
                case FIRST: {
                    if (cid == lastCid + 1 && value == lastValue) {
                        state = SERIAL;
                    }
                    else if (cid == lastCid + 1) {
                        state = BRACKET;
                        buf.append('[').append(lastValue);
                    }
                    else {
                        buf.append('[').append(lastValue).append(']').append(cid);
                    }
                    break;
                }
                case BRACKET: {
                    if (cid == lastCid + 1 && value == lastValue) {
                        state = SERIAL;
                        buf.append(']').append(lastCid);
                    }
                    else if (cid == lastCid + 1) {
                        buf.append(' ').append(lastValue);
                    }
                    else {
                        state = FIRST;
                        buf.append(' ').append(lastValue).append(']').append(cid);
                    }
                    break;
                }
                case SERIAL: {
                    if (cid != lastCid + 1 || value != lastValue) {
                        buf.append(' ').append(lastCid).append(' ').append(lastValue).append(' ').append(cid);
                        state = FIRST;
                    }
                    break;
                }
            }
            lastValue = value;
            lastCid = cid;
        }
        switch (state) {
            case FIRST: {
                buf.append('[').append(lastValue).append("]]");
                break;
            }
            case BRACKET: {
                buf.append(' ').append(lastValue).append("]]");
                break;
            }
            case SERIAL: {
                buf.append(' ').append(lastCid).append(' ').append(lastValue).append(']');
                break;
            }
        }
        return buf.toString();
    }
    
    static String convertToVCIDMetrics(int keys[], IntHashtable v, IntHashtable h) {
        if (keys.length == 0)
            return null;
        int lastCid = 0;
        int lastValue = 0;
        int lastHValue = 0;
        int start;
        for (start = 0; start < keys.length; ++start) {
            lastCid = keys[start];
            lastValue = v.get(lastCid);
            if (lastValue != 0) {
                ++start;
                break;
            }
            else
                lastHValue = h.get(lastCid);
        }
        if (lastValue == 0)
            return null;
        if (lastHValue == 0)
            lastHValue = 1000;
        StringBuffer buf = new StringBuffer();
        buf.append('[');
        buf.append(lastCid);
        int state = FIRST;
        for (int k = start; k < keys.length; ++k) {
            int cid = keys[k];
            int value = v.get(cid);
            if (value == 0)
                continue;
            int hValue = h.get(lastCid);
            if (hValue == 0)
                hValue = 1000;
            switch (state) {
                case FIRST: {
                    if (cid == lastCid + 1 && value == lastValue && hValue == lastHValue) {
                        state = SERIAL;
                    }
                    else {
                        buf.append(' ').append(lastCid).append(' ').append(-lastValue).append(' ').append(lastHValue / 2).append(' ').append(V1Y).append(' ').append(cid);
                    }
                    break;
                }
                case SERIAL: {
                    if (cid != lastCid + 1 || value != lastValue || hValue != lastHValue) {
                        buf.append(' ').append(lastCid).append(' ').append(-lastValue).append(' ').append(lastHValue / 2).append(' ').append(V1Y).append(' ').append(cid);
                        state = FIRST;
                    }
                    break;
                }
            }
            lastValue = value;
            lastCid = cid;
            lastHValue = hValue;
        }
        buf.append(' ').append(lastCid).append(' ').append(-lastValue).append(' ').append(lastHValue / 2).append(' ').append(V1Y).append(" ]");
        return buf.toString();
    }
    
    static HashMap readFontProperties(String name) {
        try {
            name += ".properties";
            InputStream is = getResourceStream(RESOURCE_PATH + name);
            Properties p = new Properties();
            p.load(is);
            is.close();
            IntHashtable W = createMetric(p.getProperty("W"));
            p.remove("W");
            IntHashtable W2 = createMetric(p.getProperty("W2"));
            p.remove("W2");
            HashMap map = new HashMap();
            for (Enumeration e = p.keys(); e.hasMoreElements();) {
                Object obj = e.nextElement();
                map.put(obj, p.getProperty((String)obj));
            }
            map.put("W", W);
            map.put("W2", W2);
            return map;
        }
        catch (Exception e) {
            // empty on purpose
        }
        return null;
    }

    public char getUnicodeEquivalent(char c) {
        if (cidDirect)
            return translationMap[c];
        return c;
    }
    
    public char getCidCode(char c) {
        if (cidDirect)
            return c;
        return translationMap[c];
    }
    
    /** Checks if the font has any kerning pairs.
     * @return always <CODE>false</CODE>
     */    
    public boolean hasKernPairs() {
        return false;
    }
    
    /**
     * Checks if a character exists in this font.
     * @param c the character to check
     * @return <CODE>true</CODE> if the character has a glyph,
     * <CODE>false</CODE> otherwise
     */
    public boolean charExists(char c) {
        return translationMap[c] != 0;
    }
    
    /**
     * Sets the character advance.
     * @param c the character
     * @param advance the character advance normalized to 1000 units
     * @return <CODE>true</CODE> if the advance was set,
     * <CODE>false</CODE> otherwise. Will always return <CODE>false</CODE>
     */
    public boolean setCharAdvance(char c, int advance) {
        return false;
    }
    
    /**
     * Sets the font name that will appear in the pdf font dictionary.
     * Use with care as it can easily make a font unreadable if not embedded.
     * @param name the new font name
     */    
    public void setPostscriptFontName(String name) {
        fontName = name;
    }   
    
    public boolean setKerning(char char1, char char2, int kern) {
        return false;
    }
    
    public int[] getCharBBox(char c) {
        return null;
    }
    
    protected int[] getRawCharBBox(int c, String name) {
        return null;
    }
} /*
 * $Id: CMYKColor.java,v 1.43 2005/05/02 11:12:44 blowagie Exp $
 * $Name:  $
 *
 * Copyright 2001, 2002 by Paulo Soares.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf;

/**
 *
 * @author  Paulo Soares (psoares@consiste.pt)
 */
public class CMYKColor extends ExtendedColor {

    /** A serial version UID */
    private static final long serialVersionUID = 5940378778276468452L;

    float cyan;
    float magenta;
    float yellow;
    float black;

    /**
     * Constructs a CMYK Color beased on 4 colorvalues (values are integers from 0 to 255).
     * @param intCyan
     * @param intMagenta
     * @param intYellow
     * @param intBlack
     */
    public CMYKColor(int intCyan, int intMagenta, int intYellow, int intBlack) {
        this((float)intCyan / 255f, (float)intMagenta / 255f, (float)intYellow / 255f, (float)intBlack / 255f);
    }

    /**
     * Construct a CMYK Color.
     * @param floatCyan
     * @param floatMagenta
     * @param floatYellow
     * @param floatBlack
     */
    public CMYKColor(float floatCyan, float floatMagenta, float floatYellow, float floatBlack) {
        super(TYPE_CMYK, 1f - floatCyan - floatBlack, 1f - floatMagenta - floatBlack, 1f - floatYellow - floatBlack);
        cyan = normalize(floatCyan);
        magenta = normalize(floatMagenta);
        yellow = normalize(floatYellow);
        black = normalize(floatBlack);
    }
    
    /**
     * @return the cyan value
     */
    public float getCyan() {
        return cyan;
    }

    /**
     * @return the magenta value
     */
    public float getMagenta() {
        return magenta;
    }

    /**
     * @return the yellow value
     */
    public float getYellow() {
        return yellow;
    }

    /**
     * @return the black value
     */
    public float getBlack() {
        return black;
    }

}
 /*
 * $Id: ColorDetails.java,v 1.11 2002/06/20 13:06:47 blowagie Exp $
 * $Name:  $
 *
 * Copyright 2001, 2002 by Paulo Soares.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf;

import java.io.IOException;
/** Each spotcolor in the document will have an instance of this class
 *
 * @author Phillip Pan (phillip@formstar.com)
 */
class ColorDetails {

    /** The indirect reference to this color
     */
    PdfIndirectReference indirectReference;
    /** The color name that appears in the document body stream
     */
    PdfName colorName;
    /** The color
     */
    PdfSpotColor spotcolor;

    /** Each spot color used in a document has an instance of this class.
     * @param colorName the color name
     * @param indirectReference the indirect reference to the font
     * @param scolor the <CODE>PDfSpotColor</CODE>
     */
    ColorDetails(PdfName colorName, PdfIndirectReference indirectReference, PdfSpotColor scolor) {
        this.colorName = colorName;
        this.indirectReference = indirectReference;
        this.spotcolor = scolor;
    }

    /** Gets the indirect reference to this color.
     * @return the indirect reference to this color
     */
    PdfIndirectReference getIndirectReference() {
        return indirectReference;
    }

    /** Gets the color name as it appears in the document body.
     * @return the color name
     */
    PdfName getColorName() {
        return colorName;
    }

    /** Gets the <CODE>SpotColor</CODE> object.
     * @return the <CODE>PdfSpotColor</CODE>
     */
    PdfObject getSpotColor(PdfWriter writer) throws IOException {
        return spotcolor.getSpotObject(writer);
    }
}
 /*
 * $Id: ColumnText.java,v 1.58 2005/01/11 14:14:58 blowagie Exp $
 * $Name:  $
 *
 * Copyright 2001, 2002 by Paulo Soares.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Stack;
import java.util.Iterator;
import pdftk.com.lowagie.text.Phrase;
import pdftk.com.lowagie.text.Chunk;
import pdftk.com.lowagie.text.Paragraph;
// import pdftk.com.lowagie.text.Graphic; ssteward: dropped in 1.44
import pdftk.com.lowagie.text.ListItem;
import pdftk.com.lowagie.text.Element;
import pdftk.com.lowagie.text.DocumentException;
import pdftk.com.lowagie.text.ExceptionConverter;
// import pdftk.com.lowagie.text.Image; ssteward: dropped in 1.44

/**
 * Formats text in a columnwise form. The text is bound
 * on the left and on the right by a sequence of lines. This allows the column
 * to have any shape, not only rectangular.
 * <P>
 * Several parameters can be set like the first paragraph line indent and
 * extra space between paragraphs.
 * <P>
 * A call to the method <CODE>go</CODE> will return one of the following
 * situations: the column ended or the text ended.
 * <P>
 * I the column ended, a new column definition can be loaded with the method
 * <CODE>setColumns</CODE> and the method <CODE>go</CODE> can be called again.
 * <P>
 * If the text ended, more text can be loaded with <CODE>addText</CODE>
 * and the method <CODE>go</CODE> can be called again.<BR>
 * The only limitation is that one or more complete paragraphs must be loaded
 * each time.
 * <P>
 * Full bidirectional reordering is supported. If the run direction is
 * <CODE>PdfWriter.RUN_DIRECTION_RTL</CODE> the meaning of the horizontal
 * alignments and margins is mirrored.
 * @author Paulo Soares (psoares@consiste.pt)
 */

public class ColumnText {
    /** Eliminate the arabic vowels */    
    public static final int AR_NOVOWEL = ArabicLigaturizer.ar_novowel;
    /** Compose the tashkeel in the ligatures. */    
    public static final int AR_COMPOSEDTASHKEEL = ArabicLigaturizer.ar_composedtashkeel;
    /** Do some extra double ligatures. */    
    public static final int AR_LIG = ArabicLigaturizer.ar_lig;
    /**
     * Digit shaping option: Replace European digits (U+0030...U+0039) by Arabic-Indic digits.
     */
    public static final int DIGITS_EN2AN = ArabicLigaturizer.DIGITS_EN2AN;
    
    /**
     * Digit shaping option: Replace Arabic-Indic digits by European digits (U+0030...U+0039).
     */
    public static final int DIGITS_AN2EN = ArabicLigaturizer.DIGITS_AN2EN;
    
    /**
     * Digit shaping option:
     * Replace European digits (U+0030...U+0039) by Arabic-Indic digits
     * if the most recent strongly directional character
     * is an Arabic letter (its Bidi direction value is RIGHT_TO_LEFT_ARABIC).
     * The initial state at the start of the text is assumed to be not an Arabic,
     * letter, so European digits at the start of the text will not change.
     * Compare to DIGITS_ALEN2AN_INIT_AL.
     */
    public static final int DIGITS_EN2AN_INIT_LR = ArabicLigaturizer.DIGITS_EN2AN_INIT_LR;
    
    /**
     * Digit shaping option:
     * Replace European digits (U+0030...U+0039) by Arabic-Indic digits
     * if the most recent strongly directional character
     * is an Arabic letter (its Bidi direction value is RIGHT_TO_LEFT_ARABIC).
     * The initial state at the start of the text is assumed to be an Arabic,
     * letter, so European digits at the start of the text will change.
     * Compare to DIGITS_ALEN2AN_INT_LR.
     */
    public static final int DIGITS_EN2AN_INIT_AL = ArabicLigaturizer.DIGITS_EN2AN_INIT_AL;
    
    /**
     * Digit type option: Use Arabic-Indic digits (U+0660...U+0669).
     */
    public static final int DIGIT_TYPE_AN = ArabicLigaturizer.DIGIT_TYPE_AN;
    
    /**
     * Digit type option: Use Eastern (Extended) Arabic-Indic digits (U+06f0...U+06f9).
     */
    public static final int DIGIT_TYPE_AN_EXTENDED = ArabicLigaturizer.DIGIT_TYPE_AN_EXTENDED;
    
    protected int runDirection = PdfWriter.RUN_DIRECTION_DEFAULT;
    
    /** the space char ratio */
    public static final float GLOBAL_SPACE_CHAR_RATIO = 0;
    
    /** Signals that there is no more text available. */
    public static final int NO_MORE_TEXT = 1;
    
    /** Signals that there is no more column. */
    public static final int NO_MORE_COLUMN = 2;
    
    /** The column is valid. */
    protected static final int LINE_STATUS_OK = 0;
    
    /** The line is out the column limits. */
    protected static final int LINE_STATUS_OFFLIMITS = 1;
    
    /** The line cannot fit this column position. */
    protected static final int LINE_STATUS_NOLINE = 2;
    
    /** Upper bound of the column. */
    protected float maxY;
    
    /** Lower bound of the column. */
    protected float minY;
    
    protected float leftX;
    
    protected float rightX;
    
    /** The column alignment. Default is left alignment. */
    protected int alignment = Element.ALIGN_LEFT;
    
    /** The left column bound. */
    protected ArrayList leftWall;
    
    /** The right column bound. */
    protected ArrayList rightWall;
    
    /** The chunks that form the text. */
//    protected ArrayList chunks = new ArrayList();
    protected BidiLine bidiLine;
    
    /** The current y line location. Text will be written at this line minus the leading. */
    protected float yLine;
    
    /** The leading for the current line. */
    protected float currentLeading = 16;
    
    /** The fixed text leading. */
    protected float fixedLeading = 16;
    
    /** The text leading that is multiplied by the biggest font size in the line. */
    protected float multipliedLeading = 0;
    
    /** The <CODE>PdfContent</CODE> where the text will be written to. */
    protected PdfContentByte canvas;
    
    /** The line status when trying to fit a line to a column. */
    protected int lineStatus;
    
    /** The first paragraph line indent. */
    protected float indent = 0;
    
    /** The following paragraph lines indent. */
    protected float followingIndent = 0;
    
    /** The right paragraph lines indent. */
    protected float rightIndent = 0;
    
    /** The extra space between paragraphs. */
    protected float extraParagraphSpace = 0;
    
    /** The width of the line when the column is defined as a simple rectangle. */
    protected float rectangularWidth = -1;
    
    protected boolean rectangularMode = false;
    /** Holds value of property spaceCharRatio. */
    private float spaceCharRatio = GLOBAL_SPACE_CHAR_RATIO;

    private boolean lastWasNewline = true;
    
    /** Holds value of property linesWritten. */
    private int linesWritten;
    
    private float firstLineY;
    private boolean firstLineYDone = false;
    
    /** Holds value of property arabicOptions. */
    private int arabicOptions = 0;
    
    protected float descender;
    
    protected boolean composite = false;
    
    protected ColumnText compositeColumn;
    
    protected LinkedList compositeElements;
    
    protected int listIdx = 0;
    
    private boolean splittedRow;
    
    protected Phrase waitPhrase;
    
    /** if true, first line height is adjusted so that the max ascender touches the top */
    private boolean useAscender = false;

    /**
     * Creates a <CODE>ColumnText</CODE>.
     * @param canvas the place where the text will be written to. Can
     * be a template.
     */
    public ColumnText(PdfContentByte canvas) {
        this.canvas = canvas;
    }
    
    /** Creates an independent duplicated of the instance <CODE>org</CODE>.
     * @param org the original <CODE>ColumnText</CODE>
     * @return the duplicated
     */    
    public static ColumnText duplicate(ColumnText org) {
        ColumnText ct = new ColumnText(null);
        ct.setACopy(org);
        return ct;
    }
    
    /** Makes this instance an independent copy of <CODE>org</CODE>.
     * @param org the original <CODE>ColumnText</CODE>
     * @return itself
     */    
    public ColumnText setACopy(ColumnText org) {
        setSimpleVars(org);
        if (org.bidiLine != null)
            bidiLine = new BidiLine(org.bidiLine);
        return this;
    }
    
    protected void setSimpleVars(ColumnText org) {
        maxY = org.maxY;
        minY = org.minY;
        alignment = org.alignment;
        leftWall = null;
        if (org.leftWall != null)
            leftWall = new ArrayList(org.leftWall);
        rightWall = null;
        if (org.rightWall != null)
            rightWall = new ArrayList(org.rightWall);
        yLine = org.yLine;
        currentLeading = org.currentLeading;
        fixedLeading = org.fixedLeading;
        multipliedLeading = org.multipliedLeading;
        canvas = org.canvas;
        lineStatus = org.lineStatus;
        indent = org.indent;
        followingIndent = org.followingIndent;
        rightIndent = org.rightIndent;
        extraParagraphSpace = org.extraParagraphSpace;
        rectangularWidth = org.rectangularWidth;
        rectangularMode = org.rectangularMode;
        spaceCharRatio = org.spaceCharRatio;
        lastWasNewline = org.lastWasNewline;
        linesWritten = org.linesWritten;
        arabicOptions = org.arabicOptions;
        runDirection = org.runDirection;
        descender = org.descender;
        composite = org.composite;
        splittedRow = org.splittedRow;
        if (org.composite) {
            compositeElements = new LinkedList(org.compositeElements);
	    /* ssteward: dropped in 1.44 
            if (splittedRow) {
                PdfPTable table = (PdfPTable)compositeElements.getFirst();
                compositeElements.set(0, new PdfPTable(table));
            }
	    */
            if (org.compositeColumn != null)
                compositeColumn = duplicate(org.compositeColumn);
        }
        listIdx = org.listIdx;
        firstLineY = org.firstLineY;
        leftX = org.leftX;
        rightX = org.rightX;
        firstLineYDone = org.firstLineYDone;
        waitPhrase = org.waitPhrase;
        useAscender = org.useAscender;
    }
    
    private void addWaitingPhrase() {
        if (bidiLine == null && waitPhrase != null) {
            bidiLine = new BidiLine();
            for (Iterator j = waitPhrase.getChunks().iterator(); j.hasNext();) {
                bidiLine.addChunk(new PdfChunk((Chunk)j.next(), null));
            }
            waitPhrase = null;
        }
    }
    
    /**
     * Adds a <CODE>Phrase</CODE> to the current text array.
     * Will not have any effect if addElement() was called before.
     * @param phrase the text
     */
    public void addText(Phrase phrase) {
        if (phrase == null || composite)
            return;
        addWaitingPhrase();
        if (bidiLine == null) {
            waitPhrase = phrase;
            return;
        }
        for (Iterator j = phrase.getChunks().iterator(); j.hasNext();) {
            bidiLine.addChunk(new PdfChunk((Chunk)j.next(), null));
        }
    }
    
    /**
     * Replaces the current text array with this <CODE>Phrase</CODE>.
     * Anything added previously with addElement() is lost.
     * @param phrase the text
     */
    public void setText(Phrase phrase) {
        bidiLine = null;
        composite = false;
        compositeColumn = null;
        compositeElements = null;
        listIdx = 0;
        splittedRow = false;
        waitPhrase = phrase;
    }
    
    /**
     * Adds a <CODE>Chunk</CODE> to the current text array.
     * Will not have any effect if addElement() was called before.
     * @param chunk the text
     */
    public void addText(Chunk chunk) {
        if (chunk == null || composite)
            return;
        addText(new Phrase(chunk));
    }
    
    /**
     * Adds an element. Elements supported are <CODE>Paragraph</CODE>,
     * <CODE>List</CODE>, <CODE>PdfPTable</CODE>, <CODE>Image</CODE> and
     * <CODE>Graphic</CODE>.
     * <p>
     * It removes all the text placed with <CODE>addText()</CODE>.
     * @param element the <CODE>Element</CODE>
     */    
    public void addElement(Element element) {
        if (element == null)
            return;
	/* ssteward: dropped in 1.44
        if (element instanceof Image) {
            Image img = (Image)element;
            PdfPTable t = new PdfPTable(1);
            float w = img.getWidthPercentage();
            if (w == 0) {
                t.setTotalWidth(img.scaledWidth());
                t.setLockedWidth(true);
            }
            else
                t.setWidthPercentage(w);
            t.setSpacingAfter(img.spacingAfter());
            t.setSpacingBefore(img.spacingBefore());
            switch (img.alignment()) {
                case Image.LEFT:
                    t.setHorizontalAlignment(Element.ALIGN_LEFT);
                    break;
                case Image.RIGHT:
                    t.setHorizontalAlignment(Element.ALIGN_RIGHT);
                    break;
                default:
                    t.setHorizontalAlignment(Element.ALIGN_CENTER);
                    break;
            }
            PdfPCell c = new PdfPCell(img, true);
            c.setPadding(0);
            c.setBorder(img.border());
            c.setBorderColor(img.borderColor());
            c.setBorderWidth(img.borderWidth());
            c.setBackgroundColor(img.backgroundColor());
            c.setGrayFill(img.grayFill());
            t.addCell(c);
            element = t;
        }
	*/
        if (element.type() == Element.CHUNK) {
        	element = new Paragraph((Chunk)element);
        }
        else if (element.type() == Element.PHRASE) {
        	element = new Paragraph((Phrase)element);
        }
        if (element.type() != Element.PARAGRAPH && element.type() != Element.LIST && element.type() != Element.PTABLE && element.type() != Element.GRAPHIC)
            throw new IllegalArgumentException("Element not allowed.");
        if (!composite) {
            composite = true;
            compositeElements = new LinkedList();
            bidiLine = null;
            waitPhrase = null;
        }
        compositeElements.add(element);
    }
    
    /**
     * Converts a sequence of lines representing one of the column bounds into
     * an internal format.
     * <p>
     * Each array element will contain a <CODE>float[4]</CODE> representing
     * the line x = ax + b.
     * @param cLine the column array
     * @return the converted array
     */
    protected ArrayList convertColumn(float cLine[]) {
        if (cLine.length < 4)
            throw new RuntimeException("No valid column line found.");
        ArrayList cc = new ArrayList();
        for (int k = 0; k < cLine.length - 2; k += 2) {
            float x1 = cLine[k];
            float y1 = cLine[k + 1];
            float x2 = cLine[k + 2];
            float y2 = cLine[k + 3];
            if (y1 == y2)
                continue;
            // x = ay + b
            float a = (x1 - x2) / (y1 - y2);
            float b = x1 - a * y1;
            float r[] = new float[4];
            r[0] = Math.min(y1, y2);
            r[1] = Math.max(y1, y2);
            r[2] = a;
            r[3] = b;
            cc.add(r);
            maxY = Math.max(maxY, r[1]);
            minY = Math.min(minY, r[0]);
        }
        if (cc.size() == 0)
            throw new RuntimeException("No valid column line found.");
        return cc;
    }
    
    /**
     * Finds the intersection between the <CODE>yLine</CODE> and the column. It will
     * set the <CODE>lineStatus</CODE> apropriatly.
     * @param wall the column to intersect
     * @return the x coordinate of the intersection
     */
    protected float findLimitsPoint(ArrayList wall) {
        lineStatus = LINE_STATUS_OK;
        if (yLine < minY || yLine > maxY) {
            lineStatus = LINE_STATUS_OFFLIMITS;
            return 0;
        }
        for (int k = 0; k < wall.size(); ++k) {
            float r[] = (float[])wall.get(k);
            if (yLine < r[0] || yLine > r[1])
                continue;
            return r[2] * yLine + r[3];
        }
        lineStatus = LINE_STATUS_NOLINE;
        return 0;
    }
    
    /**
     * Finds the intersection between the <CODE>yLine</CODE> and the two
     * column bounds. It will set the <CODE>lineStatus</CODE> apropriatly.
     * @return a <CODE>float[2]</CODE>with the x coordinates of the intersection
     */
    protected float[] findLimitsOneLine() {
        float x1 = findLimitsPoint(leftWall);
        if (lineStatus == LINE_STATUS_OFFLIMITS || lineStatus == LINE_STATUS_NOLINE)
            return null;
        float x2 = findLimitsPoint(rightWall);
        if (lineStatus == LINE_STATUS_NOLINE)
            return null;
        return new float[]{x1, x2};
    }
    
    /**
     * Finds the intersection between the <CODE>yLine</CODE>,
     * the <CODE>yLine-leading</CODE>and the two
     * column bounds. It will set the <CODE>lineStatus</CODE> apropriatly.
     * @return a <CODE>float[4]</CODE>with the x coordinates of the intersection
     */
    protected float[] findLimitsTwoLines() {
        boolean repeat = false;
        for (;;) {
            if (repeat && currentLeading == 0)
                return null;
            repeat = true;
            float x1[] = findLimitsOneLine();
            if (lineStatus == LINE_STATUS_OFFLIMITS)
                return null;
            yLine -= currentLeading;
            if (lineStatus == LINE_STATUS_NOLINE) {
                continue;
            }
            float x2[] = findLimitsOneLine();
            if (lineStatus == LINE_STATUS_OFFLIMITS)
                return null;
            if (lineStatus == LINE_STATUS_NOLINE) {
                yLine -= currentLeading;
                continue;
            }
            if (x1[0] >= x2[1] || x2[0] >= x1[1])
                continue;
            return new float[]{x1[0], x1[1], x2[0], x2[1]};
        }
    }
    
    /**
     * Sets the columns bounds. Each column bound is described by a
     * <CODE>float[]</CODE> with the line points [x1,y1,x2,y2,...].
     * The array must have at least 4 elements.
     * @param leftLine the left column bound
     * @param rightLine the right column bound
     */
    public void setColumns(float leftLine[], float rightLine[]) {
        maxY = -10e20f;
        minY = 10e20f;
        rightWall = convertColumn(rightLine);
        leftWall = convertColumn(leftLine);
        rectangularWidth = -1;
        rectangularMode = false;
    }
    
    /**
     * Simplified method for rectangular columns.
     * @param phrase a <CODE>Phrase</CODE>
     * @param llx the lower left x corner
     * @param lly the lower left y corner
     * @param urx the upper right x corner
     * @param ury the upper right y corner
     * @param leading the leading
     * @param alignment the column alignment
     */
    public void setSimpleColumn(Phrase phrase, float llx, float lly, float urx, float ury, float leading, int alignment) {
        addText(phrase);
        setSimpleColumn(llx, lly, urx, ury, leading, alignment);
    }
    
    /**
     * Simplified method for rectangular columns.
     * @param llx the lower left x corner
     * @param lly the lower left y corner
     * @param urx the upper right x corner
     * @param ury the upper right y corner
     * @param leading the leading
     * @param alignment the column alignment
     */
    public void setSimpleColumn(float llx, float lly, float urx, float ury, float leading, int alignment) {
        setLeading(leading);
        this.alignment = alignment;
        setSimpleColumn(llx, lly, urx, ury);
    }
    
    /**
     * Simplified method for rectangular columns.
     * @param llx
     * @param lly
     * @param urx
     * @param ury
     */
    public void setSimpleColumn(float llx, float lly, float urx, float ury) {
        leftX = Math.min(llx, urx);
        maxY = Math.max(lly, ury);
        minY = Math.min(lly, ury);
        rightX = Math.max(llx, urx);
        yLine = maxY;
        rectangularWidth = rightX - leftX;
        if (rectangularWidth < 0)
            rectangularWidth = 0;
        rectangularMode = true;
    }
    /**
     * Sets the leading to fixed
     * @param leading the leading
     */
    public void setLeading(float leading) {
        fixedLeading = leading;
        multipliedLeading = 0;
    }
    
    /**
     * Sets the leading fixed and variable. The resultant leading will be
     * fixedLeading+multipliedLeading*maxFontSize where maxFontSize is the
     * size of the bigest font in the line.
     * @param fixedLeading the fixed leading
     * @param multipliedLeading the variable leading
     */
    public void setLeading(float fixedLeading, float multipliedLeading) {
        this.fixedLeading = fixedLeading;
        this.multipliedLeading = multipliedLeading;
    }
    
    /**
     * Gets the fixed leading
     * @return the leading
     */
    public float getLeading() {
        return fixedLeading;
    }
    
    /**
     * Gets the variable leading
     * @return the leading
     */
    public float getMultipliedLeading() {
        return multipliedLeading;
    }
    
    /**
     * Sets the yLine. The line will be written to yLine-leading.
     * @param yLine the yLine
     */
    public void setYLine(float yLine) {
        this.yLine = yLine;
    }
    
    /**
     * Gets the yLine.
     * @return the yLine
     */
    public float getYLine() {
        return yLine;
    }
    
    /**
     * Sets the alignment.
     * @param alignment the alignment
     */
    public void setAlignment(int alignment) {
        this.alignment = alignment;
    }
    
    /**
     * Gets the alignment.
     * @return the alignment
     */
    public int getAlignment() {
        return alignment;
    }
    
    /**
     * Sets the first paragraph line indent.
     * @param indent the indent
     */
    public void setIndent(float indent) {
        this.indent = indent;
        lastWasNewline = true;
    }
    
    /**
     * Gets the first paragraph line indent.
     * @return the indent
     */
    public float getIndent() {
        return indent;
    }
    
    /**
     * Sets the following paragraph lines indent.
     * @param indent the indent
     */
    public void setFollowingIndent(float indent) {
        this.followingIndent = indent;
        lastWasNewline = true;
    }
    
    /**
     * Gets the following paragraph lines indent.
     * @return the indent
     */
    public float getFollowingIndent() {
        return followingIndent;
    }
    
    /**
     * Sets the right paragraph lines indent.
     * @param indent the indent
     */
    public void setRightIndent(float indent) {
        this.rightIndent = indent;
        lastWasNewline = true;
    }
    
    /**
     * Gets the right paragraph lines indent.
     * @return the indent
     */
    public float getRightIndent() {
        return rightIndent;
    }
    
    /**
     * Outputs the lines to the document. It is equivalent to <CODE>go(false)</CODE>.
     * @return returns the result of the operation. It can be <CODE>NO_MORE_TEXT</CODE>
     * and/or <CODE>NO_MORE_COLUMN</CODE>
     * @throws DocumentException on error
     */
    public int go() throws DocumentException {
        return go(false);
    }
    
    /**
     * Outputs the lines to the document. The output can be simulated.
     * @param simulate <CODE>true</CODE> to simulate the writting to the document
     * @return returns the result of the operation. It can be <CODE>NO_MORE_TEXT</CODE>
     * and/or <CODE>NO_MORE_COLUMN</CODE>
     * @throws DocumentException on error
     */
    public int go(boolean simulate) throws DocumentException {
        if (composite)
            return goComposite(simulate);
        addWaitingPhrase();
        if (bidiLine == null)
            return NO_MORE_TEXT;
        descender = 0;
        linesWritten = 0;
        boolean dirty = false;
        float ratio = spaceCharRatio;
        Object currentValues[] = new Object[2];
        PdfFont currentFont = null;
        Float lastBaseFactor = new Float(0);
        currentValues[1] = lastBaseFactor;
        PdfDocument pdf = null;
        PdfContentByte graphics = null;
        PdfContentByte text = null;
        firstLineY = Float.NaN;
        int localRunDirection = PdfWriter.RUN_DIRECTION_NO_BIDI;
        if (runDirection != PdfWriter.RUN_DIRECTION_DEFAULT)
            localRunDirection = runDirection;
        if (canvas != null) {
            graphics = canvas;
            pdf = canvas.getPdfDocument();
            text = canvas.getDuplicate();
        }
        else if (!simulate)
            throw new NullPointerException("ColumnText.go with simulate==false and text==null.");
        if (!simulate) {
            if (ratio == GLOBAL_SPACE_CHAR_RATIO)
                ratio = text.getPdfWriter().getSpaceCharRatio();
            else if (ratio < 0.001f)
                ratio = 0.001f;
        }
        float firstIndent = 0;
        
        int status = 0;
        if (rectangularMode) {
            for (;;) {
                firstIndent = (lastWasNewline ? indent : followingIndent);
                if (rectangularWidth <= firstIndent + rightIndent) {
                    status = NO_MORE_COLUMN;
                    if (bidiLine.isEmpty())
                        status |= NO_MORE_TEXT;
                    break;
                }
                if (bidiLine.isEmpty()) {
                    status = NO_MORE_TEXT;
                    break;
                }
                PdfLine line = bidiLine.processLine(rectangularWidth - firstIndent - rightIndent, alignment, localRunDirection, arabicOptions);
                if (line == null) {
                    status = NO_MORE_TEXT;
                    break;
                }
                float maxSize = line.getMaxSizeSimple();
                if (isUseAscender() && Float.isNaN(firstLineY)) {
                    currentLeading = line.getAscender();
                }
                else {
                    currentLeading = fixedLeading + maxSize * multipliedLeading;
                }
                if (yLine > maxY || yLine - currentLeading < minY ) {
                    status = NO_MORE_COLUMN;
                    bidiLine.restore();
                    break;
                }
                yLine -= currentLeading;
                if (!simulate && !dirty) {
                    text.beginText();
                    dirty = true;
                }
                if (Float.isNaN(firstLineY)) {
                    firstLineY = yLine;
                }
                if (!simulate) {
                    currentValues[0] = currentFont;
                    text.setTextMatrix(leftX + (line.isRTL() ? rightIndent : firstIndent) + line.indentLeft(), yLine);
                    pdf.writeLineToContent(line, text, graphics, currentValues, ratio);
                    currentFont = (PdfFont)currentValues[0];
                }
                lastWasNewline = line.isNewlineSplit();
                yLine -= line.isNewlineSplit() ? extraParagraphSpace : 0;
                ++linesWritten;
                descender = line.getDescender();
            }
        }
        else {
            currentLeading = fixedLeading;
            for (;;) {
                firstIndent = (lastWasNewline ? indent : followingIndent);
                float yTemp = yLine;
                float xx[] = findLimitsTwoLines();
                if (xx == null) {
                    status = NO_MORE_COLUMN;
                    if (bidiLine.isEmpty())
                        status |= NO_MORE_TEXT;
                    yLine = yTemp;
                    break;
                }
                if (bidiLine.isEmpty()) {
                    status = NO_MORE_TEXT;
                    yLine = yTemp;
                    break;
                }
                float x1 = Math.max(xx[0], xx[2]);
                float x2 = Math.min(xx[1], xx[3]);
                if (x2 - x1 <= firstIndent + rightIndent)
                    continue;
                if (!simulate && !dirty) {
                    text.beginText();
                    dirty = true;
                }
                PdfLine line = bidiLine.processLine(x2 - x1 - firstIndent - rightIndent, alignment, localRunDirection, arabicOptions);
                if (line == null) {
                    status = NO_MORE_TEXT;
                    yLine = yTemp;
                    break;
                }
                if (!simulate) {
                    currentValues[0] = currentFont;
                    text.setTextMatrix(x1 + (line.isRTL() ? rightIndent : firstIndent) + line.indentLeft(), yLine);
                    pdf.writeLineToContent(line, text, graphics, currentValues, ratio);
                    currentFont = (PdfFont)currentValues[0];
                }
                lastWasNewline = line.isNewlineSplit();
                yLine -= line.isNewlineSplit() ? extraParagraphSpace : 0;
                ++linesWritten;
                descender = line.getDescender();
            }
        }
        if (dirty) {
            text.endText();
            canvas.add(text);
        }
        return status;
    }
    
    /**
     * Sets the extra space between paragraphs.
     * @return the extra space between paragraphs
     */
    public float getExtraParagraphSpace() {
        return extraParagraphSpace;
    }
    
    /**
     * Sets the extra space between paragraphs.
     * @param extraParagraphSpace the extra space between paragraphs
     */
    public void setExtraParagraphSpace(float extraParagraphSpace) {
        this.extraParagraphSpace = extraParagraphSpace;
    }
    
    /**
     * Clears the chunk array. A call to <CODE>go()</CODE> will always return
     * NO_MORE_TEXT.
     */
    public void clearChunks() {
        if (bidiLine != null)
            bidiLine.clearChunks();
    }
    
    /** Gets the space/character extra spacing ratio for
     * fully justified text.
     * @return the space/character extra spacing ratio
     */    
    public float getSpaceCharRatio() {
        return spaceCharRatio;
    }
    
    /** Sets the ratio between the extra word spacing and the extra character spacing
     * when the text is fully justified.
     * Extra word spacing will grow <CODE>spaceCharRatio</CODE> times more than extra character spacing.
     * If the ratio is <CODE>PdfWriter.NO_SPACE_CHAR_RATIO</CODE> then the extra character spacing
     * will be zero.
     * @param spaceCharRatio the ratio between the extra word spacing and the extra character spacing
     */
    public void setSpaceCharRatio(float spaceCharRatio) {
        this.spaceCharRatio = spaceCharRatio;
    }

    /** Sets the run direction. 
     * @param runDirection the run direction
     */    
    public void setRunDirection(int runDirection) {
        if (runDirection < PdfWriter.RUN_DIRECTION_DEFAULT || runDirection > PdfWriter.RUN_DIRECTION_RTL)
            throw new RuntimeException("Invalid run direction: " + runDirection);
        this.runDirection = runDirection;
    }
    
    /** Gets the run direction.
     * @return the run direction
     */    
    public int getRunDirection() {
        return runDirection;
    }
    
    /** Gets the number of lines written.
     * @return the number of lines written
     */
    public int getLinesWritten() {
        return this.linesWritten;
    }
    
    /** Gets the arabic shaping options.
     * @return the arabic shaping options
     */
    public int getArabicOptions() {
        return this.arabicOptions;
    }
    
    /** Sets the arabic shaping options. The option can be AR_NOVOWEL,
     * AR_COMPOSEDTASHKEEL and AR_LIG.
     * @param arabicOptions the arabic shaping options
     */
    public void setArabicOptions(int arabicOptions) {
        this.arabicOptions = arabicOptions;
    }
    
    /** Gets the biggest descender value of the last line written.
     * @return the biggest descender value of the last line written
     */    
    public float getDescender() {
        return descender;
    }
    
    /** Gets the width that the line will occupy after writing.
     * Only the width of the first line is returned.
     * @param phrase the <CODE>Phrase</CODE> containing the line
     * @param runDirection the run direction
     * @param arabicOptions the options for the arabic shaping
     * @return the width of the line
     */    
    public static float getWidth(Phrase phrase, int runDirection, int arabicOptions) {
        ColumnText ct = new ColumnText(null);
        ct.addText(phrase);
        ct.addWaitingPhrase();
        PdfLine line = ct.bidiLine.processLine(20000, Element.ALIGN_LEFT, runDirection, arabicOptions);
        if (line == null)
            return 0;
        else
            return 20000 - line.widthLeft();
    }
    
    /** Gets the width that the line will occupy after writing.
     * Only the width of the first line is returned.
     * @param phrase the <CODE>Phrase</CODE> containing the line
     * @return the width of the line
     */    
    public static float getWidth(Phrase phrase) {
        return getWidth(phrase, PdfWriter.RUN_DIRECTION_NO_BIDI, 0);
    }
    
    /** Shows a line of text. Only the first line is written.
     * @param canvas where the text is to be written to
     * @param alignment the alignment. It is not influenced by the run direction
     * @param phrase the <CODE>Phrase</CODE> with the text
     * @param x the x reference position
     * @param y the y reference position
     * @param rotation the rotation to be applied in degrees counterclockwise
     * @param runDirection the run direction
     * @param arabicOptions the options for the arabic shaping
     */    
    public static void showTextAligned(PdfContentByte canvas, int alignment, Phrase phrase, float x, float y, float rotation, int runDirection, int arabicOptions) {
        if (alignment != Element.ALIGN_LEFT && alignment != Element.ALIGN_CENTER
            && alignment != Element.ALIGN_RIGHT)
            alignment = Element.ALIGN_LEFT;
        canvas.saveState();
        ColumnText ct = new ColumnText(canvas);
        if (rotation == 0) {
            if (alignment == Element.ALIGN_LEFT)
                ct.setSimpleColumn(phrase, x, y - 1, 20000 + x, y + 2, 2, alignment);
            else if (alignment == Element.ALIGN_RIGHT)
                ct.setSimpleColumn(phrase, x-20000, y-1, x, y+2, 2, alignment);
            else
                ct.setSimpleColumn(phrase, x-20000, y-1, x+20000, y+2, 2, alignment);
        }
        else {
            double alpha = rotation * Math.PI / 180.0;
            float cos = (float)Math.cos(alpha);
            float sin = (float)Math.sin(alpha);
            canvas.concatCTM(cos, sin, -sin, cos, x, y);
            if (alignment == Element.ALIGN_LEFT)
                ct.setSimpleColumn(phrase, 0, -1, 20000, 2, 2, alignment);
            else if (alignment == Element.ALIGN_RIGHT)
                ct.setSimpleColumn(phrase, -20000, -1, 0, 2, 2, alignment);
            else
                ct.setSimpleColumn(phrase, -20000, -1, 20000, 2, 2, alignment);
        }
        if (runDirection == PdfWriter.RUN_DIRECTION_RTL) {
            if (alignment == Element.ALIGN_LEFT)
                alignment = Element.ALIGN_RIGHT;
            else if (alignment == Element.ALIGN_RIGHT)
                alignment = Element.ALIGN_LEFT;
        }
        ct.setAlignment(alignment);
        ct.setArabicOptions(arabicOptions);
        ct.setRunDirection(runDirection);
        try {
            ct.go();
        }
        catch (DocumentException e) {
            throw new ExceptionConverter(e);
        }
        canvas.restoreState();
    }

    /** Shows a line of text. Only the first line is written.
     * @param canvas where the text is to be written to
     * @param alignment the alignment
     * @param phrase the <CODE>Phrase</CODE> with the text
     * @param x the x reference position
     * @param y the y reference position
     * @param rotation the rotation to be applied in degrees counterclockwise
     */    
    public static void showTextAligned(PdfContentByte canvas, int alignment, Phrase phrase, float x, float y, float rotation) {
        showTextAligned(canvas, alignment, phrase, x, y, rotation, PdfWriter.RUN_DIRECTION_NO_BIDI, 0);
    }

    protected int goComposite(boolean simulate) throws DocumentException {
        if (!rectangularMode)
            throw new DocumentException("Irregular columns are not supported in composite mode.");
        linesWritten = 0;
        descender = 0;
        boolean firstPass = true;
        main_loop:
        while (true) {
            if (compositeElements.isEmpty())
                return NO_MORE_TEXT;
            Element element = (Element)compositeElements.getFirst();
            if (element.type() == Element.PARAGRAPH) {
                Paragraph para = (Paragraph)element;
                int status = 0;
                for (int keep = 0; keep < 2; ++keep) {
                    float lastY = yLine;
                    boolean createHere = false;
                    if (compositeColumn == null) {
                        compositeColumn = new ColumnText(canvas);
                        compositeColumn.setUseAscender(firstPass ? useAscender : false);
                        compositeColumn.setAlignment(para.alignment());
                        compositeColumn.setIndent(para.indentationLeft() + para.getFirstLineIndent());
                        compositeColumn.setExtraParagraphSpace(para.getExtraParagraphSpace());
                        compositeColumn.setFollowingIndent(para.indentationLeft());
                        compositeColumn.setRightIndent(para.indentationRight());
                        compositeColumn.setLeading(para.leading(), para.getMultipliedLeading());
                        compositeColumn.setRunDirection(runDirection);
                        compositeColumn.setArabicOptions(arabicOptions);
                        compositeColumn.setSpaceCharRatio(spaceCharRatio);
                        compositeColumn.addText(para);
                        if (!firstPass) {
                            yLine -= para.spacingBefore();
                        }
                        createHere = true;
                    }
                    compositeColumn.leftX = leftX;
                    compositeColumn.rightX = rightX;
                    compositeColumn.yLine = yLine;
                    compositeColumn.rectangularWidth = rectangularWidth;
                    compositeColumn.rectangularMode = rectangularMode;
                    compositeColumn.minY = minY;
                    compositeColumn.maxY = maxY;
                    boolean keepCandidate = (para.getKeepTogether() && createHere && !firstPass);
                    status = compositeColumn.go(simulate || (keepCandidate && keep == 0));
                    if ((status & NO_MORE_TEXT) == 0 && keepCandidate) {
                        compositeColumn = null;
                        yLine = lastY;
                        return NO_MORE_COLUMN;
                    }
                    if (simulate || !keepCandidate)
                        break;
                    if (keep == 0) {
                        compositeColumn = null;
                        yLine = lastY;
                    }
                }
                firstPass = false;
                yLine = compositeColumn.yLine;
                linesWritten += compositeColumn.linesWritten;
                descender = compositeColumn.descender;
                if ((status & NO_MORE_TEXT) != 0) {
                    compositeColumn = null;
                    compositeElements.removeFirst();
                    yLine -= para.spacingAfter();
                }
                if ((status & NO_MORE_COLUMN) != 0) {
                    return NO_MORE_COLUMN;
                }
            }
            else if (element.type() == Element.LIST) {
                pdftk.com.lowagie.text.List list = (pdftk.com.lowagie.text.List)element;
                ArrayList items = list.getItems();
                ListItem item = null;
                float listIndentation = list.indentationLeft();
                int count = 0;
                Stack stack = new Stack();
                for (int k = 0; k < items.size(); ++k) {
                    Object obj = items.get(k);
                    if (obj instanceof ListItem) {
                        if (count == listIdx) {
                            item = (ListItem)obj;
                            break;
                        }
                        else ++count;
                    }
                    else if (obj instanceof pdftk.com.lowagie.text.List) {
                        stack.push(new Object[]{list, new Integer(k), new Float(listIndentation)});
                        list = (pdftk.com.lowagie.text.List)obj;
                        items = list.getItems();
                        listIndentation += list.indentationLeft();
                        k = -1;
                        continue;
                    }
                    if (k == items.size() - 1) {
                        if (!stack.isEmpty()) {
                            Object objs[] = (Object[])stack.pop();
                            list = (pdftk.com.lowagie.text.List)objs[0];
                            items = list.getItems();
                            k = ((Integer)objs[1]).intValue();
                            listIndentation = ((Float)objs[2]).floatValue();
                        }
                    }
                }
                int status = 0;
                for (int keep = 0; keep < 2; ++keep) {
                    float lastY = yLine;
                    boolean createHere = false;
                    if (compositeColumn == null) {
                        if (item == null) {
                            listIdx = 0;
                            compositeElements.removeFirst();
                            continue main_loop;
                        }
                        compositeColumn = new ColumnText(canvas);
                        compositeColumn.setUseAscender(firstPass ? useAscender : false);
                        compositeColumn.setAlignment(item.alignment());
                        compositeColumn.setIndent(item.indentationLeft() + listIndentation + item.getFirstLineIndent());
                        compositeColumn.setExtraParagraphSpace(item.getExtraParagraphSpace());
                        compositeColumn.setFollowingIndent(compositeColumn.getIndent());
                        compositeColumn.setRightIndent(item.indentationRight() + list.indentationRight());
                        compositeColumn.setLeading(item.leading(), item.getMultipliedLeading());
                        compositeColumn.setRunDirection(runDirection);
                        compositeColumn.setArabicOptions(arabicOptions);
                        compositeColumn.setSpaceCharRatio(spaceCharRatio);
                        compositeColumn.addText(item);
                        if (!firstPass) {
                            yLine -= item.spacingBefore();
                        }
                        createHere = true;
                    }
                    compositeColumn.leftX = leftX;
                    compositeColumn.rightX = rightX;
                    compositeColumn.yLine = yLine;
                    compositeColumn.rectangularWidth = rectangularWidth;
                    compositeColumn.rectangularMode = rectangularMode;
                    compositeColumn.minY = minY;
                    compositeColumn.maxY = maxY;
                    boolean keepCandidate = (item.getKeepTogether() && createHere && !firstPass);
                    status = compositeColumn.go(simulate || (keepCandidate && keep == 0));
                    if ((status & NO_MORE_TEXT) == 0 && keepCandidate) {
                        compositeColumn = null;
                        yLine = lastY;
                        return NO_MORE_COLUMN;
                    }
                    if (simulate || !keepCandidate)
                        break;
                    if (keep == 0) {
                        compositeColumn = null;
                        yLine = lastY;
                    }
                }
                firstPass = false;
                yLine = compositeColumn.yLine;
                linesWritten += compositeColumn.linesWritten;
                descender = compositeColumn.descender;
                if (!Float.isNaN(compositeColumn.firstLineY) && !compositeColumn.firstLineYDone) {
                    if (!simulate)
                        showTextAligned(canvas, Element.ALIGN_LEFT, new Phrase(item.listSymbol()), compositeColumn.leftX + listIndentation, compositeColumn.firstLineY, 0);
                    compositeColumn.firstLineYDone = true;
                }
                if ((status & NO_MORE_TEXT) != 0) {
                    compositeColumn = null;
                    ++listIdx;
                    yLine -= item.spacingAfter();
                }
                if ((status & NO_MORE_COLUMN) != 0) {
                    return NO_MORE_COLUMN;
                }
            }
	    /* ssteward: dropped in 1.44 
            else if (element.type() == Element.PTABLE) {
                if (yLine < minY || yLine > maxY)
                    return NO_MORE_COLUMN;
                PdfPTable table = (PdfPTable)element;
                if (table.size() <= table.getHeaderRows()) {
                    compositeElements.removeFirst();
                    continue;
                }
                float yTemp = yLine;
                float yLineWrite = yLine;
                if (!firstPass && listIdx == 0) {
                    yTemp -= table.spacingBefore();
                    yLineWrite = yTemp;
                }
                currentLeading = 0;
                if (yTemp < minY || yTemp > maxY)
                    return NO_MORE_COLUMN;
                float x1 = leftX;
                float tableWidth;
                if (table.isLockedWidth())
                    tableWidth = table.getTotalWidth();
                else {
                    tableWidth = rectangularWidth * table.getWidthPercentage() / 100f;
                    table.setTotalWidth(tableWidth);
                }
                int k;
                boolean skipHeader = (!firstPass && table.isSkipFirstHeader() && listIdx <= table.getHeaderRows());
                if (!skipHeader) {
                    yTemp -= table.getHeaderHeight();
                    if (yTemp < minY || yTemp > maxY) {
                        if (firstPass) {
                            compositeElements.removeFirst();
                            continue;
                        }
                        return NO_MORE_COLUMN;
                    }
                }
                if (listIdx < table.getHeaderRows())
                    listIdx = table.getHeaderRows();
                for (k = listIdx; k < table.size(); ++k) {
                    float rowHeight = table.getRowHeight(k);
                    if (yTemp - rowHeight < minY)
                        break;
                    yTemp -= rowHeight;
                }
                if (k < table.size()) {
                    if (table.isSplitRows() && (!table.isSplitLate() || (k == listIdx && firstPass))) {
                        if (!splittedRow) {
                            splittedRow = true;
                            table = new PdfPTable(table);
                            compositeElements.set(0, table);
                            ArrayList rows = table.getRows();
                            for (int i = table.getHeaderRows(); i < listIdx; ++i)
                                rows.set(i, null);
                        }
                        float h = yTemp - minY;
                        PdfPRow newRow = table.getRow(k).splitRow(h);
                        if (newRow == null) {
                            if (k == listIdx)
                                return NO_MORE_COLUMN;
                        }
                        else {
                            yTemp = minY;
                            table.getRows().add(++k, newRow);
                        }
                    }
                    else if (!table.isSplitRows() && k == listIdx && firstPass) {
                        compositeElements.removeFirst();
                        splittedRow = false;
                        continue;
                    }
                    else if (k == listIdx && !firstPass && (!table.isSplitRows() || table.isSplitLate())) {
                            return NO_MORE_COLUMN;
                    }
                }
                firstPass = false;
                if (!simulate) {
                    switch (table.getHorizontalAlignment()) {
                        case Element.ALIGN_LEFT:
                            break;
                        case Element.ALIGN_RIGHT:
                            x1 += rectangularWidth - tableWidth;
                            break;
                        default:
                            x1 += (rectangularWidth - tableWidth) / 2f;
                    }
                    PdfPTable nt = PdfPTable.shallowCopy(table);
                    ArrayList rows = table.getRows();
                    ArrayList sub = nt.getRows();
                    if (!skipHeader) {
                        for (int j = 0; j < table.getHeaderRows(); ++j)
                            sub.add(rows.get(j));
                    }
                    else
                        nt.setHeaderRows(0);
                    for (int j = listIdx; j < k; ++j)
                        sub.add(rows.get(j));
                    float rowHeight = 0;
                    if (table.isExtendLastRow()) {
                        PdfPRow last = (PdfPRow)sub.get(sub.size() - 1);
                        rowHeight = last.getMaxHeights();
                        last.setMaxHeights(yTemp - minY + rowHeight);
                        yTemp = minY;
                    }
                    nt.writeSelectedRows(0, -1, x1, yLineWrite, canvas);
                    if (table.isExtendLastRow()) {
                        PdfPRow last = (PdfPRow)sub.get(sub.size() - 1);
                        last.setMaxHeights(rowHeight);
                    }
                }
                else if (table.isExtendLastRow() && minY > PdfPRow.BOTTOM_LIMIT)
                    yTemp = minY;
                yLine = yTemp;
                if (k >= table.size()) {
                    yLine -= table.spacingAfter();
                    compositeElements.removeFirst();
                    splittedRow = false;
                    listIdx = 0;
                }
                else {
                    if (splittedRow) {
                        ArrayList rows = table.getRows();
                        for (int i = listIdx; i < k; ++i)
                            rows.set(i, null);
                    }
                    listIdx = k;
                    return NO_MORE_COLUMN;
                }
            }
	    */
	    /* ssteward: dropped in 1.44
            else if (element.type() == Element.GRAPHIC) {
                if (!simulate) {
                    Graphic gr = (Graphic)element;
                    ByteBuffer bf = gr.getInternalBuffer();
                    ByteBuffer store = null;
                    if (bf.size() > 0) {
                        store = new ByteBuffer();
                        store.append(bf);
                        bf.reset();
                    }
                    gr.processAttributes(leftX, minY, rightX, maxY, yLine);
                    canvas.add(gr);
                    bf.reset();
                    if (store != null) {
                        bf.append(store);
                    }
                }
                compositeElements.removeFirst();
            }
	    */
            else
                compositeElements.removeFirst();
        }
    }
    
    /**
     * Gets the canvas.
     * @return a PdfContentByte.
     */
    public PdfContentByte getCanvas() {
        return canvas;
    }
    
    /**
     * Sets the canvas.
     * @param canvas
     */
    public void setCanvas(PdfContentByte canvas) {
        this.canvas = canvas;
        if (compositeColumn != null)
            compositeColumn.setCanvas(canvas);
    }
    
    /**
     * Checks if the element has a height of 0.
     * @return true or false
     */
    public boolean zeroHeightElement() {
        return composite == true && compositeElements.size() > 0 && ((Element)compositeElements.getFirst()).type() == Element.GRAPHIC;
    }

    /**
     * Checks if UseAscender is enabled/disabled.
     * @return true is the adjustment of the first line height is based on max ascender.
     */
    public boolean isUseAscender() {
        return useAscender;
    }

    /**
     * Enables/Disables adjustment of first line height based on max ascender.
     * @param use enable adjustment if true
     */
    public void setUseAscender(boolean use) {
        useAscender = use;
    }
} /*
 * $Id: Anchor.java,v 1.84 2005/05/03 13:03:49 blowagie Exp $
 * $Name:  $
 *
 * Copyright 1999, 2000, 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

import java.net.URL;
import java.net.MalformedURLException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Properties;

import pdftk.com.lowagie.text.markup.MarkupTags;
import pdftk.com.lowagie.text.markup.MarkupParser;

/**
 * An <CODE>Anchor</CODE> can be a reference or a destination of a reference.
 * <P>
 * An <CODE>Anchor</CODE> is a special kind of <CODE>Phrase</CODE>.
 * It is constructed in the same way.
 * <P>
 * Example:
 * <BLOCKQUOTE><PRE>
 * <STRONG>Anchor anchor = new Anchor("this is a link");</STRONG>
 * <STRONG>anchor.setName("LINK");</STRONG>
 * <STRONG>anchor.setReference("http://www.lowagie.com");</STRONG>
 * </PRE></BLOCKQUOTE>
 *
 * @see		Element
 * @see		Phrase
 */

public class Anchor extends Phrase implements TextElementArray, MarkupAttributes {
    
    // constant
    private static final long serialVersionUID = -852278536049236911L;

    // membervariables
    
/** This is the anchor tag. */
    public static final String ANCHOR = "anchor";
    
/** This is the name of the <CODE>Anchor</CODE>. */
    protected String name = null;
    
/** This is the reference of the <CODE>Anchor</CODE>. */
    protected String reference = null;
    
    // constructors
    
/**
 * Constructs an <CODE>Anchor</CODE> without specifying a leading.
 */
    
    public Anchor() {
        super(16);
    }
    
/**
 * Constructs an <CODE>Anchor</CODE> with a certain leading.
 *
 * @param	leading		the leading
 */
    
    public Anchor(float leading) {
        super(leading);
    }
    
/**
 * Constructs an <CODE>Anchor</CODE> with a certain <CODE>Chunk</CODE>.
 *
 * @param	chunk		a <CODE>Chunk</CODE>
 */
    
    public Anchor(Chunk chunk) {
        super(chunk);
    }
    
/**
 * Constructs an <CODE>Anchor</CODE> with a certain <CODE>String</CODE>.
 *
 * @param	string		a <CODE>String</CODE>
 */
    
    public Anchor(String string) {
        super(string);
    }
    
/**
 * Constructs an <CODE>Anchor</CODE> with a certain <CODE>String</CODE>
 * and a certain <CODE>Font</CODE>.
 *
 * @param	string		a <CODE>String</CODE>
 * @param	font		a <CODE>Font</CODE>
 */
    
    public Anchor(String string, Font font) {
        super(string, font);
    }
    
/**
 * Constructs an <CODE>Anchor</CODE> with a certain <CODE>Chunk</CODE>
 * and a certain leading.
 *
 * @param	leading		the leading
 * @param	chunk		a <CODE>Chunk</CODE>
 */
    
    public Anchor(float leading, Chunk chunk) {
        super(leading, chunk);
    }
    
/**
 * Constructs an <CODE>Anchor</CODE> with a certain leading
 * and a certain <CODE>String</CODE>.
 *
 * @param	leading		the leading
 * @param	string		a <CODE>String</CODE>
 */
    
    public Anchor(float leading, String string) {
        super(leading, string);
    }
    
/**
 * Constructs an <CODE>Anchor</CODE> with a certain leading,
 * a certain <CODE>String</CODE> and a certain <CODE>Font</CODE>.
 *
 * @param	leading		the leading
 * @param	string		a <CODE>String</CODE>
 * @param	font		a <CODE>Font</CODE>
 */
    
    public Anchor(float leading, String string, Font font) {
        super(leading, string, font);
    }
    
/**
 * Returns an <CODE>Anchor</CODE> that has been constructed taking in account
 * the value of some <VAR>attributes</VAR>.
 *
 * @param	attributes		Some attributes
 */
    
    public Anchor(Properties attributes) {
        this("", FontFactory.getFont(attributes));
        String value;
        if ((value = (String)attributes.remove(ElementTags.ITEXT)) != null) {
            Chunk chunk = new Chunk(value);
            if ((value = (String)attributes.remove(ElementTags.GENERICTAG)) != null) {
                chunk.setGenericTag(value);
            }
            add(chunk);
        }
        if ((value = (String)attributes.remove(ElementTags.LEADING)) != null) {
            setLeading(Float.valueOf(value + "f").floatValue());
        }
        else if ((value = (String)attributes.remove(MarkupTags.CSS_KEY_LINEHEIGHT)) != null) {
            setLeading(MarkupParser.parseLength(value));
        }
        if ((value = (String)attributes.remove(ElementTags.NAME)) != null) {
            setName(value);
        }
        if ((value = (String)attributes.remove(ElementTags.REFERENCE)) != null) {
            setReference(value);
        }
        if (attributes.size() > 0) setMarkupAttributes(attributes);
    }
    
    // implementation of the Element-methods
    
/**
 * Processes the element by adding it (or the different parts) to an
 * <CODE>ElementListener</CODE>.
 *
 * @param	listener	an <CODE>ElementListener</CODE>
 * @return	<CODE>true</CODE> if the element was processed successfully
 */
    
    public boolean process(ElementListener listener) {
        try {
            Chunk chunk;
            Iterator i = getChunks().iterator();
            boolean localDestination = (reference != null && reference.startsWith("#"));
            boolean notGotoOK = true;
            while (i.hasNext()) {
                chunk = (Chunk) i.next();
                if (name != null && notGotoOK && !chunk.isEmpty()) {
                    chunk.setLocalDestination(name);
                    notGotoOK = false;
                }
                if (localDestination) {
                    chunk.setLocalGoto(reference.substring(1));
                }
                listener.add(chunk);
            }
            return true;
        }
        catch(DocumentException de) {
            return false;
        }
    }
    
/**
 * Gets all the chunks in this element.
 *
 * @return	an <CODE>ArrayList</CODE>
 */
    
    public ArrayList getChunks() {
        ArrayList tmp = new ArrayList();
        Chunk chunk;
        Iterator i = iterator();
        boolean localDestination = (reference != null && reference.startsWith("#"));
        boolean notGotoOK = true;
        while (i.hasNext()) {
            chunk = (Chunk) i.next();
            if (name != null && notGotoOK && !chunk.isEmpty()) {
                chunk.setLocalDestination(name);
                notGotoOK = false;
            }
            if (localDestination) {
                chunk.setLocalGoto(reference.substring(1));
            }
            else if (reference != null)
                chunk.setAnchor(reference);
            tmp.add(chunk);
        }
        return tmp;
    }
    
/**
 * Gets the type of the text element.
 *
 * @return	a type
 */
    
    public int type() {
        return Element.ANCHOR;
    }
    
    // methods
    
/**
 * Gets an iterator of <CODE>Element</CODE>s.
 *
 * @return	an <CODE>Iterator</CODE>
 */
    
    // suggestion by by Curt Thompson
    public Iterator getElements() {
        return this.iterator();
    }
    
/**
 * Sets the name of this <CODE>Anchor</CODE>.
 *
 * @param	name		a new name
 */
    
    public void setName(String name) {
        this.name = name;
    }
    
/**
 * Sets the reference of this <CODE>Anchor</CODE>.
 *
 * @param	reference		a new reference
 */
    
    public void setReference(String reference) {
        this.reference = reference;
    }
    
    // methods to retrieve information
    
/**
 * Returns the name of this <CODE>Anchor</CODE>.
 *
 * @return	a name
 */
    
    public String name() {
        return name;
    }
    
/**
 * Gets the reference of this <CODE>Anchor</CODE>.
 *
 * @return	a reference
 */
    
    public String reference() {
        return reference;
    }
    
/**
 * Gets the reference of this <CODE>Anchor</CODE>.
 *
 * @return	an <CODE>URL</CODE>
 */
    
    public URL url() {
        try {
            return new URL(reference);
        }
        catch(MalformedURLException mue) {
            return null;
        }
    }
    
/**
 * Checks if a given tag corresponds with this object.
 *
 * @param   tag     the given tag
 * @return  true if the tag corresponds
 */
    
    public static boolean isTag(String tag) {
        return ElementTags.ANCHOR.equals(tag);
    }
}
 /*
 * $Id: Annotation.java,v 1.70 2005/04/13 09:17:09 blowagie Exp $
 * $Name:  $
 *
 * Copyright 1999, 2000, 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

import java.net.URL;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Properties;
import java.util.Set;

/**
 * An <CODE>Annotation</CODE> is a little note that can be added to a page on
 * a document.
 * 
 * @see Element
 * @see Anchor
 */

public class Annotation implements Element, MarkupAttributes {

	// membervariables

	/** This is a possible annotation type. */
	public static final int TEXT = 0;

	/** This is a possible annotation type. */
	public static final int URL_NET = 1;

	/** This is a possible annotation type. */
	public static final int URL_AS_STRING = 2;

	/** This is a possible annotation type. */
	public static final int FILE_DEST = 3;

	/** This is a possible annotation type. */
	public static final int FILE_PAGE = 4;

	/** This is a possible annotation type. */
	public static final int NAMED_DEST = 5;

	/** This is a possible annotation type. */
	public static final int LAUNCH = 6;

	/** This is a possible annotation type. */
	public static final int SCREEN = 7;

	/** This is a possible attribute. */
	public static String TITLE = "title";

	/** This is a possible attribute. */
	public static String CONTENT = "content";

	/** This is a possible attribute. */
	public static String URL = "url";

	/** This is a possible attribute. */
	public static String FILE = "file";

	/** This is a possible attribute. */
	public static String DESTINATION = "destination";

	/** This is a possible attribute. */
	public static String PAGE = "page";

	/** This is a possible attribute. */
	public static String NAMED = "named";

	/** This is a possible attribute. */
	public static String APPLICATION = "application";

	/** This is a possible attribute. */
	public static String PARAMETERS = "parameters";

	/** This is a possible attribute. */
	public static String OPERATION = "operation";

	/** This is a possible attribute. */
	public static String DEFAULTDIR = "defaultdir";

	/** This is a possible attribute. */
	public static String LLX = "llx";

	/** This is a possible attribute. */
	public static String LLY = "lly";

	/** This is a possible attribute. */
	public static String URX = "urx";

	/** This is a possible attribute. */
	public static String URY = "ury";

	/** This is a possible attribute. */
	public static String MIMETYPE = "mime";

	/** This is the type of annotation. */
	protected int annotationtype;

	/** This is the title of the <CODE>Annotation</CODE>. */
	protected HashMap annotationAttributes = new HashMap();

	/** Contains extra markupAttributes */
	protected Properties markupAttributes = null;

	/** This is the lower left x-value */
	protected float llx = Float.NaN;

	/** This is the lower left y-value */
	protected float lly = Float.NaN;

	/** This is the upper right x-value */
	protected float urx = Float.NaN;

	/** This is the upper right y-value */
	protected float ury = Float.NaN;

	// constructors

	/**
	 * Constructs an <CODE>Annotation</CODE> with a certain title and some
	 * text.
	 * 
	 * @param llx
	 *            lower left x coordinate
	 * @param lly
	 *            lower left y coordinate
	 * @param urx
	 *            upper right x coordinate
	 * @param ury
	 *            upper right y coordinate
	 */

	private Annotation(float llx, float lly, float urx, float ury) {
		this.llx = llx;
		this.lly = lly;
		this.urx = urx;
		this.ury = ury;
	}

    public Annotation(Annotation an) {
        annotationtype = an.annotationtype;
        annotationAttributes = an.annotationAttributes;
        markupAttributes = an.markupAttributes;
        llx = an.llx;
        lly = an.lly;
        urx = an.urx;
        ury = an.ury;
    }
    
	/**
	 * Constructs an <CODE>Annotation</CODE> with a certain title and some
	 * text.
	 * 
	 * @param title
	 *            the title of the annotation
	 * @param text
	 *            the content of the annotation
	 */

	public Annotation(String title, String text) {
		annotationtype = TEXT;
		annotationAttributes.put(TITLE, title);
		annotationAttributes.put(CONTENT, text);
	}

	/**
	 * Constructs an <CODE>Annotation</CODE> with a certain title and some
	 * text.
	 * 
	 * @param title
	 *            the title of the annotation
	 * @param text
	 *            the content of the annotation
	 * @param llx
	 *            the lower left x-value
	 * @param lly
	 *            the lower left y-value
	 * @param urx
	 *            the upper right x-value
	 * @param ury
	 *            the upper right y-value
	 */

	public Annotation(String title, String text, float llx, float lly,
			float urx, float ury) {
		this(llx, lly, urx, ury);
		annotationtype = TEXT;
		annotationAttributes.put(TITLE, title);
		annotationAttributes.put(CONTENT, text);
	}

	/**
	 * Constructs an <CODE>Annotation</CODE>.
	 * 
	 * @param llx
	 *            the lower left x-value
	 * @param lly
	 *            the lower left y-value
	 * @param urx
	 *            the upper right x-value
	 * @param ury
	 *            the upper right y-value
	 * @param url
	 *            the external reference
	 */

	public Annotation(float llx, float lly, float urx, float ury, URL url) {
		this(llx, lly, urx, ury);
		annotationtype = URL_NET;
		annotationAttributes.put(URL, url);
	}

	/**
	 * Constructs an <CODE>Annotation</CODE>.
	 * 
	 * @param llx
	 *            the lower left x-value
	 * @param lly
	 *            the lower left y-value
	 * @param urx
	 *            the upper right x-value
	 * @param ury
	 *            the upper right y-value
	 * @param url
	 *            the external reference
	 */

	public Annotation(float llx, float lly, float urx, float ury, String url) {
		this(llx, lly, urx, ury);
		annotationtype = URL_AS_STRING;
		annotationAttributes.put(FILE, url);
	}

	/**
	 * Constructs an <CODE>Annotation</CODE>.
	 * 
	 * @param llx
	 *            the lower left x-value
	 * @param lly
	 *            the lower left y-value
	 * @param urx
	 *            the upper right x-value
	 * @param ury
	 *            the upper right y-value
	 * @param file
	 *            an external PDF file
	 * @param dest
	 *            the destination in this file
	 */

	public Annotation(float llx, float lly, float urx, float ury, String file,
			String dest) {
		this(llx, lly, urx, ury);
		annotationtype = FILE_DEST;
		annotationAttributes.put(FILE, file);
		annotationAttributes.put(DESTINATION, dest);
	}

	/**
	 * Creates a Screen anotation to embed media clips
	 * 
	 * @param llx
	 * @param lly
	 * @param urx
	 * @param ury
	 * @param moviePath
	 *            path to the media clip file
	 * @param mimeType
	 *            mime type of the media
	 * @param showOnDisplay
	 *            if true play on display of the page
	 */
	public Annotation(float llx, float lly, float urx, float ury,
			String moviePath, String mimeType, boolean showOnDisplay) {
		this(llx, lly, urx, ury);
		annotationtype = SCREEN;
		annotationAttributes.put(FILE, moviePath);
		annotationAttributes.put(MIMETYPE, mimeType);
		annotationAttributes.put(PARAMETERS, new boolean[] {
				false /* embedded */, showOnDisplay });
	}

	/**
	 * Constructs an <CODE>Annotation</CODE>.
	 * 
	 * @param llx
	 *            the lower left x-value
	 * @param lly
	 *            the lower left y-value
	 * @param urx
	 *            the upper right x-value
	 * @param ury
	 *            the upper right y-value
	 * @param file
	 *            an external PDF file
	 * @param page
	 *            a page number in this file
	 */

	public Annotation(float llx, float lly, float urx, float ury, String file,
			int page) {
		this(llx, lly, urx, ury);
		annotationtype = FILE_PAGE;
		annotationAttributes.put(FILE, file);
		annotationAttributes.put(PAGE, new Integer(page));
	}

	/**
	 * Constructs an <CODE>Annotation</CODE>.
	 * 
	 * @param llx
	 *            the lower left x-value
	 * @param lly
	 *            the lower left y-value
	 * @param urx
	 *            the upper right x-value
	 * @param ury
	 *            the upper right y-value
	 * @param named
	 *            a named destination in this file
	 */

	public Annotation(float llx, float lly, float urx, float ury, int named) {
		this(llx, lly, urx, ury);
		annotationtype = NAMED_DEST;
		annotationAttributes.put(NAMED, new Integer(named));
	}

	/**
	 * Constructs an <CODE>Annotation</CODE>.
	 * 
	 * @param llx
	 *            the lower left x-value
	 * @param lly
	 *            the lower left y-value
	 * @param urx
	 *            the upper right x-value
	 * @param ury
	 *            the upper right y-value
	 * @param application
	 *            an external application
	 * @param parameters
	 *            parameters to pass to this application
	 * @param operation
	 *            the operation to pass to this application
	 * @param defaultdir
	 *            the default directory to run this application in
	 */

	public Annotation(float llx, float lly, float urx, float ury,
			String application, String parameters, String operation,
			String defaultdir) {
		this(llx, lly, urx, ury);
		annotationtype = LAUNCH;
		annotationAttributes.put(APPLICATION, application);
		annotationAttributes.put(PARAMETERS, parameters);
		annotationAttributes.put(OPERATION, operation);
		annotationAttributes.put(DEFAULTDIR, defaultdir);
	}

	/**
	 * Returns an <CODE>Annotation</CODE> that has been constructed taking in
	 * account the value of some <VAR>attributes </VAR>.
	 * 
	 * @param attributes
	 *            Some attributes
	 */

	public Annotation(Properties attributes) {
		String value = (String) attributes.remove(ElementTags.LLX);
		if (value != null) {
			llx = Float.valueOf(value + "f").floatValue();
		}
		value = (String) attributes.remove(ElementTags.LLY);
		if (value != null) {
			lly = Float.valueOf(value + "f").floatValue();
		}
		value = (String) attributes.remove(ElementTags.URX);
		if (value != null) {
			urx = Float.valueOf(value + "f").floatValue();
		}
		value = (String) attributes.remove(ElementTags.URY);
		if (value != null) {
			ury = Float.valueOf(value + "f").floatValue();
		}
		String title = (String) attributes.remove(ElementTags.TITLE);
		String text = (String) attributes.remove(ElementTags.CONTENT);
		if (title != null || text != null) {
			annotationtype = TEXT;
		} else if ((value = (String) attributes.remove(ElementTags.URL)) != null) {
			annotationtype = URL_AS_STRING;
			annotationAttributes.put(FILE, value);
		} else if ((value = (String) attributes.remove(ElementTags.NAMED)) != null) {
			annotationtype = NAMED_DEST;
			annotationAttributes.put(NAMED, Integer.valueOf(value));
		} else {
			String file = (String) attributes.remove(ElementTags.FILE);
			String destination = (String) attributes
					.remove(ElementTags.DESTINATION);
			String page = (String) attributes.remove(ElementTags.PAGE);
			if (file != null) {
				annotationAttributes.put(FILE, file);
				if (destination != null) {
					annotationtype = FILE_DEST;
					annotationAttributes.put(DESTINATION, destination);
				} else if (page != null) {
					annotationtype = FILE_PAGE;
					annotationAttributes.put(FILE, file);
					annotationAttributes.put(PAGE, Integer.valueOf(page));
				}
			} else if ((value = (String) attributes.remove(ElementTags.NAMED)) != null) {
				annotationtype = LAUNCH;
				annotationAttributes.put(APPLICATION, value);
				annotationAttributes.put(PARAMETERS, attributes
						.remove(ElementTags.PARAMETERS));
				annotationAttributes.put(OPERATION, attributes
						.remove(ElementTags.OPERATION));
				annotationAttributes.put(DEFAULTDIR, attributes
						.remove(ElementTags.DEFAULTDIR));
			}
		}
		if (annotationtype == TEXT) {
			if (title == null)
				title = "";
			if (text == null)
				text = "";
			annotationAttributes.put(TITLE, title);
			annotationAttributes.put(CONTENT, text);
		}
		if (attributes.size() > 0)
			setMarkupAttributes(attributes);
	}

	// implementation of the Element-methods

	/**
	 * Gets the type of the text element.
	 * 
	 * @return a type
	 */

	public int type() {
		return Element.ANNOTATION;
	}

	// methods

	/**
	 * Processes the element by adding it (or the different parts) to an <CODE>
	 * ElementListener</CODE>.
	 * 
	 * @param listener
	 *            an <CODE>ElementListener</CODE>
	 * @return <CODE>true</CODE> if the element was processed successfully
	 */

	public boolean process(ElementListener listener) {
		try {
			return listener.add(this);
		} catch (DocumentException de) {
			return false;
		}
	}

	/**
	 * Gets all the chunks in this element.
	 * 
	 * @return an <CODE>ArrayList</CODE>
	 */

	public ArrayList getChunks() {
		return new ArrayList();
	}

	// methods

	/**
	 * Sets the dimensions of this annotation.
	 * 
	 * @param llx
	 *            the lower left x-value
	 * @param lly
	 *            the lower left y-value
	 * @param urx
	 *            the upper right x-value
	 * @param ury
	 *            the upper right y-value
	 */

	public void setDimensions(float llx, float lly, float urx, float ury) {
		this.llx = llx;
		this.lly = lly;
		this.urx = urx;
		this.ury = ury;
	}

	// methods to retrieve information

	/**
	 * Returns the lower left x-value.
	 * 
	 * @return a value
	 */

	public float llx() {
		return llx;
	}

	/**
	 * Returns the lower left y-value.
	 * 
	 * @return a value
	 */

	public float lly() {
		return lly;
	}

	/**
	 * Returns the uppper right x-value.
	 * 
	 * @return a value
	 */

	public float urx() {
		return urx;
	}

	/**
	 * Returns the uppper right y-value.
	 * 
	 * @return a value
	 */

	public float ury() {
		return ury;
	}

	/**
	 * Returns the lower left x-value.
	 * 
	 * @param def
	 *            the default value
	 * @return a value
	 */

	public float llx(float def) {
		if (Float.isNaN(llx))
			return def;
		return llx;
	}

	/**
	 * Returns the lower left y-value.
	 * 
	 * @param def
	 *            the default value
	 * @return a value
	 */

	public float lly(float def) {
		if (Float.isNaN(lly))
			return def;
		return lly;
	}

	/**
	 * Returns the upper right x-value.
	 * 
	 * @param def
	 *            the default value
	 * @return a value
	 */

	public float urx(float def) {
		if (Float.isNaN(urx))
			return def;
		return urx;
	}

	/**
	 * Returns the upper right y-value.
	 * 
	 * @param def
	 *            the default value
	 * @return a value
	 */

	public float ury(float def) {
		if (Float.isNaN(ury))
			return def;
		return ury;
	}

	/**
	 * Returns the type of this <CODE>Annotation</CODE>.
	 * 
	 * @return a type
	 */

	public int annotationType() {
		return annotationtype;
	}

	/**
	 * Returns the title of this <CODE>Annotation</CODE>.
	 * 
	 * @return a name
	 */

	public String title() {
		String s = (String) annotationAttributes.get(TITLE);
		if (s == null)
			s = "";
		return s;
	}

	/**
	 * Gets the content of this <CODE>Annotation</CODE>.
	 * 
	 * @return a reference
	 */

	public String content() {
		String s = (String) annotationAttributes.get(CONTENT);
		if (s == null)
			s = "";
		return s;
	}

	/**
	 * Gets the content of this <CODE>Annotation</CODE>.
	 * 
	 * @return a reference
	 */

	public HashMap attributes() {
		return annotationAttributes;
	}

	/**
	 * Checks if a given tag corresponds with this object.
	 * 
	 * @param tag
	 *            the given tag
	 * @return true if the tag corresponds
	 */

	public static boolean isTag(String tag) {
		return ElementTags.ANNOTATION.equals(tag);
	}

	/**
	 * @see pdftk.com.lowagie.text.MarkupAttributes#setMarkupAttribute(java.lang.String,
	 *      java.lang.String)
	 */
	public void setMarkupAttribute(String name, String value) {
		if (markupAttributes == null) markupAttributes = new Properties();
		markupAttributes.put(name, value);
	}

	/**
	 * @see pdftk.com.lowagie.text.MarkupAttributes#setMarkupAttributes(java.util.Properties)
	 */
	public void setMarkupAttributes(Properties markupAttributes) {
		this.markupAttributes = markupAttributes;
	}

	/**
	 * @see pdftk.com.lowagie.text.MarkupAttributes#getMarkupAttribute(java.lang.String)
	 */
	public String getMarkupAttribute(String name) {
		return (markupAttributes == null) ? null : String
				.valueOf(markupAttributes.get(name));
	}

	/**
	 * @see pdftk.com.lowagie.text.MarkupAttributes#getMarkupAttributeNames()
	 */
	public Set getMarkupAttributeNames() {
		return Chunk.getKeySet(markupAttributes);
	}

	/**
	 * @see pdftk.com.lowagie.text.MarkupAttributes#getMarkupAttributes()
	 */
	public Properties getMarkupAttributes() {
		return markupAttributes;
	}
} /*
 * $Id: BadElementException.java,v 1.50 2004/12/14 11:33:49 blowagie Exp $
 * $Name:  $
 *
 * Copyright 1999, 2000, 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

/**
 * Signals an attempt to create an <CODE>Element</CODE> that hasn't got the right form.
 *
 * @see		DocumentException
 * @see		Cell
 * @see		Table
 */

public class BadElementException extends DocumentException {
    
    /** A serial version UID */
    private static final long serialVersionUID = -799006030723822254L;

    // constructors
    /**
     * Constructs a BadElementException
     * @param ex an Exception object that has to be turned into a BadElementException
     */
    public BadElementException(Exception ex) {
        super(ex);
    }
    
/**
 * Constructs a <CODE>BadElementException</CODE> whithout a message.
 */
    
    BadElementException() {
        super();
    }
    
/**
 * Constructs a <code>BadElementException</code> with a message.
 *
 * @param		message			a message describing the exception
 */
    
    public BadElementException(String message) {
        super(message);
    }
}
 /*
 * $Id: Chunk.java,v 1.112 2005/10/05 07:23:47 blowagie Exp $
 * $Name:  $
 *
 * Copyright 1999, 2000, 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

import java.awt.Color;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Properties;
import java.util.Set;
import java.net.URL;

import pdftk.com.lowagie.text.pdf.PdfAction;
import pdftk.com.lowagie.text.pdf.PdfAnnotation;
import pdftk.com.lowagie.text.pdf.HyphenationEvent;
import pdftk.com.lowagie.text.pdf.PdfContentByte;
import pdftk.com.lowagie.text.markup.MarkupTags;
import pdftk.com.lowagie.text.markup.MarkupParser;

/**
 * This is the smallest significant part of text that can be added to a
 * document.
 * <P>
 * Most elements can be divided in one or more <CODE>Chunk</CODE>s. A chunk
 * is a <CODE>String</CODE> with a certain <CODE>Font</CODE>. all other
 * layoutparameters should be defined in the object to which this chunk of text
 * is added.
 * <P>
 * Example: <BLOCKQUOTE>
 * 
 * <PRE>
 * 
 * <STRONG>Chunk chunk = new Chunk("Hello world",
 * FontFactory.getFont(FontFactory.COURIER, 20, Font.ITALIC, new Color(255, 0,
 * 0))); </STRONG> document.add(chunk);
 * 
 * </PRE>
 * 
 * </BLOCKQUOTE>
 */

public class Chunk implements Element, MarkupAttributes {

	// public static membervariables

	/**
	 * The character stand in for an image.
	 */
	public static final String OBJECT_REPLACEMENT_CHARACTER = "\ufffc";

	/** This is a Chunk containing a newline. */
	public static final Chunk NEWLINE = new Chunk("\n");

	/** This is a Chunk containing a newpage. */
	public static final Chunk NEXTPAGE = new Chunk("");
	static {
		NEXTPAGE.setNewPage();
	}

	/** Key for sub/superscript. */
	public static final String SUBSUPSCRIPT = "SUBSUPSCRIPT";

	/** Key for underline. */
	public static final String UNDERLINE = "UNDERLINE";

	/** Key for color. */
	public static final String COLOR = "COLOR";

	/** Key for encoding. */
	public static final String ENCODING = "ENCODING";

	/** Key for remote goto. */
	public static final String REMOTEGOTO = "REMOTEGOTO";

	/** Key for local goto. */
	public static final String LOCALGOTO = "LOCALGOTO";

	/** Key for local destination. */
	public static final String LOCALDESTINATION = "LOCALDESTINATION";

	/** Key for image. */
	public static final String IMAGE = "IMAGE";

	/** Key for generic tag. */
	public static final String GENERICTAG = "GENERICTAG";

	/** Key for newpage. */
	public static final String NEWPAGE = "NEWPAGE";

	/** Key for split character. */
	public static final String SPLITCHARACTER = "SPLITCHARACTER";

	/** Key for Action. */
	public static final String ACTION = "ACTION";

	/** Key for background. */
	public static final String BACKGROUND = "BACKGROUND";

	/** Key for annotation. */
	public static final String PDFANNOTATION = "PDFANNOTATION";

	/** Key for hyphenation. */
	public static final String HYPHENATION = "HYPHENATION";

	/** Key for text rendering mode. */
	public static final String TEXTRENDERMODE = "TEXTRENDERMODE";

	/** Key for text skewing. */
	public static final String SKEW = "SKEW";

	/** Key for text horizontal scaling. */
	public static final String HSCALE = "HSCALE";

	// member variables

	/** This is the content of this chunk of text. */
	protected StringBuffer content = null;

	/** This is the <CODE>Font</CODE> of this chunk of text. */
	protected Font font = null;

	/** Contains some of the attributes for this Chunk. */
	protected HashMap attributes = null;

	/** Contains extra markupAttributes */
	protected Properties markupAttributes = null;

	// constructors

	/**
	 * Empty constructor.
	 */
	protected Chunk() {
	}

	/**
	 * Constructs a chunk of text with a certain content and a certain <CODE>
	 * Font</CODE>.
	 * 
	 * @param content
	 *            the content
	 * @param font
	 *            the font
	 */

	public Chunk(String content, Font font) {
		this.content = new StringBuffer(content);
		this.font = font;
	}

	/**
	 * Constructs a chunk of text with a certain content, without specifying a
	 * <CODE>Font</CODE>.
	 * 
	 * @param content
	 *            the content
	 */
	public Chunk(String content) {
		this(content, new Font());
	}

	/**
	 * Constructs a chunk of text with a char and a certain <CODE>Font</CODE>.
	 * 
	 * @param c
	 *            the content
	 * @param font
	 *            the font
	 */
	public Chunk(char c, Font font) {
		this.content = new StringBuffer();
		this.content.append(c);
		this.font = font;
	}

	/**
	 * Constructs a chunk of text with a char, without specifying a <CODE>Font
	 * </CODE>.
	 * 
	 * @param c
	 *            the content
	 */
	public Chunk(char c) {
		this(c, new Font());
	}

	/**
	 * Constructs a chunk containing an <CODE>Image</CODE>.
	 * 
	 * @param image
	 *            the image
	 * @param offsetX
	 *            the image offset in the x direction
	 * @param offsetY
	 *            the image offset in the y direction
	 */
    /* ssteward: dropped in 1.44
	public Chunk(Image image, float offsetX, float offsetY) {
		this(OBJECT_REPLACEMENT_CHARACTER, new Font());
		Image copyImage = Image.getInstance(image);
		copyImage.setAbsolutePosition(Float.NaN, Float.NaN);
		setAttribute(IMAGE, new Object[] { copyImage, new Float(offsetX),
				new Float(offsetY), new Boolean(false) });
	}
    */

	/**
	 * Constructs a chunk containing an <CODE>Image</CODE>.
	 * 
	 * @param image
	 *            the image
	 * @param offsetX
	 *            the image offset in the x direction
	 * @param offsetY
	 *            the image offset in the y direction
	 * @param changeLeading
	 *            true if the leading has to be adapted to the image
	 */
    /* ssteward: dropped in 1.44
	public Chunk(Image image, float offsetX, float offsetY,
			boolean changeLeading) {
		this(OBJECT_REPLACEMENT_CHARACTER, new Font());
		setAttribute(IMAGE, new Object[] { image, new Float(offsetX),
				new Float(offsetY), new Boolean(changeLeading) });
	}
    */
	/**
	 * Returns a <CODE>Chunk</CODE> that has been constructed taking in
	 * account the value of some <VAR>attributes </VAR>.
	 * 
	 * @param attributes
	 *            Some attributes
	 */

	public Chunk(Properties attributes) {
		this("", FontFactory.getFont(attributes));
		String value;
		if ((value = (String) attributes.remove(ElementTags.ITEXT)) != null) {
			append(value);
		}
		if ((value = (String) attributes.remove(ElementTags.LOCALGOTO)) != null) {
			setLocalGoto(value);
		}
		if ((value = (String) attributes.remove(ElementTags.REMOTEGOTO)) != null) {
			String destination = (String) attributes
					.remove(ElementTags.DESTINATION);
			String page = (String) attributes.remove(ElementTags.PAGE);
			if (page != null) {
				setRemoteGoto(value, Integer.valueOf(page).intValue());
			} else if (destination != null) {
				setRemoteGoto(value, destination);
			}
		}
		if ((value = (String) attributes.remove(ElementTags.LOCALDESTINATION)) != null) {
			setLocalDestination(value);
		}
		if ((value = (String) attributes.remove(ElementTags.SUBSUPSCRIPT)) != null) {
			setTextRise(Float.valueOf(value + "f").floatValue());
		}
		if ((value = (String) attributes
				.remove(MarkupTags.CSS_KEY_VERTICALALIGN)) != null
				&& value.endsWith("%")) {
			float p = Float.valueOf(
					value.substring(0, value.length() - 1) + "f").floatValue() / 100f;
			setTextRise(p * font.size());
		}
		if ((value = (String) attributes.remove(ElementTags.GENERICTAG)) != null) {
			setGenericTag(value);
		}
		if ((value = (String) attributes.remove(ElementTags.BACKGROUNDCOLOR)) != null) {
			setBackground(MarkupParser.decodeColor(value));
		}
		if (attributes.size() > 0)
			setMarkupAttributes(attributes);
	}

	// implementation of the Element-methods

	/**
	 * Processes the element by adding it (or the different parts) to an <CODE>
	 * ElementListener</CODE>.
	 * 
	 * @param listener
	 *            an <CODE>ElementListener</CODE>
	 * @return <CODE>true</CODE> if the element was processed successfully
	 */

	public boolean process(ElementListener listener) {
		try {
			return listener.add(this);
		} catch (DocumentException de) {
			return false;
		}
	}

	/**
	 * Gets the type of the text element.
	 * 
	 * @return a type
	 */

	public int type() {
		return Element.CHUNK;
	}

	/**
	 * Gets all the chunks in this element.
	 * 
	 * @return an <CODE>ArrayList</CODE>
	 */

	public ArrayList getChunks() {
		ArrayList tmp = new ArrayList();
		tmp.add(this);
		return tmp;
	}

	// methods

	/**
	 * appends some text to this <CODE>Chunk</CODE>.
	 * 
	 * @param string
	 *            <CODE>String</CODE>
	 * @return a <CODE>StringBuffer</CODE>
	 */

	public StringBuffer append(String string) {
		return content.append(string);
	}

	// methods to retrieve information

	/**
	 * Gets the font of this <CODE>Chunk</CODE>.
	 * 
	 * @return a <CODE>Font</CODE>
	 */

	public Font font() {
		return font;
	}

	/**
	 * Sets the font of this <CODE>Chunk</CODE>.
	 * 
	 * @param font
	 *            a <CODE>Font</CODE>
	 */

	public void setFont(Font font) {
		this.font = font;
	}

	/**
	 * Returns the content of this <CODE>Chunk</CODE>.
	 * 
	 * @return a <CODE>String</CODE>
	 */

	public String content() {
		return content.toString();
	}

	/**
	 * Returns the content of this <CODE>Chunk</CODE>.
	 * 
	 * @return a <CODE>String</CODE>
	 */

	public String toString() {
		return content.toString();
	}

	/**
	 * Checks is this <CODE>Chunk</CODE> is empty.
	 * 
	 * @return <CODE>false</CODE> if the Chunk contains other characters than
	 *         space.
	 */

	public boolean isEmpty() {
		return (content.toString().trim().length() == 0)
				&& (content.toString().indexOf("\n") == -1)
				&& (attributes == null);
	}

	/**
	 * Gets the width of the Chunk in points.
	 * 
	 * @return a width in points
	 */
	public float getWidthPoint() {
	    /* ssteward: dropped in 1.44
		if (getImage() != null) {
			return getImage().scaledWidth();
		}
	    */
		return font.getCalculatedBaseFont(true).getWidthPoint(content(),
				font.getCalculatedSize())
				* getHorizontalScaling();
	}

	/**
	 * Sets the text displacement relative to the baseline. Positive values rise
	 * the text, negative values lower the text.
	 * <P>
	 * It can be used to implement sub/superscript.
	 * 
	 * @param rise
	 *            the displacement in points
	 * @return this <CODE>Chunk</CODE>
	 */

	public Chunk setTextRise(float rise) {
		return setAttribute(SUBSUPSCRIPT, new Float(rise));
	}

	/**
	 * Gets the text displacement relatiev to the baseline.
	 * 
	 * @return a displacement in points
	 */
	public float getTextRise() {
		if (attributes.containsKey(SUBSUPSCRIPT)) {
			Float f = (Float) attributes.get(SUBSUPSCRIPT);
			return f.floatValue();
		}
		return 0.0f;
	}

	/**
	 * Sets the text rendering mode. It can outline text, simulate bold and make
	 * text invisible.
	 * 
	 * @param mode
	 *            the text rendering mode. It can be <CODE>
	 *            PdfContentByte.TEXT_RENDER_MODE_FILL</CODE>,<CODE>
	 *            PdfContentByte.TEXT_RENDER_MODE_STROKE</CODE>,<CODE>
	 *            PdfContentByte.TEXT_RENDER_MODE_FILL_STROKE</CODE> and <CODE>
	 *            PdfContentByte.TEXT_RENDER_MODE_INVISIBLE</CODE>.
	 * @param strokeWidth
	 *            the stroke line width for the modes <CODE>
	 *            PdfContentByte.TEXT_RENDER_MODE_STROKE</CODE> and <CODE>
	 *            PdfContentByte.TEXT_RENDER_MODE_FILL_STROKE</CODE>.
	 * @param strokeColor
	 *            the stroke color or <CODE>null</CODE> to follow the text
	 *            color
	 * @return this <CODE>Chunk</CODE>
	 */
	public Chunk setTextRenderMode(int mode, float strokeWidth,
			Color strokeColor) {
		return setAttribute(TEXTRENDERMODE, new Object[] { new Integer(mode),
				new Float(strokeWidth), strokeColor });
	}

	/**
	 * Skews the text to simulate italic and other effects. Try <CODE>alpha=0
	 * </CODE> and <CODE>beta=12</CODE>.
	 * 
	 * @param alpha
	 *            the first angle in degrees
	 * @param beta
	 *            the second angle in degrees
	 * @return this <CODE>Chunk</CODE>
	 */
	public Chunk setSkew(float alpha, float beta) {
		alpha = (float) Math.tan(alpha * Math.PI / 180);
		beta = (float) Math.tan(beta * Math.PI / 180);
		return setAttribute(SKEW, new float[] { alpha, beta });
	}

	/**
	 * Sets the text horizontal scaling. A value of 1 is normal and a value of
	 * 0.5f shrinks the text to half it's width.
	 * 
	 * @param scale
	 *            the horizontal scaling factor
	 * @return this <CODE>Chunk</CODE>
	 */
	public Chunk setHorizontalScaling(float scale) {
		return setAttribute(HSCALE, new Float(scale));
	}

	/**
	 * Gets the horizontal scaling.
	 * 
	 * @return a percentage in float
	 */
	public float getHorizontalScaling() {
		if (attributes == null)
			return 1f;
		Float f = (Float) attributes.get(HSCALE);
		if (f == null)
			return 1f;
		return f.floatValue();
	}

	/**
	 * Sets an action for this <CODE>Chunk</CODE>.
	 * 
	 * @param action
	 *            the action
	 * @return this <CODE>Chunk</CODE>
	 */

	public Chunk setAction(PdfAction action) {
		return setAttribute(ACTION, action);
	}

	/**
	 * Sets an anchor for this <CODE>Chunk</CODE>.
	 * 
	 * @param url
	 *            the <CODE>URL</CODE> to link to
	 * @return this <CODE>Chunk</CODE>
	 */

	public Chunk setAnchor(URL url) {
		return setAttribute(ACTION, new PdfAction(url.toExternalForm()));
	}

	/**
	 * Sets an anchor for this <CODE>Chunk</CODE>.
	 * 
	 * @param url
	 *            the url to link to
	 * @return this <CODE>Chunk</CODE>
	 */

	public Chunk setAnchor(String url) {
		return setAttribute(ACTION, new PdfAction(url));
	}

	/**
	 * Sets a local goto for this <CODE>Chunk</CODE>.
	 * <P>
	 * There must be a local destination matching the name.
	 * 
	 * @param name
	 *            the name of the destination to go to
	 * @return this <CODE>Chunk</CODE>
	 */

	public Chunk setLocalGoto(String name) {
		return setAttribute(LOCALGOTO, name);
	}

	/**
	 * Sets the color of the background <CODE>Chunk</CODE>.
	 * 
	 * @param color
	 *            the color of the background
	 * @return this <CODE>Chunk</CODE>
	 */
	public Chunk setBackground(Color color) {
		return setBackground(color, 0, 0, 0, 0);
	}

	/**
	 * Sets the color and the size of the background <CODE>Chunk</CODE>.
	 * 
	 * @param color
	 *            the color of the background
	 * @param extraLeft
	 *            increase the size of the rectangle in the left
	 * @param extraBottom
	 *            increase the size of the rectangle in the bottom
	 * @param extraRight
	 *            increase the size of the rectangle in the right
	 * @param extraTop
	 *            increase the size of the rectangle in the top
	 * @return this <CODE>Chunk</CODE>
	 */
	public Chunk setBackground(Color color, float extraLeft, float extraBottom,
			float extraRight, float extraTop) {
		return setAttribute(BACKGROUND, new Object[] { color,
				new float[] { extraLeft, extraBottom, extraRight, extraTop } });
	}

	/**
	 * Sets an horizontal line that can be an underline or a strikethrough.
	 * Actually, the line can be anywhere vertically and has always the <CODE>
	 * Chunk</CODE> width. Multiple call to this method will produce multiple
	 * lines.
	 * 
	 * @param thickness
	 *            the absolute thickness of the line
	 * @param yPosition
	 *            the absolute y position relative to the baseline
	 * @return this <CODE>Chunk</CODE>
	 */
	public Chunk setUnderline(float thickness, float yPosition) {
		return setUnderline(null, thickness, 0f, yPosition, 0f,
				PdfContentByte.LINE_CAP_BUTT);
	}

	/**
	 * Sets an horizontal line that can be an underline or a strikethrough.
	 * Actually, the line can be anywhere vertically and has always the <CODE>
	 * Chunk</CODE> width. Multiple call to this method will produce multiple
	 * lines.
	 * 
	 * @param color
	 *            the color of the line or <CODE>null</CODE> to follow the
	 *            text color
	 * @param thickness
	 *            the absolute thickness of the line
	 * @param thicknessMul
	 *            the thickness multiplication factor with the font size
	 * @param yPosition
	 *            the absolute y position relative to the baseline
	 * @param yPositionMul
	 *            the position multiplication factor with the font size
	 * @param cap
	 *            the end line cap. Allowed values are
	 *            PdfContentByte.LINE_CAP_BUTT, PdfContentByte.LINE_CAP_ROUND
	 *            and PdfContentByte.LINE_CAP_PROJECTING_SQUARE
	 * @return this <CODE>Chunk</CODE>
	 */
	public Chunk setUnderline(Color color, float thickness, float thicknessMul,
			float yPosition, float yPositionMul, int cap) {
		if (attributes == null)
			attributes = new HashMap();
		Object obj[] = {
				color,
				new float[] { thickness, thicknessMul, yPosition, yPositionMul, cap } };
		Object unders[][] = addToArray((Object[][]) attributes.get(UNDERLINE),
				obj);
		return setAttribute(UNDERLINE, unders);
	}

	/**
	 * Utility method to extend an array.
	 * 
	 * @param original
	 *            the original array or <CODE>null</CODE>
	 * @param item
	 *            the item to be added to the array
	 * @return a new array with the item appended
	 */
	public static Object[][] addToArray(Object original[][], Object item[]) {
		if (original == null) {
			original = new Object[1][];
			original[0] = item;
			return original;
		} else {
			Object original2[][] = new Object[original.length + 1][];
			System.arraycopy(original, 0, original2, 0, original.length);
			original2[original.length] = item;
			return original2;
		}
	}

	/**
	 * Sets a generic annotation to this <CODE>Chunk</CODE>.
	 * 
	 * @param annotation
	 *            the annotation
	 * @return this <CODE>Chunk</CODE>
	 */
	public Chunk setAnnotation(PdfAnnotation annotation) {
		return setAttribute(PDFANNOTATION, annotation);
	}

	/**
	 * sets the hyphenation engine to this <CODE>Chunk</CODE>.
	 * 
	 * @param hyphenation
	 *            the hyphenation engine
	 * @return this <CODE>Chunk</CODE>
	 */
	public Chunk setHyphenation(HyphenationEvent hyphenation) {
		return setAttribute(HYPHENATION, hyphenation);
	}

	/**
	 * Sets a goto for a remote destination for this <CODE>Chunk</CODE>.
	 * 
	 * @param filename
	 *            the file name of the destination document
	 * @param name
	 *            the name of the destination to go to
	 * @return this <CODE>Chunk</CODE>
	 */

	public Chunk setRemoteGoto(String filename, String name) {
		return setAttribute(REMOTEGOTO, new Object[] { filename, name });
	}

	/**
	 * Sets a goto for a remote destination for this <CODE>Chunk</CODE>.
	 * 
	 * @param filename
	 *            the file name of the destination document
	 * @param page
	 *            the page of the destination to go to. First page is 1
	 * @return this <CODE>Chunk</CODE>
	 */

	public Chunk setRemoteGoto(String filename, int page) {
		return setAttribute(REMOTEGOTO, new Object[] { filename,
				new Integer(page) });
	}

	/**
	 * Sets a local destination for this <CODE>Chunk</CODE>.
	 * 
	 * @param name
	 *            the name for this destination
	 * @return this <CODE>Chunk</CODE>
	 */
	public Chunk setLocalDestination(String name) {
		return setAttribute(LOCALDESTINATION, name);
	}

	/**
	 * Sets the generic tag <CODE>Chunk</CODE>.
	 * <P>
	 * The text for this tag can be retrieved with <CODE>PdfPageEvent</CODE>.
	 * 
	 * @param text
	 *            the text for the tag
	 * @return this <CODE>Chunk</CODE>
	 */

	public Chunk setGenericTag(String text) {
		return setAttribute(GENERICTAG, text);
	}

	/**
	 * Sets the split characters.
	 * 
	 * @param splitCharacter
	 *            the <CODE>SplitCharacter</CODE> interface
	 * @return this <CODE>Chunk</CODE>
	 */
	public Chunk setSplitCharacter(SplitCharacter splitCharacter) {
		return setAttribute(SPLITCHARACTER, splitCharacter);
	}

	/**
	 * Sets a new page tag..
	 * 
	 * @return this <CODE>Chunk</CODE>
	 */

	public Chunk setNewPage() {
		return setAttribute(NEWPAGE, null);
	}

	/**
	 * Sets an arbitrary attribute.
	 * 
	 * @param name
	 *            the key for the attribute
	 * @param obj
	 *            the value of the attribute
	 * @return this <CODE>Chunk</CODE>
	 */

	private Chunk setAttribute(String name, Object obj) {
		if (attributes == null)
			attributes = new HashMap();
		attributes.put(name, obj);
		return this;
	}

	/**
	 * Gets the attributes for this <CODE>Chunk</CODE>.
	 * <P>
	 * It may be null.
	 * 
	 * @return the attributes for this <CODE>Chunk</CODE>
	 */

	public HashMap getAttributes() {
		return attributes;
	}

	/**
	 * Checks the attributes of this <CODE>Chunk</CODE>.
	 * 
	 * @return false if there aren't any.
	 */

	public boolean hasAttributes() {
		return attributes != null;
	}

	/**
	 * Returns the image.
	 * 
	 * @return the image
	 */
    /* ssteward: dropped in 1.44
	public Image getImage() {
		if (attributes == null)
			return null;
		Object obj[] = (Object[]) attributes.get(Chunk.IMAGE);
		if (obj == null)
			return null;
		else {
			return (Image) obj[0];
		}
	}
    */
	/**
	 * Checks if a given tag corresponds with this object.
	 * 
	 * @param tag
	 *            the given tag
	 * @return true if the tag corresponds
	 */

	public static boolean isTag(String tag) {
		return ElementTags.CHUNK.equals(tag);
	}

	/**
	 * @see pdftk.com.lowagie.text.MarkupAttributes#setMarkupAttribute(java.lang.String,
	 *      java.lang.String)
	 */
	public void setMarkupAttribute(String name, String value) {
		if (markupAttributes == null)
			markupAttributes = new Properties();
		markupAttributes.put(name, value);
	}

	/**
	 * @see pdftk.com.lowagie.text.MarkupAttributes#setMarkupAttributes(java.util.Properties)
	 */
	public void setMarkupAttributes(Properties markupAttributes) {
		this.markupAttributes = markupAttributes;
	}

	/**
	 * @see pdftk.com.lowagie.text.MarkupAttributes#getMarkupAttribute(java.lang.String)
	 */
	public String getMarkupAttribute(String name) {
		return (markupAttributes == null) ? null : String
				.valueOf(markupAttributes.get(name));
	}

	/**
	 * @see pdftk.com.lowagie.text.MarkupAttributes#getMarkupAttributeNames()
	 */
	public Set getMarkupAttributeNames() {
		return getKeySet(markupAttributes);
	}

	/**
	 * @see pdftk.com.lowagie.text.MarkupAttributes#getMarkupAttributes()
	 */
	public Properties getMarkupAttributes() {
		return markupAttributes;
	}

	/**
	 * Gets the keys of a Hashtable
	 * 
	 * @param table
	 *            a Hashtable
	 * @return the keyset of a Hashtable (or an empty set if table is null)
	 */
	public static Set getKeySet(Hashtable table) {
		return (table == null) ? Collections.EMPTY_SET : table.keySet();
	}
} /*
 * $Id: DocListener.java,v 1.52 2004/12/14 11:52:47 blowagie Exp $
 * $Name:  $
 *
 * Copyright (c) 1999, 2000, 2001, 2002 Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

/**
 * A class that implements <CODE>DocListener</CODE> will perform some
 * actions when some actions are performed on a <CODE>Document</CODE>.
 *
 * @see		ElementListener
 * @see		Document
 * @see		DocWriter
 */

public interface DocListener extends ElementListener {
    
    // methods
    
/**
 * Signals that the <CODE>Document</CODE> has been opened and that
 * <CODE>Elements</CODE> can be added.
 */
    
    public void open();
    
/**
 * Sets the pagesize.
 *
 * @param	pageSize	the new pagesize
 * @return	a <CODE>boolean</CODE>
 */
    
    public boolean setPageSize(Rectangle pageSize);
    
/**
 * Signals that a <CODE>Watermark</CODE> was added to the <CODE>Document</CODE>.
 * 
 * @param watermark the Watermark object
 * @return	<CODE>true</CODE> if the element was added, <CODE>false</CODE> if not.
 */
    
    // public boolean add(Watermark watermark); ssteward: dropped in 1.44
    
/**
 * Signals that a <CODE>Watermark</CODE> was removed from the <CODE>Document</CODE>.
 */
    
    // public void removeWatermark(); ssteward: dropped in 1.44
    
/**
 * Sets the margins.
 *
 * @param	marginLeft		the margin on the left
 * @param	marginRight		the margin on the right
 * @param	marginTop		the margin on the top
 * @param	marginBottom	the margin on the bottom
 * @return	a <CODE>boolean</CODE>
 */
    
    public boolean setMargins(float marginLeft, float marginRight, float marginTop, float marginBottom);
    
    /**
     * Parameter that allows you to do margin mirroring (odd/even pages)
     * @param marginMirroring
     * @return true if succesfull
     */
    public boolean setMarginMirroring(boolean marginMirroring);
    
/**
 * Signals that an new page has to be started.
 *
 * @return	<CODE>true</CODE> if the page was added, <CODE>false</CODE> if not.
 * @throws	DocumentException	when a document isn't open yet, or has been closed
 */
    
    public boolean newPage() throws DocumentException;
    
/**
 * Changes the header of this document.
 *
 * @param	header		the new header
 */
    
    // public void setHeader(HeaderFooter header); ssteward: dropped in 1.44
    
/**
 * Resets the header of this document.
 */
    
    // public void resetHeader(); ssteward: dropped in 1.44
    
/**
 * Changes the footer of this document.
 *
 * @param	footer		the new footer
 */
    
    // public void setFooter(HeaderFooter footer); ssteward: dropped in 1.44
    
/**
 * Resets the footer of this document.
 */
    
    // public void resetFooter(); ssteward: dropped in 1.44
    
/**
 * Sets the page number to 0.
 */
    
    public void resetPageCount();
    
/**
 * Sets the page number.
 *
 * @param	pageN		the new page number
 */
    
    public void setPageCount(int pageN);
    
/**
 * Clears text wrapping around images (if applicable).
 * Method suggested by Pelikan Stephan
 * @throws DocumentException
 */
	public void clearTextWrap() throws DocumentException;
    
/**
 * Signals that the <CODE>Document</CODE> was closed and that no other
 * <CODE>Elements</CODE> will be added.
 * <P>
 * The outputstream of every writer implementing <CODE>DocListener</CODE> will be closed.
 */
    
    public void close();
} /*
 * $Id: DocWriter.java,v 1.70 2004/12/14 11:52:47 blowagie Exp $
 * $Name:  $
 *
 * Copyright 1999, 2000, 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

import java.io.BufferedOutputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.util.Iterator;
import pdftk.com.lowagie.text.pdf.OutputStreamCounter;

/**
 * An abstract <CODE>Writer</CODE> class for documents.
 * <P>
 * <CODE>DocWriter</CODE> is the abstract class of several writers such
 * as <CODE>PdfWriter</CODE> and <CODE>HtmlWriter</CODE>.
 * A <CODE>DocWriter</CODE> can be added as a <CODE>DocListener</CODE>
 * to a certain <CODE>Document</CODE> by getting an instance (see method
 * <CODE>getInstance()</CODE> in the specific writer-classes).
 * Every <CODE>Element</CODE> added to the original <CODE>Document</CODE>
 * will be written to the <CODE>OutputStream</CODE> of the listening
 * <CODE>DocWriter</CODE>.
 *
 * @see   Document
 * @see   DocListener
 */

public abstract class DocWriter implements DocListener {

/** This is some byte that is often used. */
    public static final byte NEWLINE = (byte)'\n';

/** This is some byte that is often used. */
    public static final byte TAB = (byte)'\t';

/** This is some byte that is often used. */
    public static final byte LT = (byte)'<';

/** This is some byte that is often used. */
    public static final byte SPACE = (byte)' ';

/** This is some byte that is often used. */
    public static final byte EQUALS = (byte)'=';

/** This is some byte that is often used. */
    public static final byte QUOTE = (byte)'\"';

/** This is some byte that is often used. */
    public static final byte GT = (byte)'>';

/** This is some byte that is often used. */
    public static final byte FORWARD = (byte)'/';

    // membervariables

/** The pageSize. */
    protected Rectangle pageSize;

/** This is the document that has to be written. */
    // ssteward omit: protected Document document;

/** The outputstream of this writer. */
    protected OutputStreamCounter os;

/** Is the writer open for writing? */
    protected boolean open = false;

/** Do we have to pause all writing actions? */
    // ssteward: changed from "pause" to "m_pause" to
    // remove gcj complaints over ambiguity with pause()
    protected boolean m_pause = false;
    
/** Closes the stream on document close */
    protected boolean closeStream = true;

    // constructor
    
    protected DocWriter()  {
    }

/**
 * Constructs a <CODE>DocWriter</CODE>.
 *
 * @param document  The <CODE>Document</CODE> that has to be written
 * @param os  The <CODE>OutputStream</CODE> the writer has to write to.
 */

    protected DocWriter( /* ssteward omit: Document document,*/ OutputStream os)  {
        // ssteward omit: this.document = document;
        this.os = new OutputStreamCounter(new BufferedOutputStream(os));
    }

    // implementation of the DocListener methods

/**
 * Signals that an <CODE>Element</CODE> was added to the <CODE>Document</CODE>.
 * <P>
 * This method should be overriden in the specific <CODE>DocWriter<CODE> classes
 * derived from this abstract class.
 * 
 * @param element A high level object to add
 * @return  <CODE>false</CODE>
 * @throws  DocumentException when a document isn't open yet, or has been closed
 */

    public boolean add(Element element) throws DocumentException {
        return false;
    }

/**
 * Signals that the <CODE>Document</CODE> was opened.
 */

    public void open() {
        open = true;
    }

/**
 * Sets the pagesize.
 *
 * @param pageSize  the new pagesize
 * @return  a <CODE>boolean</CODE>
 */

    public boolean setPageSize(Rectangle pageSize) {
        this.pageSize = pageSize;
        return true;
    }

/**
 * Sets the <CODE>Watermark</CODE>.
 * <P>
 * This method should be overriden in the specific <CODE>DocWriter<CODE> classes
 * derived from this abstract class if they actually support the use of
 * a <CODE>Watermark</CODE>.
 * 
 * @param watermark A watermark object
 * @return  <CODE>false</CODE> (because watermarks aren't supported by default).
 */
/* ssteward: dropped in 1.44
    public boolean add(Watermark watermark) {
        return false;
    }
*/
/**
 * Removes the <CODE>Watermark</CODE> (if there is one).
 */
/* ssteward: dropped in 1.44
    public void removeWatermark() {
    }
*/
/**
 * Sets the margins.
 * <P>
 * This does nothing. Has to be overridden if needed.
 *
 * @param marginLeft    the margin on the left
 * @param marginRight   the margin on the right
 * @param marginTop   the margin on the top
 * @param marginBottom  the margin on the bottom
 * @return  <CODE>false</CODE>
 */

    public boolean setMargins(float marginLeft, float marginRight, float marginTop, float marginBottom) {
        return false;
    }

/**
 * Signals that an new page has to be started.
 * <P>
 * This does nothing. Has to be overridden if needed.
 *
 * @return  <CODE>true</CODE> if the page was added, <CODE>false</CODE> if not.
 * @throws  DocumentException when a document isn't open yet, or has been closed
 */

    public boolean newPage() throws DocumentException {
        if (!open) {
            return false;
        }
        return true;
    }

/**
 * Changes the header of this document.
 * <P>
 * This method should be overriden in the specific <CODE>DocWriter<CODE> classes
 * derived from this abstract class if they actually support the use of
 * headers.
 *
 * @param header    the new header
 */
/* ssteward: dropped in 1.44
    public void setHeader(HeaderFooter header) {
    }
*/

/**
 * Resets the header of this document.
 * <P>
 * This method should be overriden in the specific <CODE>DocWriter<CODE> classes
 * derived from this abstract class if they actually support the use of
 * headers.
 */

    public void resetHeader() {
    }

/**
 * Changes the footer of this document.
 * <P>
 * This method should be overriden in the specific <CODE>DocWriter<CODE> classes
 * derived from this abstract class if they actually support the use of
 * footers.
 *
 * @param footer    the new footer
 */
/* ssteward: dropped in 1.44
    public void setFooter(HeaderFooter footer) {
    }
*/

/**
 * Resets the footer of this document.
 * <P>
 * This method should be overriden in the specific <CODE>DocWriter<CODE> classes
 * derived from this abstract class if they actually support the use of
 * footers.
 */

    public void resetFooter() {
    }

/**
 * Sets the page number to 0.
 * <P>
 * This method should be overriden in the specific <CODE>DocWriter<CODE> classes
 * derived from this abstract class if they actually support the use of
 * pagenumbers.
 */

    public void resetPageCount() {
    }

/**
 * Sets the page number.
 * <P>
 * This method should be overriden in the specific <CODE>DocWriter<CODE> classes
 * derived from this abstract class if they actually support the use of
 * pagenumbers.
 *
 * @param pageN   the new page number
 */

    public void setPageCount(int pageN) {
    }

/**
 * Signals that the <CODE>Document</CODE> was closed and that no other
 * <CODE>Elements</CODE> will be added.
 */

    public void close() {
        open = false;
        try {
            os.flush();
            if (closeStream)
                os.close();
        }
        catch(IOException ioe) {
            throw new ExceptionConverter(ioe);
        }
    }

    // methods

/** Converts a <CODE>String</CODE> into a <CODE>Byte</CODE> array
 * according to the ISO-8859-1 codepage.
 * @param text the text to be converted
 * @return the conversion result
 */

    public static final byte[] getISOBytes(String text)
    {
        if (text == null)
            return null;
        int len = text.length();
        byte b[] = new byte[len];
        for (int k = 0; k < len; ++k)
            b[k] = (byte)text.charAt(k);
        return b;
    }

/**
 * Let the writer know that all writing has to be paused.
 */

    public void pause() {
	// ssteward
        m_pause = true;
    }

/**
 * Let the writer know that writing may be resumed.
 */

    public void resume() {
	// ssteward
        m_pause = false;
    }

/**
 * Flushes the <CODE>BufferedOutputStream</CODE>.
 */

    public void flush() {
        try {
            os.flush();
        }
        catch(IOException ioe) {
            throw new ExceptionConverter(ioe);
        }
    }

/**
 * Writes a <CODE>String</CODE> to the <CODE>OutputStream</CODE>.
 *
 * @param string    the <CODE>String</CODE> to write
 * @throws IOException
 */

    protected void write(String string) throws IOException {
        os.write(getISOBytes(string));
    }

/**
 * Writes a number of tabs.
 *
 * @param   indent  the number of tabs to add
 * @throws IOException
 */

    protected void addTabs(int indent) throws IOException {
        os.write(NEWLINE);
        for (int i = 0; i < indent; i++) {
            os.write(TAB);
        }
    }

/**
 * Writes a key-value pair to the outputstream.
 *
 * @param   key     the name of an attribute
 * @param   value   the value of an attribute
 * @throws IOException
 */

    protected void write(String key, String value)
    throws IOException {
        os.write(SPACE);
        write(key);
        os.write(EQUALS);
        os.write(QUOTE);
        write(value);
        os.write(QUOTE);
    }

/**
 * Writes a starttag to the outputstream.
 *
 * @param   tag     the name of the tag
 * @throws IOException
 */

    protected void writeStart(String tag)
    throws IOException {
        os.write(LT);
        write(tag);
    }

/**
 * Writes an endtag to the outputstream.
 *
 * @param   tag     the name of the tag
 * @throws IOException
 */

    protected void writeEnd(String tag)
    throws IOException {
        os.write(LT);
        os.write(FORWARD);
        write(tag);
        os.write(GT);
    }

/**
 * Writes an endtag to the outputstream.
 * @throws IOException
 */

    protected void writeEnd()
    throws IOException {
        os.write(SPACE);
        os.write(FORWARD);
        os.write(GT);
    }

/**
 * Writes the markup attributes of the specified <CODE>MarkupAttributes</CODE>
 * object to the <CODE>OutputStream</CODE>.
 * @param mAtt   the <CODE>MarkupAttributes</CODE> to write.
 * @return true, if writing the markup attributes succeeded
 * @throws IOException
 */
    protected boolean writeMarkupAttributes(MarkupAttributes mAtt)
     throws IOException
    {
      Iterator attributeIterator = mAtt.getMarkupAttributeNames().iterator();
      boolean result = attributeIterator.hasNext();
      while (attributeIterator.hasNext()) {
        String name = String.valueOf(attributeIterator.next());
        write(name, mAtt.getMarkupAttribute(name));
      }
      return result;
    }

/**
 * Returns <CODE>true</CODE> if the specified <CODE>Element</CODE> implements
 * <CODE>MarkupAttributes</CODE> and has one or more attributes to write.
 * @param element   the <CODE>Element</CODE> to check.
 * @return <CODE>boolean</CODE>.
 */
    protected static boolean hasMarkupAttributes(Element element) {
      return (element instanceof MarkupAttributes &&
       !(((MarkupAttributes)element).getMarkupAttributeNames().isEmpty()));
    }

    /** Checks if the stream is to be closed on document close
     * @return true if the stream is closed on documnt close
     *
     */
    public boolean isCloseStream() {
        return closeStream;
    }
    
    /** Sets the close state of the stream after document close
     * @param closeStream true if the stream is closed on document close
     *
     */
    public void setCloseStream(boolean closeStream) {
        this.closeStream = closeStream;
    }
    
    
	/**
	 * @see pdftk.com.lowagie.text.DocListener#clearTextWrap()
	 */
	public void clearTextWrap() throws DocumentException {
		// do nothing
	}
    /**
     * @see pdftk.com.lowagie.text.DocListener#setMarginMirroring(boolean)
     */
    public boolean setMarginMirroring(boolean MarginMirroring) {
        return false;
    }
    
}
 /*
 * $Id: Document.java,v 1.100 2005/07/17 14:45:30 blowagie Exp $
 * $Name:  $
 *
 * Copyright 1999, 2000, 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Iterator;

import java.util.Date;

/**
 * A generic Document class.
 * <P>
 * All kinds of Text-elements can be added to a <CODE>HTMLDocument</CODE>.
 * The <CODE>Document</CODE> signals all the listeners when an element has
 * been added.
 * <P>
 * Remark:
 * <OL>
 *     <LI>Once a document is created you can add some meta information.
 *     <LI>You can also set the headers/footers.
 *     <LI>You have to open the document before you can write content.
 * <LI>You can only write content (no more meta-formation!) once a document is
 * opened.
 * <LI>When you change the header/footer on a certain page, this will be
 * effective starting on the next page.
 * <LI>Ater closing the document, every listener (as well as its <CODE>
 * OutputStream</CODE>) is closed too.
 * </OL>
 * Example: <BLOCKQUOTE>
 *
 * <PRE>// creation of the document with a certain size and certain margins
 * <STRONG>Document document = new Document(PageSize.A4, 50, 50, 50, 50);
 * </STRONG> try { // creation of the different writers HtmlWriter.getInstance(
 * <STRONG>document </STRONG>, System.out); PdfWriter.getInstance(
 * <STRONG>document </STRONG>, new FileOutputStream("text.pdf"));
 *    // we add some meta information to the document
 * <STRONG>document.addAuthor("Bruno Lowagie"); </STRONG>
 * <STRONG>document.addSubject("This is the result of a Test."); </STRONG>
 *  // we define a header and a footer HeaderFooter header = new
 * HeaderFooter(new Phrase("This is a header."), false); HeaderFooter footer =
 * new HeaderFooter(new Phrase("This is page "), new Phrase("."));
 *    footer.setAlignment(Element.ALIGN_CENTER);
 * <STRONG>document.setHeader(header); </STRONG>
 * <STRONG>document.setFooter(footer); </STRONG>// we open the document for
 * writing <STRONG>document.open(); </STRONG> <STRONG>document.add(new
 * Paragraph("Hello world")); </STRONG>} catch(DocumentException de) {
 * System.err.println(de.getMessage()); } <STRONG>document.close(); </STRONG>
 * </CODE>
 * </PRE>
 * 
 * </BLOCKQUOTE>
 */

public class Document implements DocListener {
    
    // membervariables
    
	/** This constant may only be changed by Paulo Soares and/or Bruno Lowagie. */
	private static final String ITEXT_VERSION = "itext-paulo-155 (itextpdf.sf.net-lowagie.com)";
    
	/**
	 * Allows the pdf documents to be produced without compression for debugging
	 * purposes.
	 */
    public static boolean compress = true; 
    
	/** The DocListener. */
    private ArrayList listeners = new ArrayList();
    
	/** Is the document open or not? */
    protected boolean open;
    
	/** Has the document already been closed? */
    protected boolean close;
    
    // membervariables concerning the layout
    
	/** The size of the page. */
    protected Rectangle pageSize;
    
	/** The watermark on the pages. */
    // protected Watermark watermark = null; ssteward: dropped in 1.44
    
	/** margin in x direction starting from the left */
    protected float marginLeft = 0;
    
	/** margin in x direction starting from the right */
    protected float marginRight = 0;
    
	/** margin in y direction starting from the top */
    protected float marginTop = 0;
    
	/** margin in y direction starting from the bottom */
    protected float marginBottom = 0;
    
    protected boolean marginMirroring = false;
    
	/** Content of JavaScript onLoad function */
    protected String javaScript_onLoad = null;

	/** Content of JavaScript onUnLoad function */
    protected String javaScript_onUnLoad = null;

	/** Style class in HTML body tag */
    protected String htmlStyleClass = null;

    // headers, footers
    
	/** Current pagenumber */
    protected int pageN = 0;
    
	/** This is the textual part of a Page; it can contain a header */
    // protected HeaderFooter header = null; ssteward: dropped in 1.44
    
	/** This is the textual part of the footer */
    // protected HeaderFooter footer = null; ssteward: dropped in 1.44
    
    // constructor
    
	/**
	 * Constructs a new <CODE>Document</CODE> -object.
 */
    
    public Document() {
        this(PageSize.A4);
    }
    
	/**
	 * Constructs a new <CODE>Document</CODE> -object.
 *
	 * @param pageSize
	 *            the pageSize
 */
    
    public Document(Rectangle pageSize) {
        this(pageSize, 36, 36, 36, 36);
    }
    
	/**
	 * Constructs a new <CODE>Document</CODE> -object.
 *
	 * @param pageSize
	 *            the pageSize
	 * @param marginLeft
	 *            the margin on the left
	 * @param marginRight
	 *            the margin on the right
	 * @param marginTop
	 *            the margin on the top
	 * @param marginBottom
	 *            the margin on the bottom
 */
    
	public Document(Rectangle pageSize, float marginLeft, float marginRight,
			float marginTop, float marginBottom) {
        this.pageSize = pageSize;
        this.marginLeft = marginLeft;
        this.marginRight = marginRight;
        this.marginTop = marginTop;
        this.marginBottom = marginBottom;
    }
    
    // listener methods
    
	/**
 * Adds a <CODE>DocListener</CODE> to the <CODE>Document</CODE>.
 *
	 * @param listener
	 *            the new DocListener.
 */
    
    public void addDocListener(DocListener listener) {
        listeners.add(listener);
    }
    
	/**
 * Removes a <CODE>DocListener</CODE> from the <CODE>Document</CODE>.
 *
	 * @param listener
	 *            the DocListener that has to be removed.
 */
    
    public void removeDocListener(DocListener listener) {
        listeners.remove(listener);
    }
    
    // methods implementing the DocListener interface
    
	/**
	 * Adds an <CODE>Element</CODE> to the <CODE>Document</CODE>.
 *
	 * @param element
	 *            the <CODE>Element</CODE> to add
	 * @return <CODE>true</CODE> if the element was added, <CODE>false
	 *         </CODE> if not
	 * @throws DocumentException
	 *             when a document isn't open yet, or has been closed
 */
    
    public boolean add(Element element) throws DocumentException {
        if (close) {
			throw new DocumentException(
					"The document has been closed. You can't add any Elements.");
        }
        int type = element.type();
        if (open) {
			if (!(type == Element.CHUNK || type == Element.PHRASE
					|| type == Element.PARAGRAPH || type == Element.TABLE
					|| type == Element.PTABLE
					|| type == Element.MULTI_COLUMN_TEXT
					|| type == Element.ANCHOR || type == Element.ANNOTATION
					|| type == Element.CHAPTER || type == Element.SECTION
					|| type == Element.LIST || type == Element.LISTITEM
					|| type == Element.RECTANGLE || type == Element.JPEG
					|| type == Element.IMGRAW || type == Element.IMGTEMPLATE || type == Element.GRAPHIC)) {
				throw new DocumentException(
						"The document is open; you can only add Elements with content.");
			}
		} else {
			if (!(type == Element.HEADER || type == Element.TITLE
					|| type == Element.SUBJECT || type == Element.KEYWORDS
					|| type == Element.AUTHOR || type == Element.PRODUCER
					|| type == Element.CREATOR || type == Element.CREATIONDATE)) {
				throw new DocumentException(
						"The document is not open yet; you can only add Meta information.");
            }
        }
        boolean success = false;
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
            success |= listener.add(element);
        }
        return success;
    }
    
	/**
 * Opens the document.
 * <P>
	 * Once the document is opened, you can't write any Header- or
	 * Meta-information anymore. You have to open the document before you can
	 * begin to add content to the body of the document.
 */
    
    public void open() {
		if (!close) {
            open = true;
        }
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
            listener.setPageSize(pageSize);
			listener.setMargins(marginLeft, marginRight, marginTop,
					marginBottom);
            listener.open();
        }
    }
    
	/**
 * Sets the pagesize.
 *
	 * @param pageSize
	 *            the new pagesize
 * @return	a <CODE>boolean</CODE>
 */
    
    public boolean setPageSize(Rectangle pageSize) {
        this.pageSize = pageSize;
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
            listener.setPageSize(pageSize);
        }
        return true;
    }
    
	/**
 * Sets the <CODE>Watermark</CODE>.
 *
	 * @param watermark
	 *            the watermark to add
	 * @return <CODE>true</CODE> if the element was added, <CODE>false
	 *         </CODE> if not.
 */
    /* ssteward: dropped in 1.44
    public boolean add(Watermark watermark) {
        this.watermark = watermark;
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
            listener.add(watermark);
        }
        return true;
    }
    */
    
	/**
 * Removes the <CODE>Watermark</CODE>.
 */
    /* ssteward: dropped in 1.44
    public void removeWatermark() {
        this.watermark = null;
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
            listener.removeWatermark();
        }
    }
    */
    
	/**
 * Sets the margins.
 *
	 * @param marginLeft
	 *            the margin on the left
	 * @param marginRight
	 *            the margin on the right
	 * @param marginTop
	 *            the margin on the top
	 * @param marginBottom
	 *            the margin on the bottom
 * @return	a <CODE>boolean</CODE>
 */
    
	public boolean setMargins(float marginLeft, float marginRight,
			float marginTop, float marginBottom) {
        this.marginLeft = marginLeft;
        this.marginRight = marginRight;
        this.marginTop = marginTop;
        this.marginBottom = marginBottom;
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
			listener.setMargins(marginLeft, marginRight, marginTop,
					marginBottom);
        }
        return true;
    }
    
	/**
 * Signals that an new page has to be started.
 *
	 * @return <CODE>true</CODE> if the page was added, <CODE>false</CODE>
	 *         if not.
	 * @throws DocumentException
	 *             when a document isn't open yet, or has been closed
 */
    
    public boolean newPage() throws DocumentException {
        if (!open || close) {
            return false;
        }
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
            listener.newPage();
        }
        return true;
    }
    
	/**
 * Changes the header of this document.
 *
	 * @param header
	 *            the new header
 */
    /* ssteward: dropped in 1.44
    public void setHeader(HeaderFooter header) {
        this.header = header;
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
            listener.setHeader(header);
        }
    }
    */
    
	/**
 * Resets the header of this document.
 */
    /* ssteward: dropped in 1.44
    public void resetHeader() {
        this.header = null;
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
            listener.resetHeader();
        }
    }
    */
    
	/**
 * Changes the footer of this document.
 *
	 * @param footer
	 *            the new footer
 */
    /* ssteward: dropped in 1.44
    public void setFooter(HeaderFooter footer) {
        this.footer = footer;
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
            listener.setFooter(footer);
        }
    }
    */
    
	/**
 * Resets the footer of this document.
 */
    /* ssteward: dropped in 1.44
    public void resetFooter() {
        this.footer = null;
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
            listener.resetFooter();
        }
    }
    */
    
	/**
 * Sets the page number to 0.
 */
    
    public void resetPageCount() {
        pageN = 0;
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
            listener.resetPageCount();
        }
    }
    
	/**
 * Sets the page number.
 *
	 * @param pageN
	 *            the new page number
 */
    
    public void setPageCount(int pageN) {
        this.pageN = pageN;
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
            listener.setPageCount(pageN);
        }
    }
    
	/**
 * Returns the current page number.
 *
 * @return the current page number
 */
    
    public int getPageNumber() {
        return this.pageN;
    }
    
	/**
 * Closes the document.
 * <P>
	 * Once all the content has been written in the body, you have to close the
	 * body. After that nothing can be written to the body anymore.
 */
    
    public void close() {
		if (!close) {
            open = false;
            close = true;
        }
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
            listener.close();
        }
    }
    
    // methods concerning the header or some meta information
    
	/**
 * Adds a user defined header to the document.
 *
	 * @param name
	 *            the name of the header
	 * @param content
	 *            the content of the header
 * @return	<CODE>true</CODE> if successful, <CODE>false</CODE> otherwise
 */
    
    public boolean addHeader(String name, String content) {
        try {
            return add(new Header(name, content));
		} catch (DocumentException de) {
            throw new ExceptionConverter(de);
        }
    }
    
	/**
 * Adds the title to a Document.
 *
	 * @param title
	 *            the title
 * @return	<CODE>true</CODE> if successful, <CODE>false</CODE> otherwise
 */
    
    public boolean addTitle(String title) {
        try {
            return add(new Meta(Element.TITLE, title));
		} catch (DocumentException de) {
            throw new ExceptionConverter(de);
        }
    }
    
	/**
 * Adds the subject to a Document.
 *
	 * @param subject
	 *            the subject
 * @return	<CODE>true</CODE> if successful, <CODE>false</CODE> otherwise
 */
    
    public boolean addSubject(String subject) {
        try {
            return add(new Meta(Element.SUBJECT, subject));
		} catch (DocumentException de) {
            throw new ExceptionConverter(de);
        }
    }
    
	/**
 * Adds the keywords to a Document.
 *
	 * @param keywords
	 *            adds the keywords to the document
 * @return <CODE>true</CODE> if successful, <CODE>false</CODE> otherwise
 */
    
    public boolean addKeywords(String keywords) {
        try {
            return add(new Meta(Element.KEYWORDS, keywords));
		} catch (DocumentException de) {
            throw new ExceptionConverter(de);
        }
    }
    
	/**
 * Adds the author to a Document.
 *
	 * @param author
	 *            the name of the author
 * @return	<CODE>true</CODE> if successful, <CODE>false</CODE> otherwise
 */
    
    public boolean addAuthor(String author) {
        try {
            return add(new Meta(Element.AUTHOR, author));
		} catch (DocumentException de) {
            throw new ExceptionConverter(de);
        }
    }
    
	/**
 * Adds the creator to a Document.
 *
	 * @param creator
	 *            the name of the creator
 * @return	<CODE>true</CODE> if successful, <CODE>false</CODE> otherwise
 */
    
    public boolean addCreator(String creator) {
        try {
            return add(new Meta(Element.CREATOR, creator));
		} catch (DocumentException de) {
            throw new ExceptionConverter(de);
        }
    }
    
	/**
 * Adds the producer to a Document.
 *
 * @return	<CODE>true</CODE> if successful, <CODE>false</CODE> otherwise
 */
    
    public boolean addProducer() {
        try {
            return add(new Meta(Element.PRODUCER, "iText by lowagie.com"));
		} catch (DocumentException de) {
            throw new ExceptionConverter(de);
        }
    }
    
	/**
 * Adds the current date and time to a Document.
 *
 * @return	<CODE>true</CODE> if successful, <CODE>false</CODE> otherwise
 */
    
    public boolean addCreationDate() {
        try {
			/* bugfix by 'taqua' (Thomas) */
			final SimpleDateFormat sdf = new SimpleDateFormat(
					"EEE MMM dd HH:mm:ss zzz yyyy");
			return add(new Meta(Element.CREATIONDATE, sdf.format(new Date())));
		} catch (DocumentException de) {
            throw new ExceptionConverter(de);
        }
    }
    
    // methods to get the layout of the document.
    
	/**
 * Returns the left margin.
 *
 * @return	the left margin
 */
    
    public float leftMargin() {
        return marginLeft;
    }
    
	/**
 * Return the right margin.
 *
 * @return	the right margin
 */
    
    public float rightMargin() {
        return marginRight;
    }
    
	/**
 * Returns the top margin.
 *
 * @return	the top margin
 */
    
    public float topMargin() {
        return marginTop;
    }
    
	/**
 * Returns the bottom margin.
 *
 * @return	the bottom margin
 */
    
    public float bottomMargin() {
        return marginBottom;
    }
    
	/**
 * Returns the lower left x-coordinate.
 *
 * @return	the lower left x-coordinate
 */
    
    public float left() {
        return pageSize.left(marginLeft);
    }
    
	/**
 * Returns the upper right x-coordinate.
 *
 * @return	the upper right x-coordinate
 */
    
    public float right() {
        return pageSize.right(marginRight);
    }
    
	/**
 * Returns the upper right y-coordinate.
 *
 * @return	the upper right y-coordinate
 */
    
    public float top() {
        return pageSize.top(marginTop);
    }
    
	/**
 * Returns the lower left y-coordinate.
 *
 * @return	the lower left y-coordinate
 */
    
    public float bottom() {
        return pageSize.bottom(marginBottom);
    }
    
	/**
 * Returns the lower left x-coordinate considering a given margin.
 *
	 * @param margin
	 *            a margin
 * @return	the lower left x-coordinate
 */
    
    public float left(float margin) {
        return pageSize.left(marginLeft + margin);
    }
    
	/**
 * Returns the upper right x-coordinate, considering a given margin.
 *
	 * @param margin
	 *            a margin
 * @return	the upper right x-coordinate
 */
    
    public float right(float margin) {
        return pageSize.right(marginRight + margin);
    }
    
	/**
 * Returns the upper right y-coordinate, considering a given margin.
 *
	 * @param margin
	 *            a margin
 * @return	the upper right y-coordinate
 */
    
    public float top(float margin) {
        return pageSize.top(marginTop + margin);
    }
    
	/**
 * Returns the lower left y-coordinate, considering a given margin.
 *
	 * @param margin
	 *            a margin
 * @return	the lower left y-coordinate
 */
    
    public float bottom(float margin) {
        return pageSize.bottom(marginBottom + margin);
    }
    
	/**
 * Gets the pagesize.
	 * 
 * @return the page size
 */
    
	public Rectangle getPageSize() {
        return this.pageSize;
    }
    
	/**
	 * Checks if the document is open.
	 * 
     * @return <CODE>true</CODE> if the document is open
     */    
    public boolean isOpen() {
        return open;
    }
    
	/**
	 * Gets the iText version.
	 * This method may only be changed by Paulo Soares and/or Bruno Lowagie.
     * @return iText version
     */    
    public static final String getVersion() {
        return ITEXT_VERSION;
    }

	/**
 * Adds a JavaScript onLoad function to the HTML body tag
 *
	 * @param code
	 *            the JavaScript code to be executed on load of the HTML page
 */
    
    public void setJavaScript_onLoad(String code) {
        this.javaScript_onLoad = code;
    }

	/**
 * Gets the JavaScript onLoad command.
	 * 
 * @return the JavaScript onLoad command
 */

    public String getJavaScript_onLoad() {
        return this.javaScript_onLoad;
    }

	/**
 * Adds a JavaScript onUnLoad function to the HTML body tag
 *
	 * @param code
	 *            the JavaScript code to be executed on unload of the HTML page
 */
    
    public void setJavaScript_onUnLoad(String code) {
        this.javaScript_onUnLoad = code;
    }

	/**
 * Gets the JavaScript onUnLoad command.
	 * 
 * @return the JavaScript onUnLoad command
 */

    public String getJavaScript_onUnLoad() {
        return this.javaScript_onUnLoad;
    }

	/**
 * Adds a style class to the HTML body tag
 *
	 * @param htmlStyleClass
	 *            the style class for the HTML body tag
 */
    
    public void setHtmlStyleClass(String htmlStyleClass) {
        this.htmlStyleClass = htmlStyleClass;
    }

	/**
 * Gets the style class of the HTML body tag
 *
 * @return		the style class of the HTML body tag
 */
    
    public String getHtmlStyleClass() {
        return this.htmlStyleClass;
    }

	/**
 	 * @see pdftk.com.lowagie.text.DocListener#clearTextWrap()
     */
	public void clearTextWrap() throws DocumentException {
		if (open && !close) {
			DocListener listener;
			for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
				listener = (DocListener) iterator.next();
				listener.clearTextWrap();
			}
		}
	}
    
    /**
     * Set the margin mirroring. It will mirror margins for odd/even pages.
     * <p>
     * Note: it will not work with {@link Table}.
	 * 
	 * @param marginMirroring
	 *            <CODE>true</CODE> to mirror the margins
     * @return always <CODE>true</CODE>
     */    
    public boolean setMarginMirroring(boolean marginMirroring) {
        this.marginMirroring = marginMirroring;
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
            listener.setMarginMirroring(marginMirroring);
        }
        return true;
    }
    
    /**
     * Gets the margin mirroring flag.
	 * 
     * @return the margin mirroring flag
     */    
    public boolean isMarginMirroring() {
        return marginMirroring;
    }
}
 /*
 * $Id: DocumentException.java,v 1.50 2004/12/14 11:52:46 blowagie Exp $
 * $Name:  $
 *
 * Copyright 1999, 2000, 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 *
 */

package pdftk.com.lowagie.text;

/**
 * Signals that an error has occurred in a <CODE>Document</CODE>.
 *
 * @see		BadElementException
 * @see		Document
 * @see		DocWriter
 * @see		DocListener
 */

public class DocumentException extends Exception {

    /** A serial version UID */
    private static final long serialVersionUID = -2191131489390840739L;

    private Exception ex;

    /**
     * Creates a Document exception.
     * @param ex an exception that has to be turned into a DocumentException
     */
    public DocumentException(Exception ex) {
        this.ex = ex;
    }
    
    // constructors
    
/**
 * Constructs a <CODE>DocumentException</CODE> whithout a message.
 */
    
    public DocumentException() {
        super();
    }
    
/**
 * Constructs a <code>DocumentException</code> with a message.
 *
 * @param		message			a message describing the exception
 */
    
    public DocumentException(String message) {
        super(message);
    }

    /**
     * We print the message of the checked exception 
     * @return the error message
     */
    public String getMessage() {
        if (ex == null)
            return super.getMessage();
        else
            return ex.getMessage();
    }

    /**
     * and make sure we also produce a localized version 
     * @return a localized message
     */
    public String getLocalizedMessage() {
        if (ex == null)
            return super.getLocalizedMessage();
        else
            return ex.getLocalizedMessage();
    }

    /**
     * The toString() is changed to be prefixed with ExceptionConverter 
     * @return the String version of the exception
     */
    public String toString() {
        if (ex == null)
            return super.toString();
        else
            return split(getClass().getName()) + ": " + ex;
    }

    /** we have to override this as well */
    public void printStackTrace() {
        printStackTrace(System.err);
    }

    /**
     * here we prefix, with s.print(), not s.println(), the stack
     * trace with "ExceptionConverter:" 
     * @param s a printstream object
     */
    public void printStackTrace(java.io.PrintStream s) {
        if (ex == null)
            super.printStackTrace(s);
        else {
            synchronized (s) {
                s.print(split(getClass().getName()) + ": ");
                ex.printStackTrace(s);
            }
        }
    }

    /**
     * Again, we prefix the stack trace with "ExceptionConverter:" 
     * @param s A PrintWriter object
     */
    public void printStackTrace(java.io.PrintWriter s) {
        if (ex == null)
            super.printStackTrace(s);
        else {
            synchronized (s) {
                s.print(split(getClass().getName()) + ": ");
                ex.printStackTrace(s);
            }
        }
    }

    /**
     * Removes everything in a String that comes before a '.'
     * @param s the original string
     * @return the part that comes after the dot
     */
    private static String split(String s) {
        int i = s.lastIndexOf('.');
        if (i < 0)
            return s;
        else
            return s.substring(i + 1);
    }
    
    /** requests to fill in the stack trace we will have to ignore.
     * We can't throw an exception here, because this method
     * is called by the constructor of Throwable */
//    public Throwable fillInStackTrace() {
//        if (ex == null)
//            return super.fillInStackTrace();
//        else
//            return this;
//    }

}
 /*
 * $Id: Element.java,v 1.66 2005/05/04 14:41:15 blowagie Exp $
 * $Name:  $
 *
 * Copyright 1999, 2000, 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

import java.util.ArrayList;

/**
 * Interface for a text element.
 * <P>
 * Remark: I looked at the interface javax.swing.text.Element, but I decided to
 * write my own text-classes for two reasons:
 * <OL>
 * <LI>The javax.swing.text-classes may be very generic, I think they are
 * overkill: they are to heavy for what they have to do.
 * <LI>A lot of people using iText (formerly known as rugPdf), still use
 * JDK1.1.x. I try to keep the Java2 requirements limited to the Collection
 * classes (I think they're really great). However, if I use the
 * javax.swing.text classes, it will become very difficult to downgrade rugPdf.
 * </OL>
 * 
 * @see Anchor
 * @see Cell
 * @see Chapter
 * @see Chunk
 * @see Graphic
 * @see Header
 * @see Image
 * @see Jpeg
 * @see List
 * @see ListItem
 * @see Meta
 * @see Paragraph
 * @see Phrase
 * @see Rectangle
 * @see Row
 * @see Section
 * @see Table
 */

public interface Element {

	// static membervariables (meta information)

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int HEADER = 0;

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int TITLE = 1;

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int SUBJECT = 2;

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int KEYWORDS = 3;

	/** This is a possible type of <CODE>Element </CIDE>. */
	public static final int AUTHOR = 4;

	/** This is a possible type of <CODE>Element </CIDE>. */
	public static final int PRODUCER = 5;

	/** This is a possible type of <CODE>Element </CIDE>. */
	public static final int CREATIONDATE = 6;

	/** This is a possible type of <CODE>Element </CIDE>. */
	public static final int CREATOR = 7;

	// static membervariables (content)

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int CHUNK = 10;

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int PHRASE = 11;

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int PARAGRAPH = 12;

	/** This is a possible type of <CODE>Element</CODE> */
	public static final int SECTION = 13;

	/** This is a possible type of <CODE>Element</CODE> */
	public static final int LIST = 14;

	/** This is a possible type of <CODE>Element</CODE> */
	public static final int LISTITEM = 15;

	/** This is a possible type of <CODE>Element</CODE> */
	public static final int CHAPTER = 16;

	/** This is a possible type of <CODE>Element</CODE> */
	public static final int ANCHOR = 17;

	// static membervariables (tables)

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int CELL = 20;

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int ROW = 21;

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int TABLE = 22;

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int PTABLE = 23;

	// static membervariables (annotations)

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int ANNOTATION = 29;

	// static membervariables (geometric figures)

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int RECTANGLE = 30;

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int JPEG = 32;

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int IMGRAW = 34;

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int IMGTEMPLATE = 35;

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int GRAPHIC = 39;

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int MULTI_COLUMN_TEXT = 40;

	// static membervariables (alignment)

	/**
	 * A possible value for paragraph alignment. This specifies that the text is
	 * aligned to the left indent and extra whitespace should be placed on the
	 * right.
	 */
	public static final int ALIGN_UNDEFINED = -1;

	/**
	 * A possible value for paragraph alignment. This specifies that the text is
	 * aligned to the left indent and extra whitespace should be placed on the
	 * right.
	 */
	public static final int ALIGN_LEFT = 0;

	/**
	 * A possible value for paragraph alignment. This specifies that the text is
	 * aligned to the center and extra whitespace should be placed equally on
	 * the left and right.
	 */
	public static final int ALIGN_CENTER = 1;

	/**
	 * A possible value for paragraph alignment. This specifies that the text is
	 * aligned to the right indent and extra whitespace should be placed on the
	 * left.
	 */
	public static final int ALIGN_RIGHT = 2;

	/**
	 * A possible value for paragraph alignment. This specifies that extra
	 * whitespace should be spread out through the rows of the paragraph with
	 * the text lined up with the left and right indent except on the last line
	 * which should be aligned to the left.
	 */
	public static final int ALIGN_JUSTIFIED = 3;

	/**
	 * A possible value for vertical alignment.
	 */

	public static final int ALIGN_TOP = 4;

	/**
	 * A possible value for vertical alignment.
	 */

	public static final int ALIGN_MIDDLE = 5;

	/**
	 * A possible value for vertical alignment.
	 */

	public static final int ALIGN_BOTTOM = 6;

	/**
	 * A possible value for vertical alignment.
	 */
	public static final int ALIGN_BASELINE = 7;

	/**
	 * Does the same as ALIGN_JUSTIFIED but the last line is also spread out.
	 */
	public static final int ALIGN_JUSTIFIED_ALL = 8;

	// static member variables for CCITT compression

	/**
	 * Pure two-dimensional encoding (Group 4)
	 */
	public static final int CCITTG4 = 0x100;

	/**
	 * Pure one-dimensional encoding (Group 3, 1-D)
	 */
	public static final int CCITTG3_1D = 0x101;

	/**
	 * Mixed one- and two-dimensional encoding (Group 3, 2-D)
	 */
	public static final int CCITTG3_2D = 0x102;

	/**
	 * A flag indicating whether 1-bits are to be interpreted as black pixels
	 * and 0-bits as white pixels,
	 */
	public static final int CCITT_BLACKIS1 = 1;

	/**
	 * A flag indicating whether the filter expects extra 0-bits before each
	 * encoded line so that the line begins on a byte boundary.
	 */
	public static final int CCITT_ENCODEDBYTEALIGN = 2;

	/**
	 * A flag indicating whether end-of-line bit patterns are required to be
	 * present in the encoding.
	 */
	public static final int CCITT_ENDOFLINE = 4;

	/**
	 * A flag indicating whether the filter expects the encoded data to be
	 * terminated by an end-of-block pattern, overriding the Rows parameter. The
	 * use of this flag will set the key /EndOfBlock to false.
	 */
	public static final int CCITT_ENDOFBLOCK = 8;

	// methods

	/**
	 * Processes the element by adding it (or the different parts) to an <CODE>
	 * ElementListener</CODE>.
	 * 
	 * @param listener
	 *            an <CODE>ElementListener</CODE>
	 * @return <CODE>true</CODE> if the element was processed successfully
	 */

	public boolean process(ElementListener listener);

	/**
	 * Gets the type of the text element.
	 * 
	 * @return a type
	 */

	public int type();

	/**
	 * Gets all the chunks in this element.
	 * 
	 * @return an <CODE>ArrayList</CODE>
	 */

	public ArrayList getChunks();

	/**
	 * Gets the content of the text element.
	 * 
	 * @return a type
	 */

	public String toString();
} /*
 * $Id: ElementListener.java,v 1.48 2004/12/14 11:52:46 blowagie Exp $
 * $Name:  $
 *
 * Copyright 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

import java.util.EventListener;

/**
 * A class that implements <CODE>ElementListener</CODE> will perform some
 * actions when an <CODE>Element</CODE> is added.
 *
 * @see		DocListener
 */

public interface ElementListener extends EventListener {
    
    // methods
    
/**
 * Signals that an <CODE>Element</CODE> was added to the <CODE>Document</CODE>.
 * 
 * @param element a high level object
 * @return	<CODE>true</CODE> if the element was added, <CODE>false</CODE> if not.
 * @throws	DocumentException	when a document isn't open yet, or has been closed
 */
    
    public boolean add(Element element) throws DocumentException;
} /*
 * $Id: ElementTags.java,v 1.84 2005/04/06 07:01:18 blowagie Exp $
 * $Name:  $
 *
 * Copyright (c) 2001, 2002 Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

/**
 * A class that contains all the possible tagnames and their attributes.
 */

public class ElementTags {
    
/** the root tag. */
    public static final String ITEXT = "itext";
    
/** attribute of the root and annotation tag (also a special tag within a chapter or section) */
    public static final String TITLE = "title";
    
/** attribute of the root tag */
    public static final String SUBJECT = "subject";
    
/** attribute of the root tag */
    public static final String KEYWORDS = "keywords";
    
/** attribute of the root tag */
    public static final String AUTHOR = "author";
    
/** attribute of the root tag */
    public static final String CREATIONDATE = "creationdate";
    
/** attribute of the root tag */
    public static final String PRODUCER = "producer";
    
    // Chapters and Sections
    
/** the chapter tag */
    public static final String CHAPTER = "chapter";
    
/** the section tag */
    public static final String SECTION = "section";
    
/** attribute of section/chapter tag */
    public static final String NUMBERDEPTH = "numberdepth";
    
/** attribute of section/chapter tag */
    public static final String DEPTH = "depth";
    
/** attribute of section/chapter tag */
    public static final String NUMBER = "number";
    
/** attribute of section/chapter tag */
    public static final String INDENT = "indent";
    
/** attribute of chapter/section/paragraph/table/cell tag */
    public static final String LEFT = "left";
    
/** attribute of chapter/section/paragraph/table/cell tag */
    public static final String RIGHT = "right";
    
    // Phrases, Anchors, Lists and Paragraphs
    
/** the phrase tag */
    public static final String PHRASE = "phrase";
    
/** the anchor tag */
    public static final String ANCHOR = "anchor";
    
/** the list tag */
    public static final String LIST = "list";
    
/** the listitem tag */
    public static final String LISTITEM = "listitem";
    
/** the paragraph tag */
    public static final String PARAGRAPH = "paragraph";
    
/** attribute of phrase/paragraph/cell tag */
    public static final String LEADING = "leading";
    
/** attribute of paragraph/image/table tag */
    public static final String ALIGN = "align";
    
/** attribute of paragraph */
    public static final String KEEPTOGETHER = "keeptogether";
    
/** attribute of anchor tag */
    public static final String NAME = "name";
    
/** attribute of anchor tag */
    public static final String REFERENCE = "reference";
    
/** attribute of list tag */
    public static final String LISTSYMBOL = "listsymbol";
    
/** attribute of list tag */
    public static final String NUMBERED = "numbered";
    
/** attribute of the list tag */
    public static final String LETTERED = "lettered";

/** attribute of list tag */
    public static final String FIRST = "first";
    
/** attribute of list tag */
    public static final String SYMBOLINDENT = "symbolindent";
    
/** attribute of list tag */
    public static final String INDENTATIONLEFT = "indentationleft";
    
/** attribute of list tag */
    public static final String INDENTATIONRIGHT = "indentationright";
    
    // Chunks
    
/** the chunk tag */
    public static final String IGNORE = "ignore";
    
/** the chunk tag */
    public static final String ENTITY = "entity";
    
/** the chunk tag */
    public static final String ID = "id";
    
/** the chunk tag */
    public static final String CHUNK = "chunk";
    
/** attribute of the chunk tag */
    public static final String ENCODING = "encoding";
    
/** attribute of the chunk tag */
    public static final String EMBEDDED = "embedded";
    
/** attribute of the chunk/table/cell tag */
    public static final String COLOR = "color";
    
/** attribute of the chunk/table/cell tag */
    public static final String RED = "red";
    
/** attribute of the chunk/table/cell tag */
    public static final String GREEN = "green";
    
/** attribute of the chunk/table/cell tag */
    public static final String BLUE = "blue";
    
/** attribute of the chunk tag */
    public static final String SUBSUPSCRIPT = Chunk.SUBSUPSCRIPT.toLowerCase();
    
/** attribute of the chunk tag */
    public static final String LOCALGOTO = Chunk.LOCALGOTO.toLowerCase();
    
/** attribute of the chunk tag */
    public static final String REMOTEGOTO = Chunk.REMOTEGOTO.toLowerCase();
    
/** attribute of the chunk tag */
    public static final String LOCALDESTINATION = Chunk.LOCALDESTINATION.toLowerCase();
    
/** attribute of the chunk tag */
    public static final String GENERICTAG = Chunk.GENERICTAG.toLowerCase();
    
    // tables/cells
    
/** the table tag */
    public static final String TABLE = "table";
    
/** the cell tag */
    public static final String ROW = "row";
    
/** the cell tag */
    public static final String CELL = "cell";
    
/** attribute of the table tag */
    public static final String COLUMNS = "columns";
    
/** attribute of the table tag */
    public static final String LASTHEADERROW = "lastHeaderRow";
    
/** attribute of the table tag */
    public static final String CELLPADDING = "cellpadding";
    
/** attribute of the table tag */
    public static final String CELLSPACING = "cellspacing";
    
/** attribute of the table tag */
    public static final String OFFSET = "offset";
    
/** attribute of the table tag */
    public static final String WIDTHS = "widths";
    
/** attribute of the table tag */
    public static final String TABLEFITSPAGE = "tablefitspage";
    
/** attribute of the table tag */
    public static final String CELLSFITPAGE = "cellsfitpage";
    
/** attribute of the cell tag */
    public static final String HORIZONTALALIGN = "horizontalalign";
    
/** attribute of the cell tag */
    public static final String VERTICALALIGN = "verticalalign";
    
/** attribute of the cell tag */
    public static final String COLSPAN = "colspan";
    
/** attribute of the cell tag */
    public static final String ROWSPAN = "rowspan";
    
/** attribute of the cell tag */
    public static final String HEADER = "header";
    
/** attribute of the cell tag */
    public static final String NOWRAP = "nowrap";
    
/** attribute of the table/cell tag */
    public static final String BORDERWIDTH = "borderwidth";
    
/** attribute of the table/cell tag */
    public static final String TOP = "top";
    
/** attribute of the table/cell tag */
    public static final String BOTTOM = "bottom";
    
/** attribute of the table/cell tag */
    public static final String WIDTH = "width";
    
/** attribute of the table/cell tag */
    public static final String BORDERCOLOR = "bordercolor";
    
/** attribute of the table/cell tag */
    public static final String BACKGROUNDCOLOR = "backgroundcolor";
    
/** attribute of the table/cell tag */
    public static final String BGRED = "bgred";
    
/** attribute of the table/cell tag */
    public static final String BGGREEN = "bggreen";
    
/** attribute of the table/cell tag */
    public static final String BGBLUE = "bgblue";
    
/** attribute of the table/cell tag */
    public static final String GRAYFILL = "grayfill";
    
    // Misc
    
/** the image tag */
    public static final String IMAGE = "image";
    
/** attribute of the image and annotation tag */
    public static final String URL = "url";
    
/** attribute of the image tag */
    public static final String UNDERLYING = "underlying";
    
/** attribute of the image tag */
    public static final String TEXTWRAP = "textwrap";
    
/** attribute of the image tag */
    public static final String ALT = "alt";
    
/** attribute of the image tag */
    public static final String ABSOLUTEX = "absolutex";
    
/** attribute of the image tag */
    public static final String ABSOLUTEY = "absolutey";
    
/** attribute of the image tag */
    public static final String PLAINWIDTH = "plainwidth";
    
/** attribute of the image tag */
    public static final String PLAINHEIGHT = "plainheight";
    
/** attribute of the image tag */
    public static final String SCALEDWIDTH = "scaledwidth";
    
/** attribute of the image tag */
    public static final String SCALEDHEIGHT = "scaledheight";
    
/** attribute of the image tag */
    public static final String  ROTATION = "rotation";
    
/** the newpage tag */
    public static final String NEWPAGE = "newpage";
    
/** the newpage tag */
    public static final String NEWLINE = "newline";
    
/** the annotation tag */
    public static final String ANNOTATION = "annotation";
    
/** attribute of the annotation tag */
    public static String FILE = "file";
    
/** attribute of the annotation tag */
    public static String DESTINATION = "destination";
    
/** attribute of the annotation tag */
    public static String PAGE = "page";
    
/** attribute of the annotation tag */
    public static String NAMED = "named";
    
/** attribute of the annotation tag */
    public static String APPLICATION = "application";
    
/** attribute of the annotation tag */
    public static String PARAMETERS = "parameters";
    
/** attribute of the annotation tag */
    public static String OPERATION = "operation";
    
/** attribute of the annotation tag */
    public static String DEFAULTDIR = "defaultdir";
    
/** attribute of the annotation tag */
    public static String LLX = "llx";
    
/** attribute of the annotation tag */
    public static String LLY = "lly";
    
/** attribute of the annotation tag */
    public static String URX = "urx";
    
/** attribute of the annotation tag */
    public static String URY = "ury";
    
/** attribute of the annotation tag */
    public static final String CONTENT = "content";
    
    // alignment attribute values
    
/** the possible value of an alignment attribute */
    public static final String ALIGN_LEFT = "Left";
    
/** the possible value of an alignment attribute */
    public static final String ALIGN_CENTER = "Center";
    
/** the possible value of an alignment attribute */
    public static final String ALIGN_RIGHT = "Right";
    
/** the possible value of an alignment attribute */
    public static final String ALIGN_JUSTIFIED = "Justify";
    
/** the possible value of an alignment attribute */
    public static final String ALIGN_JUSTIFIED_ALL = "JustifyAll";
    
/** the possible value of an alignment attribute */
    public static final String ALIGN_TOP = "Top";
    
/** the possible value of an alignment attribute */
    public static final String ALIGN_MIDDLE = "Middle";
    
/** the possible value of an alignment attribute */
    public static final String ALIGN_BOTTOM = "Bottom";
    
/** the possible value of an alignment attribute */
    public static final String ALIGN_BASELINE = "Baseline";
    
/** the possible value of an alignment attribute */
    public static final String DEFAULT = "Default";
    
/** the possible value of an alignment attribute */
    public static final String UNKNOWN = "unknown";
    
/** the possible value of an alignment attribute */
    public static final String FONT = "font";
    
/** the possible value of an alignment attribute */
    public static final String SIZE = "size";
    
/** the possible value of an alignment attribute */
    public static final String STYLE = "fontstyle";
    
/** the possible value of a tag */
    public static final String HORIZONTALRULE = "horizontalrule";

    /** the possible value of a tag */
    public static final String PAGE_SIZE  = "pagesize";

    /** the possible value of a tag */
    public static final String ORIENTATION  = "orientation";
    
    // methods
    
/**
 * Translates the alignment value.
 *
 * @param   alignment   the alignment value
 * @return  the translated value
 */
    
    public static String getAlignment(int alignment) {
        switch(alignment) {
            case Element.ALIGN_LEFT:
                return ALIGN_LEFT;
            case Element.ALIGN_CENTER:
                return ALIGN_CENTER;
            case Element.ALIGN_RIGHT:
                return ALIGN_RIGHT;
            case Element.ALIGN_JUSTIFIED:
            case Element.ALIGN_JUSTIFIED_ALL:
                return ALIGN_JUSTIFIED;
            case Element.ALIGN_TOP:
                return ALIGN_TOP;
            case Element.ALIGN_MIDDLE:
                return ALIGN_MIDDLE;
            case Element.ALIGN_BOTTOM:
                return ALIGN_BOTTOM;
            case Element.ALIGN_BASELINE:
                return ALIGN_BASELINE;
                default:
                    return DEFAULT;
        }
    }
    
} /*
 * $Id: Entities.java,v 1.43 2004/12/14 11:52:46 blowagie Exp $
 * $Name:  $
 *
 * Copyright 1999, 2000, 2001, 2002 Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

import java.util.HashMap;

/**
 * This class contains entities that can be used in an entity tag.
 */

public class Entities {
    
    /** This is a map that contains all possible id values of the entity tag. */
    public static final HashMap map;
    
    static {
        map = new HashMap();
        map.put("169", new Integer(227));
        map.put("172", new Integer(216));
        map.put("174", new Integer(210));
        map.put("177", new Integer(177));
        map.put("215", new Integer(180));
        map.put("247", new Integer(184));
        map.put("8230", new Integer(188));
        map.put("8242", new Integer(162));
        map.put("8243", new Integer(178));
        map.put("8260", new Integer(164));
        map.put("8364", new Integer(240));
        map.put("8465", new Integer(193));
        map.put("8472", new Integer(195));
        map.put("8476", new Integer(194));
        map.put("8482", new Integer(212));
        map.put("8501", new Integer(192));
        map.put("8592", new Integer(172));
        map.put("8593", new Integer(173));
        map.put("8594", new Integer(174));
        map.put("8595", new Integer(175));
        map.put("8596", new Integer(171));
        map.put("8629", new Integer(191));
        map.put("8656", new Integer(220));
        map.put("8657", new Integer(221));
        map.put("8658", new Integer(222));
        map.put("8659", new Integer(223));
        map.put("8660", new Integer(219));
        map.put("8704", new Integer(34));
        map.put("8706", new Integer(182));
        map.put("8707", new Integer(36));
        map.put("8709", new Integer(198));
        map.put("8711", new Integer(209));
        map.put("8712", new Integer(206));
        map.put("8713", new Integer(207));
        map.put("8717", new Integer(39));
        map.put("8719", new Integer(213));
        map.put("8721", new Integer(229));
        map.put("8722", new Integer(45));
        map.put("8727", new Integer(42));
        map.put("8729", new Integer(183));
        map.put("8730", new Integer(214));
        map.put("8733", new Integer(181));
        map.put("8734", new Integer(165));
        map.put("8736", new Integer(208));
        map.put("8743", new Integer(217));
        map.put("8744", new Integer(218));
        map.put("8745", new Integer(199));
        map.put("8746", new Integer(200));
        map.put("8747", new Integer(242));
        map.put("8756", new Integer(92));
        map.put("8764", new Integer(126));
        map.put("8773", new Integer(64));
        map.put("8776", new Integer(187));
        map.put("8800", new Integer(185));
        map.put("8801", new Integer(186));
        map.put("8804", new Integer(163));
        map.put("8805", new Integer(179));
        map.put("8834", new Integer(204));
        map.put("8835", new Integer(201));
        map.put("8836", new Integer(203));
        map.put("8838", new Integer(205));
        map.put("8839", new Integer(202));
        map.put("8853", new Integer(197));
        map.put("8855", new Integer(196));
        map.put("8869", new Integer(94));
        map.put("8901", new Integer(215));
        map.put("8992", new Integer(243));
        map.put("8993", new Integer(245));
        map.put("9001", new Integer(225));
        map.put("9002", new Integer(241));
        map.put("913", new Integer(65));
        map.put("914", new Integer(66));
        map.put("915", new Integer(71));
        map.put("916", new Integer(68));
        map.put("917", new Integer(69));
        map.put("918", new Integer(90));
        map.put("919", new Integer(72));
        map.put("920", new Integer(81));
        map.put("921", new Integer(73));
        map.put("922", new Integer(75));
        map.put("923", new Integer(76));
        map.put("924", new Integer(77));
        map.put("925", new Integer(78));
        map.put("926", new Integer(88));
        map.put("927", new Integer(79));
        map.put("928", new Integer(80));
        map.put("929", new Integer(82));
        map.put("931", new Integer(83));
        map.put("932", new Integer(84));
        map.put("933", new Integer(85));
        map.put("934", new Integer(70));
        map.put("935", new Integer(67));
        map.put("936", new Integer(89));
        map.put("937", new Integer(87));
        map.put("945", new Integer(97));
        map.put("946", new Integer(98));
        map.put("947", new Integer(103));
        map.put("948", new Integer(100));
        map.put("949", new Integer(101));
        map.put("950", new Integer(122));
        map.put("951", new Integer(104));
        map.put("952", new Integer(113));
        map.put("953", new Integer(105));
        map.put("954", new Integer(107));
        map.put("955", new Integer(108));
        map.put("956", new Integer(109));
        map.put("957", new Integer(110));
        map.put("958", new Integer(120));
        map.put("959", new Integer(111));
        map.put("960", new Integer(112));
        map.put("961", new Integer(114));
        map.put("962", new Integer(86));
        map.put("963", new Integer(115));
        map.put("964", new Integer(116));
        map.put("965", new Integer(117));
        map.put("966", new Integer(102));
        map.put("967", new Integer(99));
        map.put("9674", new Integer(224));
        map.put("968", new Integer(121));
        map.put("969", new Integer(119));
        map.put("977", new Integer(74));
        map.put("978", new Integer(161));
        map.put("981", new Integer(106));
        map.put("982", new Integer(118));
        map.put("9824", new Integer(170));
        map.put("9827", new Integer(167));
        map.put("9829", new Integer(169));
        map.put("9830", new Integer(168));
        map.put("Alpha", new Integer(65));
        map.put("Beta", new Integer(66));
        map.put("Chi", new Integer(67));
        map.put("Delta", new Integer(68));
        map.put("Epsilon", new Integer(69));
        map.put("Eta", new Integer(72));
        map.put("Gamma", new Integer(71));
        map.put("Iota", new Integer(73));
        map.put("Kappa", new Integer(75));
        map.put("Lambda", new Integer(76));
        map.put("Mu", new Integer(77));
        map.put("Nu", new Integer(78));
        map.put("Omega", new Integer(87));
        map.put("Omicron", new Integer(79));
        map.put("Phi", new Integer(70));
        map.put("Pi", new Integer(80));
        map.put("Prime", new Integer(178));
        map.put("Psi", new Integer(89));
        map.put("Rho", new Integer(82));
        map.put("Sigma", new Integer(83));
        map.put("Tau", new Integer(84));
        map.put("Theta", new Integer(81));
        map.put("Upsilon", new Integer(85));
        map.put("Xi", new Integer(88));
        map.put("Zeta", new Integer(90));
        map.put("alefsym", new Integer(192));
        map.put("alpha", new Integer(97));
        map.put("and", new Integer(217));
        map.put("ang", new Integer(208));
        map.put("asymp", new Integer(187));
        map.put("beta", new Integer(98));
        map.put("cap", new Integer(199));
        map.put("chi", new Integer(99));
        map.put("clubs", new Integer(167));
        map.put("cong", new Integer(64));
        map.put("copy", new Integer(211));
        map.put("crarr", new Integer(191));
        map.put("cup", new Integer(200));
        map.put("dArr", new Integer(223));
        map.put("darr", new Integer(175));
        map.put("delta", new Integer(100));
        map.put("diams", new Integer(168));
        map.put("divide", new Integer(184));
        map.put("empty", new Integer(198));
        map.put("epsilon", new Integer(101));
        map.put("equiv", new Integer(186));
        map.put("eta", new Integer(104));
        map.put("euro", new Integer(240));
        map.put("exist", new Integer(36));
        map.put("forall", new Integer(34));
        map.put("frasl", new Integer(164));
        map.put("gamma", new Integer(103));
        map.put("ge", new Integer(179));
        map.put("hArr", new Integer(219));
        map.put("harr", new Integer(171));
        map.put("hearts", new Integer(169));
        map.put("hellip", new Integer(188));
        map.put("horizontal arrow extender", new Integer(190));
        map.put("image", new Integer(193));
        map.put("infin", new Integer(165));
        map.put("int", new Integer(242));
        map.put("iota", new Integer(105));
        map.put("isin", new Integer(206));
        map.put("kappa", new Integer(107));
        map.put("lArr", new Integer(220));
        map.put("lambda", new Integer(108));
        map.put("lang", new Integer(225));
        map.put("large brace extender", new Integer(239));
        map.put("large integral extender", new Integer(244));
        map.put("large left brace (bottom)", new Integer(238));
        map.put("large left brace (middle)", new Integer(237));
        map.put("large left brace (top)", new Integer(236));
        map.put("large left bracket (bottom)", new Integer(235));
        map.put("large left bracket (extender)", new Integer(234));
        map.put("large left bracket (top)", new Integer(233));
        map.put("large left parenthesis (bottom)", new Integer(232));
        map.put("large left parenthesis (extender)", new Integer(231));
        map.put("large left parenthesis (top)", new Integer(230));
        map.put("large right brace (bottom)", new Integer(254));
        map.put("large right brace (middle)", new Integer(253));
        map.put("large right brace (top)", new Integer(252));
        map.put("large right bracket (bottom)", new Integer(251));
        map.put("large right bracket (extender)", new Integer(250));
        map.put("large right bracket (top)", new Integer(249));
        map.put("large right parenthesis (bottom)", new Integer(248));
        map.put("large right parenthesis (extender)", new Integer(247));
        map.put("large right parenthesis (top)", new Integer(246));
        map.put("larr", new Integer(172));
        map.put("le", new Integer(163));
        map.put("lowast", new Integer(42));
        map.put("loz", new Integer(224));
        map.put("minus", new Integer(45));
        map.put("mu", new Integer(109));
        map.put("nabla", new Integer(209));
        map.put("ne", new Integer(185));
        map.put("not", new Integer(216));
        map.put("notin", new Integer(207));
        map.put("nsub", new Integer(203));
        map.put("nu", new Integer(110));
        map.put("omega", new Integer(119));
        map.put("omicron", new Integer(111));
        map.put("oplus", new Integer(197));
        map.put("or", new Integer(218));
        map.put("otimes", new Integer(196));
        map.put("part", new Integer(182));
        map.put("perp", new Integer(94));
        map.put("phi", new Integer(102));
        map.put("pi", new Integer(112));
        map.put("piv", new Integer(118));
        map.put("plusmn", new Integer(177));
        map.put("prime", new Integer(162));
        map.put("prod", new Integer(213));
        map.put("prop", new Integer(181));
        map.put("psi", new Integer(121));
        map.put("rArr", new Integer(222));
        map.put("radic", new Integer(214));
        map.put("radical extender", new Integer(96));
        map.put("rang", new Integer(241));
        map.put("rarr", new Integer(174));
        map.put("real", new Integer(194));
        map.put("reg", new Integer(210));
        map.put("rho", new Integer(114));
        map.put("sdot", new Integer(215));
        map.put("sigma", new Integer(115));
        map.put("sigmaf", new Integer(86));
        map.put("sim", new Integer(126));
        map.put("spades", new Integer(170));
        map.put("sub", new Integer(204));
        map.put("sube", new Integer(205));
        map.put("sum", new Integer(229));
        map.put("sup", new Integer(201));
        map.put("supe", new Integer(202));
        map.put("tau", new Integer(116));
        map.put("there4", new Integer(92));
        map.put("theta", new Integer(113));
        map.put("thetasym", new Integer(74));
        map.put("times", new Integer(180));
        map.put("trade", new Integer(212));
        map.put("uArr", new Integer(221));
        map.put("uarr", new Integer(173));
        map.put("upsih", new Integer(161));
        map.put("upsilon", new Integer(117));
        map.put("vertical arrow extender", new Integer(189));
        map.put("weierp", new Integer(195));
        map.put("xi", new Integer(120));
        map.put("zeta", new Integer(122));
    }
    
 /**
  * Gets a chunk with a symbol character.
  * @param e a symbol value (see Entities class: alfa is greek alfa,...)
  * @param font the font if the symbol isn't found (otherwise Font.SYMBIL)
  * @return a Chunk
  */
    public static Chunk get(String e, Font font) {
        int s = getCorrespondingSymbol(e);
        if (s == -1) {
            try {
                return new Chunk(String.valueOf((char)Integer.parseInt(e)), font);
            }
            catch(Exception exception) {
                return new Chunk(e, font);
            }
        }
        Font symbol = new Font(Font.SYMBOL, font.size(), font.style(), font.color());
        return new Chunk(String.valueOf((char)s), symbol);
    }
    
/**
 * Looks for the corresponding symbol in the font Symbol.
 *
 * @param	c	the original ASCII-char
 * @return	the corresponding symbol in font Symbol
 */
    
    public static int getCorrespondingSymbol(String c) {
        Integer integer = (Integer) map.get(c);
        if (integer == null) {
            return -1;
        }
        return integer.intValue();
    }
    
/**
 * Checks if a given tag corresponds with this object.
 *
 * @param   tag     the given tag
 * @return  true if the tag corresponds
 */
    
    public static boolean isTag(String tag) {
        return ElementTags.ENTITY.equals(tag);
    }
}
 /*
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */
package pdftk.com.lowagie.text;

/**
 * The ExceptionConverter changes a checked exception into an
 * unchecked exception.
 */
public class ExceptionConverter extends RuntimeException {

    /** A serial version UID */
    private static final long serialVersionUID = 8657630363395849399L;

    /** we keep a handle to the wrapped exception */
    private Exception ex;
    /** prefix for the exception */
    private String prefix;

    /**
     * Construct a RuntimeException based on another Exception
     * @param ex the exception that has to be turned into a RuntimeException
     */
    public ExceptionConverter(Exception ex) {
        this.ex = ex;
        prefix = (ex instanceof RuntimeException) ? "" : "ExceptionConverter: ";
    }

    /**
     * and allow the user of ExceptionConverter to get a handle to it. 
     * @return the original exception
     */
    public Exception getException() {
        return ex;
    }

    /**
     * We print the message of the checked exception 
     * @return message of the original exception
     */
    public String getMessage() {
        return ex.getMessage();
    }

    /**
     * and make sure we also produce a localized version
     * @return localized version of the message
     */
    public String getLocalizedMessage() {
        return ex.getLocalizedMessage();
    }

    /**
     * The toString() is changed to be prefixed with ExceptionConverter 
     * @return Stringversion of the exception
     */
    public String toString() {
        return prefix + ex;
    }

    /** we have to override this as well */
    public void printStackTrace() {
        printStackTrace(System.err);
    }

    /**
     * here we prefix, with s.print(), not s.println(), the stack
     * trace with "ExceptionConverter:" 
     * @param s
     */
    public void printStackTrace(java.io.PrintStream s) {
        synchronized (s) {
            s.print(prefix);
            ex.printStackTrace(s);
        }
    }

    /**
     * Again, we prefix the stack trace with "ExceptionConverter:" 
     * @param s
     */
    public void printStackTrace(java.io.PrintWriter s) {
        synchronized (s) {
            s.print(prefix);
            ex.printStackTrace(s);
        }
    }

    /**
     * requests to fill in the stack trace we will have to ignore.
     * We can't throw an exception here, because this method
     * is called by the constructor of Throwable 
     * @return a Throwable
     */
    public Throwable fillInStackTrace() {
        return this;
    }
} /*
 * $Id: Font.java,v 1.94 2005/10/05 14:16:04 blowagie Exp $
 * $Name:  $
 *
 * Copyright 1999, 2000, 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

import java.awt.Color;

import pdftk.com.lowagie.text.pdf.BaseFont;
import pdftk.com.lowagie.text.markup.MarkupTags;

/**
 * Contains all the specifications of a font: fontfamily, size, style and color.
 * <P>
 * Example: <BLOCKQUOTE>
 * 
 * <PRE>
 * 
 * Paragraph p = new Paragraph("This is a paragraph", <STRONG>new
 * Font(Font.HELVETICA, 18, Font.BOLDITALIC, new Color(0, 0, 255)) </STRONG>);
 * 
 * </PRE>
 * 
 * </BLOCKQUOTE>
 */

public class Font implements Comparable {

	// static membervariables for the different families

	/** a possible value of a font family. */
	public static final int COURIER = 0;

	/** a possible value of a font family. */
	public static final int HELVETICA = 1;

	/** a possible value of a font family. */
	public static final int TIMES_ROMAN = 2;

	/** a possible value of a font family. */
	public static final int SYMBOL = 3;

	/** a possible value of a font family. */
	public static final int ZAPFDINGBATS = 4;

	// static membervariables for the different styles

	/** this is a possible style. */
	public static final int NORMAL = 0;

	/** this is a possible style. */
	public static final int BOLD = 1;

	/** this is a possible style. */
	public static final int ITALIC = 2;

	/** this is a possible style. */
	public static final int UNDERLINE = 4;

	/** this is a possible style. */
	public static final int STRIKETHRU = 8;

	/** this is a possible style. */
	public static final int BOLDITALIC = BOLD | ITALIC;

	// static membervariables

	/** the value of an undefined attribute. */
	public static final int UNDEFINED = -1;

	/** the value of the default size. */
	public static final int DEFAULTSIZE = 12;

	// membervariables

	/** the value of the fontfamily. */
	private int family = UNDEFINED;

	/** the value of the fontsize. */
	private float size = UNDEFINED;

	/** the value of the style. */
	private int style = UNDEFINED;

	/** the value of the color. */
	private Color color = null;

	/** the external font */
	private BaseFont baseFont = null;

	// constructors

	/**
	 * Copy constructor of a Font
	 * 
	 * @param other
	 *            the font that has to be copied
	 */
	public Font(Font other) {
		this.color = other.color;
		this.family = other.family;
		this.size = other.size;
		this.style = other.style;
		this.baseFont = other.baseFont;
	}

	/**
	 * Constructs a Font.
	 * 
	 * @param family
	 *            the family to which this font belongs
	 * @param size
	 *            the size of this font
	 * @param style
	 *            the style of this font
	 * @param color
	 *            the <CODE>Color</CODE> of this font.
	 */

	public Font(int family, float size, int style, Color color) {
		this.family = family;
		this.size = size;
		this.style = style;
		this.color = color;
	}

	/**
	 * Constructs a Font.
	 * 
	 * @param bf
	 *            the external font
	 * @param size
	 *            the size of this font
	 * @param style
	 *            the style of this font
	 * @param color
	 *            the <CODE>Color</CODE> of this font.
	 */

	public Font(BaseFont bf, float size, int style, Color color) {
		this.baseFont = bf;
		this.size = size;
		this.style = style;
		this.color = color;
	}

	/**
	 * Constructs a Font.
	 * 
	 * @param bf
	 *            the external font
	 * @param size
	 *            the size of this font
	 * @param style
	 *            the style of this font
	 */
	public Font(BaseFont bf, float size, int style) {
		this(bf, size, style, null);
	}

	/**
	 * Constructs a Font.
	 * 
	 * @param bf
	 *            the external font
	 * @param size
	 *            the size of this font
	 */
	public Font(BaseFont bf, float size) {
		this(bf, size, UNDEFINED, null);
	}

	/**
	 * Constructs a Font.
	 * 
	 * @param bf
	 *            the external font
	 */
	public Font(BaseFont bf) {
		this(bf, UNDEFINED, UNDEFINED, null);
	}

	/**
	 * Constructs a Font.
	 * 
	 * @param family
	 *            the family to which this font belongs
	 * @param size
	 *            the size of this font
	 * @param style
	 *            the style of this font
	 */

	public Font(int family, float size, int style) {
		this(family, size, style, null);
	}

	/**
	 * Constructs a Font.
	 * 
	 * @param family
	 *            the family to which this font belongs
	 * @param size
	 *            the size of this font
	 */

	public Font(int family, float size) {
		this(family, size, UNDEFINED, null);
	}

	/**
	 * Constructs a Font.
	 * 
	 * @param family
	 *            the family to which this font belongs
	 */

	public Font(int family) {
		this(family, UNDEFINED, UNDEFINED, null);
	}

	/**
	 * Constructs a Font.
	 */

	public Font() {
		this(UNDEFINED, UNDEFINED, UNDEFINED, null);
	}

	// implementation of the Comparable interface

	/**
	 * Compares this <CODE>Font</CODE> with another
	 * 
	 * @param object
	 *            the other <CODE>Font</CODE>
	 * @return a value
	 */

	public int compareTo(Object object) {
		if (object == null) {
			return -1;
		}
		Font font;
		try {
			font = (Font) object;
			if (baseFont != null && !baseFont.equals(font.getBaseFont())) {
				return -2;
			}
			if (this.family != font.family()) {
				return 1;
			}
			if (this.size != font.size()) {
				return 2;
			}
			if (this.style != font.style()) {
				return 3;
			}
			if (this.color == null) {
				if (font.color == null) {
					return 0;
				}
				return 4;
			}
			if (font.color == null) {
				return 4;
			}
			if (this.color.equals(font.color())) {
				return 0;
			}
			return 4;
		} catch (ClassCastException cce) {
			return -3;
		}
	}

	// methods

	/**
	 * Sets the family using a <CODE>String</CODE> ("Courier", "Helvetica",
	 * "Times New Roman", "Symbol" or "ZapfDingbats").
	 * 
	 * @param family
	 *            A <CODE>String</CODE> representing a certain font-family.
	 */

	public void setFamily(String family) {
		this.family = getFamilyIndex(family);
	}

	/**
	 * Translates a <CODE>String</CODE> -value of a certain family into the
	 * index that is used for this family in this class.
	 * 
	 * @param family
	 *            A <CODE>String</CODE> representing a certain font-family
	 * @return the corresponding index
	 */

	public static int getFamilyIndex(String family) {
		if (family.equalsIgnoreCase(FontFactory.COURIER)) {
			return COURIER;
		}
		if (family.equalsIgnoreCase(FontFactory.HELVETICA)) {
			return HELVETICA;
		}
		if (family.equalsIgnoreCase(FontFactory.TIMES_ROMAN)) {
			return TIMES_ROMAN;
		}
		if (family.equalsIgnoreCase(FontFactory.SYMBOL)) {
			return SYMBOL;
		}
		if (family.equalsIgnoreCase(FontFactory.ZAPFDINGBATS)) {
			return ZAPFDINGBATS;
		}
		return UNDEFINED;
	}

	/**
	 * Gets the familyname as a String.
	 * 
	 * @return the familyname
	 */

	public String getFamilyname() {
		String tmp = "unknown";
		switch (family()) {
		case Font.COURIER:
			return FontFactory.COURIER;
		case Font.HELVETICA:
			return FontFactory.HELVETICA;
		case Font.TIMES_ROMAN:
			return FontFactory.TIMES_ROMAN;
		case Font.SYMBOL:
			return FontFactory.SYMBOL;
		case Font.ZAPFDINGBATS:
			return FontFactory.ZAPFDINGBATS;
		default:
			if (baseFont != null) {
				String[][] names = baseFont.getFamilyFontName();
				for (int i = 0; i < names.length; i++) {
					if ("0".equals(names[i][2])) {
						return names[i][3];
					}
					if ("1033".equals(names[i][2])) {
						tmp = names[i][3];
					}
					if ("".equals(names[i][2])) {
						tmp = names[i][3];
					}
				}
			}
		}
		return tmp;
	}

	/**
	 * Sets the size.
	 * 
	 * @param size
	 *            The new size of the font.
	 */

	public void setSize(float size) {
		this.size = size;
	}

	/**
	 * Sets the style using a <CODE>String</CODE> containing one of more of
	 * the following values: normal, bold, italic, underline, strike.
	 * 
	 * @param style
	 *            A <CODE>String</CODE> representing a certain style.
	 */

	public void setStyle(String style) {
		if (this.style == UNDEFINED)
			this.style = NORMAL;
		this.style |= getStyleValue(style);
	}

	/**
	 * Sets the style.
	 * 
	 * @param style
	 *            the style.
	 */

	public void setStyle(int style) {
		if (this.style == UNDEFINED)
			this.style = NORMAL;
		this.style |= style;
	}

	/**
	 * Translates a <CODE>String</CODE> -value of a certain style into the
	 * index value is used for this style in this class.
	 * 
	 * @param style
	 *            A <CODE>String</CODE>
	 * @return the corresponding value
	 */

	public static int getStyleValue(String style) {
		int s = 0;
		if (style.indexOf(MarkupTags.CSS_VALUE_NORMAL) != -1) {
			s |= NORMAL;
		}
		if (style.indexOf(MarkupTags.CSS_VALUE_BOLD) != -1) {
			s |= BOLD;
		}
		if (style.indexOf(MarkupTags.CSS_VALUE_ITALIC) != -1) {
			s |= ITALIC;
		}
		if (style.indexOf(MarkupTags.CSS_VALUE_OBLIQUE) != -1) {
			s |= ITALIC;
		}
		if (style.indexOf(MarkupTags.CSS_VALUE_UNDERLINE) != -1) {
			s |= UNDERLINE;
		}
		if (style.indexOf(MarkupTags.CSS_VALUE_LINETHROUGH) != -1) {
			s |= STRIKETHRU;
		}
		return s;
	}

	/**
	 * Sets the color.
	 * 
	 * @param color
	 *            the new color of the font
	 */

	public void setColor(Color color) {
		this.color = color;
	}

	/**
	 * Sets the color.
	 * 
	 * @param red
	 *            the red-value of the new color
	 * @param green
	 *            the green-value of the new color
	 * @param blue
	 *            the blue-value of the new color
	 */

	public void setColor(int red, int green, int blue) {
		this.color = new Color(red, green, blue);
	}

	/**
	 * Gets the leading that can be used with this font.
	 * 
	 * @param linespacing
	 *            a certain linespacing
	 * @return the height of a line
	 */

	public float leading(float linespacing) {
		if (size == UNDEFINED) {
			return linespacing * DEFAULTSIZE;
		}
		return linespacing * size;
	}

	/**
	 * Checks if the properties of this font are undefined or null.
	 * <P>
	 * If so, the standard should be used.
	 * 
	 * @return a <CODE>boolean</CODE>
	 */

	public boolean isStandardFont() {
		return (family == UNDEFINED && size == UNDEFINED && style == UNDEFINED
				&& color == null && baseFont == null);
	}

	/**
	 * Replaces the attributes that are equal to <VAR>null </VAR> with the
	 * attributes of a given font.
	 * 
	 * @param font
	 *            the font of a bigger element class
	 * @return a <CODE>Font</CODE>
	 */

	public Font difference(Font font) {
		// size
		float dSize = font.size;
		if (dSize == UNDEFINED) {
			dSize = this.size;
		}
		// style
		int dStyle = UNDEFINED;
		int style1 = this.style;
		int style2 = font.style();
		if (style1 != UNDEFINED || style2 != UNDEFINED) {
			if (style1 == UNDEFINED)
				style1 = 0;
			if (style2 == UNDEFINED)
				style2 = 0;
			dStyle = style1 | style2;
		}
		// color
		Color dColor = font.color;
		if (dColor == null) {
			dColor = this.color;
		}
		// family
		if (font.baseFont != null) {
			return new Font(font.baseFont, dSize, dStyle, dColor);
		}
		if (font.family() != UNDEFINED) {
			return new Font(font.family, dSize, dStyle, dColor);
		}
		if (this.baseFont != null) {
			if (dStyle == style1) {
				return new Font(this.baseFont, dSize, dStyle, dColor);
			} else {
				return FontFactory.getFont(this.getFamilyname(), dSize, dStyle,
						dColor);
			}
		}
		return new Font(this.family, dSize, dStyle, dColor);
	}

	// methods to retrieve the membervariables

	/**
	 * Gets the family of this font.
	 * 
	 * @return the value of the family
	 */

	public int family() {
		return family;
	}

	/**
	 * Gets the size of this font.
	 * 
	 * @return a size
	 */

	public float size() {
		return size;
	}

	/**
	 * Gets the style of this font.
	 * 
	 * @return a size
	 */

	public int style() {
		return style;
	}

	/**
	 * checks if this font is Bold.
	 * 
	 * @return a <CODE>boolean</CODE>
	 */

	public boolean isBold() {
		if (style == UNDEFINED) {
			return false;
		}
		return (style & BOLD) == BOLD;
	}

	/**
	 * checks if this font is Bold.
	 * 
	 * @return a <CODE>boolean</CODE>
	 */

	public boolean isItalic() {
		if (style == UNDEFINED) {
			return false;
		}
		return (style & ITALIC) == ITALIC;
	}

	/**
	 * checks if this font is underlined.
	 * 
	 * @return a <CODE>boolean</CODE>
	 */

	public boolean isUnderlined() {
		if (style == UNDEFINED) {
			return false;
		}
		return (style & UNDERLINE) == UNDERLINE;
	}

	/**
	 * checks if the style of this font is STRIKETHRU.
	 * 
	 * @return a <CODE>boolean</CODE>
	 */

	public boolean isStrikethru() {
		if (style == UNDEFINED) {
			return false;
		}
		return (style & STRIKETHRU) == STRIKETHRU;
	}

	/**
	 * Gets the color of this font.
	 * 
	 * @return a color
	 */

	public Color color() {
		return color;
	}

	/**
	 * Gets the <CODE>BaseFont</CODE> inside this object.
	 * 
	 * @return the <CODE>BaseFont</CODE>
	 */

	public BaseFont getBaseFont() {
		return baseFont;
	}

	/**
	 * Gets the <CODE>BaseFont</CODE> this class represents. For the built-in
	 * fonts a <CODE>BaseFont</CODE> is calculated.
	 * 
	 * @param specialEncoding
	 *            <CODE>true</CODE> to use the special encoding for Symbol and
	 *            ZapfDingbats, <CODE>false</CODE> to always use <CODE>Cp1252
	 *            </CODE>
	 * @return the <CODE>BaseFont</CODE> this class represents
	 */
	public BaseFont getCalculatedBaseFont(boolean specialEncoding) {
		if (baseFont != null)
			return baseFont;
		int style = this.style;
		if (style == UNDEFINED) {
			style = NORMAL;
		}
		String fontName = BaseFont.HELVETICA;
		String encoding = BaseFont.WINANSI;
		BaseFont cfont = null;
		switch (family) {
		case COURIER:
			switch (style & BOLDITALIC) {
			case BOLD:
				fontName = BaseFont.COURIER_BOLD;
				break;
			case ITALIC:
				fontName = BaseFont.COURIER_OBLIQUE;
				break;
			case BOLDITALIC:
				fontName = BaseFont.COURIER_BOLDOBLIQUE;
				break;
			default:
				//case NORMAL:
				fontName = BaseFont.COURIER;
				break;
			}
			break;
		case TIMES_ROMAN:
			switch (style & BOLDITALIC) {
			case BOLD:
				fontName = BaseFont.TIMES_BOLD;
				break;
			case ITALIC:
				fontName = BaseFont.TIMES_ITALIC;
				break;
			case BOLDITALIC:
				fontName = BaseFont.TIMES_BOLDITALIC;
				break;
			default:
			case NORMAL:
				fontName = BaseFont.TIMES_ROMAN;
				break;
			}
			break;
		case SYMBOL:
			fontName = BaseFont.SYMBOL;
			if (specialEncoding)
				encoding = BaseFont.SYMBOL;
			break;
		case ZAPFDINGBATS:
			fontName = BaseFont.ZAPFDINGBATS;
			if (specialEncoding)
				encoding = BaseFont.ZAPFDINGBATS;
			break;
		default:
		case Font.HELVETICA:
			switch (style & BOLDITALIC) {
			case BOLD:
				fontName = BaseFont.HELVETICA_BOLD;
				break;
			case ITALIC:
				fontName = BaseFont.HELVETICA_OBLIQUE;
				break;
			case BOLDITALIC:
				fontName = BaseFont.HELVETICA_BOLDOBLIQUE;
				break;
			default:
			case NORMAL:
				fontName = BaseFont.HELVETICA;
				break;
			}
			break;
		}
		try {
			cfont = BaseFont.createFont(fontName, encoding, false);
		} catch (Exception ee) {
			throw new ExceptionConverter(ee);
		}
		return cfont;
	}

	/**
	 * Gets the style that can be used with the calculated <CODE>BaseFont
	 * </CODE>.
	 * 
	 * @return the style that can be used with the calculated <CODE>BaseFont
	 *         </CODE>
	 */
	public int getCalculatedStyle() {
		int style = this.style;
		if (style == UNDEFINED) {
			style = NORMAL;
		}
		if (baseFont != null)
			return style;
		if (family == SYMBOL || family == ZAPFDINGBATS)
			return style;
		else
			return style & (~BOLDITALIC);
	}

	/**
	 * Gets the size that can be used with the calculated <CODE>BaseFont
	 * </CODE>.
	 * 
	 * @return the size that can be used with the calculated <CODE>BaseFont
	 *         </CODE>
	 */
	public float getCalculatedSize() {
		float s = this.size;
		if (s == UNDEFINED) {
			s = DEFAULTSIZE;
		}
		return s;
	}
} /*
 * $Id: FontFactory.java,v 1.65 2005/05/03 13:03:47 blowagie Exp $
 * $Name:  $
 *
 * Copyright 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

import java.awt.Color;
import java.io.IOException;
import java.util.Hashtable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Properties;
import java.util.Set;
import java.util.Enumeration;
import java.io.File;
import pdftk.com.lowagie.text.pdf.BaseFont;
import pdftk.com.lowagie.text.markup.MarkupTags;
import pdftk.com.lowagie.text.markup.MarkupParser;

/**
 * If you are using True Type fonts, you can declare the paths of the different ttf- and ttc-files
 * to this static class first and then create fonts in your code using one of the static getFont-method
 * without having to enter a path as parameter.
 *
 * @author  Bruno Lowagie
 */

public class FontFactory extends java.lang.Object {
    
/** This is a possible value of a base 14 type 1 font */
    public static final String COURIER = BaseFont.COURIER;
    
/** This is a possible value of a base 14 type 1 font */
    public static final String COURIER_BOLD = BaseFont.COURIER_BOLD;
    
/** This is a possible value of a base 14 type 1 font */
    public static final String COURIER_OBLIQUE = BaseFont.COURIER_OBLIQUE;
    
/** This is a possible value of a base 14 type 1 font */
    public static final String COURIER_BOLDOBLIQUE = BaseFont.COURIER_BOLDOBLIQUE;
    
/** This is a possible value of a base 14 type 1 font */
    public static final String HELVETICA = BaseFont.HELVETICA;
    
/** This is a possible value of a base 14 type 1 font */
    public static final String HELVETICA_BOLD = BaseFont.HELVETICA_BOLD;
    
/** This is a possible value of a base 14 type 1 font */
    public static final String HELVETICA_OBLIQUE = BaseFont.HELVETICA_OBLIQUE;
    
/** This is a possible value of a base 14 type 1 font */
    public static final String HELVETICA_BOLDOBLIQUE = BaseFont.HELVETICA_BOLDOBLIQUE;
    
/** This is a possible value of a base 14 type 1 font */
    public static final String SYMBOL = BaseFont.SYMBOL;
    
/** This is a possible value of a base 14 type 1 font */
    public static final String TIMES = "Times";
    
/** This is a possible value of a base 14 type 1 font */
    public static final String TIMES_ROMAN = BaseFont.TIMES_ROMAN;
    
/** This is a possible value of a base 14 type 1 font */
    public static final String TIMES_BOLD = BaseFont.TIMES_BOLD;
    
/** This is a possible value of a base 14 type 1 font */
    public static final String TIMES_ITALIC = BaseFont.TIMES_ITALIC;
    
/** This is a possible value of a base 14 type 1 font */
    public static final String TIMES_BOLDITALIC = BaseFont.TIMES_BOLDITALIC;
    
/** This is a possible value of a base 14 type 1 font */
    public static final String ZAPFDINGBATS = BaseFont.ZAPFDINGBATS;
    
/** This is a map of postscriptfontnames of True Type fonts and the path of their ttf- or ttc-file. */
    private static Properties trueTypeFonts = new Properties();
    
    private static String[] TTFamilyOrder = {
        "3", "1", "1033",
        "3", "0", "1033",
        "1", "0", "0",
        "0", "3", "0"
    };

    static {
        trueTypeFonts.setProperty(COURIER.toLowerCase(), COURIER);
        trueTypeFonts.setProperty(COURIER_BOLD.toLowerCase(), COURIER_BOLD);
        trueTypeFonts.setProperty(COURIER_OBLIQUE.toLowerCase(), COURIER_OBLIQUE);
        trueTypeFonts.setProperty(COURIER_BOLDOBLIQUE.toLowerCase(), COURIER_BOLDOBLIQUE);
        trueTypeFonts.setProperty(HELVETICA.toLowerCase(), HELVETICA);
        trueTypeFonts.setProperty(HELVETICA_BOLD.toLowerCase(), HELVETICA_BOLD);
        trueTypeFonts.setProperty(HELVETICA_OBLIQUE.toLowerCase(), HELVETICA_OBLIQUE);
        trueTypeFonts.setProperty(HELVETICA_BOLDOBLIQUE.toLowerCase(), HELVETICA_BOLDOBLIQUE);
        trueTypeFonts.setProperty(SYMBOL.toLowerCase(), SYMBOL);
        trueTypeFonts.setProperty(TIMES_ROMAN.toLowerCase(), TIMES_ROMAN);
        trueTypeFonts.setProperty(TIMES_BOLD.toLowerCase(), TIMES_BOLD);
        trueTypeFonts.setProperty(TIMES_ITALIC.toLowerCase(), TIMES_ITALIC);
        trueTypeFonts.setProperty(TIMES_BOLDITALIC.toLowerCase(), TIMES_BOLDITALIC);
        trueTypeFonts.setProperty(ZAPFDINGBATS.toLowerCase(), ZAPFDINGBATS);
    }
    
/** This is a map of fontfamilies. */
    private static Hashtable fontFamilies = new Hashtable();
    
    static {
        ArrayList tmp;
        tmp = new ArrayList();
        tmp.add(COURIER);
        tmp.add(COURIER_BOLD);
        tmp.add(COURIER_OBLIQUE);
        tmp.add(COURIER_BOLDOBLIQUE);
        fontFamilies.put(COURIER.toLowerCase(), tmp);
        tmp = new ArrayList();
        tmp.add(HELVETICA);
        tmp.add(HELVETICA_BOLD);
        tmp.add(HELVETICA_OBLIQUE);
        tmp.add(HELVETICA_BOLDOBLIQUE);
        fontFamilies.put(HELVETICA.toLowerCase(), tmp);
        tmp = new ArrayList();
        tmp.add(SYMBOL);
        fontFamilies.put(SYMBOL.toLowerCase(), tmp);
        tmp = new ArrayList();
        tmp.add(TIMES_ROMAN);
        tmp.add(TIMES_BOLD);
        tmp.add(TIMES_ITALIC);
        tmp.add(TIMES_BOLDITALIC);
        fontFamilies.put(TIMES.toLowerCase(), tmp);
        fontFamilies.put(TIMES_ROMAN.toLowerCase(), tmp);
        tmp = new ArrayList();
        tmp.add(ZAPFDINGBATS);
        fontFamilies.put(ZAPFDINGBATS.toLowerCase(), tmp);
    }
    
    
/** This is the default encoding to use. */
    public static String defaultEncoding = BaseFont.WINANSI;
    
/** This is the default value of the <VAR>embedded</VAR> variable. */
    public static boolean defaultEmbedding = BaseFont.NOT_EMBEDDED;
    
/** Creates new FontFactory */
    private FontFactory() {
    }
    
/**
 * Constructs a <CODE>Font</CODE>-object.
 *
 * @param	fontname    the name of the font
 * @param	encoding    the encoding of the font
 * @param       embedded    true if the font is to be embedded in the PDF
 * @param	size	    the size of this font
 * @param	style	    the style of this font
 * @param	color	    the <CODE>Color</CODE> of this font.
 * @return the Font constructed based on the parameters
 */
    
    public static Font getFont(String fontname, String encoding, boolean embedded, float size, int style, Color color) {
        if (fontname == null) return new Font(Font.UNDEFINED, size, style, color);
        String lowercasefontname = fontname.toLowerCase();
        ArrayList tmp = (ArrayList) fontFamilies.get(lowercasefontname);
        if (tmp != null) {
            // some bugs were fixed here by Daniel Marczisovszky
            int s = style == Font.UNDEFINED ? Font.NORMAL : style;
            int fs = Font.NORMAL;
            boolean found = false;
            for (Iterator i = tmp.iterator(); i.hasNext(); ) {
                String f = (String) i.next();
                String lcf = f.toLowerCase();
                fs = Font.NORMAL;
                if (lcf.toLowerCase().indexOf("bold") != -1) fs |= Font.BOLD;
                if (lcf.toLowerCase().indexOf("italic") != -1 || lcf.toLowerCase().indexOf("oblique") != -1) fs |= Font.ITALIC;
                if ((s & Font.BOLDITALIC) == fs) {
                    fontname = f;
                    found = true;
                    break;
                }
            }
            if (style != Font.UNDEFINED && found) {
                style &= ~fs;
            }
        }
        BaseFont basefont = null;
        try {
            try {
                // the font is a type 1 font or CJK font
                basefont = BaseFont.createFont(fontname, encoding, embedded);
            }
            catch(DocumentException de) {
                // the font is a true type font or an unknown font
                fontname = trueTypeFonts.getProperty(fontname.toLowerCase());
                // the font is not registered as truetype font
                if (fontname == null) return new Font(Font.UNDEFINED, size, style, color);
                // the font is registered as truetype font
                basefont = BaseFont.createFont(fontname, encoding, embedded);
            }
        }
        catch(DocumentException de) {
            // this shouldn't happen
            throw new ExceptionConverter(de);
        }
        catch(IOException ioe) {
            // the font is registered as a true type font, but the path was wrong
            return new Font(Font.UNDEFINED, size, style, color);
        }
        catch(NullPointerException npe) {
            // null was entered as fontname and/or encoding
            return new Font(Font.UNDEFINED, size, style, color);
        }
        return new Font(basefont, size, style, color);
    }
    
/**
 * Constructs a <CODE>Font</CODE>-object.
 *
 * @param   attributes  the attributes of a <CODE>Font</CODE> object.
 * @return the Font constructed based on the attributes
 */
    
    public static Font getFont(Properties attributes) {
        String fontname = null;
        String encoding = defaultEncoding;
        boolean embedded = defaultEmbedding;
        float size = Font.UNDEFINED;
        int style = Font.NORMAL;
        Color color = null;
        String value = (String) attributes.remove(MarkupTags.HTML_ATTR_STYLE);
        if (value != null && value.length() > 0) {
            Properties styleAttributes = MarkupParser.parseAttributes(value);
            if (styleAttributes.size() == 0) {
                attributes.put(MarkupTags.HTML_ATTR_STYLE, value);
            }
            else {
                fontname = (String)styleAttributes.remove(MarkupTags.CSS_KEY_FONTFAMILY);
                if (fontname != null) {
                    String tmp;
                    while (fontname.indexOf(",") != -1) {
                        tmp = fontname.substring(0, fontname.indexOf(","));
                        if (isRegistered(tmp)) {
                            fontname = tmp;
                        }
                        else {
                            fontname = fontname.substring(fontname.indexOf(",") + 1);
                        }
                    }
                }
                if ((value = (String)styleAttributes.remove(MarkupTags.CSS_KEY_FONTSIZE)) != null) {
                    size = MarkupParser.parseLength(value);
                }
                if ((value = (String)styleAttributes.remove(MarkupTags.CSS_KEY_FONTWEIGHT)) != null) {
                    style |= Font.getStyleValue(value);
                }
                if ((value = (String)styleAttributes.remove(MarkupTags.CSS_KEY_FONTSTYLE)) != null) {
                    style |= Font.getStyleValue(value);
                }
                if ((value = (String)styleAttributes.remove(MarkupTags.CSS_KEY_COLOR)) != null) {
                    color = MarkupParser.decodeColor(value);
                }
                attributes.putAll(styleAttributes);
                for (Enumeration e = styleAttributes.keys(); e.hasMoreElements();) {
                    Object o = e.nextElement();
                    attributes.put(o, styleAttributes.get(o));
                }
            }
        }
        if ((value = (String)attributes.remove(ElementTags.ENCODING)) != null) {
            encoding = value;
        }
        if ("true".equals(attributes.remove(ElementTags.EMBEDDED))) {
            embedded = true;
        }
        if ((value = (String)attributes.remove(ElementTags.FONT)) != null) {
            fontname = value;
        }
        if ((value = (String)attributes.remove(ElementTags.SIZE)) != null) {
            size = Float.valueOf(value + "f").floatValue();
        }
        if ((value = (String)attributes.remove(MarkupTags.HTML_ATTR_STYLE)) != null) {
            style |= Font.getStyleValue(value);
        }
        if ((value = (String)attributes.remove(ElementTags.STYLE)) != null) {
            style |= Font.getStyleValue(value);
        }
        String r = (String)attributes.remove(ElementTags.RED);
        String g = (String)attributes.remove(ElementTags.GREEN);
        String b = (String)attributes.remove(ElementTags.BLUE);
        if (r != null || g != null || b != null) {
            int red = 0;
            int green = 0;
            int blue = 0;
            if (r != null) red = Integer.parseInt(r);
            if (g != null) green = Integer.parseInt(g);
            if (b != null) blue = Integer.parseInt(b);
            color = new Color(red, green, blue);
        }
        else if ((value = (String)attributes.remove(ElementTags.COLOR)) != null) {
            color = MarkupParser.decodeColor(value);
        }
        if (fontname == null) {
            return getFont(null, encoding, embedded, size, style, color);
        }
        return getFont(fontname, encoding, embedded, size, style, color);
    }
    
/**
 * Constructs a <CODE>Font</CODE>-object.
 *
 * @param	fontname    the name of the font
 * @param	encoding    the encoding of the font
 * @param       embedded    true if the font is to be embedded in the PDF
 * @param	size	    the size of this font
 * @param	style	    the style of this font
 * @return the Font constructed based on the parameters
 */
    
    public static Font getFont(String fontname, String encoding, boolean embedded, float size, int style) {
        return getFont(fontname, encoding, embedded, size, style, null);
    }
    
/**
 * Constructs a <CODE>Font</CODE>-object.
 *
 * @param	fontname    the name of the font
 * @param	encoding    the encoding of the font
 * @param       embedded    true if the font is to be embedded in the PDF
 * @param	size	    the size of this font
 * @return the Font constructed based on the parameters
 */
    
    public static Font getFont(String fontname, String encoding, boolean embedded, float size) {
        return getFont(fontname, encoding, embedded, size, Font.UNDEFINED, null);
    }
    
/**
 * Constructs a <CODE>Font</CODE>-object.
 *
 * @param	fontname    the name of the font
 * @param	encoding    the encoding of the font
 * @param       embedded    true if the font is to be embedded in the PDF
 * @return the Font constructed based on the parameters
 */
    
    public static Font getFont(String fontname, String encoding, boolean embedded) {
        return getFont(fontname, encoding, embedded, Font.UNDEFINED, Font.UNDEFINED, null);
    }
    
/**
 * Constructs a <CODE>Font</CODE>-object.
 *
 * @param	fontname    the name of the font
 * @param	encoding    the encoding of the font
 * @param	size	    the size of this font
 * @param	style	    the style of this font
 * @param	color	    the <CODE>Color</CODE> of this font.
 * @return the Font constructed based on the parameters
 */
    
    public static Font getFont(String fontname, String encoding, float size, int style, Color color) {
        return getFont(fontname, encoding, defaultEmbedding, size, style, color);
    }
    
/**
 * Constructs a <CODE>Font</CODE>-object.
 *
 * @param	fontname    the name of the font
 * @param	encoding    the encoding of the font
 * @param	size	    the size of this font
 * @param	style	    the style of this font
 * @return the Font constructed based on the parameters
 */
    
    public static Font getFont(String fontname, String encoding, float size, int style) {
        return getFont(fontname, encoding, defaultEmbedding, size, style, null);
    }
    
/**
 * Constructs a <CODE>Font</CODE>-object.
 *
 * @param	fontname    the name of the font
 * @param	encoding    the encoding of the font
 * @param	size	    the size of this font
 * @return the Font constructed based on the parameters
 */
    
    public static Font getFont(String fontname, String encoding, float size) {
        return getFont(fontname, encoding, defaultEmbedding, size, Font.UNDEFINED, null);
    }
    
/**
 * Constructs a <CODE>Font</CODE>-object.
 *
 * @param	fontname    the name of the font
 * @param	encoding    the encoding of the font
 * @return the Font constructed based on the parameters
 */
    
    public static Font getFont(String fontname, String encoding) {
        return getFont(fontname, encoding, defaultEmbedding, Font.UNDEFINED, Font.UNDEFINED, null);
    }
    
/**
 * Constructs a <CODE>Font</CODE>-object.
 *
 * @param	fontname    the name of the font
 * @param	size	    the size of this font
 * @param	style	    the style of this font
 * @param	color	    the <CODE>Color</CODE> of this font.
 * @return the Font constructed based on the parameters
 */
    
    public static Font getFont(String fontname, float size, int style, Color color) {
        return getFont(fontname, defaultEncoding, defaultEmbedding, size, style, color);
    }
    
/**
 * Constructs a <CODE>Font</CODE>-object.
 *
 * @param	fontname    the name of the font
 * @param	size	    the size of this font
 * @param	style	    the style of this font
 * @return the Font constructed based on the parameters
 */
    
    public static Font getFont(String fontname, float size, int style) {
        return getFont(fontname, defaultEncoding, defaultEmbedding, size, style, null);
    }
    
/**
 * Constructs a <CODE>Font</CODE>-object.
 *
 * @param	fontname    the name of the font
 * @param	size	    the size of this font
 * @return the Font constructed based on the parameters
 */
    
    public static Font getFont(String fontname, float size) {
        return getFont(fontname, defaultEncoding, defaultEmbedding, size, Font.UNDEFINED, null);
    }
    
/**
 * Constructs a <CODE>Font</CODE>-object.
 *
 * @param	fontname    the name of the font
 * @return the Font constructed based on the parameters
 */
    
    public static Font getFont(String fontname) {
        return getFont(fontname, defaultEncoding, defaultEmbedding, Font.UNDEFINED, Font.UNDEFINED, null);
    }
    
/**
 * Register a ttf- or a ttc-file.
 *
 * @param   path    the path to a ttf- or ttc-file
 */
    
    public static void register(String path) {
        register(path, null);
    }
    
/**
 * Register a font file and use an alias for the font contained in it.
 *
 * @param   path    the path to a font file
 * @param   alias   the alias you want to use for the font
 */
    
    public static void register(String path, String alias) {
        try {
            if (path.toLowerCase().endsWith(".ttf") || path.toLowerCase().endsWith(".otf") || path.toLowerCase().indexOf(".ttc,") > 0) {
                Object allNames[] = BaseFont.getAllFontNames(path, BaseFont.WINANSI, null);
                trueTypeFonts.setProperty(((String)allNames[0]).toLowerCase(), path);
                if (alias != null) {
                    trueTypeFonts.setProperty(alias, path);
                }
                // register all the font names with all the locales
                String[][] names = (String[][])allNames[2]; //full name
                for (int i = 0; i < names.length; i++) {
                    trueTypeFonts.setProperty(names[i][3].toLowerCase(), path);
                }
                String fullName = null;
                String familyName = null;
                names = (String[][])allNames[1]; //family name
                for (int k = 0; k < TTFamilyOrder.length; k += 3) {
                    for (int i = 0; i < names.length; i++) {
                        if (TTFamilyOrder[k].equals(names[i][0]) && TTFamilyOrder[k + 1].equals(names[i][1]) && TTFamilyOrder[k + 2].equals(names[i][2])) {
                            familyName = names[i][3].toLowerCase();
                            k = TTFamilyOrder.length;
                            break;
                        }
                    }
                }
                if (familyName != null) {
                    String lastName = "";
                    names = (String[][])allNames[2]; //full name
                    for (int i = 0; i < names.length; i++) {
                        for (int k = 0; k < TTFamilyOrder.length; k += 3) {
                            if (TTFamilyOrder[k].equals(names[i][0]) && TTFamilyOrder[k + 1].equals(names[i][1]) && TTFamilyOrder[k + 2].equals(names[i][2])) {
                                fullName = names[i][3];
                                if (fullName.equals(lastName))
                                    continue;
                                lastName = fullName;
                                ArrayList tmp = (ArrayList) fontFamilies.get(familyName);
                                if (tmp == null) {
                                    tmp = new ArrayList();
                                    tmp.add(fullName);
                                    fontFamilies.put(familyName, tmp);
                                }
                                else {
                                    int fullNameLength = fullName.length();
                                    boolean inserted = false;
                                    for (int j = 0; j < tmp.size(); ++j) {
                                        if (((String)tmp.get(j)).length() >= fullNameLength) {
                                            tmp.add(j, fullName);
                                            inserted = true;
                                            break;
                                        }
                                    }
                                    if (!inserted)
                                        tmp.add(fullName);
                                }
                                break;
                            }
                        }
                    }
                }
            }
            else if (path.toLowerCase().endsWith(".ttc")) {
                if (alias != null)
                    System.err.println("class FontFactory: You can't define an alias for a true type collection.");
                String[] names = BaseFont.enumerateTTCNames(path);
                for (int i = 0; i < names.length; i++) {
                    register(path + "," + i);
                }
            }
            else if (path.toLowerCase().endsWith(".afm")) {
                BaseFont bf = BaseFont.createFont(path, BaseFont.CP1252, false);
                trueTypeFonts.setProperty(bf.getPostscriptFontName().toLowerCase(), path);
                trueTypeFonts.setProperty((bf.getFullFontName()[0][3]).toLowerCase(), path);
            }
        }
        catch(DocumentException de) {
            // this shouldn't happen
            throw new ExceptionConverter(de);
        }
        catch(IOException ioe) {
            throw new ExceptionConverter(ioe);
        }
    }

    /** Register all the fonts in a directory.
     * @param dir the directory
     * @return the number of fonts registered
     */    
    public static int registerDirectory(String dir) {
        int count = 0;
        try {
            File file = new File(dir);
            if (!file.exists() || !file.isDirectory())
                return 0;
            String files[] = file.list();
            if (files == null)
                return 0;
            for (int k = 0; k < files.length; ++k) {
                try {
                    file = new File(dir, files[k]);
                    String name = file.getPath().toLowerCase();
                    if (name.endsWith(".ttf") || name.endsWith(".otf") || name.endsWith(".afm") || name.endsWith(".ttc")) {
                        register(file.getPath(), null);
                        ++count;
                    }
                }
                catch (Exception e) {
                    //empty on purpose
                }
            }
        }
        catch (Exception e) {
            //empty on purpose
        }
        return count;
    }

    /** Register fonts in some probable directories. It usually works in Windows,
     * Linux and Solaris.
     * @return the number of fonts registered
     */    
    public static int registerDirectories() {
        int count = 0;
        count += registerDirectory("c:/windows/fonts");
        count += registerDirectory("c:/winnt/fonts");
        count += registerDirectory("d:/windows/fonts");
        count += registerDirectory("d:/winnt/fonts");
        count += registerDirectory("/usr/X/lib/X11/fonts/TrueType");
        count += registerDirectory("/usr/openwin/lib/X11/fonts/TrueType");
        count += registerDirectory("/usr/share/fonts/default/TrueType");
        count += registerDirectory("/usr/X11R6/lib/X11/fonts/ttf");
        return count;
    }

/**
 * Gets a set of registered fontnames.
 * @return a set of registered fonts
 */
    
    public static Set getRegisteredFonts() {
        return Chunk.getKeySet(trueTypeFonts);
    }
    
/**
 * Gets a set of registered fontnames.
 * @return a set of registered font families
 */
    
    public static Set getRegisteredFamilies() {
        return Chunk.getKeySet(fontFamilies);
    }
    
/**
 * Gets a set of registered fontnames.
 * @param fontname of a font that may or may not be registered
 * @return true if a given font is registered
 */
    
    public static boolean contains(String fontname) {
        return trueTypeFonts.containsKey(fontname.toLowerCase());
    }
    
/**
 * Checks if a certain font is registered.
 *
 * @param   fontname    the name of the font that has to be checked.
 * @return  true if the font is found
 */
    
    public static boolean isRegistered(String fontname) {
        return trueTypeFonts.containsKey(fontname.toLowerCase());
    }
} /*
 * $Id: Header.java,v 1.29 2002/07/09 10:41:33 blowagie Exp $
 * $Name:  $
 *
 * Copyright 1999, 2000, 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

/**
 * This is an <CODE>Element</CODE> that contains
 * some userdefined meta information about the document.
 * <P>
 * <B>Example:</B>
 * <BLOCKQUOTE><PRE>
 * <STRONG>Header header = new Header("inspired by", "William Shakespeare");</STRONG>
 * </PRE></BLOCKQUOTE>
 *
 * @see		Element
 * @see		Meta
 */

public class Header extends Meta implements Element {
    
    // membervariables
    
/** This is the content of this chunk of text. */
    private StringBuffer name;
    
    // constructors
    
/**
 * Constructs a <CODE>Meta</CODE>.
 *
 * @param	name		the name of the meta-information
 * @param	content		the content
 */
    
    public Header(String name, String content) {
        super(Element.HEADER, content);
        this.name = new StringBuffer(name);
    }
    
    // methods to retrieve information
    
/**
 * Returns the name of the meta information.
 *
 * @return	a <CODE>String</CODE>
 */
    
    public String name() {
        return name.toString();
    }
} /*
 * $Id: List.java,v 1.74 2005/04/13 09:17:14 blowagie Exp $
 * $Name:  $
 *
 * Copyright 1999, 2000, 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Properties;
import java.util.Set;

/**
 * A <CODE>List</CODE> contains several <CODE>ListItem</CODE>s.
 * <P>
 * <B>Example 1:</B>
 * <BLOCKQUOTE><PRE>
 * <STRONG>List list = new List(true, 20);</STRONG>
 * <STRONG>list.add(new ListItem("First line"));</STRONG>
 * <STRONG>list.add(new ListItem("The second line is longer to see what happens once the end of the line is reached. Will it start on a new line?"));</STRONG>
 * <STRONG>list.add(new ListItem("Third line"));</STRONG>
 * </PRE></BLOCKQUOTE>
 *
 * The result of this code looks like this:
 *	<OL>
 *		<LI>
 *			First line
 *		</LI>
 *		<LI>
 *			The second line is longer to see what happens once the end of the line is reached. Will it start on a new line?
 *		</LI>
 *		<LI>
 *			Third line
 *		</LI>
 *	</OL>
 *
 * <B>Example 2:</B>
 * <BLOCKQUOTE><PRE>
 * <STRONG>List overview = new List(false, 10);</STRONG>
 * <STRONG>overview.add(new ListItem("This is an item"));</STRONG>
 * <STRONG>overview.add("This is another item");</STRONG>
 * </PRE></BLOCKQUOTE>
 *
 * The result of this code looks like this:
 *	<UL>
 *		<LI>
 *			This is an item
 *		</LI>
 *		<LI>
 *			This is another item
 *		</LI>
 *	</UL>
 *
 * @see		Element
 * @see		ListItem
 */

public class List implements TextElementArray, MarkupAttributes {
    
    // membervariables
	/** a possible value for the numbered parameter */
	public static final boolean ORDERED = true;
	/** a possible value for the numbered parameter */
	public static final boolean UNORDERED = false;
	/** a possible value for the lettered parameter */
	public static final boolean NUMBERICAL = false;
	/** a possible value for the lettered parameter */
	public static final boolean ALPHABETICAL = true;
	
    
/** This is the <CODE>ArrayList</CODE> containing the different <CODE>ListItem</CODE>s. */
    protected ArrayList list = new ArrayList();
    
/** This variable indicates if the list has to be numbered. */
    protected boolean numbered;
    protected boolean lettered;
    
/** This variable indicates the first number of a numbered list. */
    protected int first = 1;
    protected char firstCh = 'A';
    protected char lastCh  = 'Z';
    
/** This is the listsymbol of a list that is not numbered. */
    protected Chunk symbol = new Chunk("-");
    
/** The indentation of this list on the left side. */
    protected float indentationLeft = 0;
    
/** The indentation of this list on the right side. */
    protected float indentationRight = 0;
    
/** The indentation of the listitems. */
    protected float symbolIndent;

/** Contains extra markupAttributes */
    protected Properties markupAttributes;
    
    // constructors
    
/**
 * Constructs a <CODE>List</CODE>.
 * <P>
 * Remark: the parameter <VAR>symbolIndent</VAR> is important for instance when
 * generating PDF-documents; it indicates the indentation of the listsymbol.
 * It is not important for HTML-documents.
 *
 * @param	numbered		a boolean
 * @param	symbolIndent	the indentation that has to be used for the listsymbol
 */
    
    public List(boolean numbered, float symbolIndent) {
        this.numbered = numbered;
        this.lettered = false;
        this.symbolIndent = symbolIndent;
    }
    
    /**
     * Creates a list
     * @param numbered has the list to be numbered?
     * @param lettered has the list to be 'numbered' with letters
     * @param symbolIndent the indentation of the symbol
     */
    public List(boolean numbered, boolean lettered, float symbolIndent ) {
        this.numbered = numbered;
        this.lettered = lettered;
        this.symbolIndent = symbolIndent;
    }
    
        /**
         * Returns a <CODE>List</CODE> that has been constructed taking in account
         * the value of some <VAR>attributes</VAR>.
         *
         * @param	attributes		Some attributes
         */
    
    public List(Properties attributes) {
        String value= (String)attributes.remove(ElementTags.LISTSYMBOL);
        if (value == null) {
            value = "-";
        }
        symbol = new Chunk(value, FontFactory.getFont(attributes));
        
        this.numbered = false;
        if ((value = (String)attributes.remove(ElementTags.NUMBERED)) != null) {
            this.numbered = new Boolean(value).booleanValue();
            if ( this.lettered && this.numbered )
                this.lettered = false;
        }
        if ((value = (String)attributes.remove(ElementTags.LETTERED)) != null) {
            this.lettered = new Boolean(value).booleanValue();
            if ( this.numbered && this.lettered )
                this.numbered = false;
        }
        this.symbolIndent = 0;
        if ((value = (String)attributes.remove(ElementTags.SYMBOLINDENT)) != null) {
            this.symbolIndent = Float.parseFloat(value);
        }
        
        if ((value = (String)attributes.remove(ElementTags.FIRST)) != null) {
            char khar = value.charAt(0);
            if ( Character.isLetter( khar ) ) {
                setFirst( khar );
            }
            else {
                setFirst(Integer.parseInt(value));
            }
        }
        if ((value = (String)attributes.remove(ElementTags.INDENTATIONLEFT)) != null) {
            setIndentationLeft(Float.valueOf(value + "f").floatValue());
        }
        if ((value = (String)attributes.remove(ElementTags.INDENTATIONRIGHT)) != null) {
            setIndentationRight(Float.valueOf(value + "f").floatValue());
        }
        if (attributes.size() > 0) setMarkupAttributes(attributes);
    }
    
    // implementation of the Element-methods
    
/**
 * Processes the element by adding it (or the different parts) to an
 * <CODE>ElementListener</CODE>.
 *
 * @param	listener	an <CODE>ElementListener</CODE>
 * @return	<CODE>true</CODE> if the element was processed successfully
 */
    
    public boolean process(ElementListener listener) {
        try {
            for (Iterator i = list.iterator(); i.hasNext(); ) {
                listener.add((Element) i.next());
            }
            return true;
        }
        catch(DocumentException de) {
            return false;
        }
    }
    
/**
 * Gets the type of the text element.
 *
 * @return	a type
 */
    
    public int type() {
        return Element.LIST;
    }
    
/**
 * Gets all the chunks in this element.
 *
 * @return	an <CODE>ArrayList</CODE>
 */
    
    public ArrayList getChunks() {
        ArrayList tmp = new ArrayList();
        for (Iterator i = list.iterator(); i.hasNext(); ) {
            tmp.addAll(((Element) i.next()).getChunks());
        }
        return tmp;
    }
    
    // methods to set the membervariables
    
/**
 * Adds an <CODE>Object</CODE> to the <CODE>List</CODE>.
 *
 * @param	o		the object to add.
 * @return true if adding the object succeeded
 */
    
    public boolean add(Object o) {
        if (o instanceof ListItem) {
            ListItem item = (ListItem) o;
            if (numbered || lettered) {
                Chunk chunk;
                if ( lettered )
                    chunk = new Chunk(nextLetter(), symbol.font());
                else
                    chunk = new Chunk(String.valueOf(first + list.size()), symbol.font());
                chunk.append(".");
                item.setListSymbol(chunk);
            }
            else {
                item.setListSymbol(symbol);
            }
            item.setIndentationLeft(symbolIndent);
            item.setIndentationRight(0);
            list.add(item);
        }
        else if (o instanceof List) {
            List nested = (List) o;
            nested.setIndentationLeft(nested.indentationLeft() + symbolIndent);
            first--;
            return list.add(nested);
        }
        else if (o instanceof String) {
            return this.add(new ListItem((String) o));
        }
        return false;
    }
    
/**
 * Sets the indentation of this paragraph on the left side.
 *
 * @param	indentation		the new indentation
 */
    
    public void setIndentationLeft(float indentation) {
        this.indentationLeft = indentation;
    }
    
/**
 * Sets the indentation of this paragraph on the right side.
 *
 * @param	indentation		the new indentation
 */
    
    public void setIndentationRight(float indentation) {
        this.indentationRight = indentation;
    }
    
/**
 * Sets the number that has to come first in the list.
 *
 * @param	first		a number
 */
    
    public void setFirst(int first) {
        this.first = first;
    }
    
    
/**
 * Sets the Letter that has to come first in the list.
 *
 * @param	first		a letter
 */
    
    public void setFirst(char first) {
        this.firstCh = first;
        if ( Character.isLowerCase( this.firstCh )) {
            this.lastCh = 'z';
        }
        else {
            this.lastCh = 'Z';
        }
    }
    
/**
 * Sets the listsymbol.
 *
 * @param	symbol		a <CODE>Chunk</CODE>
 */
    
    public void setListSymbol(Chunk symbol) {
        this.symbol = symbol;
    }
    
/**
 * Sets the listsymbol.
 * <P>
 * This is a shortcut for <CODE>setListSymbol(Chunk symbol)</CODE>.
 *
 * @param	symbol		a <CODE>String</CODE>
 */
    
    public void setListSymbol(String symbol) {
        this.symbol = new Chunk(symbol);
    }
    
    // methods to retrieve information
    
/**
 * Gets all the items in the list.
 *
 * @return	an <CODE>ArrayList</CODE> containing <CODE>ListItem</CODE>s.
 */
    
    public ArrayList getItems() {
        return list;
    }
    
/**
 * Gets the size of the list.
 *
 * @return	a <CODE>size</CODE>
 */
    
    public int size() {
        return list.size();
    }
    
/**
 * Gets the leading of the first listitem.
 *
 * @return	a <CODE>leading</CODE>
 */
    
    public float leading() {
        if (list.size() < 1) {
            return -1;
        }
        ListItem item = (ListItem) list.get(0);
        return item.leading();
    }
    
/**
 * Checks if the list is numbered.
 *
 * @return	<CODE>true</CODE> if the list is numbered, <CODE>false</CODE> otherwise.
 */
    
    public boolean isNumbered() {
        return numbered;
    }
    
/**
 * Gets the symbol indentation.
 * @return the symbol indentation
 */
    
    public float symbolIndent() {
        return symbolIndent;
    }
    
/**
 * Gets the Chunk containing the symbol.
 * @return a Chunk with a symbol
 */
    
    public Chunk symbol() {
        return symbol;
    }
    
/**
 * Gets the first number        .
 * @return a number
 */
    
    public int first() {
        return first;
    }
    
/**
 * Gets the indentation of this paragraph on the left side.
 *
 * @return	the indentation
 */
    
    public float indentationLeft() {
        return indentationLeft;
    }
    
/**
 * Gets the indentation of this paragraph on the right side.
 *
 * @return	the indentation
 */
    
    public float indentationRight() {
        return indentationRight;
    }
    
/**
 * Checks if a given tag corresponds with the listsymbol tag of this object.
 *
 * @param   tag     the given tag
 * @return  true if the tag corresponds
 */
    
    public static boolean isSymbol(String tag) {
        return ElementTags.LISTSYMBOL.equals(tag);
    }
    
/**
 * Checks if a given tag corresponds with this object.
 *
 * @param   tag     the given tag
 * @return  true if the tag corresponds
 */
    
    public static boolean isTag(String tag) {
        return ElementTags.LIST.equals(tag);
    }

/**
 * Retrieves the next letter in the sequence
 *
 * @return  String contains the next character (A-Z or a-z)
 */
    private String nextLetter() {
        int num_in_list = listItemsInList(); //list.size();
        int max_ival = (lastCh + 0);
        int ival = (firstCh + num_in_list);
        while ( ival > max_ival ) {
            ival -= 26;
        }
        char[] new_char = new char[1];
        new_char[0] = (char) ival;
        String ret = new String( new_char );
        return ret;
    }
    
    /**
     * Counts the number of ListItems in the list ommiting nested lists
     *
     * @return  Integer number of ListItems in the list
     */
    private int listItemsInList() {
        int result = 0;
        for (Iterator i = list.iterator(); i.hasNext(); ) {
            if (!(i.next() instanceof List)) result++;
        }
        return result;
    }
    
/**
 * @see pdftk.com.lowagie.text.MarkupAttributes#setMarkupAttribute(java.lang.String, java.lang.String)
 */
    public void setMarkupAttribute(String name, String value) {
		if (markupAttributes == null) markupAttributes = new Properties();
        markupAttributes.put(name, value);
    }
    
/**
 * @see pdftk.com.lowagie.text.MarkupAttributes#setMarkupAttributes(java.util.Properties)
 */
    public void setMarkupAttributes(Properties markupAttributes) {
        this.markupAttributes = markupAttributes;
    }
    
/**
 * @see pdftk.com.lowagie.text.MarkupAttributes#getMarkupAttribute(java.lang.String)
 */
    public String getMarkupAttribute(String name) {
        return (markupAttributes == null) ? null : String.valueOf(markupAttributes.get(name));
    }
    
/**
 * @see pdftk.com.lowagie.text.MarkupAttributes#getMarkupAttributeNames()
 */
    public Set getMarkupAttributeNames() {
        return Chunk.getKeySet(markupAttributes);
    }
    
/**
 * @see pdftk.com.lowagie.text.MarkupAttributes#getMarkupAttributes()
 */
    public Properties getMarkupAttributes() {
        return markupAttributes;
    }
}
 /*
 *   This file is part of the pdftk port to java
 *
 *   Copyright (c) Marc Vinyals 2017-2018
 *
 *   The program is a java port of PDFtk, the PDF Toolkit
 *   Copyright (c) 2003-2013 Steward and Lee, LLC
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   The program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/*
 * @deprecated  Use com.gitlab.pdftk_java.pdftk
 */
@Deprecated
public class pdftk {
  public static void main(String[] args) {
    System.err.println("Warning: class pdftk is deprecated. Use com.gitlab.pdftk_java.pdftk.");
    com.gitlab.pdftk_java.pdftk.main(args);
  }
}
 import static org.junit.Assert.assertEquals;
import org.junit.Rule;
import org.junit.Test;
import org.junit.contrib.java.lang.system.SystemOutRule;
import org.junit.contrib.java.lang.system.ExpectedSystemExit;

import java.nio.file.Files;
import java.nio.file.Paths;
import java.io.IOException;

import com.gitlab.pdftk_java.pdftk;

public class BlackBoxTest {
  @Rule
  public final SystemOutRule systemOutRule =
    new SystemOutRule().muteForSuccessfulTests();

  @Rule
  public final ExpectedSystemExit exit = ExpectedSystemExit.none();

  public String slurp(String filename) throws IOException {
    return new String(slurpBytes(filename));
  }
  public byte[] slurpBytes(String filename) throws IOException {
    return Files.readAllBytes(Paths.get(filename));
  }
  
  @Test
  public void dump_data() throws IOException {
    exit.expectSystemExitWithStatus(0);
    pdftk.main(new String[]{"test/files/blank.pdf", "dump_data_utf8"});
    String expectedData = slurp("test/files/blank.data");
    assertEquals(expectedData, systemOutRule.getLog());    
  }

  @Test
  public void cat() throws IOException {
    exit.expectSystemExitWithStatus(0);
    pdftk.main(new String[]{"test/files/refs.pdf",
                            "test/files/refsalt.pdf",
                            "cat", "output", "-"});
    byte[] expectedData = slurpBytes("test/files/cat-refs-refsalt.pdf");
    assertEquals(expectedData, systemOutRule.getLogAsBytes());
  }

  @Test
  public void cat_rotate_page_no_op() throws IOException {
    exit.expectSystemExitWithStatus(0);
    pdftk.main(new String[]{"test/files/blank.pdf",
                            "cat", "1north", "output", "-"});
    byte[] expectedData = slurpBytes("test/files/blank.pdf");
    assertEquals(expectedData, systemOutRule.getLogAsBytes());
  }

  @Test
  public void cat_rotate_range_no_op() throws IOException {
    exit.expectSystemExitWithStatus(0);
    pdftk.main(new String[]{"test/files/blank.pdf",
                            "cat", "1-1north", "output", "-"});
    byte[] expectedData = slurpBytes("test/files/blank.pdf");
    assertEquals(expectedData, systemOutRule.getLogAsBytes());
  }

  @Test
  public void cat_rotate_page() throws IOException {
    exit.expectSystemExitWithStatus(0);
    pdftk.main(new String[]{"test/files/blank.pdf",
                            "cat", "1east", "output", "-"});
    byte[] expectedData = slurpBytes("test/files/blank.pdf");
    assertEquals(expectedData, systemOutRule.getLogAsBytes());
  }

  @Test
  public void cat_rotate_range() throws IOException {
    exit.expectSystemExitWithStatus(0);
    pdftk.main(new String[]{"test/files/blank.pdf",
                            "cat", "1-1east", "output", "-"});
    byte[] expectedData = slurpBytes("test/files/blank.pdf");
    assertEquals(expectedData, systemOutRule.getLogAsBytes());
  }

};
 /*
 *   This file is part of the pdftk port to java
 *
 *   Copyright (c) Marc Vinyals 2017-2018
 *
 *   The program is a java port of PDFtk, the PDF Toolkit
 *   Copyright (c) 2003-2013 Steward and Lee, LLC
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   The program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.gitlab.pdftk_java;

enum ErrorCode {
  NO_ERROR(0),
  ERROR(1),
  BUG(2),
  WARNING(3);

  final int code;
  ErrorCode(int code) {
    this.code = code;
  }
}
 /*
 *
 *   This file is part of the pdftk port to java
 *
 *   Copyright (c) Marc Vinyals 2017-2018
 *
 *   The program is a java port of PDFtk, the PDF Toolkit
 *   Copyright (c) 2003-2013 Steward and Lee, LLC
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   The program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.gitlab.pdftk_java;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

class LoadableInt {
  int ii= -1;
  boolean success;
  static int BufferInt( String buff, int buff_ii ) {
    //while( buff[buff_ii] && isspace(buff[buff_ii]) ) { ++buff_ii; }
    Pattern p = Pattern.compile("\\s?(\\d+).*"); // one or no spaces before data
    Matcher m = p.matcher(buff.substring(buff_ii));
    if (m.matches()) {
      return Integer.parseInt(m.group(1));
    }
    else {
      return 0;
    }
  }
  boolean LoadInt(String buff, String label) {
    int label_len= label.length();
    if ( buff.startsWith(label) ) {
      if( ii< 0 ) { // uninitialized ints are -1
        ii= BufferInt( buff, label_len );
      }
      else { // warning
        System.err.println("pdftk Warning: " + label + " (" + ii + ") not empty when reading new " + label + " (" + BufferInt( buff, label_len ) + ") -- skipping newer item");
      }
      return true;
    }
    return false;
  }
  LoadableInt( int ii ) {
    this.ii = ii;
  }
  public String toString() {
    return Integer.toString(ii);
  }
};
 /*
 *
 *   This file is part of the pdftk port to java
 *
 *   Copyright (c) Marc Vinyals 2017-2018
 *
 *   The program is a java port of PDFtk, the PDF Toolkit
 *   Copyright (c) 2003-2013 Steward and Lee, LLC
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   The program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.gitlab.pdftk_java;

class LoadableString {
  String ss= null;
  static String BufferString( String buff, int buff_ii ) {
    //while( buff[buff_ii] && isspace(buff[buff_ii]) ) { ++buff_ii; }
    if (buff_ii>=buff.length()) return "";
    if( Character.isWhitespace(buff.charAt(buff_ii)) ) // one or no spaces before data
      ++buff_ii;
    return( buff.substring( buff_ii ) );
  }
  boolean LoadString(String buff, String label) {
    int label_len= label.length();
    if ( buff.startsWith(label) ) {
      if( ss== null ) {
        ss= BufferString( buff, label_len );
      }
      else { // warning
        System.err.println("pdftk Warning: " + label + " (" + ss + ") already loaded when reading new " + label + " (" + BufferString( buff, label_len ) + ") -- skipping newer item");
      }
      return true;
    }
    return false;
  }
  LoadableString(String ss) {
    this.ss = ss;
  }
  public String toString() {
    return ss;
  }
};
 /*
 *
 *   This file is part of the pdftk port to java
 *
 *   Copyright (c) Marc Vinyals 2017-2018
 *
 *   The program is a java port of PDFtk, the PDF Toolkit
 *   Copyright (c) 2003-2013 Steward and Lee, LLC
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   The program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.gitlab.pdftk_java;

class PdfBookmark {
  static final String m_prefix= "Bookmark";
  static final String m_begin_mark= "BookmarkBegin";
  static final String m_title_label= "BookmarkTitle:";
  static final String m_level_label= "BookmarkLevel:";
  static final String m_page_number_label= "BookmarkPageNumber:";
  //static const string m_empty_string;

  String m_title = null;
  int m_level = -1;
  int m_page_num = -1; // zero means no destination
  boolean valid() { return( 0< m_level && 0<= m_page_num && m_title!= null ); }

  public String toString() {
    return m_begin_mark + System.lineSeparator() +
      m_title_label + " " + m_title + System.lineSeparator() +
      m_level_label + " " + m_level + System.lineSeparator() +
      m_page_number_label + " " + m_page_num + System.lineSeparator();
  }

  boolean loadTitle( String buff ) {
    LoadableString loader = new LoadableString( m_title );
    boolean success = loader.LoadString( buff, m_title_label );
    m_title = loader.ss;
    return success;
  }
  boolean loadLevel( String buff ) {
    LoadableInt loader = new LoadableInt( m_level );
    boolean success = loader.LoadInt( buff, m_level_label );
    m_level = loader.ii;
    return success;
  }
  boolean loadPageNum( String buff ) {
    LoadableInt loader = new LoadableInt( m_page_num );
    boolean success = loader.LoadInt( buff, m_page_number_label );
    m_page_num = loader.ii;
    return success;
  }
  
};
//
//ostream& operator<<( ostream& ss, const PdfBookmark& bb );
 /*
 *   This file is part of the pdftk port to java
 *
 *   Copyright (c) Marc Vinyals 2017-2018
 *
 *   The program is a java port of PDFtk, the PDF Toolkit
 *   Copyright (c) 2003-2013 Steward and Lee, LLC
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   The program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.gitlab.pdftk_java;

import java.util.Collections;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.Iterator;
import java.util.Scanner;

import java.io.InputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.FileNotFoundException;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.IOException;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import pdftk.com.lowagie.text.Document;
import pdftk.com.lowagie.text.DocumentException;
import pdftk.com.lowagie.text.Rectangle;

import pdftk.com.lowagie.text.pdf.AcroFields;
import pdftk.com.lowagie.text.pdf.FdfReader;
import pdftk.com.lowagie.text.pdf.FdfWriter;
import pdftk.com.lowagie.text.pdf.XfdfReader;

import pdftk.com.lowagie.text.pdf.PdfAnnotation;
import pdftk.com.lowagie.text.pdf.PdfArray;
import pdftk.com.lowagie.text.pdf.PdfBoolean;
import pdftk.com.lowagie.text.pdf.PdfContentByte;
import pdftk.com.lowagie.text.pdf.PdfCopy;
import pdftk.com.lowagie.text.pdf.PdfDictionary;
import pdftk.com.lowagie.text.pdf.PdfFileSpecification;
import pdftk.com.lowagie.text.pdf.PdfImportedPage;
import pdftk.com.lowagie.text.pdf.PdfIndirectReference;
import pdftk.com.lowagie.text.pdf.PdfName;
import pdftk.com.lowagie.text.pdf.PdfNameTree;
import pdftk.com.lowagie.text.pdf.PdfNumber;
import pdftk.com.lowagie.text.pdf.PdfObject;
import pdftk.com.lowagie.text.pdf.PdfReader;
import pdftk.com.lowagie.text.pdf.PdfStamperImp;
import pdftk.com.lowagie.text.pdf.PdfWriter;

class TK_Session {
  
  boolean m_valid_b = false;
  boolean m_authorized_b = true;
  boolean m_input_pdf_readers_opened_b = false; // have m_input_pdf readers been opened?
  boolean m_verbose_reporting_b = false;
  boolean m_ask_about_warnings_b = pdftk.ASK_ABOUT_WARNINGS; // set default at compile-time

  //typedef unsigned long PageNumber;
  enum PageRotate { NORTH(0), EAST(90), SOUTH(180), WEST(270);
                    final int value;
                    PageRotate(int value) { this.value = value; }
  }; // DF rotation
  //typedef bool PageRotateAbsolute; // DF absolute / relative rotation

  static class InputPdf {
    String m_filename = "";
    String m_password = "";
    boolean m_authorized_b = true;

    // keep track of which pages get output under which readers,
    // because one reader mayn't output the same page twice;
    static class PagesReader {
      HashSet<Integer> first = new HashSet<Integer>();
      PdfReader second;
      PagesReader ( PdfReader second ) { this.second = second; }
    };
    ArrayList<PagesReader> m_readers = new ArrayList<PagesReader>();

    int m_num_pages = 0;

  };
  // pack input PDF in the order they're given on the command line
  ArrayList<InputPdf> m_input_pdf = new ArrayList<InputPdf>();
  //typedef vector< InputPdf >::size_type InputPdfIndex;

  // store input PDF handles here
  HashMap<String, Integer> m_input_pdf_index = new HashMap<String, Integer>();

InputPdf.PagesReader add_reader( InputPdf input_pdf_p, boolean keep_artifacts_b ) {
  boolean open_success_b= true;
  InputPdf.PagesReader pr= null;

  try {
    PdfReader reader= null;
    if( input_pdf_p.m_filename.equals( "PROMPT" ) ) {
      input_pdf_p.m_filename= pdftk.prompt_for_filename( "Please enter a filename for an input PDF:");
    }
    if( input_pdf_p.m_password.isEmpty() ) {
      reader= new PdfReader( input_pdf_p.m_filename );
    }
    else {
      if( input_pdf_p.m_password.equals( "PROMPT" ) ) {
        input_pdf_p.m_password = pdftk.prompt_for_password( "open", "the input PDF:\n   "+ input_pdf_p.m_filename );
      }

      byte[] password= passwords.utf8_password_to_pdfdoc( input_pdf_p.m_password,
                                         false ); // allow user to enter greatest selection of chars

      if ( password != null ) {
        reader= new PdfReader( input_pdf_p.m_filename, password );
        if( reader== null ) {
          System.err.println( "Error: Unexpected null from open_reader()" );
          return null; // <--- return
        }
      }
      else { // bad password
        System.err.println( "Error: Password used to decrypt input PDF:" );
        System.err.println( "   " + input_pdf_p.m_filename );
        System.err.println( "   includes invalid characters." );
        return null; // <--- return
      }
    }
    
    if( !keep_artifacts_b ) {
      // generally useful operations
      reader.consolidateNamedDestinations();
      reader.removeUnusedObjects();
      //reader->shuffleSubsetNames(); // changes the PDF subset names, but not the PostScript font names
    }

    input_pdf_p.m_num_pages= reader.getNumberOfPages();

    // keep tally of which pages have been laid claim to in this reader;
    // when creating the final PDF, this tally will be decremented
    pr = new InputPdf.PagesReader( reader );
    input_pdf_p.m_readers.add( pr );

    input_pdf_p.m_authorized_b= true; // instead of:  ( !reader->encrypted || reader->ownerPasswordUsed );

    if ( open_success_b && reader.encrypted && !reader.ownerPasswordUsed )
    {
      System.err.println( "WARNING: The creator of the input PDF:" );
      System.err.println( "   " + input_pdf_p.m_filename );
      System.err.println( "   has set an owner password (which is not required to handle this PDF)." );
      System.err.println( "   You did not supply this password. Please respect any copyright." );
    }

    if( !input_pdf_p.m_authorized_b ) {
      open_success_b= false;
    }
  }
  catch( IOException ioe_p ) { // file open error
    if( ioe_p.getMessage().equals( "Bad password" ) ) {
      input_pdf_p.m_authorized_b= false;
    }
    else if( ioe_p.getMessage().indexOf( "not found" ) != -1 ) {
      System.err.println( "Error: Unable to find file." );
    }
    else { // unexpected error
      System.err.println( "Error: Unexpected Exception in open_reader()" );
      ioe_p.printStackTrace(); // debug
    }
    open_success_b= false;
  }
  catch( Throwable t_p ) { // unexpected error
    System.err.println( "Error: Unexpected Exception in open_reader()" );
    t_p.printStackTrace(); // debug

    open_success_b= false;            
  }

  if( !input_pdf_p.m_authorized_b && m_ask_about_warnings_b ) {
    // prompt for a new password
    System.err.println( "The password you supplied for the input PDF:" );
    System.err.println( "   " + input_pdf_p.m_filename );
    System.err.println( "   did not work.  This PDF is encrypted, and you must supply the" );
    System.err.println( "   owner or the user password to open it. To quit, enter a blank" );
    System.err.println( "   password at the next prompt." );

    input_pdf_p.m_password = pdftk.prompt_for_password( "open", "the input PDF:\n   "+ input_pdf_p.m_filename );
    if( !input_pdf_p.m_password.isEmpty() ) { // reset flags try again
      input_pdf_p.m_authorized_b= true;
      return( add_reader(input_pdf_p) ); // <--- recurse, return
    }
  }

  // report
  if( !open_success_b ) { // file open error
    System.err.println( "Error: Failed to open PDF file: " );
    System.err.println( "   " + input_pdf_p.m_filename );
    if( !input_pdf_p.m_authorized_b ) {
      System.err.println( "   OWNER OR USER PASSWORD REQUIRED, but not given (or incorrect)" );
    }
  }

  // update session state
  m_authorized_b= m_authorized_b && input_pdf_p.m_authorized_b;

  return open_success_b ? pr : null;
}
  InputPdf.PagesReader add_reader( InputPdf input_pdf_p ) {
    return add_reader( input_pdf_p, false );
  }

boolean open_input_pdf_readers() {
  // try opening the input files and init m_input_pdf readers
  boolean open_success_b= true;

  if( !m_input_pdf_readers_opened_b ) {
    if( m_operation== keyword.filter_k && m_input_pdf.size()== 1 ) {
      // don't touch input pdf -- preserve artifacts
      open_success_b= ( add_reader( m_input_pdf.get(0), true ) != null );
    }
    else {
      for( InputPdf it : m_input_pdf ) {
        open_success_b = ( add_reader( it ) != null ) && open_success_b;
      }
    }
    m_input_pdf_readers_opened_b= open_success_b;
  }

  return open_success_b;
}

  
  ArrayList<String> m_input_attach_file_filename = new ArrayList<String>();
  int m_input_attach_file_pagenum = 0;

  String m_update_info_filename = "";
  boolean m_update_info_utf8_b = false;
  String m_update_xmp_filename = "";

  enum keyword {
    none_k,

    // the operations
    cat_k, // combine pages from input PDFs into a single output
    shuffle_k, // like cat, but interleaves pages from input ranges
    burst_k, // split a single, input PDF into individual pages
    barcode_burst_k, // barcode_burst project
    filter_k, // apply 'filters' to a single, input PDF based on output args
    dump_data_k, // no PDF output
    dump_data_utf8_k,
    dump_data_fields_k,
    dump_data_fields_utf8_k,
    dump_data_annots_k,
    generate_fdf_k,
    unpack_files_k, // unpack files from input; no PDF output

    // these are treated the same as operations,
    // but they are processed using the filter operation
    fill_form_k, // read FDF file and fill PDF form fields
    attach_file_k, // attach files to output
    update_info_k,
    update_info_utf8_k, // if info isn't utf-8, it is encoded using xml entities
    update_xmp_k,
    background_k, // promoted from output option to operation in pdftk 1.10
    multibackground_k, // feature added by Bernhard R. Link <brlink@debian.org>, Johann Felix Soden <johfel@gmx.de>
    stamp_k,
    multistamp_k, // feature added by Bernhard R. Link <brlink@debian.org>, Johann Felix Soden <johfel@gmx.de>
    rotate_k, // rotate given pages as directed

    // optional attach_file argument
    attach_file_to_page_k,

    // cat page range keywords
    end_k,
    even_k,
    odd_k,

    output_k,

    // encryption & decryption
    input_pw_k,
    owner_pw_k,
    user_pw_k,
    user_perms_k,

    // output arg.s, only
    encrypt_40bit_k,
    encrypt_128bit_k,

    // user permissions
    perm_printing_k,
    perm_modify_contents_k,
    perm_copy_contents_k,
    perm_modify_annotations_k,
    perm_fillin_k,
    perm_screen_readers_k,
    perm_assembly_k,
    perm_degraded_printing_k,
    perm_all_k,

    // filters
    filt_uncompress_k,
    filt_compress_k,

    // forms
    flatten_k,
    need_appearances_k,
    drop_xfa_k,
    drop_xmp_k,
    keep_first_id_k,
    keep_final_id_k,

    // pdftk options
    verbose_k,
    dont_ask_k,
    do_ask_k,

    // page rotation
    rot_north_k,
    rot_east_k,
    rot_south_k,
    rot_west_k,
    rot_left_k,
    rot_right_k,
    rot_upside_down_k
  };
static keyword is_keyword( String ss ) {
  ss = ss.toLowerCase();

  // operations
  if( ss.equals( "cat" ) ) {
    return keyword.cat_k;
  }
  else if( ss.equals( "shuffle" ) ) {
    return keyword.shuffle_k;
  }
  else if( ss.equals( "burst" ) ) {
    return keyword.burst_k;
  }
  else if( ss.equals( "filter" ) ) {
    return keyword.filter_k;
  }
  else if( ss.equals( "dump_data" ) ||
           ss.equals( "dumpdata" ) ||
           ss.equals( "data_dump" ) ||
           ss.equals( "datadump" ) ) {
    return keyword.dump_data_k;
  }
  else if( ss.equals( "dump_data_utf8" ) ) {
    return keyword.dump_data_utf8_k;
  }
  else if( ss.equals( "dump_data_fields" ) ) {
    return keyword.dump_data_fields_k;
  }
  else if( ss.equals( "dump_data_fields_utf8" ) ) {
    return keyword.dump_data_fields_utf8_k;
  }
  else if( ss.equals( "dump_data_annots" ) ) {
    return keyword.dump_data_annots_k;
  }
  else if( ss.equals( "generate_fdf" ) ||
           ss.equals( "fdfgen" ) ||
           ss.equals( "fdfdump" ) ||
           ss.equals( "dump_data_fields_fdf" ) ) {
    return keyword.generate_fdf_k;
  }
  else if( ss.equals( "fill_form" ) ||
           ss.equals( "fillform" ) ) {
    return keyword.fill_form_k;
  }
  else if( ss.equals( "attach_file" ) ||
           ss.equals( "attach_files" ) ||
           ss.equals( "attachfile" ) ) {
    return keyword.attach_file_k;
  }
  else if( ss.equals( "unpack_file" ) ||
           ss.equals( "unpack_files" ) ||
           ss.equals( "unpackfiles" ) ) {
    return keyword.unpack_files_k;
  }
  else if( ss.equals( "update_info" ) ||
           ss.equals( "undateinfo" ) ) {
    return keyword.update_info_k;
  }
  else if( ss.equals( "update_info_utf8" ) ||
           ss.equals( "undateinfoutf8" ) ) {
    return keyword.update_info_utf8_k;
  }
  /* requires more testing and work
  else if( strcmp( ss_copy, "update_xmp" ) ||
           strcmp( ss_copy, "undatexmp" ) ) {
    return update_xmp_k;
  }
  */
  else if( ss.equals( "background" ) ) {
    // pdftk 1.10: making background an operation
    // (and preserving old behavior for backwards compatibility)
    return keyword.background_k;
  }
  else if( ss.equals( "multibackground" ) ) {
    return keyword.multibackground_k;
  }
  else if( ss.equals( "multistamp" ) ) {
    return keyword.multistamp_k;
  }
  else if( ss.equals( "stamp" ) ) {
    return keyword.stamp_k;
  }
  else if( ss.equals( "rotate" ) ) {
    return keyword.rotate_k;
  }
  
  // cat range keywords
  else if( ss.startsWith( "end" ) ) { // note: strncmp
    return keyword.end_k;
  }
  else if( ss.startsWith( "even" ) ) { // note: strncmp
    return keyword.even_k;
  }
  else if( ss.startsWith( "odd" ) ) { // note: strncmp
    return keyword.odd_k;
  }

  // file attachment option
  else if( ss.equals( "to_page" ) ||
           ss.equals( "topage" ) ) {
    return keyword.attach_file_to_page_k;
  }

  else if( ss.equals( "output" ) ) {
    return keyword.output_k;
  }

  // encryption & decryption; depends on context
  else if( ss.equals( "owner_pw" ) ||
           ss.equals( "ownerpw" ) ) {
    return keyword.owner_pw_k;
  }
  else if( ss.equals( "user_pw" ) ||
           ss.equals( "userpw" ) ) {
    return keyword.user_pw_k;
  }
  else if( ss.equals( "input_pw" ) ||
           ss.equals( "inputpw" ) ) {
    return keyword.input_pw_k;
  }
  else if( ss.equals( "allow" ) ) {
    return keyword.user_perms_k;
  }

  // expect these only in output section
  else if( ss.equals( "encrypt_40bit" ) ||
           ss.equals( "encrypt_40bits" ) ||
           ss.equals( "encrypt40bit" ) ||
           ss.equals( "encrypt40bits" ) ||
           ss.equals( "encrypt40_bit" ) ||
           ss.equals( "encrypt40_bits" ) ||
           ss.equals( "encrypt_40_bit" ) ||
           ss.equals( "encrypt_40_bits" ) ) {
    return keyword.encrypt_40bit_k;
  }
  else if( ss.equals( "encrypt_128bit" ) ||
           ss.equals( "encrypt_128bits" ) ||
           ss.equals( "encrypt128bit" ) ||
           ss.equals( "encrypt128bits" ) ||
           ss.equals( "encrypt128_bit" ) ||
           ss.equals( "encrypt128_bits" ) ||
           ss.equals( "encrypt_128_bit" ) ||
           ss.equals( "encrypt_128_bits" ) ) {
    return keyword.encrypt_128bit_k;
  }
  
  // user permissions; must follow user_perms_k;
  else if( ss.equals( "printing" ) ) {
    return keyword.perm_printing_k;
  }
  else if( ss.equals( "modifycontents" ) ) {
    return keyword.perm_modify_contents_k;
  }
  else if( ss.equals( "copycontents" ) ) {
    return keyword.perm_copy_contents_k;
  }
  else if( ss.equals( "modifyannotations" ) ) {
    return keyword.perm_modify_annotations_k;
  }
  else if( ss.equals( "fillin" ) ) {
    return keyword.perm_fillin_k;
  }
  else if( ss.equals( "screenreaders" ) ) {
    return keyword.perm_screen_readers_k;
  }
  else if( ss.equals( "assembly" ) ) {
    return keyword.perm_assembly_k;
  }
  else if( ss.equals( "degradedprinting" ) ) {
    return keyword.perm_degraded_printing_k;
  }
  else if( ss.equals( "allfeatures" ) ) {
    return keyword.perm_all_k;
  }
  else if( ss.equals( "uncompress" ) ) {
    return keyword.filt_uncompress_k;
  }
  else if( ss.equals( "compress" ) ) {
    return keyword.filt_compress_k;
  }
  else if( ss.equals( "flatten" ) ) {
    return keyword.flatten_k;
  }
  else if( ss.equals( "need_appearances" ) ) {
    return keyword.need_appearances_k;
  }
  else if( ss.equals( "drop_xfa" ) ) {
    return keyword.drop_xfa_k;
  }
  else if( ss.equals( "drop_xmp" ) ) {
    return keyword.drop_xmp_k;
  }
  else if( ss.equals( "keep_first_id" ) ) {
    return keyword.keep_first_id_k;
  }
  else if( ss.equals( "keep_final_id" ) ) {
    return keyword.keep_final_id_k;
  }
  else if( ss.equals( "verbose" ) ) {
    return keyword.verbose_k;
  }
  else if( ss.equals( "dont_ask" ) ||
           ss.equals( "dontask" ) ) {
    return keyword.dont_ask_k;
  }
  else if( ss.equals( "do_ask" ) ) {
    return keyword.do_ask_k;
  }

  // more cat range keywords
  else if( ss.equals( "north" ) ) {
    return keyword.rot_north_k;
  }
  else if( ss.equals( "south" ) ) {
    return keyword.rot_south_k;
  }
  else if( ss.equals( "east" ) ) {
    return keyword.rot_east_k;
  }
  else if( ss.equals( "west" ) ) {
    return keyword.rot_west_k;
  }
  else if( ss.equals( "left" ) ) {
    return keyword.rot_left_k;
  }
  else if( ss.equals( "right" ) ) {
    return keyword.rot_right_k;
  }
  else if( ss.equals( "down" ) ) {
    return keyword.rot_upside_down_k;
  }
  
  return keyword.none_k;
}

static keyword consume_keyword( StringBuilder ssb ) {
  String ss = new String(ssb).toLowerCase();
  // cat range keywords
  if( ss.startsWith( "end" ) ) { // note: strncmp
    ssb.delete(0,3);
    return keyword.end_k;
  }
  else if( ss.startsWith( "even" ) ) { // note: strncmp
    ssb.delete(0,4);
    return keyword.even_k;
  }
  else if( ss.startsWith( "odd" ) ) { // note: strncmp
    ssb.delete(0,3);
    return keyword.odd_k;
  }
  else {
    ssb.setLength(0);
    return is_keyword( ss );
  }
}

  keyword m_operation = keyword.none_k;

  class PageRef {
    int m_input_pdf_index;
    int m_page_num; // 1-based
    PageRotate m_page_rot; // DF rotation
    boolean m_page_abs; // DF absolute / relative rotation

    PageRef( int input_pdf_index, int page_num) {
      m_input_pdf_index = input_pdf_index;
      m_page_num = page_num;
      m_page_rot = PageRotate.NORTH;
      m_page_abs = false;
    }
    PageRef( int input_pdf_index, int page_num,
             PageRotate page_rot, boolean page_abs ) {
      m_input_pdf_index = input_pdf_index;
      m_page_num = page_num;
      m_page_rot = page_rot;
      m_page_abs = page_abs;
    }
  };
  ArrayList<ArrayList<PageRef>> m_page_seq = new ArrayList<ArrayList<PageRef>>(); // one vector for each given page range

  String m_form_data_filename = "";
  String m_background_filename = "";
  String m_stamp_filename = "";
  String m_output_filename = "";
  boolean m_output_utf8_b = false;
  String m_output_owner_pw = "";
  String m_output_user_pw = "";
  int m_output_user_perms = 0;
  boolean m_multistamp_b = false; // use all pages of input stamp PDF, not just the first
  boolean m_multibackground_b = false; // use all pages of input background PDF, not just the first
  boolean m_output_uncompress_b = false;
  boolean m_output_compress_b = false;
  boolean m_output_flatten_b = false;
  boolean m_output_need_appearances_b = false;
  boolean m_output_drop_xfa_b = false;
  boolean m_output_drop_xmp_b = false;
  boolean m_output_keep_first_id_b = false;
  boolean m_output_keep_final_id_b = false;
  boolean m_cat_full_pdfs_b = true; // we are merging entire docs, not select pages

  enum encryption_strength {
    none_enc,
    bits40_enc,
    bits128_enc
  };
  encryption_strength m_output_encryption_strength = encryption_strength.none_enc;

  TK_Session( String[] args )
{
  ArgState arg_state = ArgState.input_files_e;

  // set one and only one to true when p/w used; use to
  // enforce rule that either all p/w use handles or no p/w use handles
  boolean password_using_handles_not_b= false;
  boolean password_using_handles_b= false;

  int password_input_pdf_index= 0;

  boolean fail_b= false;

  // first, look for our "dont_ask" or "do_ask" keywords, since this
  // setting must be known before we begin opening documents, etc.
  for( String argv : args ) {
    keyword kw= is_keyword( argv );
    if( kw== keyword.dont_ask_k ) {
      m_ask_about_warnings_b= false;
    }
    else if( kw== keyword.do_ask_k ) {
      m_ask_about_warnings_b= true;
    }
  }

  // iterate over cmd line arguments
  for( String argv : args ) {

    if (fail_b || arg_state== ArgState.done_e) break;
    keyword arg_keyword= is_keyword( argv );

    // these keywords can be false hits because of their loose matching requirements;
    // since they are suffixes to page ranges, their appearance here is most likely a false match;
    if( arg_keyword== keyword.end_k ||
        arg_keyword== keyword.even_k ||
        arg_keyword== keyword.odd_k )
      {
        arg_keyword= keyword.none_k;
      }  

    switch( arg_state ) {

    case input_files_e: 
    case input_pw_e: {
      // look for keywords that would advance our state,
      // and then handle the specifics of the above cases

      if( arg_keyword== keyword.input_pw_k ) { // input PDF passwords keyword

        arg_state= ArgState.input_pw_e;
      }
      else if( arg_keyword== keyword.cat_k ) {
        m_operation= keyword.cat_k;
        arg_state= ArgState.page_seq_e; // collect page sequeces
      }
      else if( arg_keyword== keyword.shuffle_k ) {
        m_operation= keyword.shuffle_k;
        arg_state= ArgState.page_seq_e; // collect page sequeces
      }
      else if( arg_keyword== keyword.burst_k ) {
        m_operation= keyword.burst_k;
        arg_state= ArgState.output_args_e; // makes "output <fn>" bit optional
      }
      else if( arg_keyword== keyword.filter_k ) {
        m_operation= keyword.filter_k;
        arg_state= ArgState.output_e; // look for an output filename
      }
      else if( arg_keyword== keyword.dump_data_k ) {
        m_operation= keyword.dump_data_k;
        arg_state= ArgState.output_e;
      }
      else if( arg_keyword== keyword.dump_data_utf8_k ) {
        m_operation= keyword.dump_data_k;
        m_output_utf8_b= true;
        arg_state= ArgState.output_e;
      }
      else if( arg_keyword== keyword.dump_data_fields_k ) {
        m_operation= keyword.dump_data_fields_k;
        arg_state= ArgState.output_e;
      }
      else if( arg_keyword== keyword.dump_data_fields_utf8_k ) {
        m_operation= keyword.dump_data_fields_k;
        m_output_utf8_b= true;
        arg_state= ArgState.output_e;
      }
      else if( arg_keyword== keyword.dump_data_k ) {
        m_operation= keyword.dump_data_k;
        arg_state= ArgState.output_e;
      }
      else if( arg_keyword== keyword.dump_data_annots_k ) {
        m_operation= keyword.dump_data_annots_k;
        arg_state= ArgState.output_e;
      }
      else if( arg_keyword== keyword.generate_fdf_k ) {
        m_operation= keyword.generate_fdf_k;
        m_output_utf8_b= true;
        arg_state= ArgState.output_e;
      }
      else if( arg_keyword== keyword.fill_form_k ) {
        m_operation= keyword.filter_k;
        arg_state= ArgState.form_data_filename_e; // look for an FDF filename
      }
      else if( arg_keyword== keyword.attach_file_k ) {
        m_operation= keyword.filter_k;
        arg_state= ArgState.attach_file_filename_e;
      }
      else if( arg_keyword== keyword.attach_file_to_page_k ) {
        arg_state= ArgState.attach_file_pagenum_e;
      }
      else if( arg_keyword== keyword.unpack_files_k ) {
        m_operation= keyword.unpack_files_k;
        arg_state= ArgState.output_e;
      }
      else if( arg_keyword== keyword.update_info_k ) {
        m_operation= keyword.filter_k;
        m_update_info_utf8_b= false;
        arg_state= ArgState.update_info_filename_e;
      }
      else if( arg_keyword== keyword.update_info_utf8_k ) {
        m_operation= keyword.filter_k;
        m_update_info_utf8_b= true;
        arg_state= ArgState.update_info_filename_e;
      }
      /*
      else if( arg_keyword== update_xmp_k ) {
        m_operation= filter_k;
        arg_state= update_xmp_filename_e;
      }
      */
      else if( arg_keyword== keyword.background_k ) {
        m_operation= keyword.filter_k;
        arg_state= ArgState.background_filename_e;
      }
      else if( arg_keyword== keyword.multibackground_k ) {
        m_operation= keyword.filter_k;
        m_multibackground_b= true;
        arg_state= ArgState.background_filename_e;
      }
      else if( arg_keyword== keyword.stamp_k ) {
        m_operation= keyword.filter_k;
        arg_state= ArgState.stamp_filename_e;
      }
      else if( arg_keyword== keyword.multistamp_k ) {
        m_operation= keyword.filter_k;
        m_multistamp_b= true;
        arg_state= ArgState.stamp_filename_e;
      }
      else if( arg_keyword== keyword.rotate_k ) {
        m_operation= keyword.filter_k;
        arg_state= ArgState.page_seq_e; // collect page sequeces
      }
      else if( arg_keyword== keyword.output_k ) { // we reached the output section
        arg_state= ArgState.output_filename_e;
      }
      else if( arg_keyword== keyword.none_k ) {
        // here is where the two cases (input_files_e, input_pw_e) diverge

        String handle, data;
        {
          Pattern p = Pattern.compile("(?:([A-Z]+)=)?(.*)");
          Matcher m = p.matcher(argv);
          m.matches();
          handle = m.group(1);
          data = m.group(2);
        }

        if( arg_state== ArgState.input_files_e ) {
          // input_files_e:
          // expecting input handle=filename pairs, or
          // an input filename w/o a handle
          //
          // treat argv[ii] like an optional input handle and filename
          // like this: [<handle>=]<filename>

          InputPdf input_pdf = new InputPdf();
          input_pdf.m_filename= data;

          if( handle == null ) { // no handle
            m_input_pdf.add( input_pdf );
          }
          else { // use given handle for filename; test, first

            // look up handle
            Integer it = m_input_pdf_index.get( handle );
            if( it!= null ) { // error: alreay in use

              System.err.println("Error: Handle given here: ");
              System.err.println("      " + argv);
              System.err.println("   is already associated with: ");
              System.err.println("      " + m_input_pdf.get(it).m_filename);
              System.err.println("   Exiting.");
              fail_b= true;
            }
            else { // add handle/filename association
              m_input_pdf.add( input_pdf );
              m_input_pdf_index.put(handle, m_input_pdf.size()- 1);
            }
          }
        } // end: arg_state== input_files_e

        else if( arg_state== ArgState.input_pw_e ) {
          // expecting input handle=password pairs, or
          // an input PDF password w/o a handle
          //
          // treat argv[ii] like an input handle and password
          // like this <handle>=<password>; if no handle is
          // given, assign passwords to input in order;

          // if handles not used for input PDFs, then assume
          // any equals signs found in p/w are part of p/w
          if( m_input_pdf_index.size()== 0 ) {
            handle= "";
            data= argv;
          }

          if( handle.isEmpty() ) { // no equal sign; try using default handles
            if( password_using_handles_b ) { // error: expected a handle

              System.err.println("Error: Expected a user-supplied handle for this input");
              System.err.println("   PDF password: " + argv);
              System.err.println();
              System.err.println("   Handles must be supplied with ~all~ input");
              System.err.println("   PDF passwords, or with ~no~ input PDF passwords.");
              System.err.println("   If no handles are supplied, then passwords are applied");
              System.err.println("   according to input PDF order.");
              System.err.println();
              System.err.println("   Handles are given like this: <handle>=<password>, and");
              System.err.println("   they must be single, upper case letters, like: A, B, etc.");
              fail_b= true;
            }
            else {
              password_using_handles_not_b= true;

              if( password_input_pdf_index< m_input_pdf.size() ) {
                m_input_pdf.get(password_input_pdf_index).m_password= argv;
                ++password_input_pdf_index;
              }
              else { // error
                System.err.println("Error: more input passwords than input PDF documents.");
                System.err.println("   Exiting.");
                fail_b= true;
              }
            }
          }
          else { // handle given; use for password
            if( password_using_handles_not_b ) { // error; remark and set fail_b

              System.err.println("Error: Expected ~no~ user-supplied handle for this input");
              System.err.println("   PDF password: " + argv);
              System.err.println();
              System.err.println("   Handles must be supplied with ~all~ input");
              System.err.println("   PDF passwords, or with ~no~ input PDF passwords.");
              System.err.println("   If no handles are supplied, then passwords are applied");
              System.err.println("   according to input PDF order.");
              System.err.println();
              System.err.println("   Handles are given like this: <handle>=<password>, and");
              System.err.println("   they must be single, upper case letters, like: A, B, etc.");
              fail_b= true;
            }
            else {
              password_using_handles_b= true;

              // look up this handle
              Integer it = m_input_pdf_index.get( handle );
              if( it!= null ) { // found

                if( m_input_pdf.get(it).m_password.isEmpty() ) {
                  m_input_pdf.get(it).m_password= data; // set
                }
                else { // error: password already given

                  System.err.println("Error: Handle given here: ");
                  System.err.println("      " + argv);
                  System.err.println("   is already associated with this password: ");
                  System.err.println("      " + m_input_pdf.get(it).m_password);
                  System.err.println("   Exiting.");
                  fail_b= true;
                }
              }
              else { // error: no input file matches this handle

                System.err.println("Error: Password handle: " + argv);
                System.err.println("   is not associated with an input PDF file.");
                System.err.println("   Exiting.");
                fail_b= true;
              }
            }
          }
        } // end: arg_state== input_pw_e
        else { // error
          System.err.println("Error: Internal error: unexpected arg_state.  Exiting.");
          fail_b= true;
        }
      }
      else { // error: unexpected keyword; remark and set fail_b
        System.err.println("Error: Unexpected command-line data: ");
        System.err.println("      " + argv);
        if( arg_state== ArgState.input_files_e ) {
          System.err.println("   where we were expecting an input PDF filename,");
          System.err.println("   operation (e.g. \"cat\") or \"input_pw\".  Exiting.");
        }
        else {
          System.err.println("   where we were expecting an input PDF password");
          System.err.println("   or operation (e.g. \"cat\").  Exiting.");
        }
        fail_b= true;
      }
    }
    break;

    case page_seq_e: {
      if( m_page_seq.isEmpty() ) {
        // we just got here; validate input filenames

        if( m_input_pdf.isEmpty() ) { // error; remark and set fail_b
          System.err.println("Error: No input files.  Exiting.");
          fail_b= true;
          break;
        }

        // try opening input PDF readers
        if( !open_input_pdf_readers() ) { // failure
          fail_b= true;
          break;
        }
      } // end: first pass init. pdf files

      if( arg_keyword== keyword.output_k ) {
        arg_state= ArgState.output_filename_e; // advance state
      }
      else if( arg_keyword== keyword.none_k || 
               arg_keyword== keyword.end_k )
        { // treat argv[ii] like a page sequence

          boolean even_pages_b= false;
          boolean odd_pages_b= false;

          Pattern p = Pattern.compile("([A-Z]*)(r?)([0-9]*)([^-]*)(-?)(r?)([0-9]*)(.*)");
          Matcher m = p.matcher(argv);
          m.matches();
          String handle = m.group(1);
          String pre_reverse = m.group(2);
          String pre_range = m.group(3);
          String pre_keywords = m.group(4);
          String hyphen = m.group(5);
          String post_reverse = m.group(6);
          String post_range = m.group(7);
          String post_keywords = m.group(8);

          int range_pdf_index= 0; { // defaults to first input document
            if( !handle.isEmpty() ) {
              // validate handle
              Integer it = m_input_pdf_index.get( handle );
              if( it== null ) { // error

                System.err.println("Error: Given handle has no associated file: ");
                System.err.println("   " + handle + ", used here: " + argv);
                System.err.println("   Exiting.");
                fail_b= true;
                break;
              }
              else {
                range_pdf_index= it;
              }
            }
          }

          // DF declare rotate vars
          PageRotate page_rotate= PageRotate.NORTH;
          boolean page_rotate_absolute= false;

          ////
          // beginning of page range

          boolean reverse_b= ( !pre_reverse.isEmpty() ); // single lc 'r' before page range

          // parse digits
          int page_num_beg= 0;
          boolean page_num_beg_out_of_range_b= false;
          StringBuilder trailing_keywords= new StringBuilder(pre_keywords);
          if ( !pre_range.isEmpty() ) {
            page_num_beg= Integer.parseInt(pre_range);
          }
          else if( !pre_keywords.isEmpty() ) { // look for usable keyword
            arg_keyword= consume_keyword( trailing_keywords );

            if( arg_keyword== keyword.end_k ) { // may be a single page ref or beg of range
              page_num_beg= m_input_pdf.get(range_pdf_index).m_num_pages;
            }
            else if ( !hyphen.isEmpty() ) {
              // error: can't have numbers ~and~ a keyword at the beginning of range
              System.err.println("Error: Unexpected combination of digits and text in");
              System.err.println("   page range start, here: " + argv);
              System.err.println("   Exiting.");
              fail_b= true;
              break;
            }
            else {
              // reset trailing_keywords again, since none have been handled yet,
              // but call to 'is_keyword()' above might have consumed one
              trailing_keywords = new StringBuilder(pre_keywords);
            }
          }

          if( m_input_pdf.get(range_pdf_index).m_num_pages< page_num_beg ) {
            // error: page number out of range
            System.err.println("Error: Range start page number exceeds size of PDF");
            System.err.println("   here: " + argv);
            System.err.println("   input PDF has: " + m_input_pdf.get(range_pdf_index).m_num_pages + " pages.");
            System.err.println("   Exiting.");
            fail_b= true;
            break;
          }

          if( reverse_b ) // above test ensures good value here
            page_num_beg= m_input_pdf.get(range_pdf_index).m_num_pages- page_num_beg+ 1;

          ////
          // end of page range

          int page_num_end= page_num_beg; // default value
          if( !hyphen.isEmpty() ) { // process second half of page range

            trailing_keywords = new StringBuilder(post_keywords);
            
            reverse_b= ( !post_reverse.isEmpty() ); // single lc 'r' before page range

            // parse digits
            if ( !post_range.isEmpty() ) {
              page_num_end= Integer.parseInt(post_range);
            }
            else if( !post_keywords.isEmpty() ) { // look for usable keyword
              arg_keyword= consume_keyword( trailing_keywords );
              
              if( arg_keyword== keyword.end_k ) {
                page_num_end= m_input_pdf.get(range_pdf_index).m_num_pages;
              }
              else { // error: hyphen but no range end
                System.err.println("Error: Unexpected range end; expected a page");
                System.err.println("   number or legal keyword, here: " + argv);
                System.err.println("   Exiting.");
                fail_b= true;
                break;
              }
            }

            if( m_input_pdf.get(range_pdf_index).m_num_pages< page_num_end ) {
              // error: page number out of range
              System.err.println("Error: Range end page number exceeds size of PDF");
              System.err.println("   input PDF has: " + m_input_pdf.get(range_pdf_index).m_num_pages + " pages.");
              System.err.println("   Exiting.");
              fail_b= true;
              break;
            }

            if( reverse_b ) // above test ensures good value here
              page_num_end= m_input_pdf.get(range_pdf_index).m_num_pages- page_num_end+ 1;

          }

          // trailing keywords (excluding "end" which should have been handled above)
          while( trailing_keywords.length() > 0 ) { // possibly more than one keyword, e.g., 3-endevenwest

            // read keyword
            arg_keyword= consume_keyword( trailing_keywords );

            if( arg_keyword== keyword.even_k ) {
              even_pages_b= true;
            }
            else if( arg_keyword== keyword.odd_k ) {
              odd_pages_b= true;
            }
            else if( arg_keyword== keyword.rot_north_k ) {
              page_rotate= PageRotate.NORTH; // rotate 0
              page_rotate_absolute= true;
            }
            else if( arg_keyword== keyword.rot_east_k ) {
              page_rotate= PageRotate.EAST; // rotate 90
              page_rotate_absolute= true;
            }
            else if( arg_keyword== keyword.rot_south_k ) {
              page_rotate= PageRotate.SOUTH; // rotate 180
              page_rotate_absolute= true;
            }
            else if( arg_keyword== keyword.rot_west_k ) {
              page_rotate= PageRotate.WEST; // rotate 270
              page_rotate_absolute= true;
            }
            else if( arg_keyword== keyword.rot_left_k ) {
              page_rotate= PageRotate.WEST; // rotate -90
              page_rotate_absolute= false;
            }
            else if( arg_keyword== keyword.rot_right_k ) {
              page_rotate= PageRotate.EAST; // rotate +90
              page_rotate_absolute= false;
            }
            else if( arg_keyword== keyword.rot_upside_down_k ) {
              page_rotate= PageRotate.SOUTH; // rotate +180
              page_rotate_absolute= false;
            }
            else { // error
              System.err.println("Error: Unexpected text in page range end, here: ");
              System.err.println("   " + argv /*(argv[ii]+ jj)*/);
              System.err.println("   Exiting.");
              System.err.println("   Acceptable keywords, for example: \"even\" or \"odd\".");
              System.err.println("   To rotate pages, use: \"north\" \"south\" \"east\"");
              System.err.println("       \"west\" \"left\" \"right\" or \"down\"");
              fail_b= true;
              break;
            }
          }

          ////
          // pack this range into our m_page_seq; 

          if( page_num_beg== 0 && page_num_end== 0 ) { // ref the entire document
            page_num_beg= 1;
            page_num_end= m_input_pdf.get(range_pdf_index).m_num_pages;

            // test that it's a /full/ pdf
            m_cat_full_pdfs_b= m_cat_full_pdfs_b && ( !even_pages_b && !odd_pages_b );
          }
          else if( page_num_beg== 0 || page_num_end== 0 ) { // error
            System.err.println("Error: Input page numbers include 0 (zero)");
            System.err.println("   The first PDF page is 1 (one)");
            System.err.println("   Exiting.");
            fail_b= true;
            break;
          }
          else // the user specified select pages
            m_cat_full_pdfs_b= false;

          ArrayList< PageRef > temp_page_seq = new ArrayList< PageRef >();
          boolean reverse_sequence_b= ( page_num_end< page_num_beg );
          if( reverse_sequence_b ) { // swap
            int temp= page_num_end;
            page_num_end= page_num_beg;
            page_num_beg= temp;
          }

          for( int kk= page_num_beg; kk<= page_num_end; ++kk ) {
            if( (!even_pages_b || ((kk % 2) == 0)) &&
                (!odd_pages_b || ((kk % 2) == 1)) )
              {
                if( kk<= m_input_pdf.get(range_pdf_index).m_num_pages ) {

                  // look to see if this page of this document
                  // has already been referenced; if it has,
                  // create a new reader; associate this page
                  // with a reader;
                  //
                  boolean associated = false;
                  for( InputPdf.PagesReader it : m_input_pdf.get(range_pdf_index).m_readers) {
                    if( !it.first.contains( kk ) ) { // kk not assoc. w/ this reader
                      it.first.add( kk ); // create association
                      associated = true;
                      break;
                    }
                  }
                  //
                  if( !associated ) {
                    // need to create a new reader for kk
                    InputPdf.PagesReader new_reader = add_reader( m_input_pdf.get(range_pdf_index) );
                    if ( new_reader != null) {
                      new_reader.first.add( kk );
                    }
                    else {
                      System.err.println("Internal Error: unable to add reader");
                      fail_b= true;
                      break;
                    }
                  }

                  //
                  temp_page_seq.add( new PageRef( range_pdf_index, kk, page_rotate, page_rotate_absolute ) ); // DF rotate

                }
                else { // error; break later to get most feedback
                  System.err.println("Error: Page number: " + kk);
                  System.err.println("   does not exist in file: " + m_input_pdf.get(range_pdf_index).m_filename);
                  fail_b= true;
                }
              }
          }
          if( fail_b )
            break;

          if( reverse_sequence_b ) {
            Collections.reverse ( temp_page_seq );
          }

          m_page_seq.add( temp_page_seq );

        }
      else { // error
        System.err.println("Error: expecting page ranges.  Instead, I got:");
        System.err.println("   " + argv);
        fail_b= true;
        break;
      }
    }
    break;

    case form_data_filename_e: {
      if( arg_keyword== keyword.none_k )
        { // treat argv[ii] like an FDF file filename
          
          if( m_form_data_filename.isEmpty() ) {
            m_form_data_filename = argv;
          }
          else { // error
            System.err.println("Error: Multiple fill_form filenames given: ");
            System.err.println("   " + m_form_data_filename + " and " + argv);
            System.err.println("Exiting.");
            fail_b= true;
            break;
          }

          // advance state
          arg_state= ArgState.output_e; // look for an output filename
        }
      else { // error
        System.err.println("Error: expecting a form data filename,");
        System.err.println("   instead I got this keyword: " + argv);
        System.err.println("Exiting.");
        fail_b= true;
        break;
      }
    } // end: case form_data_filename_e
    break;

    case attach_file_filename_e: {
      // keep packing filenames until we reach an expected keyword

      if( arg_keyword== keyword.attach_file_to_page_k ) {
        arg_state= ArgState.attach_file_pagenum_e; // advance state
      }
      else if( arg_keyword== keyword.output_k ) {
        arg_state= ArgState.output_filename_e; // advance state
      }
      else if( arg_keyword== keyword.none_k ) { 
        // pack argv[ii] into our list of attachment filenames
        m_input_attach_file_filename.add( argv );
      }
      else { // error
        System.err.println("Error: expecting an attachment filename,");
        System.err.println("   instead I got this keyword: " + argv);
        System.err.println("Exiting.");
        fail_b= true;
        break;
      }
    }
    break;

    case attach_file_pagenum_e: {
      if( argv.equals("PROMPT") ) { // query the user, later
        m_input_attach_file_pagenum= -1;
      }
      else if( argv.equals("end") ) { // attach to the final page
        m_input_attach_file_pagenum= -2;
      }
      else {
        try {
          m_input_attach_file_pagenum= Integer.parseInt(argv);
        }
        catch (NumberFormatException e) { // error
          System.err.println("Error: expecting a (1-based) page number.  Instead, I got:");
          System.err.println("   " + argv);
          System.err.println("Exiting.");
          fail_b= true;
        }
      }

      // advance state
      arg_state= ArgState.output_e; // look for an output filename

    } // end: case attach_file_pagenum_e
    break;

    case update_info_filename_e : {
      if( arg_keyword== keyword.none_k ) {
          if( m_update_info_filename.isEmpty() ) {
            m_update_info_filename = argv;
          }
          else { // error
            System.err.println("Error: Multiple update_info filenames given: ");
            System.err.println("   " + m_update_info_filename + " and " + argv);
            System.err.println("Exiting.");
            fail_b= true;
            break;
          }
        }
      else { // error
        System.err.println("Error: expecting an INFO file filename,");
        System.err.println("   instead I got this keyword: " + argv);
        System.err.println("Exiting.");
        fail_b= true;
        break;
      }

      // advance state
      arg_state= ArgState.output_e; // look for an output filename

    } // end: case update_info_filename_e
    break;

    /*
    case update_xmp_filename_e : {
      if( arg_keyword== none_k ) {
          if( m_update_xmp_filename.empty() ) {
            m_update_xmp_filename= argv[ii];
          }
          else { // error
            cerr << "Error: Multiple update_xmp filenames given: " << endl;
            cerr << "   " << m_update_xmp_filename << " and " << argv[ii] << endl;
            cerr << "Exiting." << endl;
            fail_b= true;
            break;
          }
        }
      else { // error
        cerr << "Error: expecting an XMP file filename," << endl;
        cerr << "   instead I got this keyword: " << argv[ii] << endl;
        cerr << "Exiting." << endl;
        fail_b= true;
        break;
      }

      // advance state
      arg_state= output_e; // look for an output filename

    } // end: case update_xmp_filename_e
    break;
    */

    case output_e: {
      if( m_input_pdf.isEmpty() ) { // error; remark and set fail_b
        System.err.println("Error: No input files.  Exiting.");
        fail_b= true;
        break;
      }

      if( arg_keyword== keyword.output_k ) {
        arg_state= ArgState.output_filename_e; // advance state
      }
      else { // error
        System.err.println("Error: expecting \"output\" keyword.  Instead, I got:");
        System.err.println("   " + argv);
        fail_b= true;
        break;
      }
    }
    break;

    case output_filename_e: {
      // we have closed all possible input operations and arguments;
      // see if we should perform any default action based on the input state
      //
      if( m_operation== keyword.none_k ) {
        if( 1< m_input_pdf.size() ) {
          // no operation given for multiple input PDF, so combine them
          m_operation= keyword.cat_k;
        }
        else {
          m_operation= keyword.filter_k;
        }
      }
      
      // try opening input PDF readers (in case they aren't already)
      if( !open_input_pdf_readers() ) { // failure
        fail_b= true;
        break;
      }

      if( ( m_operation== keyword.cat_k ||
            m_operation== keyword.shuffle_k ) )
        {
          if( m_page_seq.isEmpty() ) {
            // combining pages, but no sequences given; merge all input PDFs in order
            for( int ii= 0; ii< m_input_pdf.size(); ++ii ) {
              InputPdf input_pdf= m_input_pdf.get(ii);

              ArrayList< PageRef > temp_page_seq = new ArrayList< PageRef >();
              for( int jj= 1; jj<= input_pdf.m_num_pages; ++jj ) {
                temp_page_seq.add( new PageRef( ii, jj ) ); // DF rotate
                input_pdf.m_readers.get(input_pdf.m_readers.size()-1).first.add( jj ); // create association
              }
              m_page_seq.add( temp_page_seq );
            }
          }
          /* no longer necessary -- are upstream testing is smarter
          else { // page ranges or docs (e.g. A B A) were given
            m_cat_full_pdfs_b= false; // TODO: handle cat A B A case for bookmarks
          }
          */
        }

      if( m_output_filename.isEmpty() ) {
        m_output_filename = argv;

        if( !m_output_filename.equals("-") ) { // input and output may both be "-" (stdin and stdout)
          // simple-minded test to see if output matches an input filename
          for( InputPdf it : m_input_pdf )
            {
              if( it.m_filename.equals(m_output_filename) ) {
                System.err.println("Error: The given output filename: " + m_output_filename);
                System.err.println("   matches an input filename.  Exiting.");
                fail_b= true;
                break;
              }
            }
        }
      }
      else { // error
        System.err.println("Error: Multiple output filenames given: ");
        System.err.println("   " + m_output_filename + " and " + argv);
        System.err.println("Exiting.");
        fail_b= true;
        break;
      }

      // advance state
      arg_state= ArgState.output_args_e;
    }
    break;

    case output_args_e: {
      // output args are order-independent but must follow "output <fn>", if present;
      // we are expecting any of these keywords:
      // owner_pw_k, user_pw_k, user_perms_k ...
      // added output_k case in pdftk 1.10; this permits softer "output <fn>" enforcement
      //

      ArgStateMutable arg_state_m = new ArgStateMutable();
      arg_state_m.value = arg_state;
      if( handle_some_output_options( arg_keyword, arg_state_m ) ) {
        arg_state = arg_state_m.value;
      }
      else {
        System.err.println("Error: Unexpected data in output section: ");
        System.err.println("      " + argv);
        System.err.println("Exiting.");
        fail_b= true;
        break;
      }
    }
    break;

    case output_owner_pw_e: {
      if( m_output_owner_pw.isEmpty() ) {

        if( argv.equals("PROMPT") || !argv.equals( m_output_user_pw ) ) {
          m_output_owner_pw= argv;
        }
        else { // error: identical user and owner password
          // are interpreted by Acrobat (per the spec.) that
          // the doc has no owner password
          System.err.println("Error: The user and owner passwords are the same.");
          System.err.println("   PDF Viewers interpret this to mean your PDF has");
          System.err.println("   no owner password, so they must be different.");
          System.err.println("   Or, supply no owner password to pdftk if this is");
          System.err.println("   what you desire.");
          System.err.println("Exiting.");
          fail_b= true;
          break;
        }
      }
      else { // error: we already have an output owner pw
        System.err.println("Error: Multiple output owner passwords given: ");
        System.err.println("   " + m_output_owner_pw + " and " + argv);
        System.err.println("Exiting.");
        fail_b= true;
        break;
      }

      // revert state
      arg_state= ArgState.output_args_e;
    }
    break;

    case output_user_pw_e: {
      if( m_output_user_pw.isEmpty() ) {
        if( argv.equals("PROMPT") || !m_output_owner_pw.equals(argv) ) {
          m_output_user_pw= argv;
        }
        else { // error: identical user and owner password
          // are interpreted by Acrobat (per the spec.) that
          // the doc has no owner password
          System.err.println("Error: The user and owner passwords are the same.");
          System.err.println("   PDF Viewers interpret this to mean your PDF has");
          System.err.println("   no owner password, so they must be different.");
          System.err.println("   Or, supply no owner password to pdftk if this is");
          System.err.println("   what you desire.");
          System.err.println("Exiting.");
          fail_b= true;
          break;
        }
      }
      else { // error: we already have an output user pw
        System.err.println("Error: Multiple output user passwords given: ");
        System.err.println("   " + m_output_user_pw + " and " + argv);
        System.err.println("Exiting.");
        fail_b= true;
        break;
      }

      // revert state
      arg_state= ArgState.output_args_e;
    }
    break;

    case output_user_perms_e: {

      // we may be given any number of permission arguments,
      // so keep an eye out for other, state-altering keywords
      ArgStateMutable arg_state_m = new ArgStateMutable();
      arg_state_m.value = arg_state;
      if( handle_some_output_options( arg_keyword, arg_state_m ) ) {
        arg_state = arg_state_m.value;
        break;
      }

      switch( arg_keyword ) {

        // possible permissions
      case perm_printing_k:
        // if both perm_printing_k and perm_degraded_printing_k
        // are given, then perm_printing_k wins;
        m_output_user_perms|= 
          PdfWriter.AllowPrinting;
        break;
      case perm_modify_contents_k:
        // Acrobat 5 and 6 don't set both bits, even though
        // they both respect AllowModifyContents --> AllowAssembly;
        // so, no harm in this;
        m_output_user_perms|= 
          ( PdfWriter.AllowModifyContents | PdfWriter.AllowAssembly );
        break;
      case perm_copy_contents_k:
        // Acrobat 5 _does_ allow the user to allow copying contents
        // yet hold back screen reader perms; this is counter-intuitive,
        // and Acrobat 6 does not allow Copy w/o SceenReaders;
        m_output_user_perms|= 
          ( PdfWriter.AllowCopy | PdfWriter.AllowScreenReaders );
        break;
      case perm_modify_annotations_k:
        m_output_user_perms|= 
          ( PdfWriter.AllowModifyAnnotations | PdfWriter.AllowFillIn );
        break;
      case perm_fillin_k:
        m_output_user_perms|= 
          PdfWriter.AllowFillIn;
        break;
      case perm_screen_readers_k:
        m_output_user_perms|= 
          PdfWriter.AllowScreenReaders;
        break;
      case perm_assembly_k:
        m_output_user_perms|= 
          PdfWriter.AllowAssembly;
        break;
      case perm_degraded_printing_k:
        m_output_user_perms|= 
          PdfWriter.AllowDegradedPrinting;
        break;
      case perm_all_k:
        m_output_user_perms= 
          ( PdfWriter.AllowPrinting | // top quality printing
            PdfWriter.AllowModifyContents |
            PdfWriter.AllowCopy |
            PdfWriter.AllowModifyAnnotations |
            PdfWriter.AllowFillIn |
            PdfWriter.AllowScreenReaders |
            PdfWriter.AllowAssembly );
        break;

      default: // error: unexpected matter
        System.err.println("Error: Unexpected data in output section: ");
        System.err.println("      " + argv);
        System.err.println("Exiting.");
        fail_b= true;
        break;
      }
    }
    break;

    case background_filename_e : {
      if( arg_keyword== keyword.none_k ) {
        if( m_background_filename.isEmpty() ) {
          m_background_filename = argv;
        }
        else { // error
          System.err.println("Error: Multiple background filenames given: ");
          System.err.println("   " + m_background_filename + " and " + argv);
          System.err.println("Exiting.");
          fail_b= true;
          break;
        }
      }
      else { // error
        System.err.println("Error: expecting a PDF filename for background operation,");
        System.err.println("   instead I got this keyword: " + argv);
        System.err.println("Exiting.");
        fail_b= true;
        break;
      }

      // revert state
      // this is more liberal than used with other operations, since we want
      // to preserve backward-compatibility with pdftk 1.00 where "background"
      // was documented as an output option; in pdftk 1.10 we changed it to
      // an operation
      arg_state= ArgState.output_args_e;
    }
    break;

    case stamp_filename_e : {
      if( arg_keyword== keyword.none_k ) {
        if( m_stamp_filename.isEmpty() ) {
          m_stamp_filename = argv;
        }
        else { // error
          System.err.println("Error: Multiple stamp filenames given: ");
          System.err.println("   " + m_stamp_filename + " and " + argv);
          System.err.println("Exiting.");
          fail_b= true;
          break;
        }
      }
      else { // error
        System.err.println("Error: expecting a PDF filename for stamp operation,");
        System.err.println("   instead I got this keyword: " + argv);
        System.err.println("Exiting.");
        fail_b= true;
        break;
      }

      // advance state
      arg_state= ArgState.output_e; // look for an output filename
    }
    break;

    default: { // error
      System.err.println("Internal Error: Unexpected arg_state.  Exiting.");
      fail_b= true;
      break;
    }

    } // end: switch(arg_state)

  } // end: iterate over command-line arguments

  if( fail_b ) {
    System.err.println("Errors encountered.  No output created.");
    m_valid_b= false;

    m_input_pdf.clear();

    // preserve other data members for diagnostic dump
  }
  else {
    m_valid_b= true;

    if(!m_input_pdf_readers_opened_b ) {
      open_input_pdf_readers();
    }
  }
}

boolean is_valid() {
  return( m_valid_b &&

          ( m_operation== keyword.dump_data_k ||
            m_operation== keyword.dump_data_fields_k ||
            m_operation== keyword.dump_data_annots_k ||
            m_operation== keyword.generate_fdf_k ||
            m_authorized_b ) &&

          !m_input_pdf.isEmpty() &&
          m_input_pdf_readers_opened_b &&

          ( m_operation== keyword.cat_k ||
            m_operation== keyword.shuffle_k ||
            m_operation== keyword.burst_k ||
            m_operation== keyword.filter_k ||
            m_operation== keyword.dump_data_k ||
            m_operation== keyword.dump_data_utf8_k ||
            m_operation== keyword.dump_data_fields_k ||
            m_operation== keyword.dump_data_fields_utf8_k ||
            m_operation== keyword.dump_data_annots_k ||
            m_operation== keyword.generate_fdf_k ||
            m_operation== keyword.unpack_files_k ) &&

          // these op.s require a single input PDF file
          ( !( m_operation== keyword.burst_k ||
               m_operation== keyword.filter_k ) ||
            ( m_input_pdf.size()== 1 ) ) &&

          // these op.s do not require an output filename
          ( m_operation== keyword.burst_k ||
            m_operation== keyword.dump_data_k ||
            m_operation== keyword.dump_data_fields_k ||
            m_operation== keyword.dump_data_annots_k ||
            m_operation== keyword.generate_fdf_k ||
            m_operation== keyword.unpack_files_k ||
            !m_output_filename.isEmpty() ) );
}

void dump_session_data()
{
  if( !m_verbose_reporting_b )
    return;

  if( !m_input_pdf_readers_opened_b ) {
    System.out.println( "Input PDF Open Errors" );
    return;
  }

  //
  if( is_valid() ) {
    System.out.println( "Command Line Data is valid." );
  }
  else { 
    System.out.println( "Command Line Data is NOT valid." );
  }

  // input files
  System.out.println();
  System.out.println( "Input PDF Filenames & Passwords in Order\n( <filename>[, <password>] ) " );
  if( m_input_pdf.isEmpty() ) {
    System.out.println( "   No input PDF filenames have been given." );
  }
  else {
    for( InputPdf it : m_input_pdf )
      {
        System.out.print( "   " + it.m_filename );
        if( !it.m_password.isEmpty() ) {
          System.out.print( ", " + it.m_password );
        }

        if( !it.m_authorized_b ) {
          System.out.print( ", OWNER OR USER PASSWORD REQUIRED, but not given (or incorrect)" );
        }

        System.out.println();
      }
  }

  // operation
  System.out.println();
  System.out.println( "The operation to be performed: " );
  switch( m_operation ) {
  case cat_k:
    System.out.println( "   cat - Catenate given page ranges into a new PDF." );
    break;
  case shuffle_k:
    System.out.println( "   shuffle - Interleave given page ranges into a new PDF." );
    break;
  case burst_k:
    System.out.println( "   burst - Split a single, input PDF into individual pages." );
    break;
  case filter_k:
    System.out.println( "   filter - Apply 'filters' to a single, input PDF based on output args." );
    System.out.println( "      (When the operation is omitted, this is the default.)" );
    break;
  case dump_data_k:
    System.out.println( "   dump_data - Report statistics on a single, input PDF." );
    break;
  case dump_data_fields_k:
    System.out.println( "   dump_data_fields - Report form field data on a single, input PDF." );
    break;
  case dump_data_annots_k:
    System.out.println( "   dump_data_annots - Report annotation data on a single, input PDF." );
    break;
  case generate_fdf_k:
    System.out.println( "   generate_fdf - Generate a dummy FDF file from a PDF." );
    break;
  case unpack_files_k:
    System.out.println( "   unpack_files - Copy PDF file attachments into given directory." );
    break;
  case none_k:
    System.out.println( "   NONE - No operation has been given.  See usage instructions." );
    break;
  default:
    System.out.println( "   INTERNAL ERROR - An unexpected operation has been given." );
    break;
  }

  // pages
  /*
  cout << endl;
  cout << "The following pages will be operated on, in the given order." << endl;
  if( m_page_seq.empty() ) {
    cout << "   No pages or page ranges have been given." << endl;
  }
  else {
    for( vector< PageRef >::const_iterator it= m_page_seq.begin();
         it!= m_page_seq.end(); ++it )
      {
        map< string, InputPdf >::const_iterator jt=
          m_input_pdf.find( it->m_handle );
        if( jt!= m_input_pdf.end() ) {
          cout << "   Handle: " << it->m_handle << "  File: " << jt->second.m_filename;
          cout << "  Page: " << it->m_page_num << endl;
        }
        else { // error
          cout << "   Internal Error: handle not found in m_input_pdf: " << it->m_handle << endl;
        }
      }
  }
  */

  // output file; may be PDF or text
  System.out.println();
  System.out.println( "The output file will be named:" );
  if( m_output_filename.isEmpty() ) {
    System.out.println( "   No output filename has been given." );
  }
  else {
    System.out.println( "   " + m_output_filename );
  }

  // output encryption
  System.out.println();
  boolean output_encrypted_b= 
    m_output_encryption_strength!= encryption_strength.none_enc ||
    !m_output_user_pw.isEmpty() ||
    !m_output_owner_pw.isEmpty();

  System.out.println( "Output PDF encryption settings:" );
  if( output_encrypted_b ) {
    System.out.println( "   Output PDF will be encrypted." );

    switch( m_output_encryption_strength ) {
    case none_enc:
      System.out.println( "   Encryption strength not given. Defaulting to: 128 bits." );
      break;
    case bits40_enc:
      System.out.println( "   Given output encryption strength: 40 bits" );
      break;
    case bits128_enc:
      System.out.println( "   Given output encryption strength: 128 bits" );
      break;
    }

    System.out.println();
    {

      if( m_output_user_pw.isEmpty() )
        System.out.println( "   No user password given." );
      else
        System.out.println( "   Given user password: " + m_output_user_pw );
      if( m_output_owner_pw.isEmpty() )
        System.out.println( "   No owner password given." );
      else
        System.out.println( "   Given owner password: " + m_output_owner_pw );
      //
      // the printing section: Top Quality or Degraded, but not both;
      // AllowPrinting is a superset of both flag settings
      if( (m_output_user_perms & PdfWriter.AllowPrinting)== PdfWriter.AllowPrinting )
        System.out.println( "   ALLOW Top Quality Printing" );
      else if( (m_output_user_perms & PdfWriter.AllowPrinting)== PdfWriter.AllowDegradedPrinting )
        System.out.println( "   ALLOW Degraded Printing (Top-Quality Printing NOT Allowed)" );
      else
        System.out.println( "   Printing NOT Allowed" );
      if( (m_output_user_perms & PdfWriter.AllowModifyContents)== PdfWriter.AllowModifyContents )
        System.out.println( "   ALLOW Modifying of Contents" );
      else
        System.out.println( "   Modifying of Contents NOT Allowed" );
      if( (m_output_user_perms & PdfWriter.AllowCopy)== PdfWriter.AllowCopy )
        System.out.println( "   ALLOW Copying of Contents" );
      else
        System.out.println( "   Copying of Contents NOT Allowed" );
      if( (m_output_user_perms & PdfWriter.AllowModifyAnnotations)== PdfWriter.AllowModifyAnnotations )
        System.out.println( "   ALLOW Modifying of Annotations" );
      else
        System.out.println( "   Modifying of Annotations NOT Allowed" );
      if( (m_output_user_perms & PdfWriter.AllowFillIn)== PdfWriter.AllowFillIn )
        System.out.println( "   ALLOW Fill-In" );
      else
        System.out.println( "   Fill-In NOT Allowed" );
      if( (m_output_user_perms & PdfWriter.AllowScreenReaders)== PdfWriter.AllowScreenReaders )
        System.out.println( "   ALLOW Screen Readers" );
      else
        System.out.println( "   Screen Readers NOT Allowed" );
      if( (m_output_user_perms & PdfWriter.AllowAssembly)== PdfWriter.AllowAssembly )
        System.out.println( "   ALLOW Assembly" );
      else
        System.out.println( "   Assembly NOT Allowed" );
    }
  }
  else {
    System.out.println( "   Output PDF will not be encrypted." );
  }

  // compression filter
  System.out.println();
  if( m_operation!= keyword.filter_k ||
      output_encrypted_b ||
      !( m_output_compress_b ||
         m_output_uncompress_b ) )
    {
      System.out.println( "No compression or uncompression being performed on output." );
    }
  else {
    if( m_output_compress_b ) {
      System.out.println( "Compression will be applied to some PDF streams." );
    }
    else {
      System.out.println( "Some PDF streams will be uncompressed." );
    }
  }
}

  void attach_files
  ( PdfReader input_reader_p,
    PdfWriter writer_p ) throws IOException
{
  if( !m_input_attach_file_filename.isEmpty() ) {

    if( m_input_attach_file_pagenum== -1 ) { // our signal to prompt the user for a pagenum
      System.out.println( "Please enter the page number you want to attach these files to." );
      System.out.println( "   The first page is 1.  The final page is \"end\"." );
      System.out.println( "   To attach files at the document level, just press Enter." );

      Scanner s = new Scanner(System.in);
      String buff= s.nextLine();
      if ( buff.isEmpty() ) { // attach to document
        m_input_attach_file_pagenum= 0;
      }
      if ( buff.equals( "end" ) ) { // the final page
        m_input_attach_file_pagenum= input_reader_p.getNumberOfPages();
      }
      else {
        Pattern p = Pattern.compile("([0-9]*).*");
        Matcher m = p.matcher(buff);
        m.matches();
        try {
          m_input_attach_file_pagenum= Integer.valueOf(m.group(1));
        }
        catch (NumberFormatException e) {
          m_input_attach_file_pagenum= 0;
        }
      }
    }
    else if( m_input_attach_file_pagenum== -2 ) { // the final page ("end")
      m_input_attach_file_pagenum= input_reader_p.getNumberOfPages();
    }

    if( m_input_attach_file_pagenum != 0 ) { // attach to a page using annotations
      final int trans= 27;
      final int margin= 18;

      if( 0< m_input_attach_file_pagenum &&
          m_input_attach_file_pagenum<= input_reader_p.getNumberOfPages() ) {

        PdfDictionary page_p= input_reader_p.getPageN( m_input_attach_file_pagenum );
        if( page_p != null && page_p.isDictionary() ) {

          Rectangle crop_box_p= 
            input_reader_p.getCropBox( m_input_attach_file_pagenum );
          float corner_top= crop_box_p.top()- margin;
          float corner_left= crop_box_p.left()+ margin;

          PdfArray annots_p= (PdfArray)
            input_reader_p.getPdfObject( page_p.get( PdfName.ANNOTS ) );
          boolean annots_new_b= false;
          if( annots_p == null ) { // create Annots array
            annots_p= new PdfArray();
            annots_new_b= true;
          }
          else { // grab corner_top and corner_left from the bottom right of the newest annot
            ArrayList<PdfObject> annots_array_p= annots_p.getArrayList();
            for( PdfObject ii : annots_array_p ) {
              PdfDictionary annot_p= (PdfDictionary)
                input_reader_p.getPdfObject( ii );
              if( annot_p != null && annot_p.isDictionary() ) {
                PdfArray annot_bbox_p= (PdfArray)
                  input_reader_p.getPdfObject( annot_p.get( PdfName.RECT ) );
                if( annot_bbox_p != null && annot_bbox_p.isArray() ) {
                  ArrayList<PdfObject> bbox_array_p= annot_bbox_p.getArrayList();
                  if( bbox_array_p.size()== 4 ) {
                    corner_top= ((PdfNumber)bbox_array_p.get( 1 )).floatValue();
                    corner_left= ((PdfNumber)bbox_array_p.get( 2 )).floatValue();
                  }
                }
              }
            }
          }
          if( annots_p != null && annots_p.isArray() ) {
            for( String vit :  m_input_attach_file_filename )
              {
                if( vit.equals("PROMPT") ) {
                  vit= pdftk.prompt_for_filename( "Please enter a filename for attachment:" );
                }

                String filename= attachments.drop_path(vit);

                // wrap our location over page bounds, if needed
                if( crop_box_p.right() < corner_left+ trans ) {
                  corner_left= crop_box_p.left()+ margin;
                }
                if( corner_top- trans< crop_box_p.bottom() ) {
                  corner_top= crop_box_p.top()- margin;
                }

                Rectangle annot_bbox_p= 
                  new Rectangle( corner_left,
                                        corner_top- trans,
                                        corner_left+ trans,
                                        corner_top );
                                    
                PdfAnnotation annot_p=
                  PdfAnnotation.createFileAttachment
                  ( writer_p,
                    annot_bbox_p,
                    filename, // contents
                    null,
                    vit, // the file path
                    filename ); // display name

                PdfIndirectReference ref_p=
                  writer_p.addToBody( annot_p ).getIndirectReference();

                annots_p.add( ref_p );

                // advance the location of our annotation
                corner_left+= trans;
                corner_top-= trans;
              }
            if( annots_new_b ) { // add new Annots array to page dict
              PdfIndirectReference ref_p=
                writer_p.addToBody( annots_p ).getIndirectReference();
              page_p.put( PdfName.ANNOTS, ref_p );              
            }
          }
        }
        else { // error
          System.err.println( "Internal Error: unable to get page dictionary" );
        }
      }
      else { // error
        System.err.print( "Error: page number " + m_input_attach_file_pagenum );
        System.err.println( " is not present in the input PDF." );
      }
    }
    else { // attach to document using the EmbeddedFiles name tree
      PdfDictionary catalog_p= input_reader_p.catalog; // to top, Root dict
      if( catalog_p != null && catalog_p.isDictionary() ) {

        // the Names dict
        PdfDictionary names_p= (PdfDictionary)
          input_reader_p.getPdfObject( catalog_p.get( PdfName.NAMES ) );
        boolean names_new_b= false;
        if( names_p == null ) { // create Names dict
          names_p= new PdfDictionary();
          names_new_b= true;
        }
        if( names_p != null && names_p.isDictionary() ) {

          // the EmbeddedFiles name tree (ref. 1.5, sec. 3.8.5), which is a dict at top
          PdfDictionary emb_files_tree_p= (PdfDictionary)
            input_reader_p.getPdfObject( names_p.get( PdfName.EMBEDDEDFILES ) );
          HashMap<String,PdfIndirectReference> emb_files_map_p= null;
          boolean emb_files_tree_new_b= false;
          if( emb_files_tree_p != null ) { // read current name tree of attachments into a map
            emb_files_map_p= PdfNameTree.readTree( emb_files_tree_p );
          }
          else { // create material
            emb_files_map_p= new HashMap<String,PdfIndirectReference>();
            emb_files_tree_new_b= true;
          }

          ////
          // add matter to name tree

          for( String vit :  m_input_attach_file_filename )
            {
              if( vit.equals( "PROMPT" ) ) {
                vit= pdftk.prompt_for_filename( "Please enter a filename for attachment:" );
              }

              String filename= attachments.drop_path(vit);

              PdfFileSpecification filespec_p= null;
              try {
                // create the file spec. from file
                filespec_p= 
                  PdfFileSpecification.fileEmbedded
                  ( writer_p,
                    vit, // the file path
                    filename, // the display name
                    null );
              }
              catch( IOException ioe_p ) { // file open error
                System.err.println( "Error: Failed to open attachment file: " );
                System.err.println( "   " + vit );
                System.err.println( "   Skipping this file." );
                continue;
              }

              // add file spec. to PDF via indirect ref.
              PdfIndirectReference ref_p=
                writer_p.addToBody( filespec_p ).getIndirectReference();

              // contruct a name, if necessary, to prevent possible key collision on the name tree
              String key_p= vit;
              for(int counter=1; emb_files_map_p.containsKey( key_p ); ++counter ) { // append a unique suffix
                key_p = vit + "-" + counter;
              }

              // add file spec. to map
              emb_files_map_p.put( key_p, ref_p );
            }

          if( !emb_files_map_p.isEmpty() ) {
            // create a name tree from map
            PdfDictionary emb_files_tree_new_p=
              PdfNameTree.writeTree( emb_files_map_p, writer_p );

            if( emb_files_tree_new_b && emb_files_tree_new_p != null) {
              // adding new material
              PdfIndirectReference ref_p=
                writer_p.addToBody( emb_files_tree_new_p ).getIndirectReference();
              names_p.put( PdfName.EMBEDDEDFILES, ref_p );
            }
            else if( emb_files_tree_p != null && emb_files_tree_new_p != null ) {
              // supplementing old material
              emb_files_tree_p.merge( emb_files_tree_new_p );
            }
            else { // error
              System.err.println( "Internal Error: no valid EmbeddedFiles tree to add to PDF." );
            }

            if( names_new_b ) {
              // perform addToBody only after packing new names_p into names_p;
              // use the resulting ref. to pack our new Names dict. into the catalog (Root)
              PdfIndirectReference ref_p=
                writer_p.addToBody( names_p ).getIndirectReference();
              catalog_p.put( PdfName.NAMES, ref_p );
            }
          }
        }
        else { // error
          System.err.println( "Internal Error: couldn't read or create PDF Names dictionary." );
        }
      }
      else { // error
        System.err.println( "Internal Error: couldn't read input PDF Root dictionary." );
        System.err.println( "   File attachment failed; no new files attached to output." );
      }
    }
  }
}

  void unpack_files
    ( PdfReader input_reader_p )
{
  // output pathname; PROMPT if necessary
  String output_pathname= attachments.normalize_pathname( m_output_filename );

  { // unpack document attachments
    PdfDictionary catalog_p= input_reader_p.catalog; // to top, Root dict
    if( catalog_p != null && catalog_p.isDictionary() ) {

      // the Names dict
      PdfDictionary names_p= (PdfDictionary)
        input_reader_p.getPdfObject( catalog_p.get( PdfName.NAMES ) );
      if( names_p != null && names_p.isDictionary() ) {

        // the EmbeddedFiles name tree (ref. 1.5, sec. 3.8.5), which is a dict at top
        PdfDictionary emb_files_tree_p= (PdfDictionary)
          input_reader_p.getPdfObject( names_p.get( PdfName.EMBEDDEDFILES ) );
        HashMap<Object, PdfObject> emb_files_map_p= null;
        if( emb_files_tree_p != null && emb_files_tree_p.isDictionary() ) { 
          // read current name tree of attachments into a map
          emb_files_map_p= PdfNameTree.readTree( emb_files_tree_p );

          for( PdfObject value_p : emb_files_map_p.values() ) {
            PdfDictionary filespec_p= (PdfDictionary)
              input_reader_p.getPdfObject( value_p );
            if( filespec_p != null && filespec_p.isDictionary() ) {

              attachments.unpack_file( input_reader_p,
                           filespec_p,
                           output_pathname,
                           m_ask_about_warnings_b );
            }
          }
        }
      }
    }
  }

  { // unpack page attachments
    int num_pages= input_reader_p.getNumberOfPages();
    for( int ii= 1; ii<= num_pages; ++ii ) { // 1-based page ref.s

        PdfDictionary page_p= input_reader_p.getPageN( ii );
        if( page_p != null && page_p.isDictionary() ) {

          PdfArray annots_p= (PdfArray)
            input_reader_p.getPdfObject( page_p.get( PdfName.ANNOTS ) );
          if( annots_p != null && annots_p.isArray() ) {

            ArrayList<PdfObject> annots_array_p = annots_p.getArrayList();
            for( PdfObject jj : annots_array_p ) {
              PdfDictionary annot_p= (PdfDictionary)
                input_reader_p.getPdfObject( jj );
              if( annot_p != null && annot_p.isDictionary() ) {

                PdfName subtype_p= (PdfName)
                  input_reader_p.getPdfObject( annot_p.get( PdfName.SUBTYPE ) );
                if( subtype_p != null && subtype_p.isName() && 
                    subtype_p.equals(PdfName.FILEATTACHMENT) ) {
                  
                  PdfDictionary filespec_p= (PdfDictionary)
                    input_reader_p.getPdfObject( annot_p.get( PdfName.FS ) );
                  if( filespec_p != null && filespec_p.isDictionary() ) {
                    
                    attachments.unpack_file( input_reader_p,
                                 filespec_p,
                                 output_pathname,
                                 m_ask_about_warnings_b );
                  }
                }
              }
            }
          }
        }
      
    }
  }
}

////
// when uncompressing a PDF, we add this marker to every page,
// so the PDF is easier to navigate; when compressing a PDF,
// we remove this marker

static final String g_page_marker= "pdftk_PageNum";
static void
add_mark_to_page( PdfReader reader_p,
                  int page_index,
                  int page_num )
{
  PdfName page_marker_p=
    new PdfName( g_page_marker );
  PdfDictionary page_p= reader_p.getPageN( page_index );
  if( page_p != null && page_p.isDictionary() ) {
    page_p.put( page_marker_p, new PdfNumber( page_num ) );
  }
}
static void
add_marks_to_pages( PdfReader reader_p )
{
  int num_pages= reader_p.getNumberOfPages();
  for( int ii= 1; ii<= num_pages; ++ii ) { // 1-based page ref.s
    add_mark_to_page( reader_p, ii, ii );
  }
}
static void
remove_mark_from_page( PdfReader reader_p,
                       int page_num )
{
  PdfName page_marker_p=
    new PdfName( g_page_marker );
  PdfDictionary page_p= reader_p.getPageN( page_num );
  if( page_p != null && page_p.isDictionary() ) {
    page_p.remove( page_marker_p );
  }
}
static void
remove_marks_from_pages( PdfReader reader_p )
{
  int num_pages= reader_p.getNumberOfPages();
  for( int ii= 1; ii<= num_pages; ++ii ) { // 1-based page ref.s
    remove_mark_from_page( reader_p, ii );
  }
}
  
static void
apply_rotation_to_page( PdfReader reader_p, int page_num, int rotation, boolean absolute ) {
  // DF rotate
  PdfDictionary page_p= reader_p.getPageN( page_num );
  if( !absolute ) {
    rotation= reader_p.getPageRotation( page_num )+ rotation;
  }
  rotation= rotation % 360;
  page_p.remove( PdfName.ROTATE );
  if( rotation!= PageRotate.NORTH.value ) { // default rotation
    page_p.put( PdfName.ROTATE,
                new PdfNumber( rotation ) );
  }
}

ErrorCode create_output_page( PdfCopy writer_p, PageRef page_ref, int output_page_count ) {
  ErrorCode ret_val= ErrorCode.NO_ERROR;

  // get the reader associated with this page ref.
  if( page_ref.m_input_pdf_index< m_input_pdf.size() ) {
    InputPdf page_pdf= m_input_pdf.get( page_ref.m_input_pdf_index );

    if( m_verbose_reporting_b ) {
      System.out.print("   Adding page " + page_ref.m_page_num + " X" + page_ref.m_page_rot + "X "); // DF rotate
      System.out.println(" from " + page_pdf.m_filename);
    }

    // take the first, associated reader and then disassociate
    PdfReader input_reader_p= null;
    for (InputPdf.PagesReader mt : page_pdf.m_readers) {
      if( mt.first.contains( page_ref.m_page_num )) { // assoc. found
        input_reader_p= mt.second;
        mt.first.remove( page_ref.m_page_num ); // remove this assoc.
        break;
      }
    }

    if( input_reader_p != null) {

      //
      if( m_output_uncompress_b ) {
        add_mark_to_page( input_reader_p, page_ref.m_page_num, output_page_count+ 1 );
      }
      else if( m_output_compress_b ) {
        remove_mark_from_page( input_reader_p, page_ref.m_page_num );
      }

      // DF rotate
      apply_rotation_to_page( input_reader_p, page_ref.m_page_num, page_ref.m_page_rot.value, page_ref.m_page_abs );

      //
      try {
        PdfImportedPage page_p= 
          writer_p.getImportedPage( input_reader_p, page_ref.m_page_num );
        try {
          writer_p.addPage( page_p );
        }
        catch (DocumentException e) {
          System.err.print("Internal Error: addPage() failed for: ");
          System.err.println(page_ref.m_page_num + " in file: " + page_pdf.m_filename);
          ret_val= ErrorCode.BUG;
        }
      }
      catch (IOException e) { // error
        System.err.print("Internal Error: getImportedPage() failed for: ");
        System.err.println(page_ref.m_page_num + " in file: " + page_pdf.m_filename);
        ret_val= ErrorCode.BUG;
      }
    }
    else { // error
      System.err.print("Internal Error: no reader found for page: ");
      System.err.println(page_ref.m_page_num + " in file: " + page_pdf.m_filename);
      ret_val= ErrorCode.BUG;
    }
  }
  else { // error
    System.err.println("Internal Error: Unable to find handle in m_input_pdf.");
    ret_val= ErrorCode.BUG;
  }

  return ret_val;
}

static char GetPdfVersionChar( PdfName version_p ) {
  char version_cc= PdfWriter.VERSION_1_4; // default

  if( version_p != null )
    if( version_p.equals( PdfName.VERSION_1_4 ) )
      version_cc= PdfWriter.VERSION_1_4;
    else if( version_p.equals( PdfName.VERSION_1_5 ) )
      version_cc= PdfWriter.VERSION_1_5;
    else if( version_p.equals( PdfName.VERSION_1_6 ) )
      version_cc= PdfWriter.VERSION_1_6;
    else if( version_p.equals( PdfName.VERSION_1_7 ) )
      version_cc= PdfWriter.VERSION_1_7;
    else if( version_p.equals( PdfName.VERSION_1_3 ) )
      version_cc= PdfWriter.VERSION_1_3;
    else if( version_p.equals( PdfName.VERSION_1_2 ) )
      version_cc= PdfWriter.VERSION_1_2;
    else if( version_p.equals( PdfName.VERSION_1_1 ) )
      version_cc= PdfWriter.VERSION_1_1;
    else if( version_p.equals( PdfName.VERSION_1_0 ) )
      version_cc= PdfWriter.VERSION_1_0;

  return version_cc;
}

ErrorCode create_output() {
  ErrorCode ret_val= ErrorCode.NO_ERROR; // default: no error

  if( is_valid() ) {

    /*
    bool rdfcat_available_b= false;
    { // is rdfcat available?  first character should be a digit;
      // grab stderr to keep messages appearing to user;
      // 2>&1 might not work on older versions of Windows (e.g., 98);
      FILE* pp= popen( "rdfcat --version 2>&1", "r" );
      if( pp ) {
        int cc= fgetc( pp );
        if( '0'<= cc && cc<= '9' ) {
          rdfcat_available_b= true;
        }
        pclose( pp );
      }
    }
    */

    if( m_verbose_reporting_b ) {
      System.out.println();
      System.out.println("Creating Output ...");
    }

    String creator= "pdftk " + pdftk.PDFTK_VER + " - www.pdftk.com";
    String jv_creator_p= creator;

    if( m_output_owner_pw.equals("PROMPT") ) {
      m_output_owner_pw = pdftk.prompt_for_password( "owner", "the output PDF" );
    }
    if( m_output_user_pw.equals("PROMPT") ) {
      m_output_user_pw= pdftk.prompt_for_password( "user", "the output PDF");
    }

    byte[] output_owner_pw_p= new byte[0];
    if( !m_output_owner_pw.isEmpty() ) {
      output_owner_pw_p= passwords.utf8_password_to_pdfdoc(m_output_owner_pw, true );
      if (output_owner_pw_p == null) { // error
        System.err.println("Error: Owner password used to encrypt output PDF includes");
        System.err.println("   invalid characters.");
        System.err.println("   No output created.");
        ret_val= ErrorCode.ERROR;
      }
    }

    byte[] output_user_pw_p= new byte[0];
    if( !m_output_user_pw.isEmpty() ) {
      output_user_pw_p= passwords.utf8_password_to_pdfdoc(m_output_user_pw, true );
      if (output_user_pw_p == null) { // error
        System.err.println("Error: User password used to encrypt output PDF includes");
        System.err.println("   invalid characters.");
        System.err.println("   No output created.");
        ret_val= ErrorCode.ERROR;
      }
    }

    if( ret_val != ErrorCode.NO_ERROR )
      return ret_val; // <--- exit

    try {
      switch( m_operation ) {

      case cat_k :
      case shuffle_k : { // catenate pages or shuffle pages
        Document output_doc_p= new Document();

        OutputStream ofs_p= 
          pdftk.get_output_stream( m_output_filename, 
                             m_ask_about_warnings_b );

        if( ofs_p == null ) { // file open error
          ret_val= ErrorCode.ERROR;
          break;
        }
        PdfCopy writer_p= new PdfCopy( output_doc_p, ofs_p );

        // update to suit any features that we add, e.g. encryption;
        char max_version_cc= PdfWriter.VERSION_1_2;

        //
        output_doc_p.addCreator( jv_creator_p );

        // un/compress output streams?
        if( m_output_uncompress_b ) {
          writer_p.filterStreams= true;
          writer_p.compressStreams= false;
        }
        else if( m_output_compress_b ) {
          writer_p.filterStreams= false;
          writer_p.compressStreams= true;
        }

        // encrypt output?
        if( m_output_encryption_strength!= encryption_strength.none_enc ||
            !m_output_owner_pw.isEmpty() || 
            !m_output_user_pw.isEmpty() )
          {
            // if no stregth is given, default to 128 bit,
            boolean bit128_b=
              ( m_output_encryption_strength!= encryption_strength.bits40_enc );

            writer_p.setEncryption( output_user_pw_p,
                                     output_owner_pw_p,
                                     m_output_user_perms,
                                     bit128_b );

            if( bit128_b )
              max_version_cc= PdfWriter.VERSION_1_4;
            else // 1.1 probably okay, here
              max_version_cc= PdfWriter.VERSION_1_3;
          }

        // copy file ID?
        if( m_output_keep_first_id_b ||
            m_output_keep_final_id_b )
          {
            PdfReader input_reader_p= 
              m_output_keep_first_id_b ?
              m_input_pdf.get(0).m_readers.get(0).second :
              m_input_pdf.get(m_input_pdf.size()- 1).m_readers.get(0).second;
                
            PdfDictionary trailer_p= input_reader_p.getTrailer();
            
            PdfArray file_id_p= (PdfArray) input_reader_p.getPdfObject( trailer_p.get( PdfName.ID ) );
            if( file_id_p != null && file_id_p.isArray() ) {

              writer_p.setFileID( file_id_p );
            }
          }

        // set output PDF version to the max PDF ver of all the input PDFs;
        // also find the maximum extension levels, if present -- this can
        // only be added /after/ opening the document;
        //
        // collected extensions information; uses PdfName::hashCode() for key
        HashMap< PdfName, PdfName > ext_base_versions = new HashMap< PdfName, PdfName >();
        HashMap< PdfName, Integer > ext_levels = new HashMap< PdfName, Integer >();
        for( InputPdf it : m_input_pdf)
          {
            PdfReader reader_p= it.m_readers.get(0).second;

            ////
            // PDF version number

            // version in header
            if( max_version_cc< reader_p.getPdfVersion() )
              max_version_cc= reader_p.getPdfVersion();

            // version override in catalog; used only if greater than header version, per PDF spec;
            PdfDictionary catalog_p= reader_p.getCatalog();
            if( catalog_p.contains( PdfName.VERSION ) ) {

              PdfName version_p= (PdfName) reader_p.getPdfObject( catalog_p.get( PdfName.VERSION ) );
              char version_cc= GetPdfVersionChar( version_p );

              if( max_version_cc< version_cc )
                max_version_cc= version_cc;
            }

            ////
            // PDF extensions

            if( catalog_p.contains( PdfName.EXTENSIONS ) ) {
              PdfDictionary extensions_p= (PdfDictionary) reader_p.getPdfObject( catalog_p.get( PdfName.EXTENSIONS ) );
              if( extensions_p != null && extensions_p.isDictionary() ) {

                // iterate over developers
                Set<PdfObject> keys_p= extensions_p.getKeys();
                Iterator<PdfObject> kit= keys_p.iterator();
                while( kit.hasNext() ) {
                  PdfName developer_p= (PdfName) reader_p.getPdfObject( kit.next() );
                    
                  PdfDictionary dev_exts_p= (PdfDictionary) reader_p.getPdfObject( extensions_p.get( developer_p ) );
                  if( dev_exts_p != null && dev_exts_p.isDictionary() ) {

                    if( dev_exts_p.contains( PdfName.BASEVERSION ) &&
                        dev_exts_p.contains( PdfName.EXTENSIONLEVEL ) )
                      {
                        // use the greater base version or the greater extension level

                        PdfName base_version_p= (PdfName) reader_p.getPdfObject( dev_exts_p.get( PdfName.BASEVERSION ) );
                        PdfNumber ext_level_p= (PdfNumber) reader_p.getPdfObject( dev_exts_p.get( PdfName.EXTENSIONLEVEL ) );

                        if( !ext_base_versions.containsKey( developer_p ) ||
                            GetPdfVersionChar( ext_base_versions.get( developer_p ) )<
                            GetPdfVersionChar( base_version_p ) )
                          { // new developer or greater base version
                            ext_base_versions.put( developer_p, base_version_p );
                            ext_levels.put( developer_p, ext_level_p.intValue() );
                          }
                        else if( GetPdfVersionChar( ext_base_versions.get( developer_p ) )==
                                 GetPdfVersionChar( base_version_p ) &&
                                 ext_levels.get( developer_p )< ext_level_p.intValue() )
                          { // greater extension level for current base version
                            ext_levels.put( developer_p, ext_level_p.intValue() );
                          }
                      }
                  }
                }
              }
            }
          }
        // set the pdf version
        writer_p.setPdfVersion( max_version_cc );

        // open the doc
        output_doc_p.open();

        // set any pdf version extensions we might have found
        if( !ext_base_versions.isEmpty() ) {
          PdfDictionary extensions_dict_p= new PdfDictionary();
          PdfIndirectReference extensions_ref_p= writer_p.getPdfIndirectReference();
          for( Map.Entry<PdfName, PdfName> it : ext_base_versions.entrySet())
            {
              PdfDictionary ext_dict_p= new PdfDictionary();
              ext_dict_p.put( PdfName.BASEVERSION, it.getValue() );
              ext_dict_p.put( PdfName.EXTENSIONLEVEL, 
                              new PdfNumber( ext_levels.get(it.getKey()) ) );
              
              extensions_dict_p.put( it.getKey(), ext_dict_p );
            }

          writer_p.addToBody( extensions_dict_p, extensions_ref_p );
          writer_p.setExtensions( extensions_ref_p );
        }

        if( m_operation== keyword.shuffle_k ) {
          int max_seq_length= 0;
          for( ArrayList< PageRef > jt : m_page_seq)
            {
              max_seq_length= ( max_seq_length< jt.size() ) ? jt.size() : max_seq_length;
            }

          int output_page_count= 0;
          // iterate over ranges
          for( int ii= 0; ( ii< max_seq_length && ret_val== ErrorCode.NO_ERROR ); ++ii ) {
            // iterate over ranges
            for( ArrayList< PageRef > jt : m_page_seq )
              {
                if (ret_val != ErrorCode.NO_ERROR) break;
                if( ii< jt.size() ) {
                  ret_val= create_output_page( writer_p, jt.get(ii), output_page_count );
                  ++output_page_count;
                }
              }
          }
        }
        else { // cat_k
          
          int output_page_count= 0;
          // iterate over page ranges
          for( ArrayList< PageRef > jt : m_page_seq )
            {
              if (ret_val != ErrorCode.NO_ERROR) break;
              // iterate over pages in page range
              for( PageRef it : jt )
                {
                  if (ret_val != ErrorCode.NO_ERROR) break;
                  ret_val= create_output_page( writer_p, it, output_page_count );
                  ++output_page_count;
                }
            }

          // first impl added a bookmark for each input PDF and then
          // added any of that PDFs bookmarks under that; now it
          // appends input PDF bookmarks, which is more attractive;
          // OTOH, some folks might want pdftk to add bookmarks for
          // input PDFs, esp if they don't have bookmarks -- TODO
          // but then, it would be nice to allow the user to specify
          // a label -- using the PDF filename is unattractive;
          if( m_cat_full_pdfs_b ) { // add bookmark info
            // cerr << "cat full pdfs!" << endl; // debug

            PdfDictionary output_outlines_p= 
              new PdfDictionary( PdfName.OUTLINES );
            PdfIndirectReference output_outlines_ref_p= 
              writer_p.getPdfIndirectReference();

            PdfDictionary after_child_p= null;
            PdfIndirectReference after_child_ref_p= null;
              
            int page_count= 1;
            int num_bookmarks_total= 0;
            /* used for adding doc bookmarks
            itext::PdfDictionary* prev_p= 0;
            itext::PdfIndirectReference* prev_ref_p= 0;
            */
            // iterate over page ranges; each full PDF has one page seq in m_page_seq;
            // using m_page_seq instead of m_input_pdf, so the doc order is right
            for( ArrayList< PageRef > jt : m_page_seq)
              {
                PdfReader reader_p=
                  m_input_pdf.get(jt.get(0).m_input_pdf_index).m_readers.get(0).second;
                long reader_page_count= 
                  m_input_pdf.get(jt.get(0).m_input_pdf_index).m_num_pages;
            
                /* used for adding doc bookmarks
                itext::PdfDictionary* item_p= new itext::PdfDictionary();
                itext::PdfIndirectReference* item_ref_p= writer_p->getPdfIndirectReference();

                item_p->put( itext::PdfName::PARENT, outlines_ref_p );
                item_p->put( itext::PdfName::TITLE, 
                             new itext::PdfString( JvNewStringUTF( (*it).m_filename.c_str() ) ) );
                  
                // wire into linked list
                if( prev_p ) {
                  prev_p->put( itext::PdfName::NEXT, item_ref_p );
                  item_p->put( itext::PdfName::PREV, prev_ref_p );
                }
                else { // first item; wire into outlines dict
                  output_outlines_p->put( itext::PdfName::FIRST, item_ref_p );
                }

                // the destination
                itext::PdfDestination* dest_p= new itext::PdfDestination(itext::PdfDestination::FIT);
                itext::PdfIndirectReference* page_ref_p= writer_p->getPageReference( page_count );
                if( page_ref_p ) {
                  dest_p->addPage( page_ref_p );
                }
                item_p->put( itext::PdfName::DEST, dest_p );
                */

                // pdf bookmarks -> children
                { 
                  PdfDictionary catalog_p= reader_p.getCatalog();
                  PdfDictionary outlines_p= (PdfDictionary) reader_p.getPdfObject( catalog_p.get( PdfName.OUTLINES ) );
                  if( outlines_p != null && outlines_p.isDictionary() ) {

                    PdfDictionary top_outline_p= (PdfDictionary)
                      reader_p.getPdfObject( outlines_p.get( PdfName.FIRST ) );
                    if( top_outline_p != null && top_outline_p.isDictionary() ) {

                      ArrayList<PdfBookmark> bookmark_data = new ArrayList<PdfBookmark>();
                      int rr= bookmarks.ReadOutlines( bookmark_data, top_outline_p, 0, reader_p, true );
                      if( rr== 0 && !bookmark_data.isEmpty() ) {

                        // passed in by reference, so must use variable:
                        bookmarks.BuildBookmarksState state = new bookmarks.BuildBookmarksState();
                        state.final_child_p = after_child_p;
                        state.final_child_ref_p = after_child_ref_p;
                        state.num_bookmarks_total = num_bookmarks_total;
                        bookmarks.BuildBookmarks( writer_p,
                                        bookmark_data.listIterator(),
                                        //item_p, item_ref_p, // used for adding doc bookmarks
                                        output_outlines_p, output_outlines_ref_p,
                                        after_child_p, after_child_ref_p,
                                        0,
                                        page_count- 1, // page offset is 0-based
                                        0,
                                        true,
                                        state);
                        after_child_p = state.final_child_p;
                        after_child_ref_p = state.final_child_ref_p;
                        num_bookmarks_total = state.num_bookmarks_total;
                      }
                      /*
                      else if( rr!= 0 )
                      cerr << "ReadOutlines error" << endl; // debug
                      else
                      cerr << "empty bookmark data" << endl; // debug
                      */
                    }
                  }
                  /*
                  else
                    cerr << "no outlines" << endl; // debug
                  */
                }

                /* used for adding doc bookmarks
                // finished with prev; add to body
                if( prev_p )
                  writer_p->addToBody( prev_p, prev_ref_p );

                prev_p= item_p;
                prev_ref_p= item_ref_p;
                */

                page_count+= reader_page_count;

              }
            /* used for adding doc bookmarks
            if( prev_p ) { // wire into outlines dict
              // finished with prev; add to body
              writer_p->addToBody( prev_p, prev_ref_p );

              output_outlines_p->put( itext::PdfName::LAST, prev_ref_p );
              output_outlines_p->put( itext::PdfName::COUNT, new itext::PdfNumber( (jint)m_input_pdf.size() ) );
            }
            */

            if( num_bookmarks_total != 0 ) { // we encountered bookmarks

              // necessary for serial appending to outlines
              if( after_child_p != null && after_child_ref_p != null )
                writer_p.addToBody( after_child_p, after_child_ref_p );

              writer_p.addToBody( output_outlines_p, output_outlines_ref_p );
              writer_p.setOutlines( output_outlines_ref_p );
            }
          }
          
        }

        output_doc_p.close();
        writer_p.close();
      }
      break;
      
      case burst_k : { // burst input into pages

        // we should have been given only a single, input file
        if( 1< m_input_pdf.size() ) { // error
          System.err.println("Error: Only one input PDF file may be given for \"burst\" op.");
          System.err.println("   No output created.");
          break;
        }

        // grab the first reader, since there's only one
        PdfReader input_reader_p= 
          m_input_pdf.get(0).m_readers.get(0).second;
        int input_num_pages= 
          m_input_pdf.get(0).m_num_pages;

        if( m_output_filename.equals("PROMPT") ) {
          m_output_filename = pdftk.prompt_for_filename( "Please enter a filename pattern for the PDF pages (e.g. pg_%04d.pdf):");
        }
        if( m_output_filename.isEmpty() ) {
          m_output_filename= "pg_%04d.pdf";
        }

        // locate the input PDF Info dictionary that holds metadata
        PdfDictionary input_info_p= null; {
          PdfDictionary input_trailer_p= input_reader_p.getTrailer();
          if( input_trailer_p != null && input_trailer_p.isDictionary() ) {
            input_info_p= (PdfDictionary)
              input_reader_p.getPdfObject( input_trailer_p.get( PdfName.INFO ) );
            if( input_info_p != null && input_info_p.isDictionary() ) {
              // success
            }
            else {
              input_info_p= null;
            }
          }
        }

        for( int ii= 0; ii< input_num_pages; ++ii ) {

          // the filename
          String jv_output_filename_p= String.format(m_output_filename, ii+ 1);

          Document output_doc_p= new Document();
          FileOutputStream ofs_p= new FileOutputStream( jv_output_filename_p );
          PdfCopy writer_p= new PdfCopy( output_doc_p, ofs_p );
          writer_p.setFromReader( input_reader_p );

          output_doc_p.addCreator( jv_creator_p );

          // un/compress output streams?
          if( m_output_uncompress_b ) {
            writer_p.filterStreams= true;
            writer_p.compressStreams= false;
          }
          else if( m_output_compress_b ) {
            writer_p.filterStreams= false;
            writer_p.compressStreams= true;
          }

          // encrypt output?
          if( m_output_encryption_strength!= encryption_strength.none_enc ||
              !m_output_owner_pw.isEmpty() || 
              !m_output_user_pw.isEmpty() )
            {
              // if no stregth is given, default to 128 bit,
              boolean bit128_b=
                ( m_output_encryption_strength!= encryption_strength.bits40_enc );

              writer_p.setEncryption( output_user_pw_p,
                                       output_owner_pw_p,
                                       m_output_user_perms,
                                       bit128_b );
            }

          output_doc_p.open(); // must open writer before copying (possibly) indirect object

          { // copy the Info dictionary metadata
            if( input_info_p != null ) {
              PdfDictionary writer_info_p= writer_p.getInfo();
              if( writer_info_p != null ) {
                PdfDictionary info_copy_p= writer_p.copyDictionary( input_info_p );
                if( info_copy_p != null ) {
                  writer_info_p.putAll( info_copy_p );
                }
              }
            }
            byte[] input_reader_xmp_p= input_reader_p.getMetadata();
            if( input_reader_xmp_p != null ) {
              writer_p.setXmpMetadata( input_reader_xmp_p );
            }
          }

          PdfImportedPage page_p= 
            writer_p.getImportedPage( input_reader_p, ii+ 1 );
          writer_p.addPage( page_p );

          output_doc_p.close();
          writer_p.close();
        }

        ////
        // dump document data

        String doc_data_fn= "doc_data.txt";
        if( !m_output_filename.isEmpty() ) {
          int loc= m_output_filename.lastIndexOf(File.separatorChar);
          if( loc >= 0 ) {
            doc_data_fn= m_output_filename.substring( 0, loc )+ File.separatorChar + doc_data_fn;
          }
        }
        try {
          PrintStream ofs = pdftk.get_print_stream( doc_data_fn, m_output_utf8_b );
          report.ReportOnPdf( ofs, input_reader_p, m_output_utf8_b );
        }
        catch (FileNotFoundException e) { // error
          System.err.println("Error: unable to open file for output: doc_data.txt");
          ret_val= ErrorCode.ERROR;
        }

      }
      break;

      case filter_k: { // apply operations to given PDF file

        // we should have been given only a single, input file
        if( 1< m_input_pdf.size() ) { // error
          System.err.println("Error: Only one input PDF file may be given for this");
          System.err.println("   operation.  Maybe you meant to use the \"cat\" operator?");
          System.err.println("   No output created.");
          ret_val= ErrorCode.ERROR;
          break;
        }

        // try opening the FDF file before we get too involved;
        // if input is stdin ("-"), don't pass it to both the FDF and XFDF readers
        FdfReader fdf_reader_p= null;
        XfdfReader xfdf_reader_p= null;
        if( m_form_data_filename.equals("PROMPT") ) { // handle case where user enters '-' or (empty) at the prompt
          m_form_data_filename = pdftk.prompt_for_filename( "Please enter a filename for the form data:");
        }
        if( !m_form_data_filename.isEmpty() ) { // we have form data to process
          if( m_form_data_filename.equals("-") ) { // form data on stdin
            //JArray<jbyte>* in_arr= itext::RandomAccessFileOrArray::InputStreamToArray( java::System::in );
            
            // first try fdf
            try {
              fdf_reader_p= new FdfReader( System.in );
            }
            catch( IOException ioe_p ) { // file open error

              // maybe it's xfdf?
              try {
                xfdf_reader_p= new XfdfReader( System.in );
              }
              catch( IOException ioe2_p ) { // file open error
                System.err.println("Error: Failed read form data on stdin.");
                System.err.println("   No output created.");
                ret_val= ErrorCode.ERROR;
                //ioe_p->printStackTrace(); // debug
                break;
              }
            }
          }
          else { // form data file

            // first try fdf
            try {
              fdf_reader_p=
                new FdfReader( m_form_data_filename );
            }
            catch( IOException ioe_p ) { // file open error
              // maybe it's xfdf?
              try {
                xfdf_reader_p=
                  new XfdfReader( m_form_data_filename );
              }
              catch( IOException ioe2_p ) { // file open error
                System.err.println("Error: Failed to open form data file: ");
                System.err.println("   " + m_form_data_filename);
                System.err.println("   No output created.");
                ret_val= ErrorCode.ERROR;
                //ioe_p->printStackTrace(); // debug
                break;
              }
            }
          }
        }

        // try opening the PDF background or stamp before we get too involved
        PdfReader mark_p= null;
        boolean background_b= true; // set false for stamp
        //
        // background
        if( m_background_filename.equals("PROMPT") ) {
          m_background_filename = pdftk.prompt_for_filename( "Please enter a filename for the background PDF:");
        }
        if( !m_background_filename.isEmpty() ) {
          try {
            mark_p= new PdfReader( m_background_filename );
            mark_p.removeUnusedObjects();
            //reader->shuffleSubsetNames(); // changes the PDF subset names, but not the PostScript font names
          }
          catch( IOException ioe_p ) { // file open error
            System.err.println("Error: Failed to open background PDF file: ");
            System.err.println("   " + m_background_filename);
            System.err.println("   No output created.");
            ret_val= ErrorCode.ERROR;
            break;
          }
        }
        //
        // stamp
        if( mark_p == null ) {
          if( m_stamp_filename.equals("PROMPT") ) {
            m_stamp_filename = pdftk.prompt_for_filename( "Please enter a filename for the stamp PDF:");
          }
          if( !m_stamp_filename.isEmpty() ) {
            background_b= false;
            try {
              mark_p= new PdfReader( m_stamp_filename );
              mark_p.removeUnusedObjects();
              //reader->shuffleSubsetNames(); // changes the PDF subset names, but not the PostScript font names
            }
            catch( IOException ioe_p ) { // file open error
              System.err.println("Error: Failed to open stamp PDF file: ");
              System.err.println("   " + m_stamp_filename);
              System.err.println("   No output created.");
              ret_val= ErrorCode.ERROR;
              break;
            }
          }
        }

        //
        OutputStream ofs_p= pdftk.get_output_stream( m_output_filename, m_ask_about_warnings_b );
        if( ofs_p == null ) { // file open error
          System.err.println("Error: unable to open file for output: " + m_output_filename);
          ret_val= ErrorCode.ERROR;
          break;
        }

        //
        PdfReader input_reader_p= m_input_pdf.get(0).m_readers.get(0).second;

        // drop the xfa?
        if( m_output_drop_xfa_b ) {
          PdfDictionary catalog_p= input_reader_p.catalog;
          if( catalog_p != null && catalog_p.isDictionary() ) {
              
            PdfDictionary acro_form_p= (PdfDictionary)
              input_reader_p.getPdfObject( catalog_p.get( PdfName.ACROFORM ) );
            if( acro_form_p != null && acro_form_p.isDictionary() ) {

              acro_form_p.remove( PdfName.XFA );
            }
          }
        }

        // drop the xmp?
        if( m_output_drop_xmp_b ) {
          PdfDictionary catalog_p= input_reader_p.catalog;
          if( catalog_p != null && catalog_p.isDictionary() ) {
              
            catalog_p.remove( PdfName.METADATA );
          }
        }

        //
        PdfStamperImp writer_p=
          new PdfStamperImp( input_reader_p, ofs_p, '\0', false /* append mode */ );

        // update the info?
        if( m_update_info_filename.equals("PROMPT") ) {
          m_update_info_filename = pdftk.prompt_for_filename( "Please enter an Info file filename:");
        }
        if( !m_update_info_filename.isEmpty() ) {
          if( m_update_info_filename.equals("-") ) {
            if( !data_import.UpdateInfo( input_reader_p, System.in, m_update_info_utf8_b ) ) {
              System.err.println("Warning: no Info added to output PDF.");
              ret_val= ErrorCode.WARNING;
            }
          }
          else {
            try {
              FileInputStream ifs = new FileInputStream( m_update_info_filename );
              if( !data_import.UpdateInfo( input_reader_p, ifs, m_update_info_utf8_b ) ) {
                System.err.println("Warning: no Info added to output PDF.");
                ret_val= ErrorCode.WARNING;
              }
            }
            catch ( FileNotFoundException e ) { // error
              System.err.println("Error: unable to open FDF file for input: " + m_update_info_filename);
              ret_val= ErrorCode.ERROR;
              break;
            }
          }
        }

        /*
        // update the xmp?
        if( !m_update_xmp_filename.empty() ) {
          if( rdfcat_available_b ) {
            if( m_update_xmp_filename== "PROMPT" ) {
              prompt_for_filename( "Please enter an Info file filename:",
                                   m_update_xmp_filename );
            }
            if( !m_update_xmp_filename.empty() ) {
              UpdateXmp( input_reader_p, m_update_xmp_filename );
            }
          }
          else { // error
            cerr << "Error: to use this feature, you must install the rdfcat program." << endl;
            cerr << "   Perhaps the replace_xmp feature would suit you, instead?" << endl;
            break;
          }
        }
        */

        // rotate pages?
        if( !m_page_seq.isEmpty() ) {
          for( ArrayList< PageRef > jt : m_page_seq ) {
            for ( PageRef kt : jt ) {
              apply_rotation_to_page( input_reader_p, kt.m_page_num,
                                      kt.m_page_rot.value, kt.m_page_abs );
            }
          }
        }

        // un/compress output streams?
        if( m_output_uncompress_b ) {
          add_marks_to_pages( input_reader_p );
          writer_p.filterStreams= true;
          writer_p.compressStreams= false;
        }
        else if( m_output_compress_b ) {
          remove_marks_from_pages( input_reader_p );
          writer_p.filterStreams= false;
          writer_p.compressStreams= true;
        }

        // encrypt output?
        if( m_output_encryption_strength!= encryption_strength.none_enc ||
            !m_output_owner_pw.isEmpty() ||
            !m_output_user_pw.isEmpty() )
          {

            // if no stregth is given, default to 128 bit,
            // (which is incompatible w/ Acrobat 4)
            boolean bit128_b=
              ( m_output_encryption_strength!= encryption_strength.bits40_enc );

            writer_p.setEncryption( output_user_pw_p,
                                      output_owner_pw_p,
                                      m_output_user_perms,
                                      bit128_b );
          }

        // fill form fields?
        if( fdf_reader_p != null || xfdf_reader_p != null ) {
          if( input_reader_p.getAcroForm() != null ) { // we really have a form to fill

            AcroFields fields_p= writer_p.getAcroFields();
            fields_p.setGenerateAppearances( true ); // have iText create field appearances
            if( ( fdf_reader_p != null && fields_p.setFields( fdf_reader_p ) ) ||
                ( xfdf_reader_p != null && fields_p.setFields( xfdf_reader_p ) ) )
              { // Rich Text input found

                // set the PDF so that Acrobat will create appearances;
                // this might appear contradictory to our setGenerateAppearances( true ) call,
                // above; setting this, here, allows us to keep the generated appearances,
                // in case the PDF is opened somewhere besides Acrobat; yet, Acrobat/Reader
                // will create the Rich Text appearance if it has a chance
                m_output_need_appearances_b= true;
                /*
                itext::PdfDictionary* catalog_p= input_reader_p->catalog;
                if( catalog_p && catalog_p->isDictionary() ) {
              
                  itext::PdfDictionary* acro_form_p= (itext::PdfDictionary*)
                    input_reader_p->getPdfObject( catalog_p->get( itext::PdfName::ACROFORM ) );
                  if( acro_form_p && acro_form_p->isDictionary() ) {

                    acro_form_p->put( itext::PdfName::NEEDAPPEARANCES, itext::PdfBoolean::PDFTRUE );
                  }
                }
                */
              }
          }
          else { // warning
            System.err.println("Warning: input PDF is not an acroform, so its fields were not filled.");
            ret_val= ErrorCode.WARNING;
          }
        }

        // flatten form fields?
        writer_p.setFormFlattening( m_output_flatten_b );

        // cue viewer to render form field appearances?
        if( m_output_need_appearances_b ) {
          PdfDictionary catalog_p= input_reader_p.catalog;
          if( catalog_p != null && catalog_p.isDictionary() ) {
            PdfDictionary acro_form_p= (PdfDictionary)
              input_reader_p.getPdfObject( catalog_p.get( PdfName.ACROFORM ) );
            if( acro_form_p != null && acro_form_p.isDictionary() ) {
              acro_form_p.put( PdfName.NEEDAPPEARANCES, 
                                PdfBoolean.PDFTRUE );
            }
          }
        }

        // add background/watermark?
        if( mark_p != null ) {

          int mark_num_pages= 1; // default: use only the first page of mark
          if( m_multistamp_b || m_multibackground_b ) { // use all pages of mark
            mark_num_pages= mark_p.getNumberOfPages();
          }

          // the mark information; initialized inside loop
          PdfImportedPage mark_page_p= null;
          Rectangle mark_page_size_p= null;
          int mark_page_rotation= 0;

          // iterate over document's pages, adding mark_page as
          // a layer above (stamp) or below (watermark) the page content;
          // scale mark_page and move it so it fits within the document's page;
          //
          int num_pages= input_reader_p.getNumberOfPages();
          for( int ii= 0; ii< num_pages; ) {
            ++ii; // page refs are 1-based, not 0-based

            // the mark page and its geometry
            if( ii<= mark_num_pages ) {
              mark_page_size_p= mark_p.getCropBox( ii );
              mark_page_rotation= mark_p.getPageRotation( ii );
              for( int mm= 0; mm< mark_page_rotation; mm+=90 ) {
                mark_page_size_p= mark_page_size_p.rotate();
              }

              // create a PdfTemplate from the first page of mark
              // (PdfImportedPage is derived from PdfTemplate)
              mark_page_p= writer_p.getImportedPage( mark_p, ii );
            }

            // the target page geometry
            Rectangle doc_page_size_p= 
              input_reader_p.getCropBox( ii );
            int doc_page_rotation= input_reader_p.getPageRotation( ii );
            for( int mm= 0; mm< doc_page_rotation; mm+=90 ) {
              doc_page_size_p= doc_page_size_p.rotate();
            }

            float h_scale= doc_page_size_p.width() / mark_page_size_p.width();
            float v_scale= doc_page_size_p.height() / mark_page_size_p.height();
            float mark_scale= (h_scale< v_scale) ? h_scale : v_scale;

            float h_trans= (float)(doc_page_size_p.left()- mark_page_size_p.left()* mark_scale +
                                     (doc_page_size_p.width()- 
                                      mark_page_size_p.width()* mark_scale) / 2.0);
            float v_trans= (float)(doc_page_size_p.bottom()- mark_page_size_p.bottom()* mark_scale +
                                     (doc_page_size_p.height()- 
                                      mark_page_size_p.height()* mark_scale) / 2.0);
          
            PdfContentByte content_byte_p= 
              ( background_b ) ? writer_p.getUnderContent( ii ) : writer_p.getOverContent( ii );

            if( mark_page_rotation== 0 ) {
              content_byte_p.addTemplate( mark_page_p, 
                                           mark_scale, 0,
                                           0, mark_scale,
                                           h_trans, 
                                           v_trans );
            }
            else if( mark_page_rotation== 90 ) {
              content_byte_p.addTemplate( mark_page_p, 
                                           0, -1* mark_scale,
                                           mark_scale, 0,
                                           h_trans, 
                                           v_trans+ mark_page_size_p.height()* mark_scale );
            }
            else if( mark_page_rotation== 180 ) {
              content_byte_p.addTemplate( mark_page_p, 
                                           -1* mark_scale, 0,
                                           0, -1* mark_scale,
                                           h_trans+ mark_page_size_p.width()* mark_scale, 
                                           v_trans+ mark_page_size_p.height()* mark_scale );
            }
            else if( mark_page_rotation== 270 ) {
              content_byte_p.addTemplate( mark_page_p, 
                                           0, mark_scale,
                                           -1* mark_scale, 0,
                                           h_trans+ mark_page_size_p.width()* mark_scale, v_trans );
            }
          }
        }

        // attach file to document?
        if( !m_input_attach_file_filename.isEmpty() ) {
          this.attach_files( input_reader_p,
                              writer_p );
        }

        // performed in add_reader(), but this eliminates objects after e.g. drop_xfa, drop_xmp
        input_reader_p.removeUnusedObjects();

        // done; write output
        writer_p.close();
      }
      break;

      case dump_data_fields_k :
      case dump_data_annots_k :
      case dump_data_k: { // report on input document

        // we should have been given only a single, input file
        if( 1< m_input_pdf.size() ) { // error
          System.err.println("Error: Only one input PDF file may be used for the dump_data operation");
          System.err.println("   No output created.");
          ret_val= ErrorCode.ERROR;
          break;
        }

        PdfReader input_reader_p=
          m_input_pdf.get(0).m_readers.get(0).second;

        try {
          PrintStream ofs = pdftk.get_print_stream( m_output_filename, m_output_utf8_b );
          if( m_operation== keyword.dump_data_k ) {
            report.ReportOnPdf( ofs, input_reader_p, m_output_utf8_b );
          }
          else if( m_operation== keyword.dump_data_fields_k ) {
            report.ReportAcroFormFields( ofs, input_reader_p, m_output_utf8_b );
          }
          else if( m_operation== keyword.dump_data_annots_k ) {
            report.ReportAnnots( ofs, input_reader_p, m_output_utf8_b );
          }
        }
        catch (FileNotFoundException e) { // error
          System.err.println("Error: unable to open file for output: " + m_output_filename);
        }
      }
      break;

      case generate_fdf_k : { // create a dummy FDF file that would work with the input PDF form

        // we should have been given only a single, input file
        if( 1< m_input_pdf.size() ) { // error
          System.err.println("Error: Only one input PDF file may be used for the generate_fdf operation");
          System.err.println("   No output created.");
          break;
        }

        PdfReader input_reader_p= 
          m_input_pdf.get(0).m_readers.get(0).second;

        OutputStream ofs_p= 
          pdftk.get_output_stream( m_output_filename, 
                             m_ask_about_warnings_b );
        if( ofs_p != null ) {
          FdfWriter writer_p= new FdfWriter();
          input_reader_p.getAcroFields().exportAsFdf( writer_p );
          writer_p.writeTo( ofs_p );
          // no writer_p->close() function

          //delete writer_p; // OK? GC? -- NOT okay!
        }
        else { // error: get_output_stream() reports error
          ret_val= ErrorCode.ERROR;
          break;
        }
      }
        break;

      case unpack_files_k: { // copy PDF file attachments into current directory

        // we should have been given only a single, input file
        if( 1< m_input_pdf.size() ) { // error
          System.err.println("Error: Only one input PDF file may be given for \"unpack_files\" op.");
          System.err.println("   No output created.");
          ret_val= ErrorCode.ERROR;
          break;
        }

        PdfReader input_reader_p= 
          m_input_pdf.get(0).m_readers.get(0).second;

        this.unpack_files( input_reader_p );
      }
        break;
      default:
        // error
        System.err.println("Unexpected pdftk Error in create_output()");
        ret_val= ErrorCode.BUG;
        break;
      }
    }
    catch( Throwable t_p )
      {
        System.err.println("Unhandled Java Exception in create_output():");
        t_p.printStackTrace();
        ret_val= ErrorCode.BUG;
      }
  }
  else { // error
    ret_val= ErrorCode.ERROR;
  }

  return ret_val;
}

  private enum ArgState {
    input_files_e,
    input_pw_e,

    page_seq_e,
    form_data_filename_e,
    
    attach_file_filename_e,
    attach_file_pagenum_e,

    update_info_filename_e,
    update_xmp_filename_e,

    output_e, // state where we expect output_k, next
    output_filename_e,

    output_args_e, // output args are order-independent; switch here
    output_owner_pw_e,
    output_user_pw_e,
    output_user_perms_e,

    background_filename_e,
    stamp_filename_e,

    done_e
  };
  class ArgStateMutable {
    ArgState value;
  }

  // convenience function; return true iff handled
  private boolean handle_some_output_options( TK_Session.keyword kw, ArgStateMutable arg_state_p )
{
  switch( kw ) {
  case output_k:
    // added this case for the burst operation and "output" support;
    // also helps with backward compatibility of the "background" feature
    // change state
    arg_state_p.value= ArgState.output_filename_e;
    break;

    // state-altering keywords
  case owner_pw_k:
    // change state
    arg_state_p.value= ArgState.output_owner_pw_e;
    break;
  case user_pw_k:
    // change state
    arg_state_p.value= ArgState.output_user_pw_e;
    break;
  case user_perms_k:
    // change state
    arg_state_p.value= ArgState.output_user_perms_e;
    break;

    ////
    // no arguments to these keywords, so the state remains unchanged
  case encrypt_40bit_k:
    m_output_encryption_strength= encryption_strength.bits40_enc;
    break;
  case encrypt_128bit_k:
    m_output_encryption_strength= encryption_strength.bits128_enc;
    break;
  case filt_uncompress_k:
    m_output_uncompress_b= true;
    break;
  case filt_compress_k:
    m_output_compress_b= true;
    break;
  case flatten_k:
    m_output_flatten_b= true;
    break;
  case need_appearances_k:
    m_output_need_appearances_b= true;
    break;
  case drop_xfa_k:
    m_output_drop_xfa_b= true;
    break;
  case drop_xmp_k:
    m_output_drop_xmp_b= true;
    break;
  case keep_first_id_k:
    m_output_keep_first_id_b= true;
    break;
  case keep_final_id_k:
    m_output_keep_final_id_b= true;
    break;
  case verbose_k:
    m_verbose_reporting_b= true;
    break;
  case dont_ask_k:
    m_ask_about_warnings_b= false;
    break;
  case do_ask_k:
    m_ask_about_warnings_b= true;
    break;

  case background_k:
    if( m_operation!= keyword.filter_k ) { // warning
      System.err.println("Warning: the \"background\" output option works only in filter mode.");
      System.err.println("  This means it won't work in combination with \"cat\", \"burst\",");
      System.err.println("  \"attach_file\", etc.  To run pdftk in filter mode, simply omit");
      System.err.println("  the operation, e.g.: pdftk in.pdf output out.pdf background back.pdf");
      System.err.println("  Or, use background as an operation; this is the preferred technique:");
      System.err.println("    pdftk in.pdf background back.pdf output out.pdf");
    }
    // change state
    arg_state_p.value= ArgState.background_filename_e;
    break;

  default: // not handled here; no change to *arg_state_p
    return false;
  }

  return true;
}

};
 /*
 *
 *   This file is part of the pdftk port to java
 *
 *   Copyright (c) Marc Vinyals 2017-2018
 *
 *   The program is a java port of PDFtk, the PDF Toolkit
 *   Copyright (c) 2003-2013 Steward and Lee, LLC
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   The program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.gitlab.pdftk_java;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;

import pdftk.com.lowagie.text.pdf.PdfDictionary;
import pdftk.com.lowagie.text.pdf.PdfName;
import pdftk.com.lowagie.text.pdf.PdfReader;
import pdftk.com.lowagie.text.pdf.PdfStream;
import pdftk.com.lowagie.text.pdf.PdfString;
import pdftk.com.lowagie.text.pdf.PRStream;

class attachments {
static String
  drop_path( String ss )
{
  int loc = ss.lastIndexOf( File.separatorChar );
  if( loc != -1 && loc!= ss.length()- 1 ) {
    return ss.substring( loc+ 1 );
  }
  return ss;
}

static String
normalize_pathname( String output_pathname )
{
  if( output_pathname== "PROMPT" ) {
    output_pathname = pdftk.prompt_for_filename( "Please enter the directory where you want attachments unpacked:" );
  }
  if( output_pathname.lastIndexOf( File.separatorChar )== output_pathname.length()- 1 ) {
    return output_pathname;
  }
  else{ // add delim to end
    return output_pathname+ File.separatorChar;
  }
}

static void
unpack_file( PdfReader input_reader_p,
             PdfDictionary filespec_p,
             String output_pathname,
             boolean ask_about_warnings_b )
{
  if( filespec_p != null && filespec_p.isDictionary() ) {

    PdfName type_p= (PdfName)
      input_reader_p.getPdfObject( filespec_p.get( PdfName.TYPE ) );
    if( type_p != null && type_p.isName() && 
        ( type_p.compareTo( PdfName.FILESPEC )== 0 ||
          type_p.compareTo( PdfName.F )== 0 ) )
      {
        PdfDictionary ef_p= (PdfDictionary)
          input_reader_p.getPdfObject( filespec_p.get( PdfName.EF ) );
        if( ef_p != null && ef_p.isDictionary() ) {

          // UF introduced in PDF 1.7
          PdfString fn_p= (PdfString)
            input_reader_p.getPdfObject( filespec_p.get( PdfName.UF ) );
          if( fn_p == null ) { // try the F key
            fn_p= (PdfString)
            input_reader_p.getPdfObject( filespec_p.get( PdfName.F ) );
          }

          if( fn_p != null && fn_p.isString() ) {

            // patch by Johann Felix Soden <johfel@gmx.de>
            // patch tweaked by Sid Steward:
            // toString() doesn't ensure conversion from internal encoding (e.g., Y+diaeresis)
            String fn_str = fn_p.toUnicodeString();
            String fn= drop_path( fn_str );

            // did the user supply a path?
            if( !output_pathname.isEmpty() ) { // prepend it
              fn= output_pathname+ fn; // output_pathname has been normalized, already
            }
                      
            // assuming that F key is used to store the data, and not DOS, Mac, or Unix
            PdfStream f_p= (PdfStream)
              input_reader_p.getPdfObject( ef_p.get( PdfName.F ) );
            if( f_p != null && f_p.isStream() ) {

              try {
                byte[] bytes_p= input_reader_p.getStreamBytes( (PRStream)f_p );

                if( ask_about_warnings_b ) {
                  // test for existing file by this name
                  if ( pdftk.file_exists( fn ) ) {
                    if ( !pdftk.confirm_overwrite( fn ) ) {
                      System.out.println( "   Skipping: " + fn );
                      return; // <--- return
                    }
                  }
                }
                FileOutputStream ofs = new FileOutputStream( fn );
                ofs.write( bytes_p );
                ofs.close();
              }
              catch ( IOException e ) { // error
                System.err.println( "Error: unable to create the file:" );
                System.err.println( "   " + fn );
                System.err.println( "   Skipping.");
              }
            }
          }
        }
      }
  }
}
  
}
 /*
 *
 *   This file is part of the pdftk port to java
 *
 *   Copyright (c) Marc Vinyals 2017-2018
 *
 *   The program is a java port of PDFtk, the PDF Toolkit
 *   Copyright (c) 2003-2013 Steward and Lee, LLC
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   The program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.gitlab.pdftk_java;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.ListIterator;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

import pdftk.com.lowagie.text.pdf.PdfArray;
import pdftk.com.lowagie.text.pdf.PdfDestination;
import pdftk.com.lowagie.text.pdf.PdfDictionary;
import pdftk.com.lowagie.text.pdf.PdfIndirectReference;
import pdftk.com.lowagie.text.pdf.PdfObject;
import pdftk.com.lowagie.text.pdf.PdfName;
import pdftk.com.lowagie.text.pdf.PdfNumber;
import pdftk.com.lowagie.text.pdf.PdfReader;
import pdftk.com.lowagie.text.pdf.PdfString;
import pdftk.com.lowagie.text.pdf.PdfWriter;
import pdftk.com.lowagie.text.pdf.PRIndirectReference;

class bookmarks {

static int
GetPageNumber( PdfDictionary dict_p,
               PdfReader reader_p,
               HashMap<PdfDictionary, Integer> cache )
// take a PdfPage dictionary and return its page location in the document;
// recurse our way up the pages tree, counting pages as we go;
// dict_p may be a page or a page tree object;
// return value is zero-based;
{
  { // consult the cache
    Integer it = cache.get( dict_p );
    if ( it != null ) return it;
  }

  int ret_val= 0;

  if( dict_p != null && dict_p.contains( PdfName.PARENT ) ) {
    PdfDictionary parent_p= (PdfDictionary)
      reader_p.getPdfObject( dict_p.get( PdfName.PARENT ) );
    if( parent_p!= null && parent_p.isDictionary() ) {
      // a parent is a page tree object and will have Kids

      // recurse up the page tree
      int sum_pages= GetPageNumber( parent_p, reader_p, cache );

      PdfArray parent_kids_p= (PdfArray)
        reader_p.getPdfObject( parent_p.get( PdfName.KIDS ) );
      if( parent_kids_p!= null && parent_kids_p.isArray() ) {
        // Kids may be Pages or Page Tree Nodes

        // iterate over *dict_p's parent's kids until we run into *dict_p
        ArrayList<PRIndirectReference> kids_p= parent_kids_p.getArrayList();
        if( kids_p!= null ) {
          for( PRIndirectReference kids_ii : kids_p ) {

            PdfDictionary kid_p= (PdfDictionary)
              reader_p.getPdfObject( kids_ii );
            if( kid_p!= null && kid_p.isDictionary() ) {

              if( kid_p== dict_p ) // we have what we were looking for
                ret_val= sum_pages;

              // is kid a page, or is kid a page tree object? add count to sum;
              // PdfDictionary::isPage() and PdfDictionary::isPages()
              // are not reliable, here

              PdfName kid_type_p= (PdfName)
                reader_p.getPdfObject( kid_p.get( PdfName.TYPE ) );
              if( kid_type_p!= null && kid_type_p.isName() ) {

                if( kid_type_p.equals( PdfName.PAGE ) ) {
                  // *kid_p is a Page

                  // store page number in our cache
                  cache.put( kid_p, sum_pages );

                  //
                  sum_pages+= 1;
                }
                else if( kid_type_p.equals( PdfName.PAGES ) ) {
                  // *kid_p is a Page Tree Node

                  PdfNumber count_p= (PdfNumber)
                    reader_p.getPdfObject( kid_p.get( PdfName.COUNT ) );
                  if( count_p != null && count_p.isNumber() ) {

                    //
                    sum_pages+= count_p.intValue();
                  }
                  else { // error
                    System.err.println( "pdftk Error in GetPageNumber(): invalid count;" );
                  }
                }
                else { // error
                  System.err.println( "pdftk Error in GetPageNumber(): unexpected kid type;" );
                }
              }
              else { // error
                System.err.println( "pdftk Error in GetPageNumber(): invalid kid_type_p;" );
              }
            }
            else { // error
              System.err.println( "pdftk Error in GetPageNumber(): invalid kid_p;" );
            }
          } // done iterating over kids

        }
        else { // error
          System.err.println( "pdftk Error in GetPageNumber(): invalid kids_p;" );
        }
      }
      else { // error
        System.err.println( "pdftk Error in GetPageNumber(): invalid kids array;" );
      }
    }
    else { // error
      System.err.println( "pdftk Error in GetPageNumber(): invalid parent;" );
    }
  }
  else {
    // *dict_p has no parent; end recursion
    ret_val= 0;
    cache.put( dict_p, ret_val );
  }

  return ret_val;
}
  
static int 
ReadOutlines( ArrayList<PdfBookmark> bookmark_data,
              PdfDictionary outline_p,
              int level,
              PdfReader reader_p,              
              boolean utf8_b ) {

  int ret_val= 0;
  HashMap<PdfDictionary, Integer> cache = new HashMap<PdfDictionary, Integer>();

  while( outline_p != null ) {

    // load this with collected data, then add to vector
    PdfBookmark bookmark = new PdfBookmark();

    // the title
    PdfString title_p= (PdfString)
      reader_p.getPdfObject( outline_p.get( PdfName.TITLE ) );
    if( title_p != null && title_p.isString() ) {

      bookmark.m_title= report.OutputPdfString( title_p, utf8_b );
    }
    else { // error
      ret_val= 1;
    }

    // the level; 1-based to jive with HTML heading level concept
    bookmark.m_level= level+ 1;

    // page number, 1-based; 
    // a zero value indicates no page destination or an error
    {
      boolean fail_b= false;

      // the destination object may take be in a couple different places
      // and may take a couple, different forms

      PdfObject destination_p= null; {
        if( outline_p.contains( PdfName.DEST ) ) {
          destination_p=
            reader_p.getPdfObject( outline_p.get( PdfName.DEST ) );
        }
        else if( outline_p.contains( PdfName.A ) ) {

          PdfDictionary action_p= (PdfDictionary)
            reader_p.getPdfObject( outline_p.get( PdfName.A ) );
          if( action_p != null && action_p.isDictionary() ) {

            PdfName s_p= (PdfName)
              reader_p.getPdfObject( action_p.get( PdfName.S ) );
            if( s_p != null && s_p.isName() ) {

              if( s_p.equals( PdfName.GOTO ) ) {
                destination_p=
                  reader_p.getPdfObject( action_p.get( PdfName.D ) );
              }
              else { // immediate action is not a link in this document;
                // not an error
                // fail_b= true;
              }
            }
            else { // error
              fail_b= true;
            }
          }
          else { // error
            fail_b= true;
          }
        }
        else { // unexpected
          fail_b= true;
        }
      }

      // destination is an array
      if( destination_p != null && destination_p.isArray() ) {

        ArrayList<PRIndirectReference> array_list_p= ((PdfArray)destination_p).getArrayList();
        if( array_list_p != null && !array_list_p.isEmpty() ) {

          PdfDictionary page_p= (PdfDictionary)
            reader_p.getPdfObject( array_list_p.get(0) );

          if( page_p !=null && page_p.isDictionary() ) {
            bookmark.m_page_num= GetPageNumber(page_p, reader_p, cache)+ 1;
          }
          else { // error
            fail_b= true;
          }
        }
        else { // error
          fail_b= true;
        }
      } // TODO: named destinations handling
      else { // error
        fail_b= true;
      }

      if( fail_b ) { // output our 'null page reference' code
        bookmark.m_page_num= 0;
      }
    }

    // add bookmark to collected data
    if( 0< bookmark.m_level )
      bookmark_data.add( bookmark );

    // recurse into any children
    if( outline_p.contains( PdfName.FIRST ) ) {

      PdfDictionary child_p= (PdfDictionary)
        reader_p.getPdfObject( outline_p.get( PdfName.FIRST ) );
      if( child_p != null && child_p.isDictionary() ) {

        ret_val+= ReadOutlines( bookmark_data, child_p, level+ 1, reader_p, utf8_b );
      }
    }

    // iterate over siblings
    if( outline_p.contains( PdfName.NEXT ) ) {

      PdfDictionary sibling_p= (PdfDictionary)
        reader_p.getPdfObject( outline_p.get( PdfName.NEXT ) );
      if( sibling_p != null && sibling_p.isDictionary() ) {
        outline_p= sibling_p;
      }
      else // break out of loop
        outline_p= null;
    }
    else // break out of loop
      outline_p= null;
  }

  return ret_val;
}
  
static void
RemoveBookmarks( PdfReader reader_p,
                 PdfDictionary bookmark_p )
// call reader_p->removeUnusedObjects() afterward
{
  if( bookmark_p.contains( PdfName.FIRST ) ) { // recurse
    PdfDictionary first_p= (PdfDictionary)
      reader_p.getPdfObject( bookmark_p.get( PdfName.FIRST ) );
    RemoveBookmarks( reader_p, first_p );

    bookmark_p.remove( PdfName.FIRST );
  }

  if( bookmark_p.contains( PdfName.NEXT ) ) { // recurse
    PdfDictionary next_p= (PdfDictionary)
      reader_p.getPdfObject( bookmark_p.get( PdfName.NEXT ) );
    RemoveBookmarks( reader_p, next_p );

    bookmark_p.remove( PdfName.NEXT );
  }

  bookmark_p.remove( PdfName.PARENT );
  bookmark_p.remove( PdfName.PREV );
  bookmark_p.remove( PdfName.LAST );
}
  
static class BuildBookmarksState {
  PdfDictionary final_child_p;
  PdfIndirectReference final_child_ref_p;
  int num_bookmarks_total;
};

// Translator note: returns num_bookmarks_total
static int
BuildBookmarks(PdfReader reader_p,
               ListIterator<PdfBookmark> it,
               PdfDictionary parent_p,
               PRIndirectReference parent_ref_p,
               int parent_level,
               boolean utf8_b ) {
  int num_bookmarks_total = 0;

  PdfDictionary bookmark_prev_p= null;
  PRIndirectReference bookmark_first_ref_p= null;
  PRIndirectReference bookmark_prev_ref_p= null;
  int num_bookmarks= 0;

  PdfBookmark it_content = it.next();it.previous();
  if( parent_level+ 1< it_content.m_level ) { // first child jumping levels

    ////
    // add missing level

    ++num_bookmarks; ++num_bookmarks_total;
    PdfDictionary bookmark_p= new PdfDictionary();
    PRIndirectReference bookmark_ref_p= reader_p.getPRIndirectReference( bookmark_p );
    bookmark_first_ref_p= bookmark_ref_p;

    bookmark_p.put( PdfName.PARENT, (PdfObject)parent_ref_p );

    PdfString title_p= new PdfString( "" );
    bookmark_p.put( PdfName.TITLE, title_p );

    bookmark_prev_p= bookmark_p;
    bookmark_prev_ref_p= bookmark_ref_p;

    // recurse in loop
  }

  for( ;it.hasNext(); it.next() ) {
    it_content = it.next();it.previous();
  
    if( parent_level+ 1< it_content.m_level ) { // encountered child; recurse
      num_bookmarks_total += BuildBookmarks( reader_p,
                               it,
                               bookmark_prev_p, // parent
                               bookmark_prev_ref_p,
                               parent_level+ 1,
                               utf8_b );
      it.previous();
      continue;
    }
    else if( it_content.m_level< parent_level+ 1 ) {
      break; // no more children; add children to parent and return
    }

    ////
    // create child

    ++num_bookmarks; ++num_bookmarks_total;
    PdfDictionary bookmark_p= new PdfDictionary();
    PRIndirectReference bookmark_ref_p= reader_p.getPRIndirectReference( bookmark_p );
    if( bookmark_first_ref_p==null )
      bookmark_first_ref_p= bookmark_ref_p;

    bookmark_p.put( PdfName.PARENT, (PdfObject)parent_ref_p );

    if( bookmark_prev_ref_p!=null ) {
      bookmark_p.put( PdfName.PREV, (PdfObject)bookmark_prev_ref_p );
      bookmark_prev_p.put( PdfName.NEXT, (PdfObject)bookmark_ref_p );
    }

    if( utf8_b ) { // UTF-8 encoded input
      bookmark_p.put( PdfName.TITLE,
                       new PdfString( it_content.m_title /*,
                       itext::PdfObject::TEXT_UNICODE*/ ) );
    }
    else { // XML entities input
      String jvs = data_import.XmlStringToJcharArray( it_content.m_title );

      bookmark_p.put( PdfName.TITLE,
                       new PdfString( jvs /*,
                       itext::PdfObject::TEXT_UNICODE*/ ) );
    }

    if( 0< it_content.m_page_num ) { // destination
      PdfDestination dest_p= new PdfDestination(PdfDestination.FIT);
      PRIndirectReference page_ref_p= reader_p.getPageOrigRef( it_content.m_page_num );
      if( page_ref_p!=null ) {
        dest_p.addPage( (PdfIndirectReference)page_ref_p );
      }
      bookmark_p.put( PdfName.DEST, dest_p );
    }

    bookmark_prev_p= bookmark_p;
    bookmark_prev_ref_p= bookmark_ref_p;
  }

  if( bookmark_first_ref_p!=null && bookmark_prev_ref_p!=null ) {
    // pack these children into parent before returning
    parent_p.put( PdfName.FIRST, (PdfObject)bookmark_first_ref_p );
    parent_p.put( PdfName.LAST, (PdfObject)bookmark_prev_ref_p );
    if( parent_level== 0 ) {
      parent_p.put( PdfName.COUNT, new PdfNumber( num_bookmarks_total ) );
    }
    else {
      parent_p.put( PdfName.COUNT, new PdfNumber( num_bookmarks ) );
    }
  }

  return num_bookmarks_total;
}
  
// for use with writers, e.g. PdfCopy (esp. PdfCopy.setOutlines())
static void
BuildBookmarks(PdfWriter writer_p,
               ListIterator<PdfBookmark> it,
               PdfDictionary parent_p,
               PdfIndirectReference parent_ref_p,
               PdfDictionary after_child_p,
               PdfIndirectReference after_child_ref_p,
               int parent_level,
               int page_num_offset,
               int level_offset,
               boolean utf8_b,
               BuildBookmarksState state)
  throws IOException
{
  // when using after_child, caller must
  // call writer_p->addToBody( after_child_p, after_child_ref_p ) upon return
  PdfDictionary bookmark_prev_p= after_child_p;
  PdfIndirectReference bookmark_prev_ref_p= after_child_ref_p;

  PdfIndirectReference bookmark_first_ref_p= null;
  int num_bookmarks= 0;

  PdfBookmark it_content = it.next();it.previous();
  if( parent_level+ 1< it_content.m_level ) { // first child jumping levels

    ////
    // add missing level

    ++num_bookmarks; ++state.num_bookmarks_total;
    PdfDictionary bookmark_p= new PdfDictionary();
    PdfIndirectReference bookmark_ref_p= writer_p.getPdfIndirectReference();
    bookmark_first_ref_p= bookmark_ref_p;

    bookmark_p.put( PdfName.PARENT, (PdfObject)parent_ref_p );

    PdfString title_p= new PdfString( "" );
    bookmark_p.put( PdfName.TITLE, title_p );

    bookmark_prev_p= bookmark_p;
    bookmark_prev_ref_p= bookmark_ref_p;

    // recurse in loop
  }

  for( ;it.hasNext(); it.next() ) {
    it_content = it.next();it.previous();
  
    if( parent_level+ 1< it_content.m_level ) { // encountered child; recurse
      BuildBookmarks( writer_p,
                      it,
                      bookmark_prev_p, // parent
                      bookmark_prev_ref_p,
                      null, null,
                      parent_level+ 1,
                      page_num_offset,
                      level_offset,
                      utf8_b,
                      state );
      it.previous();
      continue;
    }
    else if( it_content.m_level< parent_level+ 1 ) {
      break; // no more children; add children to parent and return
    }

    ////
    // create child

    ++num_bookmarks; ++state.num_bookmarks_total;
    PdfDictionary bookmark_p= new PdfDictionary();
    PdfIndirectReference bookmark_ref_p= writer_p.getPdfIndirectReference();
    if( bookmark_first_ref_p == null )
      bookmark_first_ref_p= bookmark_ref_p;

    bookmark_p.put( PdfName.PARENT, (PdfObject)parent_ref_p );

    if( bookmark_prev_ref_p != null ) {
      bookmark_p.put( PdfName.PREV, (PdfObject)bookmark_prev_ref_p );
      bookmark_prev_p.put( PdfName.NEXT, (PdfObject)bookmark_ref_p );
    }

    if( utf8_b ) { // UTF-8 encoded input
      bookmark_p.put( PdfName.TITLE,
                       new PdfString( it_content.m_title /*,
                       itext::PdfObject::TEXT_UNICODE*/ ) );
    }
    else { // XML entities input
      String jvs = data_import.XmlStringToJcharArray( it_content.m_title );

      bookmark_p.put( PdfName.TITLE,
                       new PdfString( jvs /*,
                       itext::PdfObject::TEXT_UNICODE*/ ) );
    }

    if( 0< it_content.m_page_num ) { // destination
      PdfDestination dest_p= new PdfDestination(PdfDestination.FIT);
      PdfIndirectReference page_ref_p= 
        writer_p.getPageReference( it_content.m_page_num+ page_num_offset );
      if( page_ref_p != null ) {
        dest_p.addPage( (PdfIndirectReference)page_ref_p );
      }
      bookmark_p.put( PdfName.DEST, dest_p );
    }

    // finished with prev; add to body
    if( bookmark_prev_p != null )
      writer_p.addToBody( bookmark_prev_p, bookmark_prev_ref_p );

    bookmark_prev_p= bookmark_p;
    bookmark_prev_ref_p= bookmark_ref_p;
  }

  // finished with prev; add to body (unless we're appending)
  if( bookmark_prev_p != null && after_child_p == null )
    writer_p.addToBody( bookmark_prev_p, bookmark_prev_ref_p );

  if( bookmark_first_ref_p != null && bookmark_prev_ref_p != null ) {
    // pack these children into parent before returning
    if( !parent_p.contains( PdfName.FIRST ) ) // in case we're appending
      parent_p.put( PdfName.FIRST, (PdfObject)bookmark_first_ref_p );
    parent_p.put( PdfName.LAST, (PdfObject)bookmark_prev_ref_p );
    if( parent_level== 0 ) { // only for top-level "outlines" dict
      parent_p.put( PdfName.COUNT, new PdfNumber( state.num_bookmarks_total ) );
    }
    else {
      parent_p.put( PdfName.COUNT, new PdfNumber( num_bookmarks ) );
    }
  }

  // pass back to calling function so it can call BuildBookmarks serially
  state.final_child_p= bookmark_prev_p;
  state.final_child_ref_p= bookmark_prev_ref_p;
}

};
 /*
 *   This file is part of the pdftk port to java
 *
 *   Copyright (c) Marc Vinyals 2017-2018
 *
 *   The program is a java port of PDFtk, the PDF Toolkit
 *   Copyright (c) 2003-2013 Steward and Lee, LLC
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   The program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.gitlab.pdftk_java;

import java.util.ArrayList;
import java.util.Scanner;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

import org.apache.commons.lang3.StringEscapeUtils;

import pdftk.com.lowagie.text.Rectangle;
import pdftk.com.lowagie.text.pdf.PdfArray;
import pdftk.com.lowagie.text.pdf.PdfBoolean;
import pdftk.com.lowagie.text.pdf.PdfDictionary;
import pdftk.com.lowagie.text.pdf.PdfName;
import pdftk.com.lowagie.text.pdf.PdfNumber;
import pdftk.com.lowagie.text.pdf.PdfObject;
import pdftk.com.lowagie.text.pdf.PdfReader;
import pdftk.com.lowagie.text.pdf.PdfString;
import pdftk.com.lowagie.text.pdf.PdfWriter;
import pdftk.com.lowagie.text.pdf.PRIndirectReference;

class data_import {
  
static PdfData
  LoadDataFile( InputStream input_stream )
{
  PdfData pdf_data_p = new PdfData();
  Scanner ifs = new Scanner( input_stream );

  String buff= "";

  String buff_prev= "";
  int buff_prev_len= 0;

  PdfInfo info = new PdfInfo();
  boolean info_b= false;

  PdfBookmark bookmark = new PdfBookmark();
  boolean bookmark_b= false;

  boolean eof = !ifs.hasNextLine();
  
  while( !eof ) {
    eof = !ifs.hasNextLine();
    if (eof) buff = "";
    else buff = ifs.nextLine();

    if( eof ||
        buff.startsWith( PdfInfo.m_begin_mark ) ||
        buff.startsWith( PdfBookmark.m_begin_mark ) ||
        buff.startsWith( report.PdfPageLabel.m_begin_mark ) ||
        !buff_prev.isEmpty() && !buff.startsWith( buff_prev ) )
    { // start of a new record or end of file
      // pack data and reset

      if( info_b ) {
        if( info.valid() ) {
          pdf_data_p.m_info.add( info );
        }
        else { // warning
          System.err.println( "pdftk Warning: data info record not valid -- skipped; data:" );
          System.err.print( info );
        }
      }
      else if( bookmark_b ) {
        if( bookmark.valid() ) {
          pdf_data_p.m_bookmarks.add( bookmark );
        }
        else { // warning
          System.err.println( "pdftk Warning: data bookmark record not valid -- skipped; data:" );
          System.err.print( bookmark );
        }
      }

      // reset
      buff_prev= "";
      //
      info= new PdfInfo();
      info_b= false;
      //
      bookmark= new PdfBookmark();
      bookmark_b= false;
    }

    // whitespace or comment; skip
    if( buff.isEmpty() || buff.startsWith("#") ) {
      continue;
    }

    // info record
    else if( buff.startsWith( PdfInfo.m_prefix ) ) {
      buff_prev_len= PdfInfo.m_prefix.length();
      info_b= true;
      
      if( buff.startsWith( PdfInfo.m_begin_mark ) ||
          info.loadKey( buff ) ||
          info.loadValue( buff ) )
        {
          // success
        }
      else { // warning
        System.err.println( "pdftk Warning: unexpected Info case in LoadDataFile(); continuing" );
      }
    }

    // bookmark record
    else if( buff.startsWith( PdfBookmark.m_prefix ) ) {
      buff_prev_len= PdfBookmark.m_prefix.length();
      bookmark_b= true;
      
      if( buff.startsWith( PdfBookmark.m_begin_mark ) ||
          bookmark.loadTitle( buff ) ||
          bookmark.loadLevel( buff ) ||
          bookmark.loadPageNum( buff ) )
      {
        // success
      }
      else { // warning
        System.err.println( "pdftk Warning: unexpected Bookmark case in LoadDataFile(); continuing" );
      }
    }
    
    // page label record
    else if( buff.startsWith( report.PdfPageLabel.m_prefix ) ) {
      buff_prev_len= 0;
      // TODO
    }
    
    // page media record
    else if( buff.startsWith( report.PdfPageMedia.m_prefix ) ) {
      buff_prev_len= 0;
      // TODO
    }

    // pdf id
    else if( buff.startsWith( PdfData.m_prefix ) ) {
      buff_prev_len= 0; // not a record
      
      if( pdf_data_p.loadID0( buff ) ||
          pdf_data_p.loadID1( buff ) )
        {
          // success
        }
      else { // warning
        System.err.println( "pdftk Warning: unexpected PdfID case in LoadDataFile(); continuing" );
      }
    }

    // number of pages
    else if( pdf_data_p.loadNumPages( buff ) ) {
      buff_prev_len= 0; // not a record
    }

    else { // warning
      System.err.println( "pdftk Warning: unexpected case 1 in LoadDataFile(); continuing" );
    }
      
    buff_prev = buff.substring( 0, buff_prev_len );
  }

  if( buff_prev_len!= 0 ) { // warning; some incomplete record hasn't been packed
    System.err.println( "pdftk Warning in LoadDataFile(): incomplete record;" );
  }

  return pdf_data_p;
}
  
static boolean
UpdateInfo( PdfReader reader_p,
            InputStream ifs,
            boolean utf8_b ) {
  boolean ret_val_b= true;

  PdfData pdf_data = LoadDataFile( ifs );
  if( pdf_data != null ) {
    
    { // trailer data
      PdfDictionary trailer_p= reader_p.getTrailer();
      if( trailer_p != null && trailer_p.isDictionary() ) {

        // bookmarks
        if( !pdf_data.m_bookmarks.isEmpty() ) {
          
          // build bookmarks
          PdfDictionary outlines_p= new PdfDictionary( PdfName.OUTLINES );
          if( outlines_p != null ) {
            PRIndirectReference outlines_ref_p= reader_p.getPRIndirectReference( outlines_p );

            int num_bookmarks_total = bookmarks.BuildBookmarks( reader_p,
                            pdf_data.m_bookmarks.listIterator(),
                            outlines_p,
                            outlines_ref_p,
                            0,
                            utf8_b );
            
            PdfDictionary root_p= (PdfDictionary)
              reader_p.getPdfObject( trailer_p.get( PdfName.ROOT ) );
            if( root_p.contains( PdfName.OUTLINES ) ) {
              // erase old bookmarks
              PdfDictionary old_outlines_p= (PdfDictionary)
                reader_p.getPdfObject( root_p.get( PdfName.OUTLINES ) );
              bookmarks.RemoveBookmarks( reader_p, old_outlines_p );
            }
            // insert into document
            root_p.put( PdfName.OUTLINES, (PdfObject)outlines_ref_p );
          }
        }

        // metadata
        if( !pdf_data.m_info.isEmpty() ) {
          PdfDictionary info_p= (PdfDictionary)
            reader_p.getPdfObject( trailer_p.get( PdfName.INFO ) );
          if( info_p != null && info_p.isDictionary() ) {

            for( PdfInfo it : pdf_data.m_info ) {
              if( it.m_value.isEmpty() ) {
                info_p.remove( new PdfName( it.m_key ) );
              }
              else {
                if( utf8_b ) { // UTF-8 encoded input
                  info_p.put( new PdfName( it.m_key ) ,
                               // patch by Quentin Godfroy <godfroy@clipper.ens.fr>, Chris Adams <cadams@salk.edu>
                               new PdfString( it.m_value ) );
                }
                else { // XML entities input
                  String jvs = XmlStringToJcharArray( it.m_value );
                  info_p.put( new PdfName( it.m_key ),
                               new PdfString( jvs ) );
                }
              }
            }
          }
          else { // error
            System.err.println( "pdftk Error in UpdateInfo(): no Info dictionary found;" );
            ret_val_b= false;
          }
        }
      }
      else { // error
        System.err.println( "pdftk Error in UpdateInfo(): no document trailer found;" );
        ret_val_b= false;
      }
    }

  }
  else { // error
    System.err.println( "pdftk Error in UpdateInfo(): LoadDataFile() failure;" );
  }
  // cerr << pdf_data; // debug

  return ret_val_b;
}

//////
////
// created for data import, maybe useful for export, too

//
static class PdfInfo {
  static final String m_prefix= "Info";
  static final String m_begin_mark= "InfoBegin";
  static final String m_key_label= "InfoKey:";
  static final String m_value_label= "InfoValue:";

  String m_key = null;
  String m_value = null;

  boolean valid() { return( m_key!= null && m_value!= null ); }

  public String toString() {
    return m_begin_mark + System.lineSeparator() +
      m_key_label + " " + m_key + System.lineSeparator() +
      m_value_label + " " + m_value + System.lineSeparator();
  }
  boolean loadKey ( String buff ) {
    LoadableString loader = new LoadableString( m_key );
    boolean success = loader.LoadString( buff, m_key_label );
    m_key = loader.ss;
    return success;
  }
  boolean loadValue ( String buff ) {
    LoadableString loader = new LoadableString( m_value );
    boolean success = loader.LoadString( buff, m_value_label );
    m_value = loader.ss;
    return success;
  }
};

static class PdfData {
  ArrayList<PdfInfo> m_info = new ArrayList<PdfInfo>();
  ArrayList<PdfBookmark> m_bookmarks = new ArrayList<PdfBookmark>();

  static final String m_prefix= "PdfID";
  static final String m_id_0_label= "PdfID0:";
  static final String m_id_1_label= "PdfID1:";
  static final String m_num_pages_label= "NumberOfPages:";
  
  int m_num_pages = -1;

  String m_id_0 = null;
  String m_id_1 = null;

  public String toString() {
    StringBuilder ss = new StringBuilder();
    for (PdfInfo vit : m_info) {
      ss.append(vit);
    }
    ss.append("PdfID0: " + m_id_0 + System.lineSeparator() +
              "PdfID1: " + m_id_1 + System.lineSeparator() +
              "NumberOfPages: " + m_num_pages + System.lineSeparator());
    for (PdfBookmark vit : m_bookmarks) {
      ss.append(vit);
    }
    return ss.toString();
  }

  boolean loadNumPages ( String buff ) {
    LoadableInt loader = new LoadableInt( m_num_pages );
    boolean success = loader.LoadInt( buff, m_num_pages_label );
    m_num_pages = loader.ii;
    return success;
  }
  boolean loadID0 ( String buff ) {
    LoadableString loader = new LoadableString( m_id_0 );
    boolean success = loader.LoadString( buff, m_id_0_label );
    m_id_0 = loader.ss;
    return success;
  }
  boolean loadID1 ( String buff ) {
    LoadableString loader = new LoadableString( m_id_1 );
    boolean success = loader.LoadString( buff, m_id_1_label );
    m_id_1 = loader.ss;
    return success;
  }
};

static String
XmlStringToJcharArray( String jvs )
{
  return StringEscapeUtils.unescapeXml( jvs );
}

};
 /*
 *
 *   This file is part of the pdftk port to java
 *
 *   Copyright (c) Marc Vinyals 2017-2018
 *
 *   The program is a java port of PDFtk, the PDF Toolkit
 *   Copyright (c) 2003-2013 Steward and Lee, LLC
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   The program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.gitlab.pdftk_java;

import java.util.ArrayList;
import java.nio.charset.StandardCharsets;

/*
  password character mapping by Acrobat (pre-1.7 PDF)

  * characters in PDFDocEncoding use PDFDocEncoding
  * some PDFDocEncoding characters are not accepted as input into Acrobat/Reader --
      this is consistent with the next rule:
  * unicode 0x200 and up: Acrobat/Reader prohibits input
  * some chars below 0x200 are mapped to . (period)
  * some chars below 0x200 are mapped to non-accented ASCII char
  * many points are mapped to Windows CP-1250

  These were tested on Windows 7 using Acrobat 7.  From what I've read, Adobe's mapping
  of characters that aren't in PDFDocEncoding is platform dependent.  So this map should
  only be used for mapping PDF passwords for decryption.  When encrypting, it would be
  best to enforce a limited set of characters for the purpose of platform independence.

*/

class passwords {

// unicode 0x100 - 0x1FF
final static int[] unicode_latin_extended_windows_map=
  {
    // latin extended a
    'A',  //U+0100      Latin Capital Letter A with macron
    'a',  //U+0101      Latin Small Letter A with macron
    0xC3, //U+0102      Latin Capital Letter A with breve
    0xC4, //U+0103      Latin Small Letter A with breve
    0xA5, //U+0104      Latin Capital Letter A with ogonek
    0xB9, //U+0105      Latin Small Letter A with ogonek
    0xC6, //U+0106      Latin Capital Letter C with acute
    0xE6, //U+0107      Latin Small Letter C with acute
    '.',  //U+0108      Latin Capital Letter C with circumflex
    '.',  //U+0109      Latin Small Letter C with circumflex
    '.',  //U+010A      Latin Capital Letter C with dot above
    '.',  //U+010B      Latin Small Letter C with dot above
    0xC8, //U+010C      Latin Capital Letter C with caron
    0xE8, //U+010D      Latin Small Letter C with caron
    0xCF, //U+010E      Latin Capital Letter D with caron
    0xEF, //U+010F      Latin Small Letter D with caron
    0xD0, //U+0110      Latin Capital Letter D with stroke
    0xF0, //U+0111      Latin Small Letter D with stroke
    'E',  //U+0112      Latin Capital Letter E with macron
    'e',  //U+0113      Latin Small Letter E with macron
    '.',  //U+0114      Latin Capital Letter E with breve
    '.',  //U+0115      Latin Small Letter E with breve
    'E',  //U+0116      Latin Capital Letter E with dot above
    'e',  //U+0117      Latin Small Letter E with dot above
    0xCA, //U+0118      Latin Capital Letter E with ogonek
    0xEA, //U+0119      Latin Small Letter E with ogonek
    0xCC, //U+011A      Latin Capital Letter E with caron
    0xEC, //U+011B      Latin Small Letter E with caron
    '.',  //U+011C      Latin Capital Letter G with circumflex
    '.',  //U+011D      Latin Small Letter G with circumflex
    'G',  //U+011E      Latin Capital Letter G with breve
    'g',  //U+011F      Latin Small Letter G with breve
    '.',  //U+0120      Latin Capital Letter G with dot above
    '.',  //U+0121      Latin Small Letter G with dot above
    'G',  //U+0122      Latin Capital Letter G with cedilla
    'g',  //U+0123      Latin Small Letter G with cedilla
    '.',  //U+0124      Latin Capital Letter H with circumflex
    '.',  //U+0125      Latin Small Letter H with circumflex
    '.',  //U+0126      Latin Capital Letter H with stroke
    '.',  //U+0127      Latin Small Letter H with stroke
    '.',  //U+0128      Latin Capital Letter I with tilde
    '.',  //U+0129      Latin Small Letter I with tilde
    'I',  //U+012A      Latin Capital Letter I with macron
    'i',  //U+012B      Latin Small Letter I with macron
    '.',  //U+012C      Latin Capital Letter I with breve
    '.',  //U+012D      Latin Small Letter I with breve
    'I',  //U+012E      Latin Capital Letter I with ogonek
    'i',  //U+012F      Latin Small Letter I with ogonek
    'I',  //U+0130      Latin Capital Letter I with dot above
    'i',  //U+0131      Latin Small Letter dotless I
    '.',  //U+0132      Latin Capital Ligature IJ
    '.',  //U+0133      Latin Small Ligature IJ
    '.',  //U+0134      Latin Capital Letter J with circumflex
    '.',  //U+0135      Latin Small Letter J with circumflex
    'K',  //U+0136      Latin Capital Letter K with cedilla
    'k',  //U+0137      Latin Small Letter K with cedilla
    '.',  //U+0138      Latin Small Letter Kra
    0xC5, //U+0139      Latin Capital Letter L with acute
    0xE5, //U+013A      Latin Small Letter L with acute
    'L',  //U+013B      Latin Capital Letter L with cedilla
    'l',  //U+013C      Latin Small Letter L with cedilla
    0xBC, //U+013D      Latin Capital Letter L with caron
    0xBE, //U+013E      Latin Small Letter L with caron
    '.',  //U+013F      Latin Capital Letter L with middle dot
    '.',  //U+0140      Latin Small Letter L with middle dot
    0xA3, //U+0141      Latin Capital Letter L with stroke
    0xB3, //U+0142      Latin Small Letter L with stroke
    0xD1, //U+0143      Latin Capital Letter N with acute
    0xF1, //U+0144      Latin Small Letter N with acute
    'N',  //U+0145      Latin Capital Letter N with cedilla
    'n',  //U+0146      Latin Small Letter N with cedilla
    0xD2, //U+0147      Latin Capital Letter N with caron
    0xF2, //U+0148      Latin Small Letter N with caron
    '.',  //U+0149      Latin Small Letter N preceded by apostrophe[1]
    '.',  //U+014A      Latin Capital Letter Eng
    '.',  //U+014B      Latin Small Letter Eng
    'O',  //U+014C      Latin Capital Letter O with macron
    'o',  //U+014D      Latin Small Letter O with macron
    '.',  //U+014E      Latin Capital Letter O with breve
    '.',  //U+014F      Latin Small Letter O with breve
    0xD5, //U+0150      Latin Capital Letter O with double acute
    0xF5, //U+0151      Latin Small Letter O with double acute
    0226, //U+0152      Latin Capital Ligature OE (mapped to PDFDocEncoding)
    0234, //U+0153      Latin Small Ligature OE (mapped to PDFDocEncoding)
    0xC0, //U+0154      Latin Capital Letter R with acute
    0xE0, //U+0155      Latin Small Letter R with acute
    'R',  //U+0156      Latin Capital Letter R with cedilla
    'r',  //U+0157      Latin Small Letter R with cedilla
    0xD8, //U+0158      Latin Capital Letter R with caron
    0xF8, //U+0159      Latin Small Letter R with caron
    0x8C, //U+015A      Latin Capital Letter S with acute
    0x9C, //U+015B      Latin Small Letter S with acute
    '.',  //U+015C      Latin Capital Letter S with circumflex
    '.',  //U+015D      Latin Small Letter S with circumflex
    0xAA, //U+015E      Latin Capital Letter S with cedilla
    0xBA, //U+015F      Latin Small Letter S with cedilla
    0x8A, //U+0160      Latin Capital Letter S with caron
    0x9A, //U+0161      Latin Small Letter S with caron
    0xDE, //U+0162      Latin Capital Letter T with cedilla
    0xFE, //U+0163      Latin Small Letter T with cedilla
    0x8D, //U+0164      Latin Capital Letter T with caron
    0x9D, //U+0165      Latin Small Letter T with caron
    'T',  //U+0166      Latin Capital Letter T with stroke
    't',  //U+0167      Latin Small Letter T with stroke
    '.',  //U+0168      Latin Capital Letter U with tilde
    '.',  //U+0169      Latin Small Letter U with tilde
    'U',  //U+016A      Latin Capital Letter U with macron
    'u',  //U+016B      Latin Small Letter U with macron
    '.',  //U+016C      Latin Capital Letter U with breve
    '.',  //U+016D      Latin Small Letter U with breve
    0xD9, //U+016E      Latin Capital Letter U with ring above
    0xF9, //U+016F      Latin Small Letter U with ring above
    0xDB, //U+0170      Latin Capital Letter U with double acute
    0xFB, //U+0171      Latin Small Letter U with double acute
    'U',  //U+0172      Latin Capital Letter U with ogonek
    'u',  //U+0173      Latin Small Letter U with ogonek
    '.',  //U+0174      Latin Capital Letter W with circumflex
    '.',  //U+0175      Latin Small Letter W with circumflex
    '.',  //U+0176      Latin Capital Letter Y with circumflex
    '.',  //U+0177      Latin Small Letter Y with circumflex
    0230, //U+0178      Latin Capital Letter Y with diaeresis (mapped to PDFDocEncoding)
    0x8F, //U+0179      Latin Capital Letter Z with acute
    0x9F, //U+017A      Latin Small Letter Z with acute
    0xAF, //U+017B      Latin Capital Letter Z with dot above
    0xBF, //U+017C      Latin Small Letter Z with dot above
    0231, //U+017D      Latin Capital Letter Z with caron (mapped to PDFDocEncoding)
    0236, //U+017E      Latin Small Letter Z with caron (mapped to PDFDocEncoding)
    '.',  //U+017F      Latin Small Letter long S

    // portion of latin extended b
    'b',  //U+0180     &#384;   Latin Small Letter B with stroke
    '.',  //U+0181     &#385;   Latin Capital Letter B with hook
    '.',  //U+0182     &#386;   Latin Capital Letter B with top bar
    '.',  //U+0183     &#387;   Latin Small Letter B with top bar
    '.',  //U+0184     &#388;   Latin Capital Letter Tone Six
    '.',  //U+0185     &#389;   Latin Small Letter Tone Six
    '.',  //U+0186     &#390;   Latin Capital Letter Open O
    '.',  //U+0187     &#391;   Latin Capital Letter C with hook
    '.',  //U+0188     &#392;   Latin Small Letter C with hook
    0xD0,  //U+0189     &#393;   Latin Capital Letter African D
    '.',  //U+018A     &#394;   Latin Capital Letter D with hook
    '.',  //U+018B     &#395;   Latin Capital Letter D with top bar
    '.',  //U+018C     &#396;   Latin Small Letter D with top bar
    '.',  //U+018D     &#397;   Latin Small Letter Turned Delta
    '.',  //U+018E     &#398;   Latin Capital Letter Reversed E
    '.',  //U+018F     &#399;   Latin Capital Letter Schwa
    '.',  //U+0190     &#400;   Latin Capital Letter Open E
    0x83,  //U+0191     &#401;   Latin Capital Letter F with hook (from win cp-1252)(maybe)
    0x83,  //U+0192     &#402;   Latin Small Letter F with hook (from win cp-1252)(maybe)
    '.',  //U+0193     &#403;   Latin Capital Letter G with hook
    '.',  //U+0194     &#404;   Latin Capital Letter Gamma
    '.',  //U+0195     &#405;   Latin Small Letter HV
    '.',  //U+0196     &#406;   Latin Capital Letter Iota
    'I',  //U+0197     &#407;   Latin Capital Letter I with stroke
    '.',  //U+0198     &#408;   Latin Capital Letter K with hook
    '.',  //U+0199     &#409;   Latin Small Letter K with hook
    'l',  //U+019A     &#410;   Latin Small Letter L with bar
    '.',  //U+019B     &#411;   Latin Small Letter Lambda with stroke
    '.',  //U+019C     &#412;   Latin Capital Letter Turned M
    '.',  //U+019D     &#413;   Latin Capital Letter N with left hook
    '.',  //U+019E     &#414;   Latin Small Letter N with long right leg
    'O',  //U+019F     &#415;   Latin Capital Letter O with middle tilde
    'O',  //U+01A0     &#416;   Latin Capital Letter O with horn
    'o',  //U+01A1     &#417;   Latin Small Letter O with horn
    '.',  //U+01A2     &#418;   Latin Capital Letter OI (= Latin Capital Letter Gha)
    '.',  //U+01A3     &#419;   Latin Small Letter OI (= Latin Small Letter Gha)
    '.',  //U+01A4     &#420;   Latin Capital Letter P with hook
    '.',  //U+01A5     &#421;   Latin Small Letter P with hook
    '.',  //U+01A6     &#422;   Latin Letter YR
    '.',  //U+01A7     &#423;   Latin Capital Letter Tone Two
    '.',  //U+01A8     &#424;   Latin Small Letter Tone Two
    '.',  //U+01A9     &#425;   Latin Capital Letter Esh
    '.',  //U+01AA     &#426;   Latin Letter Reversed Esh Loop
    't',  //U+01AB     &#427;   Latin Small Letter T with palatal hook
    '.',  //U+01AC     &#428;   Latin Capital Letter T with hook
    '.',  //U+01AD     &#429;   Latin Small Letter T with hook
    'T',  //U+01AE     &#430;   Latin Capital Letter T with retroflex hook
    'U',  //U+01AF     &#431;   Latin Capital Letter U with horn
    'u',  //U+01B0     &#432;   Latin Small Letter U with horn
    '.',  //U+01B1     &#433;   Latin Capital Letter Upsilon
    '.',  //U+01B2     &#434;   Latin Capital Letter V with hook
    '.',  //U+01B3     &#435;   Latin Capital Letter Y with hook
    '.',  //U+01B4     &#436;   Latin Small Letter Y with hook
    '.',  //U+01B5     &#437;   Latin Capital Letter Z with stroke
    '.',  //U+01B6     &#438;   Latin Small Letter Z with stroke
    '.',  //U+01B7     &#439;   Latin Capital Letter Ezh
    '.',  //U+01B8     &#440;   Latin Capital Letter Ezh reversed
    '.',  //U+01B9     &#441;   Latin Small Letter Ezh reversed
    '.',  //U+01BA     &#442;   Latin Small Letter Ezh with tail
    '.',  //U+01BB     &#443;   Latin Letter Two with stroke
    '.',  //U+01BC     &#444;   Latin Capital Letter Tone Five
    '.',  //U+01BD     &#445;   Latin Small Letter Tone Five
    '.',  //U+01BE     &#446;   Latin Letter Inverted Glottal Stop with stroke
    '.',  //U+01BF     &#447;   Latin Letter Wynn
    '|',  //U+01C0     &#448;   Latin Letter Dental Click

    // I couldn't figure this one out
    '.',  //U+01C1     &#449;   Latin Letter Lateral Click

    '.',  //U+01C2     &#450;   Latin Letter Alveolar Click
    '!',  //U+01C3     &#451;   Latin Letter Retroflex Click
    '.',  //U+01C4     &#452;   Latin Capital Letter DZ with caron
    '.',  //U+01C5     &#453;   Latin Capital Letter D with Small Letter Z with caron
    '.',  //U+01C6     &#454;   Latin Small Letter DZ with caron
    '.',  //U+01C7     &#455;   Latin Capital Letter LJ
    '.',  //U+01C8     &#456;   Latin Capital Letter L with Small Letter J
    '.',  //U+01C9     &#457;   Latin Small Letter LJ
    '.',  //U+01CA     &#458;   Latin Capital Letter NJ
    '.',  //U+01CB     &#459;   Latin Capital Letter N with Small Letter J
    '.',  //U+01CC     &#460;   Latin Small Letter NJ
    '.',  //U+01CD     &#461;   Latin Capital Letter A with caron
    '.',  //U+01CE     &#462;   Latin Small Letter A with caron
    '.',  //U+01CF     &#463;   Latin Capital Letter I with caron
    '.',  //U+01D0     &#464;   Latin Small Letter I with caron
    '.',  //U+01D1     &#465;   Latin Capital Letter O with caron
    '.',  //U+01D2     &#466;   Latin Small Letter O with caron
    '.',  //U+01D3     &#467;   Latin Capital Letter U with caron
    '.',  //U+01D4     &#468;   Latin Small Letter U with caron
    '.',  //U+01D5     &#469;   Latin Capital Letter U with diaeresis and macron
    '.',  //U+01D6     &#470;   Latin Small Letter U with diaeresis and macron
    '.',  //U+01D7     &#471;   Latin Capital Letter U with diaeresis and acute
    '.',  //U+01D8     &#472;   Latin Small Letter U with diaeresis and acute
    '.',  //U+01D9     &#473;   Latin Capital Letter U with diaeresis and caron
    '.',  //U+01DA     &#474;   Latin Small Letter U with diaeresis and caron
    '.',  //U+01DB     &#475;   Latin Capital Letter U with diaeresis and grave
    '.',  //U+01DC     &#476;   Latin Small Letter U with diaeresis and grave
    '.',  //U+01DD     &#477;   Latin Small Letter Turned E
    'A',  //U+01DE     &#478;   Latin Capital Letter A with diaeresis and macron
    'a',  //U+01DF     &#479;   Latin Small Letter A with diaeresis and macron
    '.',  //U+01E0     &#480;   Latin Capital Letter A with dot above and macron
    '.',  //U+01E1     &#481;   Latin Small Letter A with dot above and macron
    '.',  //U+01E2     &#482;   Latin Capital Letter  with macron
    '.',  //U+01E3     &#483;   Latin Small Letter  with macron
    'G',  //U+01E4     &#484;   Latin Capital Letter G with stroke
    'g',  //U+01E5     &#485;   Latin Small Letter G with stroke
    '.',  //U+01E6     &#486;   Latin Capital Letter G with caron
    '.',  //U+01E7     &#487;   Latin Small Letter G with caron
    '.',  //U+01E8     &#488;   Latin Capital Letter K with caron
    '.',  //U+01E9     &#489;   Latin Small Letter K with caron
    '.',  //U+01EA     &#490;   Latin Capital Letter O with ogonek
    '.',  //U+01EB     &#491;   Latin Small Letter O with ogonek
    'O',  //U+01EC     &#492;   Latin Capital Letter O with ogonek and macron
    'o',  //U+01ED     &#493;   Latin Small Letter O with ogonek and macron
    '.',  //U+01EE     &#494;   Latin Capital Letter Ezh with caron
    '.',  //U+01EF     &#495;   Latin Small Letter Ezh with caron
    '.',  //U+01F0     &#496;   Latin Small Letter J with caron
    '.',  //U+01F1     &#497;   Latin Capital Letter DZ
    '.',  //U+01F2     &#498;   Latin Capital Letter D with Small Letter Z
    '.',  //U+01F3     &#499;   Latin Small Letter DZ
    '.',  //U+01F4     &#500;   Latin Capital Letter G with acute
    '.',  //U+01F5     &#501;   Latin Small Letter G with acute
    '.',  //U+01F6     &#502;   Latin Capital Letter Hwair
    '.',  //U+01F7     &#503;   Latin Capital Letter Wynn
    '.',  //U+01F8     &#504;   Latin Capital Letter N with grave
    '.',  //U+01F9     &#505;   Latin Small Letter N with grave
    '.',  //U+01FA     &#506;   Latin Capital Letter A with ring above and acute
    '.',  //U+01FB     &#507;   Latin Small Letter A with ring above and acute
    '.',  //U+01FC     &#508;   Latin Capital Letter  with acute
    '.',  //U+01FD     &#509;   Latin Small Letter  with acute
    '.',  //U+01FE     &#510;   Latin Capital Letter O with stroke and acute
    '.'   //U+01FF     &#511;   Latin Small Letter O with stroke and acute
  };

/*
  Older PDF security passwords use PDFDocEncoding, which is a modified iso-8859-1.
  Newer PDF security (version 5) passwords use unicode.
  This function is just for older PDF security passwords, since pdftk doesn't yet
  handle version 5 security.
  In practice, Acrobat/Reader accepts password characters outside of PDFDocEncoding.

  Returns -1 if input ss uses invalid characters
  otherwise returns the number of bytes copied to bb.
  If bb is null, then returns the number of bytes needed to copy ss.

  If we are encrypting, allow only the most conservative set of input characters
  in order to maximize platform independence.
  If we are decrypting, allow as many input characters as possible.

  TRANSLATOR NOTES:
  Returns a byte array; null if input uses invalid characters.
*/
static byte[] utf8_password_to_pdfdoc( String ss_, boolean encrypt_b ) {

  byte[] ss = ss_.getBytes(StandardCharsets.UTF_8);
  int ss_size = ss.length;
  ArrayList<Byte> bb = new ArrayList<Byte>(ss_size);

  for( int ii= 0; ii< ss_size; ) {

    // decode UTF-8
    int data= 0;
    //
    // our greatest valid point is 0x2122, so testing out to three bytes is enough
    if( (ss[ii] & 0x80) == 0 ) 
      { // single byte
        data= ss[ii];
        ii++;
      }
    else if( (ss[ii] & 0xE0) == 0xC0 && 
             ii+ 1< ss_size && (ss[ii+ 1] & 0xC0)== 0x80 ) 
      { // two-byte
        data= (ss[ii] & 0x1f);
        data= data<< 6;
        data= data+ (ss[ii+ 1] & 0x3f);
        ii+= 2;
      }
    else if( (ss[ii] & 0xF0) == 0xE0 && 
             ii+ 1< ss_size && (ss[ii+ 1] & 0xC0)== 0x80 && 
             ii+ 2< ss_size && (ss[ii+ 2] & 0xC0)== 0x80 ) 
      { // three-byte
        data= (ss[ii] & 0x0f);
        data= data<< 6;
        data= data+ (ss[ii+ 1] & 0x3f);
        data= data<< 6;
        data= data+ (ss[ii+ 2] & 0x3f);
        ii+= 3;
      }
    else { // something else: out of range
      return null;
    }

    if( 0x20<= data && data< 0x7f || 0xa0<= data && data<= 0xff ) {
      // data point good
    }
    else { // convert some unicode points to PDFDocEncoding

      switch( data ) {
      case 0x0152: // OE ligature
        data= 0226;
        break;
      case 0x0153: // oe ligature
        data= 0234;
        break;
      case 0x0160: // Scaron
        data= 0227;
        break;
      case 0x017E: // zcaron
        data= 0236;
        break;
      case 0x0178: // Ydieresis
        data= 0230;
        break;
      case 0x017D: // Zcaron
        data= 0231;
        break;
      case 0x0192: // florin
        data= 0206;
        break;
      case 0x0161: // scaron
        data= 0235;
        break;
      default:
        if( encrypt_b ) { // data point out of bounds
          return null;
        }
        else {
          // password is being used to decrypt, so test for more mappings to PDFDocEncoding;

          if( 0x100<= data && data<= 0x1FF ) {
            // use our latin extended windows map; these points are accepted by Acrobat/Reader
            // but are mapped to single-byte alternatives in a platform-dependent way
            data= unicode_latin_extended_windows_map[ data- 0x100 ];
          }
          else {
            // in practice, Acorbat/Reader won't allow these characters to be input for V4 security and earlier;
            switch( data ) {
            case 0x20AC: // Euro
              data= 0240;
              break;
            case 0x2022: // bullet
              data= 0200;
              break;
            case 0x2020: // dagger
              data= 0201;
              break;
            case 0x2021: // daggerdbl
              data= 0202;
              break;
            case 0x2026: // ellipsis
              data= 0203;
              break;
            case 0x02C6: // circumflex
              data= 0032;
              break;
            case 0x2014 : // emdash
              data= 0204;
              break;
            case 0x2013: // endash
              data= 0205;
              break;
            case 0x2039: // guilsinglleft
              data= 0210;
              break;
            case 0x203A: // guilsinglright
              data= 0211;
              break;
            case 0x2030: // perthousand
              data= 0213;
              break;
            case 0x201E: // quotedblbase
              data= 0214;
              break;
            case 0x201C: // quotedblleft
              data= 0215;
              break;
            case 0x201D: // quotedblright
              data= 0216;
              break;
            case 0x2018: // quoteleft
              data= 0217;
              break;
            case 0x2019: // quoteright
              data= 0220;
              break;
            case 0x201A: // quotesinglebase
              data= 0221;
              break;
            case 0x02DC: // tilde
              data= 0037;
              break;
            case 0x2122: // trademark
              data= 0222;
              break;
            default:

              return null; // data point is still out of bounds
            }
          }
        }
      }
    }

    bb.add((byte)data);
  }

  byte[] out = new byte[bb.size()];
  for (int i=0; i<out.length; ++i) out[i]=bb.get(i);
  return out;
}

};
 /*
 *
 *   This file is part of the pdftk port to java
 *
 *   Copyright (c) Marc Vinyals 2017-2018
 *
 *   The program is a java port of PDFtk, the PDF Toolkit
 *   Copyright (c) 2003-2013 Steward and Lee, LLC
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   The program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.gitlab.pdftk_java;

import java.io.BufferedWriter;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.PrintStream;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;

public class pdftk {

/* TODO: should read from compiler */
static final String PDFTK_VER = "3.0.2";
static final boolean ASK_ABOUT_WARNINGS = false;

static String
prompt_for_password( String pass_name, 
                     String pass_app) {
  System.out.println( "Please enter the " + pass_name + " password to use on " + pass_app + "." );
  System.out.println( "   It can be empty, or have a maximum of 32 characters:" );
  Scanner s = new Scanner(System.in);
  String password= s.nextLine();
  if( 32< password.length() ) { // too long; trim
    System.out.println( "The password you entered was over 32 characters long," );
    System.out.println( "   so I am dropping: \"" + password.substring( 32 ) + "\"" );
    password= password.substring( 0, 32 );
  }
  return password;
}

static String
prompt_for_filename( String message ) {
  // input could be multibyte, so try working
  // with bytes instead of formatted input features

  System.out.println( message );

  Scanner s = new Scanner(System.in);
  return s.nextLine();
}

static boolean
confirm_overwrite( String filename ) {
  System.out.println("Warning: the output file: " + filename + " already exists.  Overwrite? (y/n)");
  Scanner s = new Scanner(System.in);
  String buff= s.nextLine();
  return buff.startsWith("y") || buff.startsWith("Y");
}

static boolean
file_exists( String filename ) {
  try {
    FileInputStream fp= new FileInputStream( filename );
    return true;
  }
  catch ( FileNotFoundException e ) {
    return false;
  }
}
  
static OutputStream
get_output_stream( String output_filename,
                   boolean ask_about_warnings_b ) {
  OutputStream os_p= null;

  if( output_filename.isEmpty() || output_filename.equals("PROMPT") ) {
    output_filename = prompt_for_filename( "Please enter a name for the output:" );
    // recurse; try again
    return get_output_stream( output_filename,
                              ask_about_warnings_b );
  }
  if( output_filename.equals("-") ) { // stdout
    os_p= System.out;
  }
  else {
    if( ask_about_warnings_b ) {
      // test for existing file by this name
      boolean output_exists_b= false;
      if( file_exists( output_filename ) ) {
        if( !confirm_overwrite( output_filename ) ) {
          // recurse; try again
          return get_output_stream( "PROMPT",
                                    ask_about_warnings_b );
        }
      }
    }

    // attempt to open the stream
    try {
      os_p= new FileOutputStream( output_filename );
    }
    catch( IOException ioe_p ) { // file open error
      System.err.println("Error: Failed to open output file: ");
      System.err.println("   " + output_filename);
      System.err.println("   No output created.");
      os_p= null;
    }
  }

  return os_p;
}

static PrintStream
get_print_stream(String m_output_filename, boolean m_output_utf8_b )
throws IOException
{
  Charset encoding = ( m_output_utf8_b ? StandardCharsets.UTF_8 : StandardCharsets.US_ASCII );
  if(m_output_filename.isEmpty() || m_output_filename.equals("-")) {
    return new PrintStream(System.out, true, encoding.name() );
  }
  else {
    return new PrintStream(m_output_filename, encoding.name() );
  }
}
  
public static void main(String[] args) {
  boolean help_b= false;
  boolean version_b= false;
  boolean synopsis_b= ( args.length == 0 );
  ErrorCode ret_val= ErrorCode.NO_ERROR; // default: no error

  for( String argv : args) {
    version_b = version_b ||
      (argv.equals("--version")) ||
      (argv.equals("-version"));
    help_b = help_b ||
      (argv.equals("--help")) ||
      (argv.equals("-help")) ||
      (argv.equals("-h"));
  }

  if( help_b ) {
    describe_full();
  }
  else if( version_b ) {
    describe_header();
  }
  else if( synopsis_b ) {
    describe_synopsis();
  }
  else {
    try {
      TK_Session tk_session = new TK_Session( args );

      tk_session.dump_session_data();

      if( tk_session.is_valid() ) {
        // create_output() prints necessary error messages
        ret_val= tk_session.create_output();
      }
      else { // error
        System.err.println("Done.  Input errors, so no output created.");
        ret_val= ErrorCode.ERROR;
      }
    }
    // per https://bugs.launchpad.net/ubuntu/+source/pdftk/+bug/544636
    catch( java.lang.ClassCastException c_p ) {
      String message= c_p.getMessage();
      if( message.indexOf("com.lowagie.text.pdf.PdfDictionary")>= 0 &&
          message.indexOf("com.lowagie.text.pdf.PRIndirectReference")>= 0 )
      {
        System.err.println("Error: One input PDF seems to not conform to the PDF standard.");
        System.err.println("Perhaps the document information dictionary is a direct object");
        System.err.println("   instead of an indirect reference.");
        System.err.println("Please report this bug to the program which produced the PDF.");
        System.err.println();
      }
      System.err.println("Java Exception:");
      c_p.printStackTrace();
      ret_val= ErrorCode.ERROR;
    }
    catch( java.lang.Throwable t_p ) {
      System.err.println("Unhandled Java Exception in main():");
      t_p.printStackTrace();
      ret_val= ErrorCode.BUG;
    }
  }
  if ( ret_val == ErrorCode.BUG ) {
    describe_bug_report();
  }
  System.exit(ret_val.code);
}

static void
describe_header() {
  System.out.println("pdftk port to java " + PDFTK_VER + " a Handy Tool for Manipulating PDF Documents");
  System.out.println("Copyright (c) 2017-2018 Marc Vinyals - https://gitlab.com/pdftk-java/pdftk");
  System.out.println("Copyright (c) 2003-2013 Steward and Lee, LLC.");
  System.out.println("pdftk includes a modified version of the iText library.");
  System.out.println("Copyright (c) 1999-2009 Bruno Lowagie, Paulo Soares, et al.");
  System.out.println("This is free software; see the source code for copying conditions. There is");
  System.out.println("NO warranty, not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.");
}

static void
describe_synopsis() {
  System.out.println(
"SYNOPSIS\n" +
"       pdftk <input PDF files | - | PROMPT>\n" +
"      [ input_pw <input PDF owner passwords | PROMPT> ]\n" +
"      [ <operation> <operation arguments> ]\n" +
"      [ output <output filename | - | PROMPT> ]\n" +
"      [ encrypt_40bit | encrypt_128bit ]\n" +
"      [ allow <permissions> ]\n" +
"      [ owner_pw <owner password | PROMPT> ]\n" +
"      [ user_pw <user password | PROMPT> ]\n" +
"      [ flatten ] [ need_appearances ]\n" +
"      [ compress | uncompress ]\n" +
"      [ keep_first_id | keep_final_id ] [ drop_xfa ] [ drop_xmp ]\n" +
"      [ verbose ] [ dont_ask | do_ask ]\n" +
"       Where:\n" +
"      <operation> may be empty, or:\n" +
"      [ cat | shuffle | burst | rotate |\n" +
"        generate_fdf | fill_form |\n" +
"        background | multibackground |\n" +
"        stamp | multistamp |\n" +
"        dump_data | dump_data_utf8 |\n" +
"        dump_data_fields | dump_data_fields_utf8 |\n" +
"        dump_data_annots |\n" +
"        update_info | update_info_utf8 |\n" +
"        attach_files | unpack_files ]\n" +
"\n" +
"       For Complete Help: pdftk --help\n");
}

static void
describe_full() {
  describe_header();
  System.out.println();

  describe_synopsis();
  System.out.println();

  System.out.println(
"DESCRIPTION\n" +
"       If PDF is electronic paper, then pdftk is an electronic staple-remover,\n" +
"       hole-punch, binder, secret-decoder-ring, and X-Ray-glasses.  Pdftk is a\n" +
"       simple tool for doing everyday things with PDF documents.  Use it to:\n" +
"\n" +
"       * Merge PDF Documents or Collate PDF Page Scans\n" +
"       * Split PDF Pages into a New Document\n" +
"       * Rotate PDF Documents or Pages\n" +
"       * Decrypt Input as Necessary (Password Required)\n" +
"       * Encrypt Output as Desired\n" +
"       * Fill PDF Forms with X/FDF Data and/or Flatten Forms\n" +
"       * Generate FDF Data Stencils from PDF Forms\n" +
"       * Apply a Background Watermark or a Foreground Stamp\n" +
"       * Report PDF Metrics, Bookmarks and Metadata\n" +
"       * Add/Update PDF Bookmarks or Metadata\n" +
"       * Attach Files to PDF Pages or the PDF Document\n" +
"       * Unpack PDF Attachments\n" +
"       * Burst a PDF Document into Single Pages\n" +
"       * Uncompress and Re-Compress Page Streams\n" +
"       * Repair Corrupted PDF (Where Possible)\n" +
"\n" +
"OPTIONS\n" +
"       A summary of options is included below.\n" +
"\n" +
"       --help, -h\n" +
"        Show this summary of options.\n" +
"\n" +
"       <input PDF files | - | PROMPT>\n" +
"        A list of the input PDF files. If you plan to combine these PDFs\n" +
"        (without using handles) then list files in the order you want\n" +
"        them combined.  Use - to pass a single PDF into pdftk via stdin.\n" +
"        Input files can be associated with handles, where a handle is\n" +
"        one or more upper-case letters:\n" +
"\n" +
"        <input PDF handle>=<input PDF filename>\n" +
"\n" +
"        Handles are often omitted.  They are useful when specifying PDF\n" +
"        passwords or page ranges, later.\n" +
"\n" +
"        For example: A=input1.pdf QT=input2.pdf M=input3.pdf\n" +
"\n" +
"       [input_pw <input PDF owner passwords | PROMPT>]\n" +
"        Input PDF owner passwords, if necessary, are associated with\n" +
"        files by using their handles:\n" +
"\n" +
"        <input PDF handle>=<input PDF file owner password>\n" +
"\n" +
"        If handles are not given, then passwords are associated with\n" +
"        input files by order.\n" +
"\n" +
"        Most pdftk features require that encrypted input PDF are accom-\n" +
"        panied by the ~owner~ password. If the input PDF has no owner\n" +
"        password, then the user password must be given, instead.  If the\n" +
"        input PDF has no passwords, then no password should be given.\n" +
"\n" +
"        When running in do_ask mode, pdftk will prompt you for a pass-\n" +
"        word if the supplied password is incorrect or none was given.\n" +
"\n" +
"       [<operation> <operation arguments>]\n" +
"        Available operations are: cat, shuffle, burst, rotate, gener-\n" +
"        ate_fdf, fill_form, background, multibackground, stamp, multi-\n" +
"        stamp, dump_data, dump_data_utf8, dump_data_fields,\n" +
"        dump_data_fields_utf8, dump_data_annots, update_info,\n" +
"        update_info_utf8, attach_files, unpack_files. Some operations\n" +
"        takes additional arguments, described below.\n" +
"\n" +
"        If this optional argument is omitted, then pdftk runs in 'fil-\n" +
"        ter' mode.  Filter mode takes only one PDF input and creates a\n" +
"        new PDF after applying all of the output options, like encryp-\n" +
"        tion and compression.\n" +
"\n" +
"    cat [<page ranges>]\n" +
"     Assembles (catenates) pages from input PDFs to create a new\n" +
"     PDF. Use cat to merge PDF pages or to split PDF pages from\n" +
"     documents. You can also use it to rotate PDF pages. Page\n" +
"     order in the new PDF is specified by the order of the given\n" +
"     page ranges. Page ranges are described like this:\n" +
"\n" +
"     <input PDF handle>[<begin page number>[-<end page num-\n" +
"     ber>[<qualifier>]]][<page rotation>]\n" +
"\n" +
"     Where the handle identifies one of the input PDF files, and\n" +
"     the beginning and ending page numbers are one-based refer-\n" +
"     ences to pages in the PDF file.  The qualifier can be even or\n" +
"     odd, and the page rotation can be north, south, east, west,\n" +
"     left, right, or down.\n" +
"\n" +
"     If a PDF handle is given but no pages are specified, then the\n" +
"     entire PDF is used. If no pages are specified for any of the\n" +
"     input PDFs, then the input PDFs' bookmarks are also merged\n" +
"     and included in the output.\n" +
"\n" +
"     If the handle is omitted from the page range, then the pages\n" +
"     are taken from the first input PDF.\n" +
"\n" +
"     The even qualifier causes pdftk to use only the even-numbered\n" +
"     PDF pages, so 1-6even yields pages 2, 4 and 6 in that order.\n" +
"     6-1even yields pages 6, 4 and 2 in that order.\n" +
"\n" +
"     The odd qualifier works similarly to the even.\n" +
"\n" +
"     The page rotation setting can cause pdftk to rotate pages and\n" +
"     documents.  Each option sets the page rotation as follows (in\n" +
"     degrees): north: 0, east: 90, south: 180, west: 270, left:\n" +
"     -90, right: +90, down: +180. left, right, and down make rela-\n" +
"     tive adjustments to a page's rotation.\n" +
"\n" +
"     If no arguments are passed to cat, then pdftk combines all\n" +
"     input PDFs in the order they were given to create the output.\n" +
"\n" +
"     NOTES:\n" +
"     * <end page number> may be less than <begin page number>.\n" +
"     * The keyword end may be used to reference the final page of\n" +
"     a document instead of a page number.\n" +
"     * Reference a single page by omitting the ending page number.\n" +
"     * The handle may be used alone to represent the entire PDF\n" +
"     document, e.g., B1-end is the same as B.\n" +
"     * You can reference page numbers in reverse order by prefix-\n" +
"     ing them with the letter r. For example, page r1 is the last\n" +
"     page of the document, r2 is the next-to-last page of the doc-\n" +
"     ument, and rend is the first page of the document. You can\n" +
"     use this prefix in ranges, too, for example r3-r1 is the last\n" +
"     three pages of a PDF.\n" +
"\n" +
"     Page Range Examples without Handles:\n" +
"     1-endeast - rotate entire document 90 degrees\n" +
"     5 11 20 - take single pages from input PDF\n" +
"     5-25oddwest - take odd pages in range, rotate 90 degrees\n" +
"     6-1 - reverse pages in range from input PDF\n" +
"\n" +
"     Page Range Examples Using Handles:\n" +
"     Say A=in1.pdf B=in2.pdf, then:\n" +
"     A1-21 - take range from in1.pdf\n" +
"     Bend-1odd - take all odd pages from in2.pdf in reverse order\n" +
"     A72 - take a single page from in1.pdf\n" +
"     A1-21 Beven A72 - assemble pages from both in1.pdf and\n" +
"     in2.pdf\n" +
"     Awest - rotate entire in1.pdf document 90 degrees\n" +
"     B - use all of in2.pdf\n" +
"     A2-30evenleft - take the even pages from the range, remove 90\n" +
"     degrees from each page's rotation\n" +
"     A A - catenate in1.pdf with in1.pdf\n" +
"     Aevenwest Aoddeast - apply rotations to even pages, odd pages\n" +
"     from in1.pdf\n" +
"     Awest Bwest Bdown - catenate rotated documents\n" +
"\n" +
"    shuffle [<page ranges>]\n" +
"     Collates pages from input PDFs to create a new PDF.  Works\n" +
"     like the cat operation except that it takes one page at a\n" +
"     time from each page range to assemble the output PDF.  If one\n" +
"     range runs out of pages, it continues with the remaining\n" +
"     ranges.  Ranges can use all of the features described above\n" +
"     for cat, like reverse page ranges, multiple ranges from a\n" +
"     single PDF, and page rotation.  This feature was designed to\n" +
"     help collate PDF pages after scanning paper documents.\n" +
"\n" +
"    burst  Splits a single input PDF document into individual pages.\n" +
"     Also creates a report named doc_data.txt which is the same as\n" +
"     the output from dump_data.  If the output section is omitted,\n" +
"     then PDF pages are named: pg_%04d.pdf, e.g.: pg_0001.pdf,\n" +
"     pg_0002.pdf, etc.  To name these pages yourself, supply a\n" +
"     printf-styled format string via the output section.  For\n" +
"     example, if you want pages named: page_01.pdf, page_02.pdf,\n" +
"     etc., pass output page_%02d.pdf to pdftk.  Encryption can be\n" +
"     applied to the output by appending output options such as\n" +
"     owner_pw, e.g.:\n" +
"\n" +
"     pdftk in.pdf burst owner_pw foopass\n" +
"\n" +
"    rotate [<page ranges>]\n" +
"     Takes a single input PDF and rotates just the specified\n" +
"     pages.  All other pages remain unchanged.  The page order\n" +
"     remains unchaged.  Specify the pages to rotate using the same\n" +
"     notation as you would with cat, except you omit the pages\n" +
"     that you aren't rotating:\n" +
"\n" +
"     [<begin page number>[-<end page number>[<qualifier>]]][<page\n" +
"     rotation>]\n" +
"\n" +
"     The qualifier can be even or odd, and the page rotation can\n" +
"     be north, south, east, west, left, right, or down.\n" +
"\n" +
"     Each option sets the page rotation as follows (in degrees):\n" +
"     north: 0, east: 90, south: 180, west: 270, left: -90, right:\n" +
"     +90, down: +180. left, right, and down make relative adjust-\n" +
"     ments to a page's rotation.\n" +
"\n" +
"     The given order of the pages doesn't change the page order in\n" +
"     the output.\n" +
"\n" +
"    generate_fdf\n" +
"     Reads a single input PDF file and generates an FDF file suit-\n" +
"     able for fill_form out of it to the given output filename or\n" +
"     (if no output is given) to stdout.  Does not create a new\n" +
"     PDF.\n" +
"\n" +
"    fill_form <FDF data filename | XFDF data filename | - | PROMPT>\n" +
"     Fills the single input PDF's form fields with the data from\n" +
"     an FDF file, XFDF file or stdin. Enter the data filename\n" +
"     after fill_form, or use - to pass the data via stdin, like\n" +
"     so:\n" +
"\n" +
"     pdftk form.pdf fill_form data.fdf output form.filled.pdf\n" +
"\n" +
"     If the input FDF file includes Rich Text formatted data in\n" +
"     addition to plain text, then the Rich Text data is packed\n" +
"     into the form fields as well as the plain text.  Pdftk also\n" +
"     sets a flag that cues Reader/Acrobat to generate new field\n" +
"     appearances based on the Rich Text data.  So when the user\n" +
"     opens the PDF, the viewer will create the Rich Text appear-\n" +
"     ance on the spot.  If the user's PDF viewer does not support\n" +
"     Rich Text, then the user will see the plain text data\n" +
"     instead.  If you flatten this form before Acrobat has a\n" +
"     chance to create (and save) new field appearances, then the\n" +
"     plain text field data is what you'll see.\n" +
"\n" +
"     Also see the flatten and need_appearances options.\n" +
"\n" +
"    background <background PDF filename | - | PROMPT>\n" +
"     Applies a PDF watermark to the background of a single input\n" +
"     PDF.  Pass the background PDF's filename after background\n" +
"     like so:\n" +
"\n" +
"     pdftk in.pdf background back.pdf output out.pdf\n" +
"\n" +
"     Pdftk uses only the first page from the background PDF and\n" +
"     applies it to every page of the input PDF.  This page is\n" +
"     scaled and rotated as needed to fit the input page.  You can\n" +
"     use - to pass a background PDF into pdftk via stdin.\n" +
"\n" +
"     If the input PDF does not have a transparent background (such\n" +
"     as a PDF created from page scans) then the resulting back-\n" +
"     ground won't be visible -- use the stamp operation instead.\n" +
"\n" +
"    multibackground <background PDF filename | - | PROMPT>\n" +
"     Same as the background operation, but applies each page of\n" +
"     the background PDF to the corresponding page of the input\n" +
"     PDF.  If the input PDF has more pages than the stamp PDF,\n" +
"     then the final stamp page is repeated across these remaining\n" +
"     pages in the input PDF.\n" +
"\n" +
"    stamp <stamp PDF filename | - | PROMPT>\n" +
"     This behaves just like the background operation except it\n" +
"     overlays the stamp PDF page on top of the input PDF docu-\n" +
"     ment's pages.  This works best if the stamp PDF page has a\n" +
"     transparent background.\n" +
"\n" +
"    multistamp <stamp PDF filename | - | PROMPT>\n" +
"     Same as the stamp operation, but applies each page of the\n" +
"     background PDF to the corresponding page of the input PDF.\n" +
"     If the input PDF has more pages than the stamp PDF, then the\n" +
"     final stamp page is repeated across these remaining pages in\n" +
"     the input PDF.\n" +
"\n" +
"    dump_data\n" +
"     Reads a single input PDF file and reports its metadata, book-\n" +
"     marks (a/k/a outlines), page metrics (media, rotation and\n" +
"     labels), data embedded by STAMPtk (see STAMPtk's embed\n" +
"     option) and other data to the given output filename or (if no\n" +
"     output is given) to stdout.  Non-ASCII characters are encoded\n" +
"     as XML numerical entities.  Does not create a new PDF.\n" +
"\n" +
"    dump_data_utf8\n" +
"     Same as dump_data excepct that the output is encoded as\n" +
"     UTF-8.\n" +
"\n" +
"    dump_data_fields\n" +
"     Reads a single input PDF file and reports form field statis-\n" +
"     tics to the given output filename or (if no output is given)\n" +
"     to stdout. Non-ASCII characters are encoded as XML numerical\n" +
"     entities. Does not create a new PDF.\n" +
"\n" +
"    dump_data_fields_utf8\n" +
"     Same as dump_data_fields excepct that the output is encoded\n" +
"     as UTF-8.\n" +
"\n" +
"    dump_data_annots\n" +
"     This operation currently reports only link annotations.\n" +
"     Reads a single input PDF file and reports annotation informa-\n" +
"     tion to the given output filename or (if no output is given)\n" +
"     to stdout. Non-ASCII characters are encoded as XML numerical\n" +
"     entities. Does not create a new PDF.\n" +
"\n" +
"    update_info <info data filename | - | PROMPT>\n" +
"     Changes the bookmarks and metadata in a single PDF's Info\n" +
"     dictionary to match the input data file. The input data file\n" +
"     uses the same syntax as the output from dump_data. Non-ASCII\n" +
"     characters should be encoded as XML numerical entities.\n" +
"\n" +
"     This operation does not change the metadata stored in the\n" +
"     PDF's XMP stream, if it has one. (For this reason you should\n" +
"     include a ModDate entry in your updated info with a current\n" +
"     date/timestamp, format: D:YYYYMMDDHHmmSS, e.g. D:201307241346\n" +
"     -- omitted data after YYYY revert to default values.)\n" +
"\n" +
"     For example:\n" +
"\n" +
"     pdftk in.pdf update_info in.info output out.pdf\n" +
"\n" +
"    update_info_utf8 <info data filename | - | PROMPT>\n" +
"     Same as update_info except that the input is encoded as\n" +
"     UTF-8.\n" +
"\n" +
"    attach_files <attachment filenames | PROMPT> [to_page <page number |\n" +
"    PROMPT>]\n" +
"     Packs arbitrary files into a PDF using PDF's file attachment\n" +
"     features. More than one attachment may be listed after\n" +
"     attach_files. Attachments are added at the document level\n" +
"     unless the optional to_page option is given, in which case\n" +
"     the files are attached to the given page number (the first\n" +
"     page is 1, the final page is end). For example:\n" +
"\n" +
"     pdftk in.pdf attach_files table1.html table2.html to_page 6\n" +
"     output out.pdf\n" +
"\n" +
"    unpack_files\n" +
"     Copies all of the attachments from the input PDF into the\n" +
"     current folder or to an output directory given after output.\n" +
"     For example:\n" +
"\n" +
"     pdftk report.pdf unpack_files output ~/atts/\n" +
"\n" +
"     or, interactively:\n" +
"\n" +
"     pdftk report.pdf unpack_files output PROMPT\n" +
"\n" +
"       [output <output filename | - | PROMPT>]\n" +
"        The output PDF filename may not be set to the name of an input\n" +
"        filename. Use - to output to stdout.  When using the dump_data\n" +
"        operation, use output to set the name of the output data file.\n" +
"        When using the unpack_files operation, use output to set the\n" +
"        name of an output directory.  When using the burst operation,\n" +
"        you can use output to control the resulting PDF page filenames\n" +
"        (described above).\n" +
"\n" +
"       [encrypt_40bit | encrypt_128bit]\n" +
"        If an output PDF user or owner password is given, output PDF\n" +
"        encryption strength defaults to 128 bits.  This can be overrid-\n" +
"        den by specifying encrypt_40bit.\n" +
"\n" +
"       [allow <permissions>]\n" +
"        Permissions are applied to the output PDF only if an encryption\n" +
"        strength is specified or an owner or user password is given.  If\n" +
"        permissions are not specified, they default to 'none,' which\n" +
"        means all of the following features are disabled.\n" +
"\n" +
"        The permissions section may include one or more of the following\n" +
"        features:\n" +
"\n" +
"        Printing\n" +
"         Top Quality Printing\n" +
"\n" +
"        DegradedPrinting\n" +
"         Lower Quality Printing\n" +
"\n" +
"        ModifyContents\n" +
"         Also allows Assembly\n" +
"\n" +
"        Assembly\n" +
"\n" +
"        CopyContents\n" +
"         Also allows ScreenReaders\n" +
"\n" +
"        ScreenReaders\n" +
"\n" +
"        ModifyAnnotations\n" +
"         Also allows FillIn\n" +
"\n" +
"        FillIn\n" +
"\n" +
"        AllFeatures\n" +
"         Allows the user to perform all of the above, and top\n" +
"         quality printing.\n" +
"\n" +
"       [owner_pw <owner password | PROMPT>]\n" +
"\n" +
"       [user_pw <user password | PROMPT>]\n" +
"        If an encryption strength is given but no passwords are sup-\n" +
"        plied, then the owner and user passwords remain empty, which\n" +
"        means that the resulting PDF may be opened and its security\n" +
"        parameters altered by anybody.\n" +
"\n" +
"       [compress | uncompress]\n" +
"        These are only useful when you want to edit PDF code in a text\n" +
"        editor like vim or emacs.  Remove PDF page stream compression by\n" +
"        applying the uncompress filter. Use the compress filter to\n" +
"        restore compression.\n" +
"\n" +
"       [flatten]\n" +
"        Use this option to merge an input PDF's interactive form fields\n" +
"        (and their data) with the PDF's pages. Only one input PDF may be\n" +
"        given. Sometimes used with the fill_form operation.\n" +
"\n" +
"       [need_appearances]\n" +
"        Sets a flag that cues Reader/Acrobat to generate new field\n" +
"        appearances based on the form field values.  Use this when fill-\n" +
"        ing a form with non-ASCII text to ensure the best presentation\n" +
"        in Adobe Reader or Acrobat.  It won't work when combined with\n" +
"        the flatten option.\n" +
"\n" +
"       [keep_first_id | keep_final_id]\n" +
"        When combining pages from multiple PDFs, use one of these\n" +
"        options to copy the document ID from either the first or final\n" +
"        input document into the new output PDF. Otherwise pdftk creates\n" +
"        a new document ID for the output PDF. When no operation is\n" +
"        given, pdftk always uses the ID from the (single) input PDF.\n" +
"\n" +
"       [drop_xfa]\n" +
"        If your input PDF is a form created using Acrobat 7 or Adobe\n" +
"        Designer, then it probably has XFA data.  Filling such a form\n" +
"        using pdftk yields a PDF with data that fails to display in\n" +
"        Acrobat 7 (and 6?).  The workaround solution is to remove the\n" +
"        form's XFA data, either before you fill the form using pdftk or\n" +
"        at the time you fill the form. Using this option causes pdftk to\n" +
"        omit the XFA data from the output PDF form.\n" +
"\n" +
"        This option is only useful when running pdftk on a single input\n" +
"        PDF.  When assembling a PDF from multiple inputs using pdftk,\n" +
"        any XFA data in the input is automatically omitted.\n" +
"\n" +
"       [drop_xmp]\n" +
"        Many PDFs store document metadata using both an Info dictionary\n" +
"        (old school) and an XMP stream (new school).  Pdftk's\n" +
"        update_info operation can update the Info dictionary, but not\n" +
"        the XMP stream.  The proper remedy for this is to include a\n" +
"        ModDate entry in your updated info with a current date/time-\n" +
"        stamp. The date/timestamp format is: D:YYYYMMDDHHmmSS, e.g.\n" +
"        D:201307241346 -- omitted data after YYYY revert to default val-\n" +
"        ues. This newer ModDate should cue PDF viewers that the Info\n" +
"        metadata is more current than the XMP data.\n" +
"\n" +
"        Alternatively, you might prefer to remove the XMP stream from\n" +
"        the PDF altogether -- that's what this option does.  Note that\n" +
"        objects inside the PDF might have their own, separate XMP meta-\n" +
"        data streams, and that drop_xmp does not remove those.  It only\n" +
"        removes the PDF's document-level XMP stream.\n" +
"\n" +
"       [verbose]\n" +
"        By default, pdftk runs quietly. Append verbose to the end and it\n" +
"        will speak up.\n" +
"\n" +
"       [dont_ask | do_ask]\n" +
"        Depending on the compile-time settings (see ASK_ABOUT_WARNINGS),\n" +
"        pdftk might prompt you for further input when it encounters a\n" +
"        problem, such as a bad password. Override this default behavior\n" +
"        by adding dont_ask (so pdftk won't ask you what to do) or do_ask\n" +
"        (so pdftk will ask you what to do).\n" +
"\n" +
"        When running in dont_ask mode, pdftk will over-write files with\n" +
"        its output without notice.\n" +
"\n" +
"EXAMPLES\n" +
"       Collate scanned pages\n" +
"   pdftk A=even.pdf B=odd.pdf shuffle A B output collated.pdf\n" +
"   or if odd.pdf is in reverse order:\n" +
"   pdftk A=even.pdf B=odd.pdf shuffle A Bend-1 output collated.pdf\n" +
"\n" +
"       Decrypt a PDF\n" +
"   pdftk secured.pdf input_pw foopass output unsecured.pdf\n" +
"\n" +
"       Encrypt a PDF using 128-bit strength (the default), withhold all per-\n" +
"       missions (the default)\n" +
"   pdftk 1.pdf output 1.128.pdf owner_pw foopass\n" +
"\n" +
"       Same as above, except password 'baz' must also be used to open output\n" +
"       PDF\n" +
"   pdftk 1.pdf output 1.128.pdf owner_pw foo user_pw baz\n" +
"\n" +
"       Same as above, except printing is allowed (once the PDF is open)\n" +
"   pdftk 1.pdf output 1.128.pdf owner_pw foo user_pw baz allow printing\n" +
"\n" +
"       Join in1.pdf and in2.pdf into a new PDF, out1.pdf\n" +
"   pdftk in1.pdf in2.pdf cat output out1.pdf\n" +
"   or (using handles):\n" +
"   pdftk A=in1.pdf B=in2.pdf cat A B output out1.pdf\n" +
"   or (using wildcards):\n" +
"   pdftk *.pdf cat output combined.pdf\n" +
"\n" +
"       Remove page 13 from in1.pdf to create out1.pdf\n" +
"   pdftk in.pdf cat 1-12 14-end output out1.pdf\n" +
"   or:\n" +
"   pdftk A=in1.pdf cat A1-12 A14-end output out1.pdf\n" +
"\n" +
"       Apply 40-bit encryption to output, revoking all permissions (the\n" +
"       default). Set the owner PW to 'foopass'.\n" +
"   pdftk 1.pdf 2.pdf cat output 3.pdf encrypt_40bit owner_pw foopass\n" +
"\n" +
"       Join two files, one of which requires the password 'foopass'. The out-\n" +
"       put is not encrypted.\n" +
"   pdftk A=secured.pdf 2.pdf input_pw A=foopass cat output 3.pdf\n" +
"\n" +
"       Uncompress PDF page streams for editing the PDF in a text editor (e.g.,\n" +
"       vim, emacs)\n" +
"   pdftk doc.pdf output doc.unc.pdf uncompress\n" +
"\n" +
"       Repair a PDF's corrupted XREF table and stream lengths, if possible\n" +
"   pdftk broken.pdf output fixed.pdf\n" +
"\n" +
"       Burst a single PDF document into pages and dump its data to\n" +
"       doc_data.txt\n" +
"   pdftk in.pdf burst\n" +
"\n" +
"       Burst a single PDF document into encrypted pages. Allow low-quality\n" +
"       printing\n" +
"   pdftk in.pdf burst owner_pw foopass allow DegradedPrinting\n" +
"\n" +
"       Write a report on PDF document metadata and bookmarks to report.txt\n" +
"   pdftk in.pdf dump_data output report.txt\n" +
"\n" +
"       Rotate the first PDF page to 90 degrees clockwise\n" +
"   pdftk in.pdf cat 1east 2-end output out.pdf\n" +
"\n" +
"       Rotate an entire PDF document to 180 degrees\n" +
"   pdftk in.pdf cat 1-endsouth output out.pdf\n" +
"\n" +
"NOTES\n" +
"       This is a port of pdftk to java. See https://gitlab.com/pdftk-java/pdftk\n" +
"       The original program can be found at www.pdftk.com\n" +
"\n" +
"AUTHOR\n" +
"       Original author of pdftk is Sid Steward (sid.steward at pdflabs dot com).");
}

static void describe_bug_report() {
  System.err.println("There was a problem with pdftk-java. Please report it at");
  System.err.println("https://gitlab.com/pdftk-java/pdftk/issues");
  System.err.println("including the message above, the version of pdftk-java (" + PDFTK_VER + "), and if possible steps to reproduce the error.");
}

};

 /*
 *   This file is part of the pdftk port to java
 *
 *   Copyright (c) Marc Vinyals 2017-2018
 *
 *   The program is a java port of PDFtk, the PDF Toolkit
 *   Copyright (c) 2003-2013 Steward and Lee, LLC
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   The program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package com.gitlab.pdftk_java;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Set;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.nio.charset.StandardCharsets;
import java.text.NumberFormat;


import org.apache.commons.lang3.StringEscapeUtils;

import pdftk.com.lowagie.text.Rectangle;
import pdftk.com.lowagie.text.pdf.PdfArray;
import pdftk.com.lowagie.text.pdf.PdfBoolean;
import pdftk.com.lowagie.text.pdf.PdfDictionary;
import pdftk.com.lowagie.text.pdf.PdfName;
import pdftk.com.lowagie.text.pdf.PdfNumber;
import pdftk.com.lowagie.text.pdf.PdfObject;
import pdftk.com.lowagie.text.pdf.PdfReader;
import pdftk.com.lowagie.text.pdf.PdfString;
import pdftk.com.lowagie.text.pdf.PdfWriter;
import pdftk.com.lowagie.text.pdf.PRIndirectReference;
import pdftk.com.lowagie.text.pdf.PRStream;

class report {

static String
OutputXmlString( String jss_p )
{
  return StringEscapeUtils.escapeXml10( jss_p );
}

static String
OutputUtf8String( String jss_p )
{
  return jss_p;
}
  
static String
OutputPdfString( PdfString pdfss_p,
                 boolean utf8_b )
{
  if( pdfss_p != null && pdfss_p.isString() ) {
    String jss_p= pdfss_p.toUnicodeString();
    if( utf8_b ) {
      return OutputUtf8String( jss_p );
    }
    else {
      return OutputXmlString( jss_p );
    }
  }
  return "";
}

static String
OutputPdfName( PdfName pdfnn_p )
{
  if( pdfnn_p != null && pdfnn_p.isName() ) {
    String jnn_p= new String( pdfnn_p.getBytes() );
    jnn_p= PdfName.decodeName( jnn_p );
    return OutputXmlString( jnn_p );
  }
  return "";
}

static String
OutputPdfStringOrName( PdfObject pdfoo_p ,
                       boolean utf8_b )
{
  if( pdfoo_p != null && pdfoo_p.isString() ) {
    return OutputPdfString( (PdfString)pdfoo_p, utf8_b );
  }
  else if( pdfoo_p != null && pdfoo_p.isName() ) {
    return OutputPdfName( (PdfName)pdfoo_p );
  }
  return null;
}

static class FormField {
  String m_ft = ""; // type
  String m_tt = ""; // name
  String m_tu = ""; // alt. name
  int m_ff = 0; // flags
  Set<String> m_vv = new HashSet<String>(); // value -- may be an array
  String m_dv = ""; // default value

  // variable-text features
  int m_qq = 0; // quadding (justification)
  String m_ds = ""; // default style (rich text)
  byte[] m_rv = new byte[0]; // rich text value

  int m_maxlen = 0;

  // for checkboxes and such
  Set<String> m_states = new HashSet<String>(); // possible states
  // states as (value,display) pairs
  Set<List<String>> m_states_value_display = new HashSet<List<String>>();
  String m_state = "";

  FormField () {}
  FormField( FormField copy ) {
    m_ft = copy.m_ft;
    m_tt = copy.m_tt;
    m_tu = copy.m_tu;
    m_ff = copy.m_ff;
    m_vv = new HashSet<String>( copy.m_vv );
    m_dv = copy.m_dv;
    m_qq = copy.m_qq;
    m_ds = copy.m_ds;
    m_rv = Arrays.copyOf( copy.m_rv, copy.m_rv.length );
    m_maxlen = copy.m_maxlen;
    m_states = new HashSet<String>( copy.m_states );
    m_states_value_display = new HashSet<List<String>>();
    for (List<String> l : copy.m_states_value_display) {
      m_states_value_display.add( new ArrayList<String>(l) );
    }
    m_state = copy.m_state;
  }

  void addOptions(PdfReader reader_p,
                  PdfArray opts_p,
                  boolean utf8_b) {
    ArrayList<PdfObject> opts_a = opts_p.getArrayList();
    for( PdfObject opts_ii : opts_a ) {
      PdfObject opt_p= reader_p.getPdfObject( opts_ii );
      if (opt_p == null) continue;
      if( opt_p.isString() ) {
        // Option is a text string
        m_states.add( OutputPdfString( (PdfString)opt_p, utf8_b ) );
      }
      else if ( opt_p.isArray() ) {
        // Option is an array (value, display)
        ArrayList<PdfString> opt_value_display_p =
          ((PdfArray)opt_p).getArrayList();
        if (opt_value_display_p.size() != 2) continue;
        ArrayList<String> opt_value_display_a = new ArrayList<String>();
        for (PdfString subopt_p : opt_value_display_p) {
          opt_value_display_a.add( OutputPdfString( subopt_p, utf8_b ) );
        }
        m_states_value_display.add(opt_value_display_a);
      }
    }
  }

};

static void
  OutputFormField( PrintStream ofs,
                   FormField ff )
{
  ofs.println( "---" ); // delim
  ofs.println( "FieldType: " + ff.m_ft );
  ofs.println( "FieldName: " + ff.m_tt );
  if( !ff.m_tu.isEmpty() )
    ofs.println( "FieldNameAlt: " + ff.m_tu );
  ofs.println( "FieldFlags: " + ff.m_ff );
  for( String it : ff.m_vv ) {
    ofs.println( "FieldValue: " + it );
  }
  if( !ff.m_dv.isEmpty() )
    ofs.println( "FieldValueDefault: " + ff.m_dv );

  ofs.print( "FieldJustification: " );
  switch( ff.m_qq ) {
  case 0:
    ofs.println( "Left" );
    break;
  case 1:
    ofs.println( "Center" );
    break;
  case 2:
    ofs.println( "Right" );
    break;
  default:
    ofs.println( ff.m_qq );
    break;
  }
  
  if( !ff.m_ds.isEmpty() )
    ofs.println( "FieldStyleDefault: " + ff.m_ds );
  if( ff.m_rv.length > 0 ) {
    ofs.print( "FieldValueRichText: ");
    try {
      ofs.write( ff.m_rv );
    }
    catch (IOException e) {}
    ofs.println();
  }
  if( 0< ff.m_maxlen )
    ofs.println( "FieldMaxLength: " + ff.m_maxlen );

  for( String it : ff.m_states ) {
    ofs.println( "FieldStateOption: " + it );
  }
  for( List<String> it : ff.m_states_value_display ) {
    ofs.println( "FieldStateOption: " + it.get(0) );
    ofs.println( "FieldStateOptionDisplay: " + it.get(1) );
  }
}

  
static boolean
ReportAcroFormFields( PrintStream ofs,
                      PdfArray kids_array_p,
                      FormField acc_state,
                      PdfReader reader_p,
                      boolean utf8_b )
{
  FormField prev_state= new FormField( acc_state );
  boolean ret_val_b= false;

  ArrayList<PRIndirectReference> kids_p= kids_array_p.getArrayList();
  if( kids_p != null ) {
    for( PRIndirectReference kids_ii : kids_p ) {

      PdfDictionary kid_p= (PdfDictionary)
        reader_p.getPdfObject( kids_ii );
      if( kid_p != null && kid_p.isDictionary() ) {

        // field type
        if( kid_p.contains( PdfName.FT ) ) {
          PdfName ft_p= (PdfName)
            reader_p.getPdfObject( kid_p.get( PdfName.FT ) );
          if( ft_p != null && ft_p.isName() ) {
            
            if( ft_p.equals( PdfName.BTN ) ) { // button
              acc_state.m_ft= "Button";
            }
            else if( ft_p.equals( PdfName.TX ) ) { // text
              acc_state.m_ft= "Text";
            }
            else if( ft_p.equals( PdfName.CH ) ) { // choice
              acc_state.m_ft= "Choice";
            }
            else if( ft_p.equals( PdfName.SIG ) ) { // signature
              acc_state.m_ft= "Signature";
            }
            else { // warning
              System.err.println( "pdftk Warning in ReportAcroFormFields(): unexpected field type;" );
            }
          }
        }

        // field name; special inheritance rule: prepend parent name
        if( kid_p.contains( PdfName.T ) ) {
          PdfString pdfs_p= (PdfString)
            reader_p.getPdfObject( kid_p.get( PdfName.T ) );
          if( pdfs_p != null && pdfs_p.isString() ) {
            if( !acc_state.m_tt.isEmpty() ) {
              acc_state.m_tt= acc_state.m_tt + ".";
            }
            acc_state.m_tt = acc_state.m_tt + OutputPdfString( pdfs_p, utf8_b );
          }
        }

        // field alt. name
        if( kid_p.contains( PdfName.TU ) ) {
          PdfString pdfs_p= (PdfString)
            reader_p.getPdfObject( kid_p.get( PdfName.TU ) );
          if( pdfs_p != null && pdfs_p.isString() ) {
            acc_state.m_tu= OutputPdfString( pdfs_p, utf8_b );
          }
        }
        else {
          acc_state.m_tu="";
        }

        // field flags; inheritable
        if( kid_p.contains( PdfName.FF ) ) {
          PdfNumber pdfs_p= (PdfNumber)
            reader_p.getPdfObject( kid_p.get( PdfName.FF ) );
          if( pdfs_p != null && pdfs_p.isNumber() ) {
            acc_state.m_ff= pdfs_p.intValue();
          }
        }

        // field value; inheritable; may be string or name
        if( kid_p.contains( PdfName.V ) ) {
          PdfObject pdfs_p= 
            reader_p.getPdfObject( kid_p.get( PdfName.V ) );

          if( pdfs_p == null ) continue;
          String maybe_output = OutputPdfStringOrName( pdfs_p, utf8_b );
          if ( maybe_output != null ) {
            acc_state.m_vv.add( maybe_output );
          }
          else if( pdfs_p.isArray() ) {
            // multiple selections
            ArrayList<PRIndirectReference> vv_p= ((PdfArray)pdfs_p).getArrayList();
            for( PRIndirectReference vv_ii : vv_p ) {
              PdfObject pdfs_p_2= (PdfObject)
                reader_p.getPdfObject( vv_ii );
              String maybe_output_2 = OutputPdfStringOrName( pdfs_p_2, utf8_b );
              if ( maybe_output != null ) {
                acc_state.m_vv.add( maybe_output_2 );
              }
            }
          }
        }

        // default value; inheritable
        if( kid_p.contains( PdfName.DV ) ) {
          PdfObject pdfs_p= (PdfObject)
            reader_p.getPdfObject( kid_p.get( PdfName.DV ) );
          String maybe_output = OutputPdfStringOrName( pdfs_p, utf8_b );
          if( maybe_output != null ) {
            acc_state.m_dv= maybe_output;
          }
        }

        // quadding; inheritable
        if( kid_p.contains( PdfName.Q ) ) {
          PdfNumber pdfs_p= (PdfNumber)
            reader_p.getPdfObject( kid_p.get( PdfName.Q ) );
          if( pdfs_p != null && pdfs_p.isNumber() ) {

            acc_state.m_qq= pdfs_p.intValue();
          }
        }

        // default style
        if( kid_p.contains( PdfName.DS ) ) {
          PdfString pdfs_p= (PdfString)
            reader_p.getPdfObject( kid_p.get( PdfName.DS ) );
          if( pdfs_p != null && pdfs_p.isString() ) {
            acc_state.m_ds= OutputPdfString( pdfs_p, utf8_b );
          }
        }
        else {
          acc_state.m_ds="";
        }

        // rich text value; may be a string or a stream
        if( kid_p.contains( PdfName.RV ) ) {
          PdfObject pdfo_p= (PdfObject)
            reader_p.getPdfObject( kid_p.get( PdfName.RV ) );
          if( pdfo_p != null && pdfo_p.isString() ) { // string
            PdfString pdfs_p= (PdfString)pdfo_p;
            String name_oss= OutputPdfString( pdfs_p, utf8_b );
            acc_state.m_rv= name_oss.getBytes( StandardCharsets.UTF_8 );
          }
          else if( pdfo_p != null && pdfo_p.isStream() ) { // stream
            PRStream pdfs_p= (PRStream)pdfo_p;
            acc_state.m_rv = pdfs_p.getBytes();
          }
        }
        else {
          acc_state.m_rv=new byte[0];
        }

        // maximum length; inheritable
        if( kid_p.contains( PdfName.MAXLEN ) ) {
          PdfNumber pdfs_p= (PdfNumber)
            reader_p.getPdfObject( kid_p.get( PdfName.MAXLEN ) );
          if( pdfs_p != null && pdfs_p.isNumber() ) {

            acc_state.m_maxlen= pdfs_p.intValue();
          }
        }

        // available states
        if( kid_p.contains( PdfName.AP ) ) {
          PdfDictionary ap_p= (PdfDictionary)
            reader_p.getPdfObject( kid_p.get( PdfName.AP ) );
          if( ap_p != null && ap_p.isDictionary() ) {

            // this is one way to cull button option names: iterate over
            // appearance state names

            // N
            if( ap_p.contains( PdfName.N ) ) {
              PdfObject n_p= 
                reader_p.getPdfObject( ap_p.get( PdfName.N ) );
              if( n_p != null && n_p.isDictionary() ) {
                Set<PdfName> n_set_p= ((PdfDictionary)n_p).getKeys();
                for( PdfName key_p : n_set_p ) {
                  acc_state.m_states.add( OutputPdfName( key_p ) );
                }
              }
            }

            // D
            if( ap_p.contains( PdfName.D ) ) {
              PdfObject n_p= 
                reader_p.getPdfObject( ap_p.get( PdfName.D ) );
              if( n_p != null && n_p.isDictionary() ) {
                Set<PdfName> n_set_p= ((PdfDictionary)n_p).getKeys();
                for( PdfName key_p : n_set_p ) {
                  acc_state.m_states.add( OutputPdfName( key_p ) );
                }
              }
            }

            // R
            if( ap_p.contains( PdfName.R ) ) {
              PdfObject n_p= 
                reader_p.getPdfObject( ap_p.get( PdfName.N ) );
              if( n_p != null && n_p.isDictionary() ) {
                Set<PdfName> n_set_p= ((PdfDictionary)n_p).getKeys();
                for( PdfName key_p : n_set_p ) {
                  acc_state.m_states.add( OutputPdfName( key_p ) );
                }
              }
            }

          }
        }

        // list-box / combo-box possible states
        if( kid_p.contains( PdfName.OPT ) ) {
          PdfObject kid_opts_p= 
            reader_p.getPdfObject( kid_p.get( PdfName.OPT ) );
          if( kid_opts_p != null && kid_opts_p.isArray() ) {
            acc_state.addOptions( reader_p, (PdfArray)kid_opts_p, utf8_b );
          }
        }

        if( kid_p.contains( PdfName.KIDS ) ) { // recurse
          PdfArray kid_kids_p= (PdfArray)
            reader_p.getPdfObject( kid_p.get( PdfName.KIDS )  );
          if( kid_kids_p != null && kid_kids_p.isArray() ) {

            boolean kids_have_names_b=
              ReportAcroFormFields( ofs, kid_kids_p, acc_state, reader_p, utf8_b );

            if( !kids_have_names_b &&
                kid_p.contains( PdfName.T ) )
              { 
                // dump form field
                OutputFormField( ofs, acc_state );
              }

            // reset state; 
            acc_state= new FormField(prev_state);
          }
          else { // error
          }
        }
        else if( kid_p.contains( PdfName.T ) ) { 
          // term. field; dump form field
          OutputFormField( ofs, acc_state );

          // reset state; 
          acc_state= new FormField(prev_state);

          // record presense of field name
          ret_val_b= true;
        }

      }
    }
  }
  else { // warning
    System.err.println( "pdftk Warning in ReportAcroFormFields(): unable to get ArrayList;" );
  }

  return ret_val_b;
}

  
static void
ReportAcroFormFields( PrintStream ofs,
                      PdfReader reader_p,
                      boolean utf8_b ) {
  PdfDictionary catalog_p= reader_p.catalog;
  if( catalog_p != null && catalog_p.isDictionary() ) {
    
    PdfDictionary acro_form_p= (PdfDictionary)
      reader_p.getPdfObject( catalog_p.get( PdfName.ACROFORM ) );
    if( acro_form_p != null && acro_form_p.isDictionary() ) {

      PdfArray fields_p= (PdfArray)
        reader_p.getPdfObject( acro_form_p.get( PdfName.FIELDS ) );
      if( fields_p != null && fields_p.isArray() ) {

        // enter recursion
        FormField root_field_state = new FormField();
        ReportAcroFormFields( ofs, fields_p, root_field_state, reader_p, utf8_b );
      }
    }
  }
  else { // error
    System.err.println( "pdftk Error in ReportAcroFormFields(): unable to access PDF catalog;" );
  }

}

static void
ReportAction( PrintStream ofs, 
              PdfReader reader_p,
              PdfDictionary action_p,
              boolean utf8_b,
              String prefix )
{
  if( action_p.contains( PdfName.S ) ) {
    PdfName s_p= (PdfName)
      reader_p.getPdfObject( action_p.get( PdfName.S ) );

    // URI action
    if( s_p.equals( PdfName.URI ) ) {
      ofs.println( prefix + "ActionSubtype: URI" );

      // report URI
      if( action_p.contains( PdfName.URI ) ) {
        PdfString uri_p= (PdfString)
          reader_p.getPdfObject( action_p.get( PdfName.URI ) );
        if( uri_p != null && uri_p.isString() ) {
          
          ofs.println( prefix + "ActionURI: " +
                       OutputPdfString( uri_p, utf8_b ) );
        }
      }

      // report IsMap
      if( action_p.contains( PdfName.ISMAP ) ) {
        PdfBoolean ismap_p= (PdfBoolean)
          reader_p.getPdfObject( action_p.get( PdfName.ISMAP ) );
        if( ismap_p != null && ismap_p.isBoolean() )
          if( ismap_p.booleanValue() )
            ofs.println( prefix + "ActionIsMap: true" );
          else
            ofs.println( prefix + "ActionIsMap: false" );
      }
      else
        ofs.println( prefix + "ActionIsMap: false" );
    }
  }

  // subsequent actions? can be a single action or an array
  if( action_p.contains( PdfName.NEXT ) ) {
    PdfObject next_p= reader_p.getPdfObject( action_p.get( PdfName.NEXT ) );
    if( next_p.isDictionary() ) {
      ReportAction( ofs, reader_p, (PdfDictionary)next_p, utf8_b, prefix );
    }
    else if( next_p.isArray() ) {
      ArrayList<PRIndirectReference> actions_p= ((PdfArray)next_p).getArrayList();
      for( PRIndirectReference ii : actions_p ) {
        PdfDictionary next_action_p= (PdfDictionary)
          reader_p.getPdfObject( ii );
        if( next_action_p != null && next_action_p.isDictionary() )
          ReportAction( ofs, reader_p, next_action_p, utf8_b, prefix ); // recurse
      }
    }
  }
}
  
static final int LLx= 0;
static final int LLy= 1;
static final int URx= 2;
static final int URy= 3;
  
static void
ReportAnnot( PrintStream ofs,
             PdfReader reader_p,
             int page_num,
             PdfDictionary page_p,
             PdfDictionary annot_p,
             boolean utf8_b )
{
  // report things common to all annots

  // subtype
  PdfName subtype_p= (PdfName)
    reader_p.getPdfObject( annot_p.get( PdfName.SUBTYPE ) );
  if( subtype_p != null && subtype_p.isName() ) {
    ofs.println( "AnnotSubtype: " + OutputPdfName( subtype_p ) );
  }

  ////
  // rect

  // get raw rect from annot
  float[] rect = { 0.0f, 0.0f, 0.0f, 0.0f };
  PdfArray rect_p= (PdfArray)
    reader_p.getPdfObject( annot_p.get( PdfName.RECT ) );
  if( rect_p != null && rect_p.isArray() ) {
    ArrayList<PRIndirectReference> rect_al_p= rect_p.getArrayList();
    if( rect_al_p != null && rect_al_p.size()== 4 ) {

      for( int ii= 0; ii< 4; ++ii ) {
        PdfNumber coord_p= (PdfNumber)
          reader_p.getPdfObject( rect_al_p.get( ii ) );
        if( coord_p != null && coord_p.isNumber() )
          rect[ ii ]= (float)coord_p.floatValue();
        else
          rect[ ii ]= -1; // error value
      }
    }
  }
  
  // transform rect according to page crop box
  // grab width and height for later xform
  float page_crop_width= 0;
  float page_crop_height= 0;
  {
    Rectangle page_crop_p= reader_p.getCropBox( page_num );
    rect[0]= rect[0]- page_crop_p.left();
    rect[1]= rect[1]- page_crop_p.bottom();
    rect[2]= rect[2]- page_crop_p.left();
    rect[3]= rect[3]- page_crop_p.bottom();

    page_crop_width= (float)(page_crop_p.right()- page_crop_p.left());
    page_crop_height= (float)(page_crop_p.top()- page_crop_p.bottom());
  }

  // create new rect based on page rotation
  int page_rot= (int)(reader_p.getPageRotation( page_num )) % 360;
  float[] rot_rect = { 0.0f, 0.0f, 0.0f, 0.0f };
  switch( page_rot ) {

  case 90:
    rot_rect[0]= rect[LLy];
    rot_rect[1]= page_crop_width- rect[URx];
    rot_rect[2]= rect[URy];
    rot_rect[3]= page_crop_width- rect[LLx];
    break;

  case 180:
    rot_rect[0]= page_crop_width- rect[URx];
    rot_rect[1]= page_crop_height- rect[URy];
    rot_rect[2]= page_crop_width- rect[LLx];
    rot_rect[3]= page_crop_height- rect[LLy];
    break;

  case 270:
    rot_rect[0]= page_crop_height- rect[URy];
    rot_rect[1]= rect[LLx];
    rot_rect[2]= page_crop_height- rect[LLy];
    rot_rect[3]= rect[URx];
    break;

  default: // 0 deg
    rot_rect[0]= rect[0];
    rot_rect[1]= rect[1];
    rot_rect[2]= rect[2];
    rot_rect[3]= rect[3];
    break;
  }

  // output rotated rect
  ofs.println( "AnnotRect: " + rot_rect[0] + " " + rot_rect[1] +
               " " + rot_rect[2] + " " + rot_rect[3] );

}

static void
ReportAnnots( PrintStream ofs,
              PdfReader reader_p,
              boolean utf8_b ) {
  reader_p.resetReleasePage();

  ////
  // document information

  // document page count
  ofs.println("NumberOfPages: " + (int)reader_p.getNumberOfPages());

  // document base url
  PdfDictionary uri_p= (PdfDictionary)
    reader_p.getPdfObject( reader_p.catalog.get( PdfName.URI ) );
  if( uri_p != null && uri_p.isDictionary() ) {
    
    PdfString base_p= (PdfString)
      reader_p.getPdfObject( uri_p.get( PdfName.BASE ) );
    if( base_p != null && base_p.isString() ) {
      ofs.println("PdfUriBase: " + OutputPdfString( base_p, utf8_b ));
    }
  }

  ////
  // iterate over pages

  for( int ii= 1; ii<= reader_p.getNumberOfPages(); ++ii ) {
    PdfDictionary page_p= reader_p.getPageN( ii );

    PdfArray annots_p= (PdfArray)
      reader_p.getPdfObject( page_p.get( PdfName.ANNOTS ) );
    if( annots_p != null && annots_p.isArray() ) {

      ArrayList<PRIndirectReference> annots_al_p= annots_p.getArrayList();
      if( annots_al_p != null ) {

        // iterate over annotations
        for( PRIndirectReference jj : annots_al_p ) {

          PdfDictionary annot_p= (PdfDictionary)
            reader_p.getPdfObject( jj );
          if( annot_p != null && annot_p.isDictionary() ) {

            PdfName type_p= (PdfName)
              reader_p.getPdfObject( annot_p.get( PdfName.TYPE ) );
            if( type_p.equals( PdfName.ANNOT ) ) {

              PdfName subtype_p= (PdfName)
                reader_p.getPdfObject( annot_p.get( PdfName.SUBTYPE ) );
            
              // link annotation
              if( subtype_p.equals( PdfName.LINK ) ) {

                ofs.println("---"); // delim
                ReportAnnot( ofs, reader_p, ii, page_p, annot_p, utf8_b ); // base annot items
                ofs.println("AnnotPageNumber: " + ii);

                // link-specific items
                if( annot_p.contains( PdfName.A ) ) { // action
                  PdfDictionary action_p= (PdfDictionary)
                    reader_p.getPdfObject( annot_p.get( PdfName.A ) );
                  if( action_p != null && action_p.isDictionary() ) {

                    ReportAction( ofs, reader_p, action_p, utf8_b, "Annot" );
                  }
                }
              }
            }
          }
        }
      }
    }
    reader_p.releasePage( ii );
  }
  reader_p.resetReleasePage();
}

//
static class PdfPageLabel {
  static final String m_prefix= "PageLabel";
  static final String m_begin_mark= "PageLabelBegin";
  // TODO
};

//
class PdfPageMedia {
  static final String m_prefix= "PageMedia";
  static final String m_begin_mark= "PageMediaBegin";
  // TODO
};

static void
ReportOutlines( PrintStream ofs, 
                PdfDictionary outline_p,
                PdfReader reader_p,
                boolean utf8_b )
{
  ArrayList<PdfBookmark> bookmark_data = new ArrayList<PdfBookmark>();
  bookmarks.ReadOutlines( bookmark_data,
                          outline_p,
                          0,
                          reader_p,
                          utf8_b );
  
  for( PdfBookmark it : bookmark_data ) {
    ofs.print( it );
  }
}

static void
ReportInfo( PrintStream ofs,
            PdfReader reader_p,
            PdfDictionary info_p,
            boolean utf8_b ) {
  if( info_p != null && info_p.isDictionary() ) {
    Set<PdfName> keys_p= info_p.getKeys();

    // iterate over Info keys
    for( PdfName key_p : keys_p ) {

      int key_len= key_p.getBytes().length - 1; // minus one for init. slash

      PdfObject value_p= reader_p.getPdfObject( info_p.get( key_p ) );

      // don't output empty keys or values
      if( 0< key_len &&
          value_p.isString() && 
          0< ((PdfString)value_p).toUnicodeString().length() ) 
        { // ouput
          ofs.println( data_import.PdfInfo.m_begin_mark );

          ofs.println( data_import.PdfInfo.m_key_label + " " +
                       OutputPdfName( key_p ) );

          ofs.println( data_import.PdfInfo.m_value_label + " " +
                       OutputPdfString( (PdfString)value_p, utf8_b ) );
        }
    }

  }
  else { // error
  }
}

static void
ReportPageLabels( PrintStream ofs,
                  PdfDictionary numtree_node_p,
                  PdfReader reader_p,
                  boolean utf8_b )
  // if *numtree_node_p has Nums, report them;
  // else if *numtree_node_p has Kids, recurse
  // output 1-based page numbers; that's what we do for bookmarks
{
  PdfArray nums_p= (PdfArray)
    reader_p.getPdfObject( numtree_node_p.get( PdfName.NUMS ) );
  if( nums_p != null && nums_p.isArray() ) {
    // report page numbers

    ArrayList<PRIndirectReference> labels_p= nums_p.getArrayList();
    if( labels_p != null ) {
      for( Iterator<PRIndirectReference> labels_ii = labels_p.iterator(); labels_ii.hasNext(); ) {
        
        // label index
        PdfNumber index_p= (PdfNumber)
          reader_p.getPdfObject( labels_ii.next() );

        // label dictionary
        PdfDictionary label_p= (PdfDictionary)
          reader_p.getPdfObject( labels_ii.next() );

        if( index_p != null && index_p.isNumber() &&
            label_p != null && label_p.isDictionary() )
          {
            ofs.println( PdfPageLabel.m_begin_mark );

            // PageLabelNewIndex
            ofs.println( "PageLabelNewIndex: " + (long)(index_p.intValue())+ 1 );
            
            { // PageLabelStart
              ofs.print( "PageLabelStart: " ); 
              PdfNumber start_p= (PdfNumber)
                reader_p.getPdfObject( label_p.get( PdfName.ST ) );
              if( start_p != null && start_p.isNumber() ) {
                ofs.println( (long)(start_p.intValue()) );
              }
              else {
                ofs.println( "1" ); // the default
              }
            }

            { // PageLabelPrefix
              PdfString prefix_p= (PdfString)
                reader_p.getPdfObject( label_p.get( PdfName.P ) );
              if( prefix_p != null && prefix_p.isString() ) {
                ofs.println( "PageLabelPrefix: " +
                             OutputPdfString( prefix_p, utf8_b ) );
              }
            }

            { // PageLabelNumStyle
              PdfName r_p= new PdfName("r");
              PdfName a_p= new PdfName("a");

              PdfName style_p= (PdfName)
                reader_p.getPdfObject( label_p.get( PdfName.S ) );
              ofs.print( "PageLabelNumStyle: " );
              if( style_p != null && style_p.isName() ) {
                if( style_p.equals( PdfName.D ) ) {
                  ofs.println( "DecimalArabicNumerals" );
                }
                else if( style_p.equals( PdfName.R ) ) {
                  ofs.println( "UppercaseRomanNumerals" );
                }
                else if( style_p.equals( r_p ) ) {
                  ofs.println( "LowercaseRomanNumerals" );
                }
                else if( style_p.equals( PdfName.A ) ) {
                  ofs.println( "UppercaseLetters" );
                }
                else if( style_p.equals( a_p ) ) {
                  ofs.println( "LowercaseLetters" );
                }
                else { // error
                  ofs.println( "[PDFTK ERROR]" );
                }
              }
              else { // default
                ofs.println( "NoNumber" );
              }
            }

          }
        else { // error
          ofs.println( "[PDFTK ERROR: INVALID label_p IN ReportPageLabelNode]" );
        }
      }
    }
    else { // error
      ofs.println( "[PDFTK ERROR: INVALID labels_p IN ReportPageLabelNode]" );
    }
  }
  else { // try recursing
    PdfArray kids_p= (PdfArray)
      reader_p.getPdfObject( numtree_node_p.get( PdfName.KIDS ) );
    if( kids_p != null && kids_p.isArray() ) {

      ArrayList<PRIndirectReference> kids_ar_p= kids_p.getArrayList();
      if( kids_ar_p != null ) {
        for( PRIndirectReference kids_ii : kids_ar_p ) {

          PdfDictionary kid_p= (PdfDictionary)
            reader_p.getPdfObject( kids_ii );
          if( kid_p != null && kid_p.isDictionary() ) {

            // recurse
            ReportPageLabels( ofs, kid_p, reader_p, utf8_b );
          }
          else { // error
            ofs.println( "[PDFTK ERROR: INVALID kid_p]" );
          }
        }
      }
      else { // error
        ofs.println( "[PDFTK ERROR: INVALID kids_ar_p]" );
      }
    }
    else { // error; a number tree must have one or the other
      ofs.println( "[PDFTK ERROR: INVALID PAGE LABEL NUMBER TREE]" );
    }
  }
}
  
static void
ReportOnPdf( PrintStream ofs,
             PdfReader reader_p,
             boolean utf8_b )
{
  { // trailer data
    PdfDictionary trailer_p= reader_p.getTrailer();
    if( trailer_p != null && trailer_p.isDictionary() ) {

      { // metadata
        PdfDictionary info_p= (PdfDictionary)
          reader_p.getPdfObject( trailer_p.get( PdfName.INFO ) );
        if( info_p != null && info_p.isDictionary() ) {
            
          ReportInfo( ofs, reader_p, info_p, utf8_b );
        }
        else { // warning
          System.err.println( "Warning: no info dictionary found" );
        }
      }

      { // pdf ID; optional
        PdfArray id_p= (PdfArray)
          reader_p.getPdfObject( trailer_p.get( PdfName.ID ) );
        if( id_p != null && id_p.isArray() ) {

          ArrayList<PRIndirectReference> id_al_p= id_p.getArrayList();
          if( id_al_p != null ) {

            for( int ii= 0; ii< id_al_p.size(); ++ii ) {
              ofs.print( "PdfID" + ii + ": " );

              PdfString id_ss_p= (PdfString)
                reader_p.getPdfObject( id_al_p.get(ii) );
              if( id_ss_p != null && id_ss_p.isString() ) {
                
                byte[] bb= id_ss_p.getBytes();
                if( bb!=null && bb.length > 0 ) {
                  for( byte bb_ss : bb ) {
                    ofs.printf( "%02x", bb_ss );
                  }
                }
              }
              else { // error
                System.err.println( "pdftk Error in ReportOnPdf(): invalid pdf id array string;" );
              }

              ofs.println();
            }
          }
          else { // error
            System.err.println( "pdftk Error in ReportOnPdf(): invalid ID ArrayList" );
          }
        }
      }

    }
    else { // error
      System.err.println( "pdftk Error in ReportOnPdf(): invalid trailer;" );
    }
  }

  int numPages= reader_p.getNumberOfPages();

  { // number of pages and outlines
    PdfDictionary catalog_p= reader_p.catalog;
    if( catalog_p != null && catalog_p.isDictionary() ) {

      // number of pages
      /*
      itext::PdfDictionary* pages_p= (itext::PdfDictionary*)
        reader_p->getPdfObject( catalog_p->get( itext::PdfName::PAGES ) );
      if( pages_p && pages_p->isDictionary() ) {

        itext::PdfNumber* count_p= (itext::PdfNumber*)
          reader_p->getPdfObject( pages_p->get( itext::PdfName::COUNT ) );
        if( count_p && count_p->isNumber() ) {

          ofs << "NumberOfPages: " << (unsigned int)count_p->intValue() << endl;
        }
        else { // error
          cerr << "pdftk Error in ReportOnPdf(): invalid count_p;" << endl;
        }
      }
      else { // error
        cerr << "pdftk Error in ReportOnPdf(): invalid pages_p;" << endl;
      }
      */
      ofs.println( "NumberOfPages: " + numPages );

      // outlines; optional
      PdfDictionary outlines_p= (PdfDictionary)
        reader_p.getPdfObject( catalog_p.get( PdfName.OUTLINES ) );
      if( outlines_p != null && outlines_p.isDictionary() ) {

        PdfDictionary top_outline_p= (PdfDictionary)
          reader_p.getPdfObject( outlines_p.get( PdfName.FIRST ) );
        if( top_outline_p != null && top_outline_p.isDictionary() ) {

          ReportOutlines( ofs, top_outline_p, reader_p, utf8_b );
        }
        else { // error
          // okay, not a big deal
          // cerr << "Internal Error: invalid top_outline_p in ReportOnPdf()" << endl;
        }
      }

    }
    else { // error
      System.err.println( "pdftk Error in ReportOnPdf(): couldn't find catalog;" );
    }
  }

  { // page metrics, rotation, stamptkData
    for( int ii= 1; ii<= numPages; ++ii ) {
      PdfDictionary page_p= reader_p.getPageN( ii );

      ofs.println( PdfPageMedia.m_begin_mark );
      ofs.println( "PageMediaNumber: " + ii );

      ofs.println( "PageMediaRotation: " + reader_p.getPageRotation( page_p ) );

      NumberFormat c_format = NumberFormat.getInstance(Locale.ROOT);
      
      Rectangle page_rect_p= reader_p.getPageSize( page_p );
      if( page_rect_p != null ) {
        ofs.println( "PageMediaRect: " 
            + c_format.format(page_rect_p.left()) + " "
            + c_format.format(page_rect_p.bottom()) + " "
            + c_format.format(page_rect_p.right()) + " "
            + c_format.format(page_rect_p.top()) );
        ofs.println( "PageMediaDimensions: " 
            + c_format.format(page_rect_p.right()- page_rect_p.left()) + " "
            + c_format.format(page_rect_p.top()- page_rect_p.bottom()) );
      }
      
      Rectangle page_crop_p= reader_p.getBoxSize( page_p, PdfName.CROPBOX );
      if( page_crop_p != null && 
          !( page_crop_p.left()== page_rect_p.left() &&
             page_crop_p.bottom()== page_rect_p.bottom() &&
             page_crop_p.right()== page_rect_p.right() &&
             page_crop_p.top()== page_rect_p.top() ) )
        {
          ofs.println( "PageMediaCropRect: " 
              + c_format.format(page_crop_p.left()) + " "
              + c_format.format(page_crop_p.bottom()) + " "
              + c_format.format(page_crop_p.right()) + " "
              + c_format.format(page_crop_p.top()) );
        } 

      PdfString stamptkData_p= page_p.getAsString( PdfName.STAMPTKDATA );
      if( stamptkData_p != null ) {
        ofs.println( "PageMediaStamptkData: " +
                     OutputPdfString( stamptkData_p, utf8_b ) );
      }

      reader_p.releasePage( ii );
    }
  }

  { // page labels (a/k/a logical page numbers)
    PdfDictionary catalog_p= reader_p.catalog;
    if( catalog_p != null && catalog_p.isDictionary() ) {

      PdfDictionary pagelabels_p= (PdfDictionary)
        reader_p.getPdfObject( catalog_p.get( PdfName.PAGELABELS ) );
      if( pagelabels_p != null && pagelabels_p.isDictionary() ) {

        ReportPageLabels( ofs, pagelabels_p, reader_p, utf8_b );
      }
    }
    else { // error
      System.err.println( "pdftk Error in ReportOnPdf(): couldn't find catalog (2);" );
    }
  }

} // end: ReportOnPdf

};
 /*
 * $Id$
 *
 * Copyright 2007 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.exceptions;

import java.io.IOException;

/**
 * Typed exception used when opening an existing PDF document.
 * Gets thrown when the document isn't a valid PDF document.
 * @since 2.1.5 It was written for iText 2.0.8, but moved to another package
 */
public class BadPasswordException extends IOException {

	/** Serial Version UID. */
	private static final long serialVersionUID = -4333706268155063964L;

	/**
	 * Creates an exception saying the user password was incorrect.
	 */
	public BadPasswordException(String message) {
		super(message);
	}
}
 /*
 * $Id$
 *
 * Copyright 2009 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999-2009 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000-2009 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.exceptions;

/**
 * Typed exception used when creating PDF syntax that isn't valid.
 * @since 2.1.6
 */
public class IllegalPdfSyntaxException extends IllegalArgumentException {

	/** Serial version ID */
	private static final long serialVersionUID = -643024246596031671L;

	/**
	 * Creates an exception saying the PDF syntax isn't correct.
	 * @param	message	some extra info about the exception
	 */
	public IllegalPdfSyntaxException(String message) {
		super(message);
	}
}
 /*
 * $Id$
 *
 * Copyright 2009 Bruno Lowagie
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999-2009 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000-2009 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.exceptions;

import java.io.IOException;

/**
 * Typed exception used when opening an existing PDF document.
 * Gets thrown when the document isn't a valid PDF document.
 * @since 2.1.5
 */
public class InvalidPdfException extends IOException {

	/** a serial version UID */
	private static final long serialVersionUID = -2319614911517026938L;

	/**
	 * Creates an instance of a NoPdfException.
	 * @param	message	the reason why the document isn't a PDF document according to iText.
	 */
	public InvalidPdfException(String message) {
		super(message);
	}
}
 /*
 * $Id$
 *
 * Copyright 2009 Bruno Lowagie
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999-2009 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000-2009 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.exceptions;
/**
 * Typed exception used when opening an existing PDF document.
 * Gets thrown when the document isn't a valid PDF document according to iText,
 * but it's different from the InvalidPdfException in the sense that it may
 * be an iText limitation (most of the times it isn't but you might have
 * bumped into something that has been added to the PDF specs, but that isn't
 * supported in iText yet).
 * @since 2.1.5
 */
public class UnsupportedPdfException extends InvalidPdfException {

	/** a serial version UID */
	private static final long serialVersionUID = 2180764250839096628L;

	/**
	 * Creates an instance of an UnsupportedPdfException.
	 * @param	message	the reason why the document isn't a PDF document according to iText.
	 */
	public UnsupportedPdfException(String message) {
		super(message);
	}
}
 /*
 * $Id: MarkupParser.java,v 1.53 2005/05/09 08:40:41 blowagie Exp $
 * $Name:  $
 *
 * Copyright 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.markup;

import java.awt.Color;
import java.io.BufferedReader;
import java.io.FileReader;
import java.util.HashMap;
import java.util.Properties;
import java.util.StringTokenizer;

import pdftk.com.lowagie.text.Element;
import pdftk.com.lowagie.text.ExceptionConverter;
import pdftk.com.lowagie.text.Font;
import pdftk.com.lowagie.text.FontFactory;
import pdftk.com.lowagie.text.ListItem;
import pdftk.com.lowagie.text.Paragraph;
import pdftk.com.lowagie.text.Phrase;
import pdftk.com.lowagie.text.Rectangle;
// import pdftk.com.lowagie.text.SimpleCell; ssteward: dropped in 1.44
// import pdftk.com.lowagie.text.SimpleTable; ssteward: dropped in 1.44

/**
 * This class is a HashMap that contains selectors (String) and styles (a
 * Properties object). Given a tag and its attributes (id/class), this class can
 * return an iText object with the according style.
 * 
 * @author blowagie
 */
public class MarkupParser extends HashMap {
    
    // constants
    private static final long serialVersionUID = 2643594602455839674L;

	/**
	 * HashMap with styles for each known combination of tag/id/class. The key
	 * is a String-combination, the value a Properties object.
	 */
	protected HashMap stylecache = new HashMap();

	/**
	 * HashMap with fonts for each known combination of tag/id/class. The key is
	 * the same String-combination used for the stylecache.
	 */
	protected HashMap fontcache = new HashMap();

	// processing CSS

	/**
	 * Creates new MarkupParser
	 * 
	 * @param file
	 *            the path to a CSS file.
	 */
	public MarkupParser(String file) {
		super();
		try {
			FileReader reader = new FileReader(file);
			BufferedReader br = new BufferedReader(reader);
			StringBuffer buf = new StringBuffer();
			String line;
			while ((line = br.readLine()) != null) {
				buf.append(line.trim());
			}
			String string = buf.toString();
			string = removeComment(string, "/*", "*/");
			StringTokenizer tokenizer = new StringTokenizer(string, "}");
			String tmp;
			int pos;
			String selector;
			String attributes;
			while (tokenizer.hasMoreTokens()) {
				tmp = tokenizer.nextToken();
				pos = tmp.indexOf("{");
				if (pos > 0) {
					selector = tmp.substring(0, pos).trim();
					attributes = tmp.substring(pos + 1).trim();
					if (attributes.endsWith("}"))
						attributes = attributes.substring(0, attributes
								.length() - 1);
					put(selector, parseAttributes(attributes));
				}
			}
		} catch (Exception e) {
			throw new ExceptionConverter(e);
		}
	}

	/**
	 * Removes the comments sections of a String.
	 * 
	 * @param string
	 *            the original String
	 * @param startComment
	 *            the String that marks the start of a Comment section
	 * @param endComment
	 *            the String that marks the end of a Comment section.
	 * @return the String stripped of its comment section
	 */
	public static String removeComment(String string, String startComment,
			String endComment) {
		StringBuffer result = new StringBuffer();
		int pos = 0;
		int end = endComment.length();
		int start = string.indexOf(startComment, pos);
		while (start > -1) {
			result.append(string.substring(pos, start));
			pos = string.indexOf(endComment, start) + end;
			start = string.indexOf(startComment, pos);
		}
		result.append(string.substring(pos));
		return result.toString();
	}

	/**
	 * This method parses a String with attributes and returns a Properties
	 * object.
	 * 
	 * @param string
	 *            a String of this form: 'key1="value1"; key2="value2";...
	 *            keyN="valueN" '
	 * @return a Properties object
	 */
	public static Properties parseAttributes(String string) {
		Properties result = new Properties();
		if (string == null)
			return result;
		StringTokenizer keyValuePairs = new StringTokenizer(string, ";");
		StringTokenizer keyValuePair;
		String key;
		String value;
		while (keyValuePairs.hasMoreTokens()) {
			keyValuePair = new StringTokenizer(keyValuePairs.nextToken(), ":");
			if (keyValuePair.hasMoreTokens())
				key = keyValuePair.nextToken().trim();
			else
				continue;
			if (keyValuePair.hasMoreTokens())
				value = keyValuePair.nextToken().trim();
			else
				continue;
			if (value.startsWith("\""))
				value = value.substring(1);
			if (value.endsWith("\""))
				value = value.substring(0, value.length() - 1);
			result.setProperty(key, value);
		}
		return result;
	}

	// reading attributevalues

	/**
	 * Parses a length.
	 * 
	 * @param string
	 *            a length in the form of an optional + or -, followed by a
	 *            number and a unit.
	 * @return a float
	 */

	public static float parseLength(String string) {
		int pos = 0;
		int length = string.length();
		boolean ok = true;
		while (ok && pos < length) {
			switch (string.charAt(pos)) {
			case '+':
			case '-':
			case '0':
			case '1':
			case '2':
			case '3':
			case '4':
			case '5':
			case '6':
			case '7':
			case '8':
			case '9':
			case '.':
				pos++;
				break;
			default:
				ok = false;
			}
		}
		if (pos == 0)
			return 0f;
		if (pos == length)
			return Float.valueOf(string + "f").floatValue();
		float f = Float.valueOf(string.substring(0, pos) + "f").floatValue();
		string = string.substring(pos);
		// inches
		if (string.startsWith("in")) {
			return f * 72f;
		}
		// centimeters
		if (string.startsWith("cm")) {
			return (f / 2.54f) * 72f;
		}
		// millimeters
		if (string.startsWith("mm")) {
			return (f / 25.4f) * 72f;
		}
		// picas
		if (string.startsWith("pc")) {
			return f * 12f;
		}
		// default: we assume the length was measured in points
		return f;
	}

	/**
	 * Converts a <CODE>Color</CODE> into a HTML representation of this <CODE>
	 * Color</CODE>.
	 * 
	 * @param color
	 *            the <CODE>Color</CODE> that has to be converted.
	 * @return the HTML representation of this <COLOR>Color </COLOR>
	 */

	public static Color decodeColor(String color) {
		int red = 0;
		int green = 0;
		int blue = 0;
		try {
			red = Integer.parseInt(color.substring(1, 3), 16);
			green = Integer.parseInt(color.substring(3, 5), 16);
			blue = Integer.parseInt(color.substring(5), 16);
		} catch (Exception sioobe) {
			// empty on purpose
		}
		return new Color(red, green, blue);
	}

	// helper methods

	/**
	 * Generates a key for an tag/id/class combination and adds the style
	 * attributes to the stylecache.
	 * 
	 * @param attributes
	 *            a Properties object with the tagname and the attributes of the
	 *            tag.
	 * @return a key
	 */
	private String getKey(Properties attributes) {
		String tag = attributes.getProperty(MarkupTags.ITEXT_TAG);
		String id = attributes.getProperty(MarkupTags.HTML_ATTR_CSS_ID);
		String cl = attributes.getProperty(MarkupTags.HTML_ATTR_CSS_CLASS);
		if (id == null) {
			id = "";
		} else {
			id = "#" + id;
		}
		if (cl == null) {
			cl = "";
		} else {
			cl = "." + cl;
		}
		String key = tag + id + cl;
		if (!stylecache.containsKey(key) && key.length() > 0) {
			Properties props = new Properties();
			Properties tagprops = (Properties) get(tag);
			Properties idprops = (Properties) get(id);
			Properties clprops = (Properties) get(cl);
			Properties tagidprops = (Properties) get(tag + id);
			Properties tagclprops = (Properties) get(tag + cl);
			if (tagprops != null)
				props.putAll(tagprops);
			if (idprops != null)
				props.putAll(idprops);
			if (clprops != null)
				props.putAll(clprops);
			if (tagidprops != null)
				props.putAll(tagidprops);
			if (tagclprops != null)
				props.putAll(tagclprops);
			stylecache.put(key, props);
		}
		return key;
	}

	// getting the objects based on the tag and its attributes

	/**
	 * Returns pagebreak information.
	 * 
	 * @param attributes
	 * @return true if a page break is needed before the tag
	 */
	public boolean getPageBreakBefore(Properties attributes) {
		String key = getKey(attributes);
		Properties styleattributes = (Properties) stylecache.get(key);
		if (styleattributes != null
				&& MarkupTags.CSS_VALUE_ALWAYS.equals(styleattributes
						.getProperty(MarkupTags.CSS_KEY_PAGE_BREAK_BEFORE))) {
			return true;
		}
		return false;
	}

	/**
	 * Returns pagebreak information.
	 * 
	 * @param attributes
	 * @return true if a page break is needed after the tag
	 */
	public boolean getPageBreakAfter(Properties attributes) {
		String key = getKey(attributes);
		Properties styleattributes = (Properties) stylecache.get(key);
		if (styleattributes != null
				&& MarkupTags.CSS_VALUE_ALWAYS.equals(styleattributes
						.getProperty(MarkupTags.CSS_KEY_PAGE_BREAK_AFTER))) {
			return true;
		}
		return false;
	}

	/**
	 * Returns an object based on a tag and its attributes.
	 * 
	 * @param attributes
	 *            a Properties object with the tagname and the attributes of the
	 *            tag.
	 * @return an iText object
	 */
	public Element getObject(Properties attributes) {
		String key = getKey(attributes);
		Properties styleattributes = (Properties) stylecache.get(key);
		if (styleattributes != null
				&& MarkupTags.CSS_VALUE_HIDDEN.equals(styleattributes
						.get(MarkupTags.CSS_KEY_VISIBILITY))) {
			return null;
		}
		String display = styleattributes
				.getProperty(MarkupTags.CSS_KEY_DISPLAY);
		Element element = null;
		if (MarkupTags.CSS_VALUE_INLINE.equals(display)) {
			element = retrievePhrase(getFont(attributes), styleattributes);
		} else if (MarkupTags.CSS_VALUE_BLOCK.equals(display)) {
			element = retrieveParagraph(getFont(attributes), styleattributes);
		} else if (MarkupTags.CSS_VALUE_LISTITEM.equals(display)) {
			element = retrieveListItem(getFont(attributes), styleattributes);
		} /* ssteward: dropped in pdftk 1.44:
		  else if (MarkupTags.CSS_VALUE_TABLECELL.equals(display)) {
			element = retrieveTableCell(attributes, styleattributes);
		} else if (MarkupTags.CSS_VALUE_TABLEROW.equals(display)) {
			element = retrieveTableRow(attributes, styleattributes);
		} else if (MarkupTags.CSS_VALUE_TABLE.equals(display)) {
			element = retrieveTable(attributes, styleattributes);
		} */
		return element;
	}

	/**
	 * Returns a font based on the ID and CLASS attributes of a tag.
	 * 
	 * @param attributes
	 *            a Properties object with the tagname and the attributes of the
	 *            tag.
	 * @return an iText Font;
	 */
	public Font getFont(Properties attributes) {
		String key = getKey(attributes);
		Font f = (Font) fontcache.get(key);
		if (f != null) {
			return f;
		} else {
			Properties styleattributes = (Properties) stylecache.get(key);
			f = retrieveFont(styleattributes);
			fontcache.put(key, f);
		}
		return f;
	}

	/**
	 * Returns a rectangle based on the width and height attributes of a tag,
	 * can be overridden by the ID and CLASS attributes.
	 * 
	 * @param attrs
	 *            the attributes that came with the tag
	 * @return an iText Rectangle object
	 */
	public Rectangle getRectangle(Properties attrs) {
		String width = null;
		String height = null;
		String key = getKey(attrs);
		Properties styleattributes = (Properties) stylecache.get(key);
		if (styleattributes != null) {
			width = styleattributes.getProperty(MarkupTags.HTML_ATTR_WIDTH);
			height = styleattributes.getProperty(MarkupTags.HTML_ATTR_HEIGHT);
		}
		if (width == null)
			width = attrs.getProperty(MarkupTags.HTML_ATTR_WIDTH);
		if (height == null)
			height = attrs.getProperty(MarkupTags.HTML_ATTR_HEIGHT);
		if (width == null || height == null)
			return null;
		return new Rectangle(parseLength(width), parseLength(height));
	}

	// retrieving objects based on the styleAttributes

	/**
	 * Retrieves a Phrase based on some style attributes.
	 * 
	 * @param font
	 * @param styleattributes
	 *            a Properties object containing keys and values
	 * @return an iText Phrase object
	 */
	public Element retrievePhrase(Font font, Properties styleattributes) {
		Phrase p = new Phrase("", font);
		if (styleattributes == null)
			return p;
		String leading = styleattributes
				.getProperty(MarkupTags.CSS_KEY_LINEHEIGHT);
		if (leading != null) {
			if (leading.endsWith("%")) {
				p.setLeading(p.font().size() * (parseLength(leading) / 100f));
			} else {
				p.setLeading(parseLength(leading));
			}
		}
		return p;
	}

	/**
	 * Retrieves a Paragraph based on some style attributes.
	 * 
	 * @param font
	 * @param styleattributes
	 *            a Properties object containing keys and values
	 * @return an iText Paragraph object
	 */
	public Element retrieveParagraph(Font font, Properties styleattributes) {
		Paragraph p = new Paragraph((Phrase) retrievePhrase(font,
				styleattributes));
		if (styleattributes == null)
			return p;
		String margin = styleattributes.getProperty(MarkupTags.CSS_KEY_MARGIN);
		float f;
		if (margin != null) {
			f = parseLength(margin);
			p.setIndentationLeft(f);
			p.setIndentationRight(f);
			p.setSpacingBefore(f);
			p.setSpacingAfter(f);
		}
		margin = styleattributes.getProperty(MarkupTags.CSS_KEY_MARGINLEFT);
		if (margin != null) {
			f = parseLength(margin);
			p.setIndentationLeft(f);
		}
		margin = styleattributes.getProperty(MarkupTags.CSS_KEY_MARGINRIGHT);
		if (margin != null) {
			f = parseLength(margin);
			p.setIndentationRight(f);
		}
		margin = styleattributes.getProperty(MarkupTags.CSS_KEY_MARGINTOP);
		if (margin != null) {
			f = parseLength(margin);
			p.setSpacingBefore(f);
		}
		margin = styleattributes.getProperty(MarkupTags.CSS_KEY_MARGINBOTTOM);
		if (margin != null) {
			f = parseLength(margin);
			p.setSpacingAfter(f);
		}
		String align = styleattributes
				.getProperty(MarkupTags.CSS_KEY_TEXTALIGN);
		if (MarkupTags.CSS_VALUE_TEXTALIGNLEFT.equals(align)) {
			p.setAlignment(Element.ALIGN_LEFT);
		} else if (MarkupTags.CSS_VALUE_TEXTALIGNRIGHT.equals(align)) {
			p.setAlignment(Element.ALIGN_RIGHT);
		} else if (MarkupTags.CSS_VALUE_TEXTALIGNCENTER.equals(align)) {
			p.setAlignment(Element.ALIGN_CENTER);
		} else if (MarkupTags.CSS_VALUE_TEXTALIGNJUSTIFY.equals(align)) {
			p.setAlignment(Element.ALIGN_JUSTIFIED);
		}
		return p;
	}

	/**
	 * Gets a table based on the styleattributes.
	 * 
	 * @param attributes
	 * @param styleattributes
	 * @return an iText Table
	 */
    /* ssteward: dropped in 1.44
	private Element retrieveTable(Properties attributes,
			Properties styleattributes) {
		SimpleTable table = new SimpleTable();
		applyBordersColors(table, attributes, styleattributes);
		return table;
	}
    */

	/**
	 * Returns a Cell based on the styleattributes.
	 * 
	 * @param attributes
	 * @param styleattributes
	 * @return an iText Cell
	 */
    /* ssteward: dropped in 1.44
	private Element retrieveTableRow(Properties attributes,
			Properties styleattributes) {
		SimpleCell row = new SimpleCell(SimpleCell.ROW);
		applyBordersColors(row, attributes, styleattributes);
		String width = null;
		if (attributes != null)
			width = attributes.getProperty(MarkupTags.HTML_ATTR_WIDTH);
		if (width == null)
			width = styleattributes.getProperty(MarkupTags.HTML_ATTR_WIDTH);
		if (width != null) {
			if (width.endsWith("%")) {
				row.setWidthpercentage(parseLength(width));
			} else {
				row.setWidth(parseLength(width));
			}
		}
		String margin = styleattributes.getProperty(MarkupTags.CSS_KEY_MARGIN);
		float f;
		if (margin != null) {
			f = parseLength(margin);
			row.setSpacing(f);
		}
		margin = styleattributes.getProperty(MarkupTags.CSS_KEY_MARGINLEFT);
		if (margin != null) {
			f = parseLength(margin);
			row.setSpacing_left(f);
		}
		margin = styleattributes.getProperty(MarkupTags.CSS_KEY_MARGINRIGHT);
		if (margin != null) {
			f = parseLength(margin);
			row.setSpacing_right(f);
		}
		margin = styleattributes.getProperty(MarkupTags.CSS_KEY_MARGINTOP);
		if (margin != null) {
			f = parseLength(margin);
			row.setSpacing_top(f);
		}
		margin = styleattributes.getProperty(MarkupTags.CSS_KEY_MARGINBOTTOM);
		if (margin != null) {
			f = parseLength(margin);
			row.setSpacing_bottom(f);
		}
		String padding = styleattributes.getProperty(MarkupTags.CSS_KEY_PADDING);
		if (padding != null) {
			f = parseLength(padding);
			row.setPadding(f);
		}
		padding = styleattributes.getProperty(MarkupTags.CSS_KEY_PADDINGLEFT);
		if (padding != null) {
			f = parseLength(padding);
			row.setSpacing_left(f);
		}
		padding = styleattributes.getProperty(MarkupTags.CSS_KEY_PADDINGRIGHT);
		if (padding != null) {
			f = parseLength(padding);
			row.setSpacing_right(f);
		}
		padding = styleattributes.getProperty(MarkupTags.CSS_KEY_PADDINGTOP);
		if (padding != null) {
			f = parseLength(padding);
			row.setSpacing_top(f);
		}
		padding = styleattributes.getProperty(MarkupTags.CSS_KEY_PADDINGBOTTOM);
		if (padding != null) {
			f = parseLength(padding);
			row.setSpacing_bottom(f);
		}
		return row;
	}
    */

	/**
	 * Returns a Cell based on the styleattributes.
	 * 
	 * @param attributes
	 * @param styleattributes
	 * @return an iText Cell
	 */
    /* ssteward: dropped in 1.44
	private Element retrieveTableCell(Properties attributes,
			Properties styleattributes) {
		SimpleCell cell = (SimpleCell) retrieveTableRow(attributes,
				styleattributes);
		cell.setCellgroup(false);
		return cell;
	}
    */

	/**
	 * Returns a ListItem based on the styleattributes.
	 * 
	 * @param font
	 * @param styleattributes
	 * @return an iText ListItem
	 */
	private Element retrieveListItem(Font font, Properties styleattributes) {
		ListItem li = new ListItem();
		return li;
	}

	/**
	 * Applies colors to a Rectangle object.
	 * @param rect
	 * @param attributes
	 * @param styleattributes
	 */
    /* ssteward omit:
	private void applyBordersColors(Rectangle rect, Properties attributes,	Properties styleattributes) {
		String s = styleattributes.getProperty(MarkupTags.CSS_KEY_BORDERWIDTH);
		float f;
		if (s != null) {
			f = parseLength(s);
			rect.setBorderWidth(f);
		}
		s = styleattributes.getProperty(MarkupTags.CSS_KEY_BORDERWIDTHLEFT);
		if (s != null) {
			f = parseLength(s);
			rect.setBorderWidthLeft(f);
		}
		s = styleattributes.getProperty(MarkupTags.CSS_KEY_BORDERWIDTHRIGHT);
		if (s != null) {
			f = parseLength(s);
			rect.setBorderWidthRight(f);
		}
		s = styleattributes.getProperty(MarkupTags.CSS_KEY_BORDERWIDTHTOP);
		if (s != null) {
			f = parseLength(s);
			rect.setBorderWidthTop(f);
		}
		s = styleattributes.getProperty(MarkupTags.CSS_KEY_BORDERWIDTHBOTTOM);
		if (s != null) {
			f = parseLength(s);
			rect.setBorderWidthBottom(f);
		}
		s = styleattributes.getProperty(MarkupTags.CSS_KEY_BORDERCOLOR);
		if (s != null) {
			rect.setBorderColor(decodeColor(s));
		}
	}
    */

	/**
	 * Retrieves a font from the FontFactory based on some style attributes.
	 * Looks for the font-family, font-size, font-weight, font-style and color.
	 * Takes the default encoding and embedded value.
	 * 
	 * @param styleAttributes
	 *            a Properties object containing keys and values
	 * @return an iText Font object
	 */

	public Font retrieveFont(Properties styleAttributes) {
		String fontname = null;
		String encoding = FontFactory.defaultEncoding;
		boolean embedded = FontFactory.defaultEmbedding;
		float size = Font.UNDEFINED;
		int style = Font.NORMAL;
		Color color = null;
		String value = (String) styleAttributes
				.get(MarkupTags.CSS_KEY_FONTFAMILY);
		if (value != null) {
			if (value.indexOf(",") == -1) {
				fontname = value.trim();
			} else {
				String tmp;
				while (value.indexOf(",") != -1) {
					tmp = value.substring(0, value.indexOf(",")).trim();
					if (FontFactory.isRegistered(tmp)) {
						fontname = tmp;
						break;
					} else {
						value = value.substring(value.indexOf(",") + 1);
					}
				}
			}
		}
		if ((value = (String) styleAttributes.get(MarkupTags.CSS_KEY_FONTSIZE)) != null) {
			size = MarkupParser.parseLength(value);
		}
		if ((value = (String) styleAttributes
				.get(MarkupTags.CSS_KEY_FONTWEIGHT)) != null) {
			style |= Font.getStyleValue(value);
		}
		if ((value = (String) styleAttributes.get(MarkupTags.CSS_KEY_FONTSTYLE)) != null) {
			style |= Font.getStyleValue(value);
		}
		if ((value = (String) styleAttributes.get(MarkupTags.CSS_KEY_COLOR)) != null) {
			color = MarkupParser.decodeColor(value);
		}
		return FontFactory.getFont(fontname, encoding, embedded, size, style,
				color);
	}
} /*
 * $Id: MarkupTags.java,v 1.50 2005/05/03 14:44:38 blowagie Exp $
 * $Name:  $
 *
 * Copyright 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.markup;

/**
 * A class that contains all the possible tagnames and their attributes.
 */

public class MarkupTags {
	
	// iText specific
	
	/** the key for any tag */
	public static final String ITEXT_TAG = "tag";

	// HTML tags

	/** the markup for the body part of a file */
	public static final String HTML_TAG_BODY = "body";
	
	/** The DIV tag. */
	public static final String HTML_TAG_DIV = "div";

	/** This is a possible HTML-tag. */
	public static final String HTML_TAG_LINK = "link";

	/** The SPAN tag. */
	public static final String HTML_TAG_SPAN = "span";

	// HTML attributes

	/** the height attribute. */
	public static final String HTML_ATTR_HEIGHT = "height";

	/** the hyperlink reference attribute. */
	public static final String HTML_ATTR_HREF = "href";

	/** This is a possible HTML attribute for the LINK tag. */
	public static final String HTML_ATTR_REL = "rel";

	/** This is used for inline css style information */
	public static final String HTML_ATTR_STYLE = "style";

	/** This is a possible HTML attribute for the LINK tag. */
	public static final String HTML_ATTR_TYPE = "type";

	/** This is a possible HTML attribute. */
	public static final String HTML_ATTR_STYLESHEET = "stylesheet";

	/** the width attribute. */
	public static final String HTML_ATTR_WIDTH = "width";

	/** attribute for specifying externally defined CSS class */
	public static final String HTML_ATTR_CSS_CLASS = "class";

	/** The ID attribute. */
	public static final String HTML_ATTR_CSS_ID = "id";

	// HTML values
	
	/** This is a possible value for the language attribute (SCRIPT tag). */
	public static final String HTML_VALUE_JAVASCRIPT = "text/javascript";
	
	/** This is a possible HTML attribute for the LINK tag. */
	public static final String HTML_VALUE_CSS = "text/css";

	// CSS keys

	/** the CSS tag for background color */
	public static final String CSS_KEY_BGCOLOR = "background-color";

	/** the CSS tag for text color */
	public static final String CSS_KEY_COLOR = "color";

	/** CSS key that indicate the way something has to be displayed */
	public static final String CSS_KEY_DISPLAY = "display";

	/** the CSS tag for the font family */
	public static final String CSS_KEY_FONTFAMILY = "font-family";

	/** the CSS tag for the font size */
	public static final String CSS_KEY_FONTSIZE = "font-size";

	/** the CSS tag for the font style */
	public static final String CSS_KEY_FONTSTYLE = "font-style";

	/** the CSS tag for the font weight */
	public static final String CSS_KEY_FONTWEIGHT = "font-weight";

	/** the CSS tag for text decorations */
	public static final String CSS_KEY_LINEHEIGHT = "line-height";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_MARGIN = "margin";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_MARGINLEFT = "margin-left";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_MARGINRIGHT = "margin-right";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_MARGINTOP = "margin-top";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_MARGINBOTTOM = "margin-bottom";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_PADDING = "padding";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_PADDINGLEFT = "padding-left";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_PADDINGRIGHT = "padding-right";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_PADDINGTOP = "padding-top";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_PADDINGBOTTOM = "padding-bottom";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_BORDERCOLOR = "border-color";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_BORDERWIDTH = "border-width";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_BORDERWIDTHLEFT = "border-left-width";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_BORDERWIDTHRIGHT = "border-right-width";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_BORDERWIDTHTOP = "border-top-width";

	/** the CSS tag for the margin of an object */
	public static final String CSS_KEY_BORDERWIDTHBOTTOM = "border-bottom-width";

	/** the CSS tag for adding a page break when the document is printed */
	public static final String CSS_KEY_PAGE_BREAK_AFTER = "page-break-after";

	/** the CSS tag for adding a page break when the document is printed */
	public static final String CSS_KEY_PAGE_BREAK_BEFORE = "page-break-before";

	/** the CSS tag for the horizontal alignment of an object */
	public static final String CSS_KEY_TEXTALIGN = "text-align";

	/** the CSS tag for text decorations */
	public static final String CSS_KEY_TEXTDECORATION = "text-decoration";

	/** the CSS tag for text decorations */
	public static final String CSS_KEY_VERTICALALIGN = "vertical-align";

	/** the CSS tag for the visibility of objects */
	public static final String CSS_KEY_VISIBILITY = "visibility";

	// CSS values

	/** value for the CSS tag for adding a page break when the document is printed */
	public static final String CSS_VALUE_ALWAYS = "always";

	/** A possible value for the DISPLAY key */
	public static final String CSS_VALUE_BLOCK = "block";

	/** a CSS value for text font weight */
	public static final String CSS_VALUE_BOLD = "bold";

	/** the value if you want to hide objects. */
	public static final String CSS_VALUE_HIDDEN = "hidden";

	/** A possible value for the DISPLAY key */
	public static final String CSS_VALUE_INLINE = "inline";
	
	/** a CSS value for text font style */
	public static final String CSS_VALUE_ITALIC = "italic";

	/** a CSS value for text decoration */
	public static final String CSS_VALUE_LINETHROUGH = "line-through";

	/** A possible value for the DISPLAY key */
	public static final String CSS_VALUE_LISTITEM = "list-item";
	
	/** a CSS value */
	public static final String CSS_VALUE_NONE = "none";

	/** a CSS value */
	public static final String CSS_VALUE_NORMAL = "normal";

	/** a CSS value for text font style */
	public static final String CSS_VALUE_OBLIQUE = "oblique";

	/** A possible value for the DISPLAY key */
	public static final String CSS_VALUE_TABLE = "table";

	/** A possible value for the DISPLAY key */
	public static final String CSS_VALUE_TABLEROW = "table-row";

	/** A possible value for the DISPLAY key */
	public static final String CSS_VALUE_TABLECELL = "table-cell";

	/** the CSS value for a horizontal alignment of an object */
	public static final String CSS_VALUE_TEXTALIGNLEFT = "left";

	/** the CSS value for a horizontal alignment of an object */
	public static final String CSS_VALUE_TEXTALIGNRIGHT = "right";

	/** the CSS value for a horizontal alignment of an object */
	public static final String CSS_VALUE_TEXTALIGNCENTER = "center";

	/** the CSS value for a horizontal alignment of an object */
	public static final String CSS_VALUE_TEXTALIGNJUSTIFY = "justify";

	/** a CSS value for text decoration */
	public static final String CSS_VALUE_UNDERLINE = "underline";

} /*
 * $Id$
 *
 * Copyright 2006 Paulo Soares
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */
package pdftk.com.lowagie.text.pdf.crypto;

import org.bouncycastle.crypto.BlockCipher;
import org.bouncycastle.crypto.engines.AESFastEngine;
import org.bouncycastle.crypto.modes.CBCBlockCipher;
import org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.crypto.params.ParametersWithIV;

/**
 * Creates an AES Cipher with CBC and padding PKCS5/7.
 * @author Paulo Soares (psoares@consiste.pt)
 */
public class AESCipher {
    private PaddedBufferedBlockCipher bp;
    
    /** Creates a new instance of AESCipher */
    public AESCipher(boolean forEncryption, byte[] key, byte[] iv) {
        BlockCipher aes = new AESFastEngine();
        BlockCipher cbc = new CBCBlockCipher(aes);
        bp = new PaddedBufferedBlockCipher(cbc);
        KeyParameter kp = new KeyParameter(key);
        ParametersWithIV piv = new ParametersWithIV(kp, iv);
        bp.init(forEncryption, piv);
    }
    
    public byte[] update(byte[] inp, int inpOff, int inpLen) {
        int neededLen = bp.getUpdateOutputSize(inpLen);
        byte[] outp = null;
        if (neededLen > 0)
            outp = new byte[neededLen];
        else
            neededLen = 0;
        bp.processBytes(inp, inpOff, inpLen, outp, 0);
        return outp;
    }
    
    public byte[] doFinal() {
        int neededLen = bp.getOutputSize(0);
        byte[] outp = new byte[neededLen];
        int n = 0;
        try {
            n = bp.doFinal(outp, 0);
        } catch (Exception ex) {
            return outp;
        }
        if (n != outp.length) {
            byte[] outp2 = new byte[n];
            System.arraycopy(outp, 0, outp2, 0, n);
            return outp2;
        }
        else
            return outp;
    }
    
}
 /*
 * $Id$
 *
 * Copyright 2006 Paulo Soares
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */
package pdftk.com.lowagie.text.pdf.crypto;

public class ARCFOUREncryption {
    private byte state[] = new byte[256];
    private int x;
    private int y;

    /** Creates a new instance of ARCFOUREncryption */
    public ARCFOUREncryption() {
    }
    
    public void prepareARCFOURKey(byte key[]) {
        prepareARCFOURKey(key, 0, key.length);
    }

    public void prepareARCFOURKey(byte key[], int off, int len) {
        int index1 = 0;
        int index2 = 0;
        for (int k = 0; k < 256; ++k)
            state[k] = (byte)k;
        x = 0;
        y = 0;
        byte tmp;
        for (int k = 0; k < 256; ++k) {
            index2 = (key[index1 + off] + state[k] + index2) & 255;
            tmp = state[k];
            state[k] = state[index2];
            state[index2] = tmp;
            index1 = (index1 + 1) % len;
        }
    }

    public void encryptARCFOUR(byte dataIn[], int off, int len, byte dataOut[], int offOut) {
        int length = len + off;
        byte tmp;
        for (int k = off; k < length; ++k) {
            x = (x + 1) & 255;
            y = (state[x] + y) & 255;
            tmp = state[x];
            state[x] = state[y];
            state[y] = tmp;
            dataOut[k - off + offOut] = (byte)(dataIn[k] ^ state[(state[x] + state[y]) & 255]);
        }
    }

    public void encryptARCFOUR(byte data[], int off, int len) {
        encryptARCFOUR(data, off, len, data, off);
    }

    public void encryptARCFOUR(byte dataIn[], byte dataOut[]) {
        encryptARCFOUR(dataIn, 0, dataIn.length, dataOut, 0);
    }

    public void encryptARCFOUR(byte data[]) {
        encryptARCFOUR(data, 0, data.length, data, 0);
    }   
} /*
 * $Id$
 *
 * Copyright 2006 Paulo Soares
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */
package pdftk.com.lowagie.text.pdf.crypto;

/**
 * An initialization vector generator for a CBC block encryption. It's a random generator based on ARCFOUR.
 * @author Paulo Soares (psoares@consiste.pt)
 */
public final class IVGenerator {
    
    private static ARCFOUREncryption arcfour;
    
    static {
        arcfour = new ARCFOUREncryption();
        long time = System.currentTimeMillis();
        long mem = Runtime.getRuntime().freeMemory();
        String s = time + "+" + mem;
        arcfour.prepareARCFOURKey(s.getBytes());
    }
    
    /** Creates a new instance of IVGenerator */
    private IVGenerator() {
    }
    
    /**
     * Gets a 16 byte random initialization vector.
     * @return a 16 byte random initialization vector
     */
    public static byte[] getIV() {
        return getIV(16);
    }
    
    /**
     * Gets a random initialization vector.
     * @param len the length of the initialization vector
     * @return a random initialization vector
     */
    public static byte[] getIV(int len) {
        byte[] b = new byte[len];
        synchronized (arcfour) {
            arcfour.encryptARCFOUR(b);
        }
        return b;
    }    
} /*
 * Copyright 2004 by Paulo Soares.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */
package pdftk.com.lowagie.text.pdf.fonts;

/**
 * A class to facilitate the loading of resources
 *
 * @author Paulo Soares (psoares@consiste.pt)
 */
public class FontsResourceAnchor {
    
    /**
     * Creates a FontsResourceAnchor
     */
    public FontsResourceAnchor() {
    }
    
}
 /*
 * $Id$
 *
 * Copyright 2006 Bruno Lowagie
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf.interfaces;

import pdftk.com.lowagie.text.pdf.PdfAcroForm;
import pdftk.com.lowagie.text.pdf.PdfAnnotation;
import pdftk.com.lowagie.text.pdf.PdfFormField;

public interface PdfAnnotations {

    /**
     * Use this methods to get the AcroForm object.
     * Use this method only if you know what you're doing
     * @return the PdfAcroform object of the PdfDocument
     */
    public PdfAcroForm getAcroForm();
    
    /**
     * Use this methods to add a <CODE>PdfAnnotation</CODE> or a <CODE>PdfFormField</CODE>
     * to the document. Only the top parent of a <CODE>PdfFormField</CODE>
     * needs to be added.
     * @param annot the <CODE>PdfAnnotation</CODE> or the <CODE>PdfFormField</CODE> to add
     */
    public void addAnnotation(PdfAnnotation annot);
    /**
     * Use this method to adds the <CODE>PdfAnnotation</CODE>
     * to the calculation order array.
     * @param annot the <CODE>PdfAnnotation</CODE> to be added
     */
    public void addCalculationOrder(PdfFormField annot);
    
    /**
     * Use this method to set the signature flags.
     * @param f the flags. This flags are ORed with current ones
     */
    public void setSigFlags(int f);
}
 /*
 * $Id$
 *
 * Copyright 2006 Bruno Lowagie
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf.interfaces;

import pdftk.com.lowagie.text.DocumentException;
import pdftk.com.lowagie.text.pdf.PdfAction;
import pdftk.com.lowagie.text.pdf.PdfName;

/**
 * A PDF document can have an open action and other additional actions.
 */

public interface PdfDocumentActions {

    /**
     * When the document opens it will jump to the destination with
     * this name.
     * @param name the name of the destination to jump to
     */
    public void setOpenAction(String name);
    
    /**
     * When the document opens this <CODE>action</CODE> will be
     * invoked.
     * @param action the action to be invoked
     */
    public void setOpenAction(PdfAction action);
    
    /**
     * Additional-actions defining the actions to be taken in
     * response to various trigger events affecting the document
     * as a whole. The actions types allowed are: <CODE>DOCUMENT_CLOSE</CODE>,
     * <CODE>WILL_SAVE</CODE>, <CODE>DID_SAVE</CODE>, <CODE>WILL_PRINT</CODE>
     * and <CODE>DID_PRINT</CODE>.
     *
     * @param actionType the action type
     * @param action the action to execute in response to the trigger
     * @throws DocumentException on invalid action type
     */
    public void setAdditionalAction(PdfName actionType, PdfAction action) throws DocumentException;

} /*
 * $Id$
 *
 * Copyright 2006 Bruno Lowagie
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf.interfaces;

import java.security.cert.Certificate;

import pdftk.com.lowagie.text.DocumentException;

/**
 * Encryption settings are described in section 3.5 (more specifically
 * section 3.5.2) of the PDF Reference 1.7.
 * They are explained in section 3.3.3 of the book 'iText in Action'.
 * The values of the different  preferences were originally stored
 * in class PdfWriter, but they have been moved to this separate interface
 * for reasons of convenience.
 */

public interface PdfEncryptionSettings {

    
    /**
     * Sets the encryption options for this document. The userPassword and the
     * ownerPassword can be null or have zero length. In this case the ownerPassword
     * is replaced by a random string. The open permissions for the document can be
     * AllowPrinting, AllowModifyContents, AllowCopy, AllowModifyAnnotations,
     * AllowFillIn, AllowScreenReaders, AllowAssembly and AllowDegradedPrinting.
     * The permissions can be combined by ORing them.
     * @param userPassword the user password. Can be null or empty
     * @param ownerPassword the owner password. Can be null or empty
     * @param permissions the user permissions
     * @param encryptionType the type of encryption. It can be one of STANDARD_ENCRYPTION_40, STANDARD_ENCRYPTION_128 or ENCRYPTION_AES128.
     * Optionally DO_NOT_ENCRYPT_METADATA can be ored to output the metadata in cleartext
     * @throws DocumentException if the document is already open
     */
    public void setEncryption(byte userPassword[], byte ownerPassword[], int permissions, int encryptionType) throws DocumentException;

    /**
     * Sets the certificate encryption options for this document. An array of one or more public certificates
     * must be provided together with an array of the same size for the permissions for each certificate.
     *  The open permissions for the document can be
     *  AllowPrinting, AllowModifyContents, AllowCopy, AllowModifyAnnotations,
     *  AllowFillIn, AllowScreenReaders, AllowAssembly and AllowDegradedPrinting.
     *  The permissions can be combined by ORing them.
     * Optionally DO_NOT_ENCRYPT_METADATA can be ored to output the metadata in cleartext
     * @param certs the public certificates to be used for the encryption
     * @param permissions the user permissions for each of the certificates
     * @param encryptionType the type of encryption. It can be one of STANDARD_ENCRYPTION_40, STANDARD_ENCRYPTION_128 or ENCRYPTION_AES128.
     * @throws DocumentException if the document is already open
     */
    public void setEncryption(Certificate[] certs, int[] permissions, int encryptionType) throws DocumentException;
} /*
 * $Id$
 *
 * Copyright 2006 Bruno Lowagie
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf.interfaces;

import pdftk.com.lowagie.text.DocumentException;
import pdftk.com.lowagie.text.pdf.PdfAction;
import pdftk.com.lowagie.text.pdf.PdfName;
import pdftk.com.lowagie.text.pdf.PdfTransition;

/**
 * A PDF page can have an open and/or close action.
 */

public interface PdfPageActions {
    
    /**
     * Sets the open and close page additional action.
     * @param actionType the action type. It can be <CODE>PdfWriter.PAGE_OPEN</CODE>
     * or <CODE>PdfWriter.PAGE_CLOSE</CODE>
     * @param action the action to perform
     * @throws DocumentException if the action type is invalid
     */    
    public void setPageAction(PdfName actionType, PdfAction action) throws DocumentException;

    /**
     * Sets the display duration for the page (for presentations)
     * @param seconds   the number of seconds to display the page
     */
    public void setDuration(int seconds);
    
    /**
     * Sets the transition for the page
     * @param transition   the Transition object
     */
    public void setTransition(PdfTransition transition);
}
 /*
 * $Id$
 *
 * Copyright 2006 Bruno Lowagie
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf.interfaces;

public interface PdfRunDirection {
    
    /** Sets the run direction. This is only used as a placeholder
     * as it does not affect anything.
     * @param runDirection the run direction
     */    
    public void setRunDirection(int runDirection);
    
    /** Gets the run direction.
     * @return the run direction
     */    
    public int getRunDirection();
}
 /*
 * $Id$
 *
 * Copyright 2006 Bruno Lowagie
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf.interfaces;

import pdftk.com.lowagie.text.pdf.PdfDeveloperExtension;
import pdftk.com.lowagie.text.pdf.PdfName;

/**
 * The PDF version is described in the PDF Reference 1.7 p92
 * (about the PDF Header) and page 139 (the version entry in
 * the Catalog). You'll also find info about setting the version
 * in the book 'iText in Action' sections 2.1.3 (PDF Header)
 * and 3.3 (Version history).
 */

public interface PdfVersion {
    
    /**
	 * If the PDF Header hasn't been written yet,
	 * this changes the version as it will appear in the PDF Header.
	 * If the PDF header was already written to the OutputStream,
	 * this changes the version as it will appear in the Catalog.
	 * @param version	a character representing the PDF version
	 */
	public void setPdfVersion(char version);
    /**
	 * If the PDF Header hasn't been written yet,
	 * this changes the version as it will appear in the PDF Header,
	 * but only if the parameter refers to a higher version.
	 * If the PDF header was already written to the OutputStream,
	 * this changes the version as it will appear in the Catalog.
	 * @param version	a character representing the PDF version
	 */
	public void setAtLeastPdfVersion(char version);
	/**
	 * Sets the PDF version as it will appear in the Catalog.
	 * Note that this only has effect if you use a later version
	 * than the one that appears in the header; this method
	 * ignores the parameter if you try to set a lower version.
	 * @param version	the PDF name that will be used for the Version key in the catalog
	 */
	public void setPdfVersion(PdfName version);
	/**
	 * Adds a developer extension to the Extensions dictionary
	 * in the Catalog.
	 * @param de	an object that contains the extensions prefix and dictionary
	 * @since	2.1.6
	 */
	public void addDeveloperExtension(PdfDeveloperExtension de);
} /*
 * $Id$
 *
 * Copyright 2006 Bruno Lowagie
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf.interfaces;

import pdftk.com.lowagie.text.pdf.PdfName;
import pdftk.com.lowagie.text.pdf.PdfObject;

/**
 * Viewer preferences are described in section 3.6.1 and 8.1 of the
 * PDF Reference 1.7 (Table 3.25 on p139-142 and Table 8.1 on p579-581).
 * They are explained in section 13.1 of the book 'iText in Action'.
 * The values of the different  preferences were originally stored
 * in class PdfWriter, but they have been moved to this separate interface
 * for reasons of convenience.
 */

public interface PdfViewerPreferences {	
		
    /**
     * Sets the page layout and page mode preferences by ORing one or two of these constants.
     * <p>
     * <ul>
     * <li>The page layout to be used when the document is opened (choose one).
     *   <ul>
     *   <li><b>PAGE_LAYOUT_SINGLE_PAGE</b> - Display one page at a time. (default)
     *   <li><b>PAGE_LAYOUT_ONE_COLUMN</b> - Display the pages in one column.
     *   <li><b>PAGE_LAYOUT_TWO_COLUMN_LEFT</b> - Display the pages in two columns, with
     *       oddnumbered pages on the left.
     *   <li><b>PAGE_LAYOUT_TWO_COLUMN_RIGHT</b> - Display the pages in two columns, with
     *       oddnumbered pages on the right.
     *   <li><b>PAGE_LAYOUT_TWO_PAGE_LEFT</b> - Display the pages two at a time, with
     *       oddnumbered pages on the left.
     *   <li><b>PAGE_LAYOUT_TWO_PAGE_RIGHT</b> - Display the pages two at a time, with
     *       oddnumbered pages on the right.
     *   </ul>
     * <li>The page mode how the document should be displayed
     *     when opened (choose one).
     *   <ul>
     *   <li><b>PAGE_MODE_USE_NONE</b> - Neither document outline nor thumbnail images visible. (default)
     *   <li><b>PAGE_MODE_USE_OUTLINES</b> - Document outline visible.
     *   <li><b>PAGE_MODE_USE_THUMBS</b> - Thumbnail images visible.
     *   <li><b>PAGE_MODE_FULL_SCREEN</b> - Full-screen mode, with no menu bar, window
     *       controls, or any other window visible.
     *   <li><b>PAGE_MODE_USE_OC</b> - Optional content group panel visible
     *   <li><b>PAGE_MODE_USE_ATTACHMENTS</b> - Attachments panel visible
     *   </ul>
     * </ul>
     * For backward compatibility these values are also supported,
     * but it's better to use method <code>addViewerPreference(key, value)</code>
     * if you want to change the following preferences:
     * <ul>
     * <li><b>HIDE_TOOLBAR</b> - A flag specifying whether to hide the viewer application's tool
     *     bars when the document is active.
     * <li><b>HIDE_MENUBAR</b> - A flag specifying whether to hide the viewer application's
     *     menu bar when the document is active.
     * <li><b>HIDE_WINDOW_UI</b> - A flag specifying whether to hide user interface elements in
     *     the document's window (such as scroll bars and navigation controls),
     *     leaving only the document's contents displayed.
     * <li><b>FIT_WINDOW</b> - A flag specifying whether to resize the document's window to
     *     fit the size of the first displayed page.
     * <li><b>CENTER_WINDOW</b> - A flag specifying whether to position the document's window
     *     in the center of the screen.
     * <li><b>DISPLAY_DOC_TITLE</b> - A flag specifying whether to display the document's title
     *     in the top bar.
     * <li>The predominant reading order for text. This entry has no direct effect on the
     *     document's contents or page numbering, but can be used to determine the relative
     *     positioning of pages when displayed side by side or printed <i>n-up</i> (choose one).
     *   <ul>
     *   <li><b>DIRECTION_L2R</b> - Left to right
     *   <li><b>DIRECTION_R2L</b> - Right to left (including vertical writing systems such as
     *       Chinese, Japanese, and Korean)
     *   </ul>
     * <li>The document's page mode, specifying how to display the
     *     document on exiting full-screen mode. It is meaningful only
     *     if the page mode is <b>PageModeFullScreen</b> (choose one).
     *   <ul>
     *   <li><b>NON_FULL_SCREEN_PAGE_MODE_USE_NONE</b> - Neither document outline nor thumbnail images
     *       visible
     *   <li><b>NON_FULL_SCREEN_PAGE_MODE_USE_OUTLINES</b> - Document outline visible
     *   <li><b>NON_FULL_SCREEN_PAGE_MODE_USE_THUMBS</b> - Thumbnail images visible
     *   <li><b>NON_FULL_SCREEN_PAGE_MODE_USE_OC</b> - Optional content group panel visible
     *   </ul>
     * <li><b>PRINT_SCALING_NONE</b> - Indicates that the print dialog should reflect no page scaling.
     * </ul>
     * @param preferences the viewer preferences
	 * @see PdfViewerPreferences#addViewerPreference
     */
    public void setViewerPreferences(int preferences);
    
    /**
     * Adds a viewer preference.
     * <ul>
     * <li>In case the key is one of these values:
     * 		<ul>
     * 			<li>PdfName.<b>HIDETOOLBAR</b>
     * 			<li>PdfName.<b>HIDEMENUBAR</b>
     * 			<li>PdfName.<b>HIDEWINDOWUI</b>
     * 			<li>PdfName.<b>FITWINDOW</b>
     * 			<li>PdfName.<b>CENTERWINDOW</b>
     * 			<li>PdfName.<b>DISPLAYDOCTITLE</b>
     * 		</ul>
     * The value must be a of type PdfBoolean (true or false).
     * <li>In case the key is PdfName.<b>NONFULLSCREENPAGEMODE</b>,
     * the value must be one of these names:
     * 		<ul>
     * 			<li>PdfName.<b>USENONE</b>
     * 			<li>PdfName.<b>USEOUTLINES</b>
     * 			<li>PdfName.<b>USETHUMBS</b>
     * 			<li>PdfName.<b>USEOC</b>
     * 		</ul>
     * <li>In case the key is PdfName.DIRECTION,
     * the value must be one of these names:
     * 		<ul>
     * 			<li>PdfName.<b>L2R</b>
     * 			<li>PdfName.<b>R2L</b>
     * 		</ul>
     * <li>In case the key is one of these values:
     * 		<ul>
     * 			<li>PdfName.<b>VIEWAREA</b>
     * 			<li>PdfName.<b>VIEWCLIP</b>
     * 			<li>PdfName.<b>PRINTAREA</b>
     * 			<li>PdfName.<b>PRINTCLIP</b>
     * 		</ul>
     * 	The value must be one of these names:
     * 		<ul>
     * 			<li>PdfName.<b>MEDIABOX</b>
     * 			<li>PdfName.<b>CROPBOX</b>
     * 			<li>PdfName.<b>BLEEDBOX</b>
     * 			<li>PdfName.<b>TRIMBOX</b>
     * 			<li>PdfName.<b>ARTBOX</b>
     * 		</ul>
     * <li>In case the key is PdfName.<b>PRINTSCALING</b>, the value can be
     * 		<ul>
     * 			<li>PdfName.<b>APPDEFAULT</b>
     * 			<li>PdfName.<b>NONE</b>
     * 		</ul>
     * <li>In case the key is PdfName.<b>DUPLEX</b>, the value can be:
     * 		<ul>
     * 			<li>PdfName.<b>SIMPLEX</b>
     * 			<li>PdfName.<b>DUPLEXFLIPSHORTEDGE</b>
     * 			<li>PdfName.<b>DUPLEXFLIPLONGEDGE</b>
     * 		</ul>
     * <li>In case the key is PdfName.<b>PICKTRAYBYPDFSIZE</b>, the value must be of type PdfBoolean.
     * <li>In case the key is PdfName.<b>PRINTPAGERANGE</b>, the value must be of type PdfArray.
     * <li>In case the key is PdfName.<b>NUMCOPIES</b>, the value must be of type PdfNumber.
     * <ul>
     * </ul>
     * @param key	the name of the viewer preference
     * @param value	the value of the viewer preference
	 * @see PdfViewerPreferences#setViewerPreferences
     */
    public void addViewerPreference(PdfName key, PdfObject value);    	
} /*
 * $Id$
 *
 * Copyright 2006 Bruno Lowagie
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf.interfaces;

public interface PdfXConformance {
    
    /**
     * Sets the PDF/X conformance level.
     * Allowed values are PDFX1A2001, PDFX32002, PDFA1A and PDFA1B.
     * It must be called before opening the document.
     * @param pdfxConformance the conformance level
     */    
    public void setPDFXConformance(int pdfxConformance);

	/**
	 * Getter for the PDF/X Conformance value.
	 * @return the pdfxConformance
	 */
	public int getPDFXConformance();
	
    /**
     * Checks if the PDF/X Conformance is necessary.
     * @return true if the PDF has to be in conformance with any of the PDF/X specifications
     */
    public boolean isPdfX();
}
 /*
 * $Id$
 *
 * Copyright 2006 Bruno Lowagie
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf.internal;

import java.io.IOException;

import pdftk.com.lowagie.text.DocWriter;
import pdftk.com.lowagie.text.pdf.OutputStreamCounter;
import pdftk.com.lowagie.text.pdf.PdfDeveloperExtension;
import pdftk.com.lowagie.text.pdf.PdfDictionary;
import pdftk.com.lowagie.text.pdf.PdfName;
import pdftk.com.lowagie.text.pdf.PdfWriter;
import pdftk.com.lowagie.text.pdf.interfaces.PdfVersion;

/**
 * Stores the PDF version information,
 * knows how to write a PDF Header,
 * and how to add the version to the catalog (if necessary).
 */

public class PdfVersionImp implements PdfVersion {
    
    /** Contains different strings that are part of the header. */
    public static final byte[][] HEADER = {
    	DocWriter.getISOBytes("\n"),
    	DocWriter.getISOBytes("%PDF-"),
    	DocWriter.getISOBytes("\n%\u00e2\u00e3\u00cf\u00d3\n")
    };
    
	/** Indicates if the header was already written. */
	protected boolean headerWasWritten = false;
	/** Indicates if we are working in append mode. */
	protected boolean appendmode = false;
	/** The version that was or will be written to the header. */
	protected char header_version = PdfWriter.VERSION_1_4;
	/** The version that will be written to the catalog. */
	protected PdfName catalog_version = null;
	/**
	 * The extensions dictionary.
	 * @since	2.1.6
	 */
	protected PdfDictionary extensions = null;
	
	/**
	 * @see pdftk.com.lowagie.text.pdf.interfaces.PdfVersion#setPdfVersion(char)
	 */
	public void setPdfVersion(char version) {
		if (headerWasWritten || appendmode) {
			setPdfVersion(getVersionAsName(version));
		}
		else {
			this.header_version = version;
		}
	}
	
	/**
	 * @see pdftk.com.lowagie.text.pdf.interfaces.PdfVersion#setAtLeastPdfVersion(char)
	 */
	public void setAtLeastPdfVersion(char version) {
		if (version > header_version) {
			setPdfVersion(version);
		}
	}
	
	/**
	 * @see pdftk.com.lowagie.text.pdf.interfaces.PdfVersion#setPdfVersion(pdftk.com.lowagie.text.pdf.PdfName)
	 */
	public void setPdfVersion(PdfName version) {
		if (catalog_version == null || catalog_version.compareTo(version) < 0) {
			this.catalog_version = version;
		}
	}
	
	/**
	 * Sets the append mode.
	 */
	public void setAppendmode(boolean appendmode) {
		this.appendmode = appendmode;
	}
	
	/**
	 * Writes the header to the OutputStreamCounter.
	 * @throws IOException 
	 */
	public void writeHeader(OutputStreamCounter os) throws IOException {
		if (appendmode) {
			os.write(HEADER[0]);
		}
		else {
			os.write(HEADER[1]);
			os.write(getVersionAsByteArray(header_version));
			os.write(HEADER[2]);
			headerWasWritten = true;
		}
	}
	
	/**
	 * Returns the PDF version as a name.
	 * @param version	the version character.
	 */
	public PdfName getVersionAsName(char version) {
		switch(version) {
		case PdfWriter.VERSION_1_2:
			return PdfWriter.PDF_VERSION_1_2;
		case PdfWriter.VERSION_1_3:
			return PdfWriter.PDF_VERSION_1_3;
		case PdfWriter.VERSION_1_4:
			return PdfWriter.PDF_VERSION_1_4;
		case PdfWriter.VERSION_1_5:
			return PdfWriter.PDF_VERSION_1_5;
		case PdfWriter.VERSION_1_6:
			return PdfWriter.PDF_VERSION_1_6;
		case PdfWriter.VERSION_1_7:
			return PdfWriter.PDF_VERSION_1_7;
		default:
			return PdfWriter.PDF_VERSION_1_4;
		}
	}
	
	/**
	 * Returns the version as a byte[].
	 * @param version the version character
	 */
	public byte[] getVersionAsByteArray(char version) {
		return DocWriter.getISOBytes(getVersionAsName(version).toString().substring(1));
	}

	/** Adds the version to the Catalog dictionary. */
	public void addToCatalog(PdfDictionary catalog) {
		if(catalog_version != null) {
			catalog.put(PdfName.VERSION, catalog_version);
		}
		if (extensions != null) {
			catalog.put(PdfName.EXTENSIONS, extensions);
		}
	}

	/**
	 * @see pdftk.com.lowagie.text.pdf.interfaces.PdfVersion#addDeveloperExtension(pdftk.com.lowagie.text.pdf.PdfDeveloperExtension)
	 * @since	2.1.6
	 */
	public void addDeveloperExtension(PdfDeveloperExtension de) {
		if (extensions == null) {
			extensions = new PdfDictionary();
		}
		else {
			PdfDictionary extension = extensions.getAsDict(de.getPrefix());
			if (extension != null) {
				int diff = de.getBaseversion().compareTo(extension.getAsName(PdfName.BASEVERSION));
				if (diff < 0)
					return;
				diff = de.getExtensionLevel() - extension.getAsNumber(PdfName.EXTENSIONLEVEL).intValue();
				if (diff <= 0)
					return;
			}
		}
		extensions.put(de.getPrefix(), de.getDeveloperExtensions());
	}
} /*
 * $Id$
 *
 * Copyright 2006 Bruno Lowagie
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf.internal;

import pdftk.com.lowagie.text.pdf.PdfArray;
import pdftk.com.lowagie.text.pdf.PdfBoolean;
import pdftk.com.lowagie.text.pdf.PdfDictionary;
import pdftk.com.lowagie.text.pdf.PdfName;
import pdftk.com.lowagie.text.pdf.PdfNumber;
import pdftk.com.lowagie.text.pdf.PdfObject;
import pdftk.com.lowagie.text.pdf.PdfReader;
import pdftk.com.lowagie.text.pdf.PdfWriter;
import pdftk.com.lowagie.text.pdf.interfaces.PdfViewerPreferences;

/**
 * Stores the information concerning viewer preferences,
 * and contains the business logic that allows you to set viewer preferences.
 */

public class PdfViewerPreferencesImp implements PdfViewerPreferences {
	public static final PdfName[] VIEWER_PREFERENCES = {
			PdfName.HIDETOOLBAR,			// 0
			PdfName.HIDEMENUBAR,            // 1
			PdfName.HIDEWINDOWUI,           // 2
			PdfName.FITWINDOW,              // 3
			PdfName.CENTERWINDOW,			// 4
			PdfName.DISPLAYDOCTITLE,		// 5
			PdfName.NONFULLSCREENPAGEMODE,	// 6
			PdfName.DIRECTION,				// 7
			PdfName.VIEWAREA,				// 8
			PdfName.VIEWCLIP,				// 9
			PdfName.PRINTAREA,				// 10
			PdfName.PRINTCLIP,				// 11
			PdfName.PRINTSCALING,			// 12
			PdfName.DUPLEX,					// 13
			PdfName.PICKTRAYBYPDFSIZE,		// 14
			PdfName.PRINTPAGERANGE,			// 15
			PdfName.NUMCOPIES				// 16
		};


    /** A series of viewer preferences. */
    public static final PdfName NONFULLSCREENPAGEMODE_PREFERENCES[] = {
    	PdfName.USENONE, PdfName.USEOUTLINES, PdfName.USETHUMBS, PdfName.USEOC
    };
    /** A series of viewer preferences. */
    public static final PdfName DIRECTION_PREFERENCES[] = {
    	PdfName.L2R, PdfName.R2L
    };
	/** A series of viewer preferences. */
	public static final PdfName PAGE_BOUNDARIES[] = {
		PdfName.MEDIABOX, PdfName.CROPBOX, PdfName.BLEEDBOX, PdfName.TRIMBOX, PdfName.ARTBOX
	};
	/** A series of viewer preferences */
	public static final PdfName PRINTSCALING_PREFERENCES[] = {
		PdfName.APPDEFAULT, PdfName.NONE
	};
	/** A series of viewer preferences. */
	public static final PdfName DUPLEX_PREFERENCES[] = {
		PdfName.SIMPLEX, PdfName.DUPLEXFLIPSHORTEDGE, PdfName.DUPLEXFLIPLONGEDGE
	};
	
	/** This value will hold the viewer preferences for the page layout and page mode. */
	private int pageLayoutAndMode = 0;
	
	/** This dictionary holds the viewer preferences (other than page layout and page mode). */
	private PdfDictionary viewerPreferences = new PdfDictionary();
	
	/** The mask to decide if a ViewerPreferences dictionary is needed */
	private static final int viewerPreferencesMask = 0xfff000;

	/**
	 * Returns the page layout and page mode value.
	 */
	public int getPageLayoutAndMode() {
		return pageLayoutAndMode;
	}

	/**
	 * Returns the viewer preferences.
	 */
	public PdfDictionary getViewerPreferences() {
		return viewerPreferences;
	}
	
	/**
	 * Sets the viewer preferences as the sum of several constants.
	 * 
	 * @param preferences
	 *            the viewer preferences
	 * @see PdfViewerPreferences#setViewerPreferences
	 */
	public void setViewerPreferences(int preferences) {
		this.pageLayoutAndMode |= preferences;
		// for backwards compatibility, it is also possible
		// to set the following viewer preferences with this method:
		if ((preferences & viewerPreferencesMask) != 0) {
			pageLayoutAndMode = ~viewerPreferencesMask & pageLayoutAndMode;
			if ((preferences & PdfWriter.HideToolbar) != 0)
				viewerPreferences.put(PdfName.HIDETOOLBAR, PdfBoolean.PDFTRUE);
			if ((preferences & PdfWriter.HideMenubar) != 0)
				viewerPreferences.put(PdfName.HIDEMENUBAR, PdfBoolean.PDFTRUE);
			if ((preferences & PdfWriter.HideWindowUI) != 0)
				viewerPreferences.put(PdfName.HIDEWINDOWUI, PdfBoolean.PDFTRUE);
			if ((preferences & PdfWriter.FitWindow) != 0)
				viewerPreferences.put(PdfName.FITWINDOW, PdfBoolean.PDFTRUE);
			if ((preferences & PdfWriter.CenterWindow) != 0)
				viewerPreferences.put(PdfName.CENTERWINDOW, PdfBoolean.PDFTRUE);
			if ((preferences & PdfWriter.DisplayDocTitle) != 0)
				viewerPreferences.put(PdfName.DISPLAYDOCTITLE, PdfBoolean.PDFTRUE);
			
			if ((preferences & PdfWriter.NonFullScreenPageModeUseNone) != 0)
				viewerPreferences.put(PdfName.NONFULLSCREENPAGEMODE, PdfName.USENONE);
			else if ((preferences & PdfWriter.NonFullScreenPageModeUseOutlines) != 0)
				viewerPreferences.put(PdfName.NONFULLSCREENPAGEMODE, PdfName.USEOUTLINES);
			else if ((preferences & PdfWriter.NonFullScreenPageModeUseThumbs) != 0)
				viewerPreferences.put(PdfName.NONFULLSCREENPAGEMODE, PdfName.USETHUMBS);
			else if ((preferences & PdfWriter.NonFullScreenPageModeUseOC) != 0)
				viewerPreferences.put(PdfName.NONFULLSCREENPAGEMODE, PdfName.USEOC);

			if ((preferences & PdfWriter.DirectionL2R) != 0)
				viewerPreferences.put(PdfName.DIRECTION, PdfName.L2R);
			else if ((preferences & PdfWriter.DirectionR2L) != 0)
				viewerPreferences.put(PdfName.DIRECTION, PdfName.R2L);

			if ((preferences & PdfWriter.PrintScalingNone) != 0)
				viewerPreferences.put(PdfName.PRINTSCALING, PdfName.NONE);			
		}
	}
	
	/**
	 * Given a key for a viewer preference (a PdfName object),
	 * this method returns the index in the VIEWER_PREFERENCES array.
	 * @param key	a PdfName referring to a viewer preference
	 * @return	an index in the VIEWER_PREFERENCES array
	 */
	private int getIndex(PdfName key) {
		for (int i = 0; i < VIEWER_PREFERENCES.length; i++) {
			if (VIEWER_PREFERENCES[i].equals(key))
				return i;
		}
		return -1;
	}
	
	/**
	 * Checks if some value is valid for a certain key.
	 */
	private boolean isPossibleValue(PdfName value, PdfName[] accepted) {
		for (int i = 0; i < accepted.length; i++) {
			if (accepted[i].equals(value)) {
				return true;
			}
		}
		return false;
	}
	
	/**
	 * Sets the viewer preferences for printing.
	 */
	public void addViewerPreference(PdfName key, PdfObject value) {
		switch(getIndex(key)) {
		case 0: // HIDETOOLBAR
		case 1: // HIDEMENUBAR
		case 2: // HIDEWINDOWUI
		case 3: // FITWINDOW
		case 4: // CENTERWINDOW
		case 5: // DISPLAYDOCTITLE
		case 14: // PICKTRAYBYPDFSIZE
			if (value instanceof PdfBoolean) {
				viewerPreferences.put(key, value);
			}
			break;
		case 6: // NONFULLSCREENPAGEMODE
			if (value instanceof PdfName
					&& isPossibleValue((PdfName)value, NONFULLSCREENPAGEMODE_PREFERENCES)) {
				viewerPreferences.put(key, value);
			}
			break;
		case 7: // DIRECTION
			if (value instanceof PdfName
					&& isPossibleValue((PdfName)value, DIRECTION_PREFERENCES)) {
				viewerPreferences.put(key, value);
			}
			break;
		case 8:  // VIEWAREA
		case 9:  // VIEWCLIP
		case 10: // PRINTAREA
		case 11: // PRINTCLIP
			if (value instanceof PdfName
					&& isPossibleValue((PdfName)value, PAGE_BOUNDARIES)) {
				viewerPreferences.put(key, value);
			}
			break;
		case 12: // PRINTSCALING
			if (value instanceof PdfName
					&& isPossibleValue((PdfName)value, PRINTSCALING_PREFERENCES)) {
				viewerPreferences.put(key, value);
			}
			break;
		case 13: // DUPLEX
			if (value instanceof PdfName
					&& isPossibleValue((PdfName)value, DUPLEX_PREFERENCES)) {
				viewerPreferences.put(key, value);
			}
			break;
		case 15: // PRINTPAGERANGE
			if (value instanceof PdfArray) {
				viewerPreferences.put(key, value);
			}
			break;
		case 16: // NUMCOPIES
			if (value instanceof PdfNumber)  {
				viewerPreferences.put(key, value);
			}
			break;
		}
	}

	/**
	 * Adds the viewer preferences defined in the preferences parameter to a
	 * PdfDictionary (more specifically the root or catalog of a PDF file).
	 * 
	 * @param catalog
	 */
	public void addToCatalog(PdfDictionary catalog) {
		// Page Layout
		catalog.remove(PdfName.PAGELAYOUT);
		if ((pageLayoutAndMode & PdfWriter.PageLayoutSinglePage) != 0)
			catalog.put(PdfName.PAGELAYOUT, PdfName.SINGLEPAGE);
		else if ((pageLayoutAndMode & PdfWriter.PageLayoutOneColumn) != 0)
			catalog.put(PdfName.PAGELAYOUT, PdfName.ONECOLUMN);
		else if ((pageLayoutAndMode & PdfWriter.PageLayoutTwoColumnLeft) != 0)
			catalog.put(PdfName.PAGELAYOUT, PdfName.TWOCOLUMNLEFT);
		else if ((pageLayoutAndMode & PdfWriter.PageLayoutTwoColumnRight) != 0)
			catalog.put(PdfName.PAGELAYOUT, PdfName.TWOCOLUMNRIGHT);
		else if ((pageLayoutAndMode & PdfWriter.PageLayoutTwoPageLeft) != 0)
			catalog.put(PdfName.PAGELAYOUT, PdfName.TWOPAGELEFT);
		else if ((pageLayoutAndMode & PdfWriter.PageLayoutTwoPageRight) != 0)
			catalog.put(PdfName.PAGELAYOUT, PdfName.TWOPAGERIGHT);

		// Page Mode
		catalog.remove(PdfName.PAGEMODE);
		if ((pageLayoutAndMode & PdfWriter.PageModeUseNone) != 0)
			catalog.put(PdfName.PAGEMODE, PdfName.USENONE);
		else if ((pageLayoutAndMode & PdfWriter.PageModeUseOutlines) != 0)
			catalog.put(PdfName.PAGEMODE, PdfName.USEOUTLINES);
		else if ((pageLayoutAndMode & PdfWriter.PageModeUseThumbs) != 0)
			catalog.put(PdfName.PAGEMODE, PdfName.USETHUMBS);
		else if ((pageLayoutAndMode & PdfWriter.PageModeFullScreen) != 0)
			catalog.put(PdfName.PAGEMODE, PdfName.FULLSCREEN);
		else if ((pageLayoutAndMode & PdfWriter.PageModeUseOC) != 0)
			catalog.put(PdfName.PAGEMODE, PdfName.USEOC);
		else if ((pageLayoutAndMode & PdfWriter.PageModeUseAttachments) != 0)
			catalog.put(PdfName.PAGEMODE, PdfName.USEATTACHMENTS);

		// viewer preferences (Table 8.1 of the PDF Reference)
		catalog.remove(PdfName.VIEWERPREFERENCES);
		if (viewerPreferences.size() > 0) {
			catalog.put(PdfName.VIEWERPREFERENCES, viewerPreferences);
		}
	}

	public static PdfViewerPreferencesImp getViewerPreferences(PdfDictionary catalog) {
		PdfViewerPreferencesImp preferences = new PdfViewerPreferencesImp();
		int prefs = 0;
		PdfName name = null;
		// page layout
		PdfObject obj = PdfReader.getPdfObjectRelease(catalog.get(PdfName.PAGELAYOUT));
		if (obj != null && obj.isName()) {
			name = (PdfName) obj;
			if (name.equals(PdfName.SINGLEPAGE))
				prefs |= PdfWriter.PageLayoutSinglePage;
			else if (name.equals(PdfName.ONECOLUMN))
				prefs |= PdfWriter.PageLayoutOneColumn;
			else if (name.equals(PdfName.TWOCOLUMNLEFT))
				prefs |= PdfWriter.PageLayoutTwoColumnLeft;
			else if (name.equals(PdfName.TWOCOLUMNRIGHT))
				prefs |= PdfWriter.PageLayoutTwoColumnRight;
			else if (name.equals(PdfName.TWOPAGELEFT))
				prefs |= PdfWriter.PageLayoutTwoPageLeft;
			else if (name.equals(PdfName.TWOPAGERIGHT))
				prefs |= PdfWriter.PageLayoutTwoPageRight;
		}
		// page mode
		obj = PdfReader.getPdfObjectRelease(catalog.get(PdfName.PAGEMODE));
		if (obj != null && obj.isName()) {
			name = (PdfName) obj;
			if (name.equals(PdfName.USENONE))
				prefs |= PdfWriter.PageModeUseNone;
			else if (name.equals(PdfName.USEOUTLINES))
				prefs |= PdfWriter.PageModeUseOutlines;
			else if (name.equals(PdfName.USETHUMBS))
				prefs |= PdfWriter.PageModeUseThumbs;
			else if (name.equals(PdfName.FULLSCREEN))
				prefs |= PdfWriter.PageModeFullScreen;
			else if (name.equals(PdfName.USEOC))
				prefs |= PdfWriter.PageModeUseOC;
			else if (name.equals(PdfName.USEATTACHMENTS))
				prefs |= PdfWriter.PageModeUseAttachments;
		}
		// set page layout and page mode preferences
		preferences.setViewerPreferences(prefs);
		// other preferences
		obj = PdfReader.getPdfObjectRelease(catalog
				.get(PdfName.VIEWERPREFERENCES));
		if (obj != null && obj.isDictionary()) {
			PdfDictionary vp = (PdfDictionary) obj;
			for (int i = 0; i < VIEWER_PREFERENCES.length; i++) {
				obj = PdfReader.getPdfObjectRelease(vp.get(VIEWER_PREFERENCES[i]));
				preferences.addViewerPreference(VIEWER_PREFERENCES[i], obj);
			}
		}
		return preferences;
	}
} /* -*- Mode: Java; tab-width: 4; c-basic-offset: 4 -*- */
/*
 * Copyright 2003 by Paulo Soares.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */
package pdftk.com.lowagie.text.pdf;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Iterator;
import java.util.Comparator;
import java.util.Collections;
import pdftk.com.lowagie.text.Rectangle;
import pdftk.com.lowagie.text.Element;
import pdftk.com.lowagie.text.ExceptionConverter;
import pdftk.com.lowagie.text.DocumentException;
import java.io.IOException;
import java.io.InputStream;
import java.awt.Color;

/** Query and change fields in existing documents either by method
 * calls or by FDF merging.
 * @author Paulo Soares (psoares@consiste.pt)
 */
public class AcroFields {

    PdfReader reader;
    PdfWriter writer;
    HashMap fields;
    private int topFirst;
    private HashMap sigNames;
    private boolean append;
    static private final int DA_FONT = 0;
    static private final int DA_SIZE = 1;
    static private final int DA_COLOR = 2;
    /**
     * A field type invalid or not found.
     */    
    public static final int FIELD_TYPE_NONE = 0;
    /**
     * A field type.
     */    
    public static final int FIELD_TYPE_PUSHBUTTON = 1;
    /**
     * A field type.
     */    
    public static final int FIELD_TYPE_CHECKBOX = 2;
    /**
     * A field type.
     */    
    public static final int FIELD_TYPE_RADIOBUTTON = 3;
    /**
     * A field type.
     */    
    public static final int FIELD_TYPE_TEXT = 4;
    /**
     * A field type.
     */    
    public static final int FIELD_TYPE_LIST = 5;
    /**
     * A field type.
     */    
    public static final int FIELD_TYPE_COMBO = 6;
    /**
     * A field type.
     */    
    public static final int FIELD_TYPE_SIGNATURE = 7;
    
    private boolean lastWasString;
    
    /** Holds value of property generateAppearances. */
    private boolean generateAppearances = true;
    
    private HashMap localFonts = new HashMap();
    
    private float extraMarginLeft;
    private float extraMarginTop;
    
    AcroFields(PdfReader reader, PdfWriter writer) {
        this.reader = reader;
        this.writer = writer;
        if (writer instanceof PdfStamperImp) {
            append = ((PdfStamperImp)writer).isAppend();
        }
        fill();
    }

    void fill() {
        fields = new HashMap();
        PdfDictionary top = (PdfDictionary)PdfReader.getPdfObjectRelease(reader.getCatalog().get(PdfName.ACROFORM));
        if (top == null)
            return;
        PdfArray arrfds = (PdfArray)PdfReader.getPdfObjectRelease(top.get(PdfName.FIELDS));
        if (arrfds == null || arrfds.size() == 0)
            return;
        arrfds = null;
        for (int k = 1; k <= reader.getNumberOfPages(); ++k) {
            if ((k % 100) == 0)
                System.out.println(k);
            PdfDictionary page = reader.getPageNRelease(k);
            PdfArray annots = (PdfArray)PdfReader.getPdfObjectRelease(page.get(PdfName.ANNOTS), page);
            if (annots == null)
                continue;
            ArrayList arr = annots.getArrayList();
            for (int j = 0; j < arr.size(); ++j) {
                PdfObject annoto = PdfReader.getPdfObject((PdfObject)arr.get(j), annots);
                if ((annoto instanceof PdfIndirectReference) && !annoto.isIndirect()) {
                    PdfReader.releaseLastXrefPartial((PdfObject)arr.get(j));
                    continue;
                }
				// ssteward: because we've seen a PDF where an annot array item was null
				if( !annoto.isDictionary() )
					continue;
                PdfDictionary annot = (PdfDictionary)annoto;
                if (!PdfName.WIDGET.equals(annot.get(PdfName.SUBTYPE))) {
                    PdfReader.releaseLastXrefPartial((PdfObject)arr.get(j));
                    continue;
                }
                PdfDictionary widget = annot;
                PdfDictionary dic = new PdfDictionary();
                dic.putAll(annot);
                String name = "";
                PdfDictionary value = null;
                PdfObject lastV = null;
                while (annot != null) {
                    dic.mergeDifferent(annot);
                    PdfString t = (PdfString)PdfReader.getPdfObject(annot.get(PdfName.T));
                    if (t != null)
                        name = t.toUnicodeString() + "." + name;
                    if (lastV == null && annot.get(PdfName.V) != null)
                        lastV = PdfReader.getPdfObjectRelease(annot.get(PdfName.V));
                    if (value == null &&  t != null) {
                        value = annot;
                        if (annot.get(PdfName.V) == null && lastV  != null)
                            value.put(PdfName.V, lastV);
                    }
					annot = (PdfDictionary)PdfReader.getPdfObject(annot.get(PdfName.PARENT), annot);
                }
                if (name.length() > 0)
                    name = name.substring(0, name.length() - 1);
                Item item = (Item)fields.get(name);
                if (item == null) {
                    item = new Item();
                    fields.put(name, item);
                }
                if (value == null)
                    item.values.add(widget);
                else
                    item.values.add(value);
                item.widgets.add(widget);
                item.widget_refs.add(arr.get(j)); // must be a reference
                if (top != null)
                    dic.mergeDifferent(top);
                item.merged.add(dic);
                item.page.add(new Integer(k));
                item.tabOrder.add(new Integer(j));
            }
        }
    }
    
    /** Gets the list of appearance names. Use it to get the names allowed
     * with radio and checkbox fields. If the /Opt key exists the values will
     * also be included. The name 'Off' may also be valid
     * even if not returned in the list.
     * @param fieldName the fully qualified field name
     * @return the list of names or <CODE>null</CODE> if the field does not exist
     */    
    public String[] getAppearanceStates(String fieldName) {
        Item fd = (Item)fields.get(fieldName);
        if (fd == null)
            return null;
        HashMap names = new HashMap();
        PdfDictionary vals = (PdfDictionary)fd.values.get(0);
        PdfObject opts = PdfReader.getPdfObject(vals.get(PdfName.OPT));
        if (opts != null) {
            if (opts.isString())
                names.put(((PdfString)opts).toUnicodeString(), null);
            else if (opts.isArray()) {
                ArrayList list = ((PdfArray)opts).getArrayList();
                for (int k = 0; k < list.size(); ++k) {
                    PdfObject v = PdfReader.getPdfObject((PdfObject)list.get(k));
                    if (v != null && v.isString())
                        names.put(((PdfString)v).toUnicodeString(), null);
                }
            }
        }
        ArrayList wd = fd.widgets;
        for (int k = 0; k < wd.size(); ++k) {
            PdfDictionary dic = (PdfDictionary)wd.get(k);
            dic = (PdfDictionary)PdfReader.getPdfObject(dic.get(PdfName.AP));
            if (dic == null)
                continue;
            PdfObject ob = PdfReader.getPdfObject(dic.get(PdfName.N));
            if (ob == null || !ob.isDictionary())
                continue;
            dic = (PdfDictionary)ob;
            for (Iterator it = dic.getKeys().iterator(); it.hasNext();) {
                String name = PdfName.decodeName(((PdfName)it.next()).toString());
                names.put(name, null);
            }
        }
        String out[] = new String[names.size()];
        return (String[])names.keySet().toArray(out);
    }
    
    /**
     * Gets the field type. The type can be one of: <CODE>FIELD_TYPE_PUSHBUTTON</CODE>,
     * <CODE>FIELD_TYPE_CHECKBOX</CODE>, <CODE>FIELD_TYPE_RADIOBUTTON</CODE>,
     * <CODE>FIELD_TYPE_TEXT</CODE>, <CODE>FIELD_TYPE_LIST</CODE>,
     * <CODE>FIELD_TYPE_COMBO</CODE> or <CODE>FIELD_TYPE_SIGNATURE</CODE>.
     * <p>
     * If the field does not exist or is invalid it returns
     * <CODE>FIELD_TYPE_NONE</CODE>.
     * @param fieldName the field name
     * @return the field type
     */    
    public int getFieldType(String fieldName) {
        Item fd = (Item)fields.get(fieldName);
        if (fd == null)
            return FIELD_TYPE_NONE;
        PdfObject type = PdfReader.getPdfObject(((PdfDictionary)fd.merged.get(0)).get(PdfName.FT));
        if (type == null)
            return FIELD_TYPE_NONE;
        int ff = 0;
        PdfObject ffo = PdfReader.getPdfObject(((PdfDictionary)fd.merged.get(0)).get(PdfName.FF));
        if (ffo != null && ffo.type() == PdfObject.NUMBER)
            ff = ((PdfNumber)ffo).intValue();
        if (PdfName.BTN.equals(type)) {
            if ((ff & PdfFormField.FF_PUSHBUTTON) != 0)
                return FIELD_TYPE_PUSHBUTTON;
            if ((ff & PdfFormField.FF_RADIO) != 0)
                return FIELD_TYPE_RADIOBUTTON;
            else
                return FIELD_TYPE_CHECKBOX;
        }
        else if (PdfName.TX.equals(type)) {
            return FIELD_TYPE_TEXT;
        }
        else if (PdfName.CH.equals(type)) {
            if ((ff & PdfFormField.FF_COMBO) != 0)
                return FIELD_TYPE_COMBO;
            else
                return FIELD_TYPE_LIST;
        }
        else if (PdfName.SIG.equals(type)) {
            return FIELD_TYPE_SIGNATURE;
        }
        return FIELD_TYPE_NONE;
    }
    
    /**
     * Export the fields as a FDF.
     * @param writer the FDF writer
     */    
    public void exportAsFdf(FdfWriter writer) {
        for (Iterator it = fields.entrySet().iterator(); it.hasNext();) {
            Map.Entry entry = (Map.Entry)it.next();
            // ssteward omit: Item item = (Item)entry.getValue();
            String name = (String)entry.getKey();
            // PdfObject v = PdfReader.getPdfObject(((PdfDictionary)item.merged.get(0)).get(PdfName.V));
			// ssteward: moved this logic to getField, where lastWasString is set;
			// we also want to output empty fields, too;
            //if (v != null)
			String value = getField(name);
            if (lastWasString)
                writer.setFieldAsString(name, value);
            else /* ssteward: TODO: if (!value.isEmpty())*/
                writer.setFieldAsName(name, value);
        }
    }
    
    /**
     * Renames a field. Only the last part of the name can be renamed. For example,
     * if the original field is "ab.cd.ef" only the "ef" part can be renamed.
     * @param oldName the old field name
     * @param newName the new field name
     * @return <CODE>true</CODE> if the renaming was successful, <CODE>false</CODE>
     * otherwise
     */    
    public boolean renameField(String oldName, String newName) {
        int idx1 = oldName.lastIndexOf('.') + 1;
        int idx2 = newName.lastIndexOf('.') + 1;
        if (idx1 != idx2)
            return false;
        if (!oldName.substring(0, idx1).equals(newName.substring(0, idx2)))
            return false;
        if (fields.containsKey(newName))
            return false;
        Item item = (Item)fields.get(oldName);
        if (item == null)
            return false;
        newName = newName.substring(idx2);
        PdfString ss = new PdfString(newName, PdfObject.TEXT_UNICODE);
        for (int k = 0; k < item.merged.size(); ++k) {
            PdfDictionary dic = (PdfDictionary)item.values.get(k);
            dic.put(PdfName.T, ss);
            markUsed(dic);
            dic = (PdfDictionary)item.merged.get(k);
            dic.put(PdfName.T, ss);
        }
        fields.remove(oldName);
        fields.put(newName, item);
        return true;
    }
    
    static private Object[] splitDAelements(String da) {
        try {
            PRTokeniser tk = new PRTokeniser(PdfEncodings.convertToBytes(da, null));
            ArrayList stack = new ArrayList();
            Object ret[] = new Object[3];
            while (tk.nextToken()) {
                if (tk.getTokenType() == PRTokeniser.TK_COMMENT)
                    continue;
                if (tk.getTokenType() == PRTokeniser.TK_OTHER) {
                    String operator = tk.getStringValue();
                    if (operator.equals("Tf")) {
                        if (stack.size() >= 2) {
                            ret[DA_FONT] = stack.get(stack.size() - 2);
                            ret[DA_SIZE] = new Float((String)stack.get(stack.size() - 1));
                        }
                    }
                    else if (operator.equals("g")) {
                        if (stack.size() >= 1) {
                            float gray = new Float((String)stack.get(stack.size() - 1)).floatValue();
                            if (gray != 0)
                                ret[DA_COLOR] = new GrayColor(gray);
                        }
                    }
                    else if (operator.equals("rg")) {
                        if (stack.size() >= 3) {
                            float red = new Float((String)stack.get(stack.size() - 3)).floatValue();
                            float green = new Float((String)stack.get(stack.size() - 2)).floatValue();
                            float blue = new Float((String)stack.get(stack.size() - 1)).floatValue();
                            ret[DA_COLOR] = new Color(red, green, blue);
                        }
                    }
                    else if (operator.equals("k")) {
                        if (stack.size() >= 4) {
                            float cyan = new Float((String)stack.get(stack.size() - 4)).floatValue();
                            float magenta = new Float((String)stack.get(stack.size() - 3)).floatValue();
                            float yellow = new Float((String)stack.get(stack.size() - 2)).floatValue();
                            float black = new Float((String)stack.get(stack.size() - 1)).floatValue();
                            ret[DA_COLOR] = new CMYKColor(cyan, magenta, yellow, black);
                        }
                    }
                    stack.clear();
                }
                else
                    stack.add(tk.getStringValue());
            }
            return ret;
        }
        catch (IOException ioe) {
            throw new ExceptionConverter(ioe);
        }
    }
    
    PdfAppearance getAppearance(PdfDictionary merged, String text, String fieldName) throws IOException, DocumentException {
        topFirst = 0;
        int flags = 0;
        TextField tx = null;
        if (fieldCache == null || !fieldCache.containsKey(fieldName)) {
            tx = new TextField(writer, null, null);
            tx.setExtraMargin(extraMarginLeft, extraMarginTop);
            tx.setBorderWidth(0);
            // the text size and color
            PdfString da = (PdfString)PdfReader.getPdfObject(merged.get(PdfName.DA));
            if (da != null) {
                Object dab[] = splitDAelements(da.toUnicodeString());
                if (dab[DA_SIZE] != null)
                    tx.setFontSize(((Float)dab[DA_SIZE]).floatValue());
                if (dab[DA_COLOR] != null)
                    tx.setTextColor((Color)dab[DA_COLOR]);
                if (dab[DA_FONT] != null) {
                    PdfDictionary font = (PdfDictionary)PdfReader.getPdfObject(merged.get(PdfName.DR));
                    if (font != null) {
                        font = (PdfDictionary)PdfReader.getPdfObject(font.get(PdfName.FONT));
                        if (font != null) {
                            PdfObject po = font.get(new PdfName((String)dab[DA_FONT]));
                            if (po != null && po.type() == PdfObject.INDIRECT)
                                tx.setFont(new DocumentFont((PRIndirectReference)po));
                            else {
                                BaseFont bf = (BaseFont)localFonts.get(dab[DA_FONT]);
                                if (bf == null) {
                                    String fn[] = (String[])stdFieldFontNames.get(dab[DA_FONT]);
                                    if (fn != null) {
                                        try {
                                            String enc = "winansi";
                                            if (fn.length > 1)
                                                enc = fn[1];
                                            bf = BaseFont.createFont(fn[0], enc, false);
                                            tx.setFont(bf);
                                        }
                                        catch (Exception e) {
                                            // empty
                                        }
                                    }
                                }
                                else
                                    tx.setFont(bf);
                            }
                        }
                    }
                }
            }
            //rotation, border and backgound color
            PdfDictionary mk = (PdfDictionary)PdfReader.getPdfObject(merged.get(PdfName.MK));
            if (mk != null) {
                PdfArray ar = (PdfArray)PdfReader.getPdfObject(mk.get(PdfName.BC));
                Color border = getMKColor(ar);
                tx.setBorderColor(border);
                if (border != null)
                    tx.setBorderWidth(1);
                ar = (PdfArray)PdfReader.getPdfObject(mk.get(PdfName.BG));
                tx.setBackgroundColor(getMKColor(ar));
                PdfNumber rotation = (PdfNumber)PdfReader.getPdfObject(mk.get(PdfName.R));
                if (rotation != null)
                    tx.setRotation(rotation.intValue());
            }
            //multiline
            PdfNumber nfl = (PdfNumber)PdfReader.getPdfObject(merged.get(PdfName.FF));
            if (nfl != null)
                flags = nfl.intValue();
            tx.setOptions(((flags & PdfFormField.FF_MULTILINE) == 0 ? 0 : TextField.MULTILINE) | ((flags & PdfFormField.FF_COMB) == 0 ? 0 : TextField.COMB));
            if ((flags & PdfFormField.FF_COMB) != 0) {
                PdfNumber maxLen = (PdfNumber)PdfReader.getPdfObject(merged.get(PdfName.MAXLEN));
                int len = 0;
                if (maxLen != null)
                    len = maxLen.intValue();
                tx.setMaxCharacterLength(len);
            }
            //alignment
            nfl = (PdfNumber)PdfReader.getPdfObject(merged.get(PdfName.Q));
            if (nfl != null) {
                if (nfl.intValue() == PdfFormField.Q_CENTER)
                    tx.setAlignment(Element.ALIGN_CENTER);
                else if (nfl.intValue() == PdfFormField.Q_RIGHT)
                    tx.setAlignment(Element.ALIGN_RIGHT);
            }
            //border styles
            PdfDictionary bs = (PdfDictionary)PdfReader.getPdfObject(merged.get(PdfName.BS));
            if (bs != null) {
                PdfNumber w = (PdfNumber)PdfReader.getPdfObject(bs.get(PdfName.W));
                if (w != null)
                    tx.setBorderWidth(w.floatValue());
                PdfName s = (PdfName)PdfReader.getPdfObject(bs.get(PdfName.S));
                if (PdfName.D.equals(s))
                    tx.setBorderStyle(PdfBorderDictionary.STYLE_DASHED);
                else if (PdfName.B.equals(s))
                    tx.setBorderStyle(PdfBorderDictionary.STYLE_BEVELED);
                else if (PdfName.I.equals(s))
                    tx.setBorderStyle(PdfBorderDictionary.STYLE_INSET);
                else if (PdfName.U.equals(s))
                    tx.setBorderStyle(PdfBorderDictionary.STYLE_UNDERLINE);
            }
            else {
                PdfArray bd = (PdfArray)PdfReader.getPdfObject(merged.get(PdfName.BORDER));
                if (bd != null) {
                    ArrayList ar = bd.getArrayList();
                    if (ar.size() >= 3)
                        tx.setBorderWidth(((PdfNumber)ar.get(2)).floatValue());
                    if (ar.size() >= 4)
                        tx.setBorderStyle(PdfBorderDictionary.STYLE_DASHED);
                }
            }
            //rect
            PdfArray rect = (PdfArray)PdfReader.getPdfObject(merged.get(PdfName.RECT));
            Rectangle box = PdfReader.getNormalizedRectangle(rect);
            if (tx.getRotation() == 90 || tx.getRotation() == 270)
                box = box.rotate();
            tx.setBox(box);
            if (fieldCache != null)
                fieldCache.put(fieldName, tx);
        }
        else {
            tx = (TextField)fieldCache.get(fieldName);
            tx.setWriter(writer);
        }
        PdfName fieldType = (PdfName)PdfReader.getPdfObject(merged.get(PdfName.FT));
        if (PdfName.TX.equals(fieldType)) {
            tx.setText(text);
            return tx.getAppearance();
        }
        if (!PdfName.CH.equals(fieldType))
            throw new DocumentException("An appearance was requested without a variable text field.");
        PdfArray opt = (PdfArray)PdfReader.getPdfObject(merged.get(PdfName.OPT));
        if ((flags & PdfFormField.FF_COMBO) != 0 && opt == null) {
            tx.setText(text);
            return tx.getAppearance();
        }
        if (opt != null) {
            ArrayList op = opt.getArrayList();
            String choices[] = new String[op.size()];
            String choicesExp[] = new String[op.size()];
            for (int k = 0; k < op.size(); ++k) {
                PdfObject obj = (PdfObject)op.get(k);
                if (obj.isString()) {
                    choices[k] = choicesExp[k] = ((PdfString)obj).toUnicodeString();
                }
                else {
                    ArrayList opar = ((PdfArray)obj).getArrayList();
                    choicesExp[k] = ((PdfString)opar.get(0)).toUnicodeString();
                    choices[k] = ((PdfString)opar.get(1)).toUnicodeString();
                }
            }
            if ((flags & PdfFormField.FF_COMBO) != 0) {
                for (int k = 0; k < choices.length; ++k) {
                    if (text.equals(choicesExp[k])) {
                        text = choices[k];
                        break;
                    }
                }
                tx.setText(text);
                return tx.getAppearance();
            }
            int idx = 0;
            for (int k = 0; k < choicesExp.length; ++k) {
                if (text.equals(choicesExp[k])) {
                    idx = k;
                    break;
                }
            }
            tx.setChoices(choices);
            tx.setChoiceExports(choicesExp);
            tx.setChoiceSelection(idx);
        }
        PdfAppearance app = tx.getListAppearance();
        topFirst = tx.getTopFirst();
        return app;
    }
    
    Color getMKColor(PdfArray ar) {
        if (ar == null)
            return null;
        ArrayList cc = ar.getArrayList();
        switch (cc.size()) {
            case 1:
                return new GrayColor(((PdfNumber)cc.get(0)).floatValue());
            case 3:
                return new Color(((PdfNumber)cc.get(0)).floatValue(), ((PdfNumber)cc.get(1)).floatValue(), ((PdfNumber)cc.get(2)).floatValue());
            case 4:
                return new CMYKColor(((PdfNumber)cc.get(0)).floatValue(), ((PdfNumber)cc.get(1)).floatValue(), ((PdfNumber)cc.get(2)).floatValue(), ((PdfNumber)cc.get(3)).floatValue());
            default:
                return null;
        }
    }
    
    /** Gets the field value.
     * @param name the fully qualified field name
     * @return the field value
     */    
    public String getField(String name) {
        Item item = (Item)fields.get(name);
        if (item == null)
            return null;
        lastWasString = true; // ssteward: default was false
        PdfObject v = PdfReader.getPdfObject(((PdfDictionary)item.merged.get(0)).get(PdfName.V));
		// ssteward: test VT before returning
        //if (v == null)
        //    return "";
        PdfName type = (PdfName)PdfReader.getPdfObject(((PdfDictionary)item.merged.get(0)).get(PdfName.FT));
        if (PdfName.BTN.equals(type)) {
			lastWasString = false; // ssteward
            PdfNumber ff = (PdfNumber)PdfReader.getPdfObject(((PdfDictionary)item.merged.get(0)).get(PdfName.FF));
            int flags = 0;
            if (ff != null)
                flags = ff.intValue();
            if ((flags & PdfFormField.FF_PUSHBUTTON) != 0)
                return "";
            String value = "";
			if (v != null) { // ssteward
				if (v.isName())
					value = PdfName.decodeName(v.toString());
				else if (v.isString())
					value = ((PdfString)v).toUnicodeString();
			}
            PdfObject opts = PdfReader.getPdfObject(((PdfDictionary)item.values.get(0)).get(PdfName.OPT));
            if (opts != null && opts.isArray()) {
                ArrayList list = ((PdfArray)opts).getArrayList();
                int idx = 0;
                try {
                    idx = Integer.parseInt(value);
                    PdfString ps = (PdfString)list.get(idx);
                    value = ps.toUnicodeString();
                    lastWasString = true;
                }
                catch (Exception e) {
                }
            }
            return value;
        }

		if (v == null) { // ssteward
			return "";
		}
        if (v.isString()) {
            return ((PdfString)v).toUnicodeString();
        }
		lastWasString = false;
        return PdfName.decodeName(v.toString());
    }

    /**
     * Sets a field property. Valid property names are:
     * <p>
     * <ul>
     * <li>textfont - sets the text font. The value for this entry is a <CODE>BaseFont</CODE>.<br>
     * <li>textcolor - sets the text color. The value for this entry is a <CODE>java.awt.Color</CODE>.<br>
     * <li>textsize - sets the text size. The value for this entry is a <CODE>Float</CODE>.
     * <li>bgcolor - sets the background color. The value for this entry is a <CODE>java.awt.Color</CODE>.
     *     If <code>null</code> removes the background.<br>
     * <li>bordercolor - sets the border color. The value for this entry is a <CODE>java.awt.Color</CODE>.
     *     If <code>null</code> removes the border.<br>
     * </ul>
     * @param field the field name
     * @param name the property name
     * @param value the property value
     * @param inst an array of <CODE>int</CODE> indexing into <CODE>AcroField.Item.merged</CODE> elements to process.
     * Set to <CODE>null</CODE> to process all
     * @return <CODE>true</CODE> if the property exists, <CODE>false</CODE> otherwise
     */    
    public boolean setFieldProperty(String field, String name, Object value, int inst[]) {
        if (writer == null)
            throw new RuntimeException("This AcroFields instance is read-only.");
        try {
            Item item = (Item)fields.get(field);
            if (item == null)
                return false;
            InstHit hit = new InstHit(inst);
            if (name.equalsIgnoreCase("textfont")) {
                for (int k = 0; k < item.merged.size(); ++k) {
                    if (hit.isHit(k)) {
                        PdfString da = (PdfString)PdfReader.getPdfObject(((PdfDictionary)item.merged.get(k)).get(PdfName.DA));
                        PdfDictionary dr = (PdfDictionary)PdfReader.getPdfObject(((PdfDictionary)item.merged.get(k)).get(PdfName.DR));
                        if (da != null && dr != null) {
                            Object dao[] = splitDAelements(da.toUnicodeString());
                            PdfAppearance cb = new PdfAppearance();
                            if (dao[DA_FONT] != null) {
                                BaseFont bf = (BaseFont)value;
                                PdfName psn = (PdfName)PdfAppearance.stdFieldFontNames.get(bf.getPostscriptFontName());
                                if (psn == null) {
                                    psn = new PdfName(bf.getPostscriptFontName());
                                }
                                PdfDictionary fonts = (PdfDictionary)PdfReader.getPdfObject(dr.get(PdfName.FONT));
                                if (fonts == null) {
                                    fonts = new PdfDictionary();
                                    dr.put(PdfName.FONT, fonts);
                                }
                                PdfIndirectReference fref = (PdfIndirectReference)fonts.get(psn);
                                PdfDictionary top = (PdfDictionary)PdfReader.getPdfObject(reader.getCatalog().get(PdfName.ACROFORM));
                                markUsed(top);
                                dr = (PdfDictionary)PdfReader.getPdfObject(top.get(PdfName.DR));
                                if (dr == null) {
                                    dr = new PdfDictionary();
                                    top.put(PdfName.DR, dr);
                                }
                                markUsed(dr);
                                PdfDictionary fontsTop = (PdfDictionary)PdfReader.getPdfObject(dr.get(PdfName.FONT));
                                if (fontsTop == null) {
                                    fontsTop = new PdfDictionary();
                                    dr.put(PdfName.FONT, fontsTop);
                                }
                                markUsed(fontsTop);
                                PdfIndirectReference frefTop = (PdfIndirectReference)fontsTop.get(psn);
                                if (frefTop != null) {
                                    if (fref == null)
                                        fonts.put(psn, frefTop);
                                }
                                else if (fref == null) {
                                    FontDetails fd;
                                    if (bf.getFontType() == BaseFont.FONT_TYPE_DOCUMENT) {
                                        fd = new FontDetails(null, ((DocumentFont)bf).getIndirectReference(), bf);
                                    }
                                    else {
                                        bf.setSubset(false);
                                        fd = writer.addSimple(bf);
                                        localFonts.put(psn.toString().substring(1), bf);
                                    }
                                    fontsTop.put(psn, fd.getIndirectReference());
                                    fonts.put(psn, fd.getIndirectReference());
                                }
                                ByteBuffer buf = cb.getInternalBuffer();
                                buf.append(psn.getBytes()).append(' ').append(((Float)dao[DA_SIZE]).floatValue()).append(" Tf ");
                                if (dao[DA_COLOR] != null)
                                    cb.setColorFill((Color)dao[DA_COLOR]);
                                PdfString s = new PdfString(cb.toString());
                                ((PdfDictionary)item.merged.get(k)).put(PdfName.DA, s);
                                ((PdfDictionary)item.widgets.get(k)).put(PdfName.DA, s);
                                markUsed((PdfDictionary)item.widgets.get(k));
                            }
                        }
                    }
                }
            }
            else if (name.equalsIgnoreCase("textcolor")) {
                for (int k = 0; k < item.merged.size(); ++k) {
                    if (hit.isHit(k)) {
                        PdfString da = (PdfString)PdfReader.getPdfObject(((PdfDictionary)item.merged.get(k)).get(PdfName.DA));
                        if (da != null) {
                            Object dao[] = splitDAelements(da.toUnicodeString());
                            PdfAppearance cb = new PdfAppearance();
                            if (dao[DA_FONT] != null) {
                                ByteBuffer buf = cb.getInternalBuffer();
                                buf.append(new PdfName((String)dao[DA_FONT]).getBytes()).append(' ').append(((Float)dao[DA_SIZE]).floatValue()).append(" Tf ");
                                cb.setColorFill((Color)value);
                                PdfString s = new PdfString(cb.toString());
                                ((PdfDictionary)item.merged.get(k)).put(PdfName.DA, s);
                                ((PdfDictionary)item.widgets.get(k)).put(PdfName.DA, s);
                                markUsed((PdfDictionary)item.widgets.get(k));
                            }
                        }
                    }
                }
            }
            else if (name.equalsIgnoreCase("textsize")) {
                for (int k = 0; k < item.merged.size(); ++k) {
                    if (hit.isHit(k)) {
                        PdfString da = (PdfString)PdfReader.getPdfObject(((PdfDictionary)item.merged.get(k)).get(PdfName.DA));
                        if (da != null) {
                            Object dao[] = splitDAelements(da.toUnicodeString());
                            PdfAppearance cb = new PdfAppearance();
                            if (dao[DA_FONT] != null) {
                                ByteBuffer buf = cb.getInternalBuffer();
                                buf.append(new PdfName((String)dao[DA_FONT]).getBytes()).append(' ').append(((Float)value).floatValue()).append(" Tf ");
                                if (dao[DA_COLOR] != null)
                                    cb.setColorFill((Color)dao[DA_COLOR]);
                                PdfString s = new PdfString(cb.toString());
                                ((PdfDictionary)item.merged.get(k)).put(PdfName.DA, s);
                                ((PdfDictionary)item.widgets.get(k)).put(PdfName.DA, s);
                                markUsed((PdfDictionary)item.widgets.get(k));
                            }
                        }
                    }
                }
            }
            else if (name.equalsIgnoreCase("bgcolor") || name.equalsIgnoreCase("bordercolor")) {
                PdfName dname = (name.equalsIgnoreCase("bgcolor") ? PdfName.BG : PdfName.BC);
                for (int k = 0; k < item.merged.size(); ++k) {
                    if (hit.isHit(k)) {
                        PdfObject obj = PdfReader.getPdfObject(((PdfDictionary)item.merged.get(k)).get(PdfName.MK));
                        markUsed(obj);
                        PdfDictionary mk = (PdfDictionary)obj;
                        if (mk == null) {
                            if (value == null)
                                return true;
                            mk = new PdfDictionary();
                            ((PdfDictionary)item.merged.get(k)).put(PdfName.MK, mk);
                            ((PdfDictionary)item.widgets.get(k)).put(PdfName.MK, mk);
                            markUsed((PdfDictionary)item.widgets.get(k));
                        }
                        if (value == null)
                            mk.remove(dname);
                        else
                            mk.put(dname, PdfFormField.getMKColor((Color)value));
                    }
                }
            }
            else
                return false;
            return true;
        }
        catch (Exception e) {
            throw new ExceptionConverter(e);
        }
    }
    
    /**
     * Sets a field property. Valid property names are:
     * <p>
     * <ul>
     * <li>flags - a set of flags specifying various characteristics of the field's widget annotation.
	 * The value of this entry replaces that of the F entry in the form's corresponding annotation dictionary.<br>
     * <li>setflags - a set of flags to be set (turned on) in the F entry of the form's corresponding
     * widget annotation dictionary. Bits equal to 1 cause the corresponding bits in F to be set to 1.<br>
     * <li>clrflags - a set of flags to be cleared (turned off) in the F entry of the form's corresponding
     * widget annotation dictionary. Bits equal to 1 cause the corresponding
     * bits in F to be set to 0.<br>
     * <li>fflags - a set of flags specifying various characteristics of the field. The value
     * of this entry replaces that of the Ff entry in the form's corresponding field dictionary.<br>
     * <li>setfflags - a set of flags to be set (turned on) in the Ff entry of the form's corresponding
     * field dictionary. Bits equal to 1 cause the corresponding bits in Ff to be set to 1.<br>
     * <li>clrfflags - a set of flags to be cleared (turned off) in the Ff entry of the form's corresponding
     * field dictionary. Bits equal to 1 cause the corresponding bits in Ff
     * to be set to 0.<br>
     * </ul>
     * @param field the field name
     * @param name the property name
     * @param value the property value
     * @param inst an array of <CODE>int</CODE> indexing into <CODE>AcroField.Item.merged</CODE> elements to process.
     * Set to <CODE>null</CODE> to process all
     * @return <CODE>true</CODE> if the property exists, <CODE>false</CODE> otherwise
     */    
    public boolean setFieldProperty(String field, String name, int value, int inst[]) {
        if (writer == null)
            throw new RuntimeException("This AcroFields instance is read-only.");
        Item item = (Item)fields.get(field);
        if (item == null)
            return false;
        InstHit hit = new InstHit(inst);
        if (name.equalsIgnoreCase("flags")) {
            PdfNumber num = new PdfNumber(value);
            for (int k = 0; k < item.merged.size(); ++k) {
                if (hit.isHit(k)) {
                    ((PdfDictionary)item.merged.get(k)).put(PdfName.F, num);
                    ((PdfDictionary)item.widgets.get(k)).put(PdfName.F, num);
                    markUsed((PdfDictionary)item.widgets.get(k));
                }
            }
        }
        else if (name.equalsIgnoreCase("setflags")) {
            for (int k = 0; k < item.merged.size(); ++k) {
                if (hit.isHit(k)) {
                    PdfNumber num = (PdfNumber)PdfReader.getPdfObject(((PdfDictionary)item.widgets.get(k)).get(PdfName.F));
                    int val = 0;
                    if (num != null)
                        val = num.intValue();
                    num = new PdfNumber(val | value);
                    ((PdfDictionary)item.merged.get(k)).put(PdfName.F, num);
                    ((PdfDictionary)item.widgets.get(k)).put(PdfName.F, num);
                    markUsed((PdfDictionary)item.widgets.get(k));
                }
            }
        }
        else if (name.equalsIgnoreCase("clrflags")) {
            for (int k = 0; k < item.merged.size(); ++k) {
                if (hit.isHit(k)) {
                    PdfNumber num = (PdfNumber)PdfReader.getPdfObject(((PdfDictionary)item.widgets.get(k)).get(PdfName.F));
                    int val = 0;
                    if (num != null)
                        val = num.intValue();
                    num = new PdfNumber(val & (~value));
                    ((PdfDictionary)item.merged.get(k)).put(PdfName.F, num);
                    ((PdfDictionary)item.widgets.get(k)).put(PdfName.F, num);
                    markUsed((PdfDictionary)item.widgets.get(k));
                }
            }
        }
        else if (name.equalsIgnoreCase("fflags")) {
            PdfNumber num = new PdfNumber(value);
            for (int k = 0; k < item.merged.size(); ++k) {
                if (hit.isHit(k)) {
                    ((PdfDictionary)item.merged.get(k)).put(PdfName.FF, num);
                    ((PdfDictionary)item.values.get(k)).put(PdfName.FF, num);
                    markUsed((PdfDictionary)item.values.get(k));
                }
            }
        }
        else if (name.equalsIgnoreCase("setfflags")) {
            for (int k = 0; k < item.merged.size(); ++k) {
                if (hit.isHit(k)) {
                    PdfNumber num = (PdfNumber)PdfReader.getPdfObject(((PdfDictionary)item.values.get(k)).get(PdfName.FF));
                    int val = 0;
                    if (num != null)
                        val = num.intValue();
                    num = new PdfNumber(val | value);
                    ((PdfDictionary)item.merged.get(k)).put(PdfName.FF, num);
                    ((PdfDictionary)item.values.get(k)).put(PdfName.FF, num);
                    markUsed((PdfDictionary)item.values.get(k));
                }
            }
        }
        else if (name.equalsIgnoreCase("clrfflags")) {
            for (int k = 0; k < item.merged.size(); ++k) {
                if (hit.isHit(k)) {
                    PdfNumber num = (PdfNumber)PdfReader.getPdfObject(((PdfDictionary)item.values.get(k)).get(PdfName.FF));
                    int val = 0;
                    if (num != null)
                        val = num.intValue();
                    num = new PdfNumber(val & (~value));
                    ((PdfDictionary)item.merged.get(k)).put(PdfName.FF, num);
                    ((PdfDictionary)item.values.get(k)).put(PdfName.FF, num);
                    markUsed((PdfDictionary)item.values.get(k));
                }
            }
        }
        else
            return false;
        return true;
    }
    
    /** Sets the fields by FDF merging.
     * @param fdf the FDF form
     * @throws IOException on error
     * @throws DocumentException on error
     */    
    public boolean setFields(FdfReader fdf) throws IOException, DocumentException {
		boolean ret_val_b= false; // ssteward
        fdf.getFields();
        for (Iterator i = fields.keySet().iterator(); i.hasNext();) {
            String f = (String)i.next();
            String v = fdf.getFieldValue(f);
			String rv = fdf.getFieldRichValue(f); // ssteward
			if (rv != null)
				ret_val_b= true;
            if (v != null)
                setField(f, v, v, rv); // ssteward
        }
		return ret_val_b; // ssteward
    }
    
    /** Sets the fields by XFDF merging.
     * @param xfdf the XFDF form
     * @throws IOException on error
     * @throws DocumentException on error
     */
    public boolean setFields(XfdfReader xfdf) throws IOException, DocumentException {
		boolean ret_val_b= false; // ssteward
        xfdf.getFields();
        for (Iterator i = fields.keySet().iterator(); i.hasNext();) {
            String f = (String)i.next();
            String v = xfdf.getFieldValue(f);
			String rv = xfdf.getFieldRichValue(f); // ssteward
			if (rv != null)
				ret_val_b= true;
            if (v != null)
                setField(f, v, v, rv); // ssteward
        }
		return ret_val_b; // ssteward
    }

    /** Sets the field value.
     * @param name the fully qualified field name
     * @param value the field value
     * @throws IOException on error
     * @throws DocumentException on error
     * @return <CODE>true</CODE> if the field was found and changed,
     * <CODE>false</CODE> otherwise
     */    
    public boolean setField(String name, String value) throws IOException, DocumentException {
        return setField(name, value, value, null); // ssteward
    }
	// ssteward; added for backward compatibility
    public boolean setField(String name, String value, String display) throws IOException, DocumentException {
        return setField(name, value, display, null);
    }
    
    /** Sets the field value and the display string. The display string
     * is used to build the appearance in the cases where the value
     * is modified by Acrobat with JavaScript and the algorithm is
     * known.
     * @param name the fully qualified field name
     * @param value the field value
     * @param display the string that is used for the appearance
	 * @param rich_value (ssteward)
     * @return <CODE>true</CODE> if the field was found and changed,
     * <CODE>false</CODE> otherwise
     * @throws IOException on error
     * @throws DocumentException on error
     */    
    public boolean setField(String name, String value, String display, String rich_value) throws IOException, DocumentException {
        if (writer == null)
            throw new DocumentException("This AcroFields instance is read-only.");
        Item item = (Item)fields.get(name);
        if (item == null)
            return false;
        PdfName type = (PdfName)PdfReader.getPdfObject(((PdfDictionary)item.merged.get(0)).get(PdfName.FT));
        if (PdfName.TX.equals(type)) {
            PdfNumber maxLen = (PdfNumber)PdfReader.getPdfObject(((PdfDictionary)item.merged.get(0)).get(PdfName.MAXLEN));
            int len = 0;
            if (maxLen != null)
                len = maxLen.intValue();
            if (len > 0)
                value = value.substring(0, Math.min(len, value.length()));
        }
        if (PdfName.TX.equals(type) || PdfName.CH.equals(type)) {
            PdfString v = new PdfString(value, PdfObject.TEXT_UNICODE);
			// ssteward
			PdfString rv = null;
			if( rich_value != null )
				rv = new PdfString(rich_value, PdfObject.TEXT_UNICODE); // ssteward
            for (int idx = 0; idx < item.values.size(); ++idx) {

				PdfDictionary item_value= (PdfDictionary)item.values.get(idx);
                item_value.put(PdfName.V, v);
                markUsed(item_value);
				if( rich_value != null ) // ssteward
					item_value.put(PdfName.RV, rv);
				item_value.remove(PdfName.I); // ssteward; it might disagree w/ V in a Ch widget
				// PDF spec this shouldn't matter, but Reader 9 gives I precedence over V

                PdfDictionary merged = (PdfDictionary)item.merged.get(idx);
                merged.put(PdfName.V, v);
				if( rich_value != null ) // ssteward
					merged.put(PdfName.RV, rv);
				merged.remove(PdfName.I); // ssteward
				
                PdfDictionary widget = (PdfDictionary)item.widgets.get(idx);
                if (generateAppearances) {
                    PdfAppearance app = getAppearance(merged, display, name);
                    if (PdfName.CH.equals(type)) {
                        PdfNumber n = new PdfNumber(topFirst);
                        widget.put(PdfName.TI, n);
                        merged.put(PdfName.TI, n);
                    }
                    PdfDictionary appDic = (PdfDictionary)PdfReader.getPdfObject(widget.get(PdfName.AP));
                    if (appDic == null) {
                        appDic = new PdfDictionary();
                        widget.put(PdfName.AP, appDic);
                        merged.put(PdfName.AP, appDic);
                    }
                    appDic.put(PdfName.N, app.getIndirectReference());
                    writer.releaseTemplate(app);
                }
                else {
                    widget.remove(PdfName.AP);
                    merged.remove(PdfName.AP);
                }
                markUsed(widget);
            }
            return true;
        }
        else if (PdfName.BTN.equals(type)) {
            PdfNumber ff = (PdfNumber)PdfReader.getPdfObject(((PdfDictionary)item.merged.get(0)).get(PdfName.FF));
            int flags = 0;
            if (ff != null)
                flags = ff.intValue();
            if ((flags & PdfFormField.FF_PUSHBUTTON) != 0)
                return true;
            PdfName v = new PdfName(value);
            if ((flags & PdfFormField.FF_RADIO) == 0) {
                for (int idx = 0; idx < item.values.size(); ++idx) {
                    ((PdfDictionary)item.values.get(idx)).put(PdfName.V, v);
                    markUsed((PdfDictionary)item.values.get(idx));
                    PdfDictionary merged = (PdfDictionary)item.merged.get(idx);
                    merged.put(PdfName.V, v);
                    merged.put(PdfName.AS, v);
                    PdfDictionary widget = (PdfDictionary)item.widgets.get(idx);
                    if (isInAP(widget,  v))
                        widget.put(PdfName.AS, v);
                    else
                        widget.put(PdfName.AS, PdfName.Off);
                    markUsed(widget);
                }
            }
            else {
                ArrayList lopt = new ArrayList();
                PdfObject opts = PdfReader.getPdfObject(((PdfDictionary)item.values.get(0)).get(PdfName.OPT));
                if (opts != null && opts.isArray()) {
                    ArrayList list = ((PdfArray)opts).getArrayList();
                    for (int k = 0; k < list.size(); ++k) {
                        PdfObject vv = PdfReader.getPdfObject((PdfObject)list.get(k));
                        if (vv != null && vv.isString())
                            lopt.add(((PdfString)vv).toUnicodeString());
                        else
                            lopt.add(null);
                    }
                }
                int vidx = lopt.indexOf(value);
                PdfName valt = null;
                PdfName vt;
                if (vidx >= 0) {
                    vt = valt = new PdfName(String.valueOf(vidx));
                }
                else
                    vt = v;
                for (int idx = 0; idx < item.values.size(); ++idx) {
                    PdfDictionary merged = (PdfDictionary)item.merged.get(idx);
                    PdfDictionary widget = (PdfDictionary)item.widgets.get(idx);
                    markUsed((PdfDictionary)item.values.get(idx));
                    if (valt != null) {
                        PdfString ps = new PdfString(value, PdfObject.TEXT_UNICODE);
                        ((PdfDictionary)item.values.get(idx)).put(PdfName.V, ps);
                        merged.put(PdfName.V, ps);
                    }
                    else {
                        ((PdfDictionary)item.values.get(idx)).put(PdfName.V, v);
                        merged.put(PdfName.V, v);
                    }
                    markUsed(widget);
                    if (isInAP(widget,  vt)) {
                        merged.put(PdfName.AS, vt);
                        widget.put(PdfName.AS, vt);
                    }
                    else {
                        merged.put(PdfName.AS, PdfName.Off);
                        widget.put(PdfName.AS, PdfName.Off);
                    }
                }
            }
            return true;
        }
        return false;
    }
    
    boolean isInAP(PdfDictionary dic, PdfName check) {
        PdfDictionary appDic = (PdfDictionary)PdfReader.getPdfObject(dic.get(PdfName.AP));
        if (appDic == null)
            return false;
        PdfDictionary NDic = (PdfDictionary)PdfReader.getPdfObject(appDic.get(PdfName.N));
        return (NDic != null && NDic.get(check) != null);
    }
    
    /** Gets all the fields. The fields are keyed by the fully qualified field name and
     * the value is an instance of <CODE>AcroFields.Item</CODE>.
     * @return all the fields
     */    
    public HashMap getFields() {
        return fields;
    }
    
    /**
     * Gets the field structure.
     * @param name the name of the field
     * @return the field structure or <CODE>null</CODE> if the field
     * does not exist
     */    
    public Item getFieldItem(String name) {
        return (Item)fields.get(name);
    }
    
    /**
     * Gets the field box positions in the document. The return is an array of <CODE>float</CODE>
     * multiple of 5. For each of this groups the values are: [page, llx, lly, urx,
     * ury].
     * @param name the field name
     * @return the positions or <CODE>null</CODE> if field does not exist
     */    
    public float[] getFieldPositions(String name) {
        Item item = (Item)fields.get(name);
        if (item == null)
            return null;
        float ret[] = new float[item.page.size() * 5];
        int ptr = 0;
        for (int k = 0; k < item.page.size(); ++k) {
            try {
                PdfDictionary wd = (PdfDictionary)item.widgets.get(k);
                PdfArray rect = (PdfArray)wd.get(PdfName.RECT);
                if (rect == null)
                    continue;
                Rectangle r = PdfReader.getNormalizedRectangle(rect);
                ret[ptr] = ((Integer)item.page.get(k)).floatValue();
                ++ptr;
                ret[ptr++] = r.left();
                ret[ptr++] = r.bottom();
                ret[ptr++] = r.right();
                ret[ptr++] = r.top();
            }
            catch (Exception e) {
                // empty on purpose
            }
        }
        if (ptr < ret.length) {
            float ret2[] = new float[ptr];
            System.arraycopy(ret, 0, ret2, 0, ptr);
            return ret2;
        }
        return ret;
    }
    
    private int removeRefFromArray(PdfArray array, PdfObject refo) {
        ArrayList ar = array.getArrayList();
        if (refo == null || !refo.isIndirect())
            return ar.size();
        PdfIndirectReference ref = (PdfIndirectReference)refo;
        for (int j = 0; j < ar.size(); ++j) {
            PdfObject obj = (PdfObject)ar.get(j);
            if (!obj.isIndirect())
                continue;
            if (((PdfIndirectReference)obj).getNumber() == ref.getNumber())
                ar.remove(j--);
        }
        return ar.size();
    }
    
    /**
     * Removes all the fields from <CODE>page</CODE>.
     * @param page the page to remove the fields from
     * @return <CODE>true</CODE> if any field was removed, <CODE>false otherwise</CODE>
     */    
    public boolean removeFieldsFromPage(int page) {
        if (page < 1)
            return false;
        String names[] = new String[fields.size()];
        fields.keySet().toArray(names);
        boolean found = false;
        for (int k = 0; k < names.length; ++k) {
            boolean fr = removeField(names[k], page);
            found = (found || fr);
        }
        return found;
    }
    
    /**
     * Removes a field from the document. If page equals -1 all the fields with this
     * <CODE>name</CODE> are removed from the document otherwise only the fields in
     * that particular page are removed.
     * @param name the field name
     * @param page the page to remove the field from or -1 to remove it from all the pages
     * @return <CODE>true</CODE> if the field exists, <CODE>false otherwise</CODE>
     */    
    public boolean removeField(String name, int page) {
        Item item = (Item)fields.get(name);
        if (item == null)
            return false;
        PdfDictionary acroForm = (PdfDictionary)PdfReader.getPdfObject(reader.getCatalog().get(PdfName.ACROFORM), reader.getCatalog());
        
        if (acroForm == null)
            return false;
        PdfArray arrayf = (PdfArray)PdfReader.getPdfObject(acroForm.get(PdfName.FIELDS), acroForm);
        if (arrayf == null)
            return false;
        for (int k = 0; k < item.widget_refs.size(); ++k) {
            int pageV = ((Integer)item.page.get(k)).intValue();
            if (page != -1 && page != pageV)
                continue;
            PdfIndirectReference ref = (PdfIndirectReference)item.widget_refs.get(k);
            PdfDictionary wd = (PdfDictionary)PdfReader.getPdfObject(ref);
            PdfDictionary pageDic = reader.getPageN(pageV);
            PdfArray annots = (PdfArray)PdfReader.getPdfObject(pageDic.get(PdfName.ANNOTS), pageDic);
            if (annots != null) {
                if (removeRefFromArray(annots, ref) == 0) {
                    pageDic.remove(PdfName.ANNOTS);
                    markUsed(pageDic);
                }
                else
                    markUsed(annots);
            }
            PdfReader.killIndirect(ref);
            PdfIndirectReference kid = ref;
            while ((ref = (PdfIndirectReference)wd.get(PdfName.PARENT)) != null) {
                wd = (PdfDictionary)PdfReader.getPdfObject(ref);
                PdfArray kids = (PdfArray)PdfReader.getPdfObject(wd.get(PdfName.KIDS));
                if (removeRefFromArray(kids, kid) != 0)
                    break;
                kid = ref;
                PdfReader.killIndirect(ref);
            }
            if (ref == null) {
                removeRefFromArray(arrayf, kid);
                markUsed(arrayf);
            }
            if (page != -1) {
                item.merged.remove(k);
                item.page.remove(k);
                item.values.remove(k);
                item.widget_refs.remove(k);
                item.widgets.remove(k);
                --k;
            }
        }
        if (page == -1 || item.merged.size() == 0)
            fields.remove(name);
        return true;
    }
    
    /**
     * Removes a field from the document.
     * @param name the field name
     * @return <CODE>true</CODE> if the field exists, <CODE>false otherwise</CODE>
     */    
    public boolean removeField(String name) {
        return removeField(name, -1);
    }
    
    /** Gets the property generateAppearances.
     * @return the property generateAppearances
     */
    public boolean isGenerateAppearances() {
        return this.generateAppearances;
    }
    
    /** Sets the option to generate appearances. Not generating apperances
     * will speed-up form filling but the results can be
     * unexpected in Acrobat. Don't use it unless your environment is well
     * controlled. The default is <CODE>true</CODE>.
     * @param generateAppearances the option to generate appearances
     */
    public void setGenerateAppearances(boolean generateAppearances) {
        this.generateAppearances = generateAppearances;
        PdfDictionary top = (PdfDictionary)PdfReader.getPdfObject(reader.getCatalog().get(PdfName.ACROFORM));
        if (generateAppearances)
            top.remove(PdfName.NEEDAPPEARANCES);
        else
            top.put(PdfName.NEEDAPPEARANCES, PdfBoolean.PDFTRUE);
    }
    
    /** The field representations for retrieval and modification. */    
    public static class Item {
        /** An array of <CODE>PdfDictionary</CODE> where the value tag /V
         * is present.
         */        
        public ArrayList values = new ArrayList();
        /** An array of <CODE>PdfDictionary</CODE> with the widgets.
         */        
        public ArrayList widgets = new ArrayList();
        /** An array of <CODE>PdfDictionary</CODE> with the widget references.
         */
        public ArrayList widget_refs = new ArrayList();
        /** An array of <CODE>PdfDictionary</CODE> with all the field
         * and widget tags merged.
         */        
        public ArrayList merged = new ArrayList();
        /** An array of <CODE>Integer</CODE> with the page numbers where
         * the widgets are displayed.
         */        
        public ArrayList page = new ArrayList();
        /** An array of <CODE>Integer</CODE> with the tab order of the field in the page.
         */        
        public ArrayList tabOrder = new ArrayList();
    }
    
    private static class InstHit {
        IntHashtable hits;
        public InstHit(int inst[]) {
            if (inst == null)
                return;
            hits = new IntHashtable();
            for (int k = 0; k < inst.length; ++k)
                hits.put(inst[k], 1);
        }
        
        public boolean isHit(int n) {
            if (hits == null)
                return true;
            return hits.containsKey(n);
        }
    }
    
    /**
     * Gets the field names that have signatures and are signed.
     * @return the field names that have signatures and are signed
     */    
    public ArrayList getSignatureNames() {
        if (sigNames != null)
            return new ArrayList(sigNames.keySet());
        sigNames = new HashMap();
        ArrayList sorter = new ArrayList();
        for (Iterator it = fields.entrySet().iterator(); it.hasNext();) {
            Map.Entry entry = (Map.Entry)it.next();
            Item item = (Item)entry.getValue();
            PdfDictionary merged = (PdfDictionary)item.merged.get(0);
            if (!PdfName.SIG.equals(merged.get(PdfName.FT)))
                continue;
            PdfObject vo = PdfReader.getPdfObject(merged.get(PdfName.V));
            if (vo == null || vo.type() != PdfObject.DICTIONARY)
                continue;
            PdfDictionary v = (PdfDictionary)vo;
            PdfObject contents = v.get(PdfName.CONTENTS);
            if (contents == null || contents.type() != PdfObject.STRING)
                continue;
            PdfObject ro = v.get(PdfName.BYTERANGE);
            if (ro == null || ro.type() != PdfObject.ARRAY)
                continue;
            ArrayList ra = ((PdfArray)ro).getArrayList();
            if (ra.size() < 2)
                continue;
            int length = ((PdfNumber)ra.get(ra.size() - 1)).intValue() + ((PdfNumber)ra.get(ra.size() - 2)).intValue();
            sorter.add(new Object[]{entry.getKey(), new int[]{length, 0}});
        }
        Collections.sort(sorter, new AcroFields.SorterComparator());
        if (sorter.size() > 0) {
            if (((int[])((Object[])sorter.get(sorter.size() - 1))[1])[0] == reader.getFileLength())
                totalRevisions = sorter.size();
            else
                totalRevisions = sorter.size() + 1;
            for (int k = 0; k < sorter.size(); ++k) {
                Object objs[] = (Object[])sorter.get(k);
                String name = (String)objs[0];
                int p[] = (int[])objs[1];
                p[1] = k + 1;
                sigNames.put(name, p);
            }
        }
        return new ArrayList(sigNames.keySet());
    }
    
    /**
     * Gets the field names that have blank signatures.
     * @return the field names that have blank signatures
     */    
    public ArrayList getBlankSignatureNames() {
        getSignatureNames();
        ArrayList sigs = new ArrayList();
        for (Iterator it = fields.entrySet().iterator(); it.hasNext();) {
            Map.Entry entry = (Map.Entry)it.next();
            Item item = (Item)entry.getValue();
            PdfDictionary merged = (PdfDictionary)item.merged.get(0);
            if (!PdfName.SIG.equals(merged.get(PdfName.FT)))
                continue;
            if (sigNames.containsKey(entry.getKey()))
                continue;
            sigs.add(entry.getKey());
        }
        return sigs;
    }
    
    /**
     * Gets the signature dictionary, the one keyed by /V.
     * @param name the field name
     * @return the signature dictionary keyed by /V or <CODE>null</CODE> if the field is not
     * a signature
     */    
    public PdfDictionary getSignatureDictionary(String name) {
        getSignatureNames();
        if (!sigNames.containsKey(name))
            return null;
        Item item = (Item)fields.get(name);
        PdfDictionary merged = (PdfDictionary)item.merged.get(0);
        // PdfObject vo = PdfReader.getPdfObject(merged.get(PdfName.V));
        return (PdfDictionary)PdfReader.getPdfObject(merged.get(PdfName.V));
    }
    
    /**
     * Checks is the signature covers the entire document or just part of it.
     * @param name the signature field name
     * @return <CODE>true</CODE> if the signature covers the entire document,
     * <CODE>false</CODE> otherwise
     */    
    public boolean signatureCoversWholeDocument(String name) {
        getSignatureNames();
        if (!sigNames.containsKey(name))
            return false;
        return ((int[])sigNames.get(name))[0] == reader.getFileLength();
    }
    
    /**
     * Verifies a signature. An example usage is:
     * <p>
     * <pre>
     * KeyStore kall = PdfPKCS7.loadCacertsKeyStore();
     * PdfReader reader = new PdfReader("my_signed_doc.pdf");
     * AcroFields af = reader.getAcroFields();
     * ArrayList names = af.getSignatureNames();
     * for (int k = 0; k &lt; names.size(); ++k) {
     *    String name = (String)names.get(k);
     *    System.out.println("Signature name: " + name);
     *    System.out.println("Signature covers whole document: " + af.signatureCoversWholeDocument(name));
     *    PdfPKCS7 pk = af.verifySignature(name);
     *    Calendar cal = pk.getSignDate();
     *    Certificate pkc[] = pk.getCertificates();
     *    System.out.println("Subject: " + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));
     *    System.out.println("Document modified: " + !pk.verify());
     *    Object fails[] = PdfPKCS7.verifyCertificates(pkc, kall, null, cal);
     *    if (fails == null)
     *        System.out.println("Certificates verified against the KeyStore");
     *    else
     *        System.out.println("Certificate failed: " + fails[1]);
     * }
     * </pre>
     * @param name the signature field name
     * @return a <CODE>PdfPKCS7</CODE> class to continue the verification
     */    
    public PdfPKCS7 verifySignature(String name) {
        return verifySignature(name, null);
    }
    
    /**
     * Verifies a signature. An example usage is:
     * <p>
     * <pre>
     * KeyStore kall = PdfPKCS7.loadCacertsKeyStore();
     * PdfReader reader = new PdfReader("my_signed_doc.pdf");
     * AcroFields af = reader.getAcroFields();
     * ArrayList names = af.getSignatureNames();
     * for (int k = 0; k &lt; names.size(); ++k) {
     *    String name = (String)names.get(k);
     *    System.out.println("Signature name: " + name);
     *    System.out.println("Signature covers whole document: " + af.signatureCoversWholeDocument(name));
     *    PdfPKCS7 pk = af.verifySignature(name);
     *    Calendar cal = pk.getSignDate();
     *    Certificate pkc[] = pk.getCertificates();
     *    System.out.println("Subject: " + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));
     *    System.out.println("Document modified: " + !pk.verify());
     *    Object fails[] = PdfPKCS7.verifyCertificates(pkc, kall, null, cal);
     *    if (fails == null)
     *        System.out.println("Certificates verified against the KeyStore");
     *    else
     *        System.out.println("Certificate failed: " + fails[1]);
     * }
     * </pre>
     * @param name the signature field name
     * @param provider the provider or <code>null</code> for the default provider
     * @return a <CODE>PdfPKCS7</CODE> class to continue the verification
     */    
    public PdfPKCS7 verifySignature(String name, String provider) {
        PdfDictionary v = getSignatureDictionary(name);
        if (v == null)
            return null;
        try {
            PdfName sub = (PdfName)PdfReader.getPdfObject(v.get(PdfName.SUBFILTER));
            PdfString contents = (PdfString)PdfReader.getPdfObject(v.get(PdfName.CONTENTS));
            PdfPKCS7 pk = null;
            if (sub.equals(PdfName.ADBE_X509_RSA_SHA1)) {
                PdfString cert = (PdfString)PdfReader.getPdfObject(v.get(PdfName.CERT));
                pk = new PdfPKCS7(contents.getOriginalBytes(), cert.getBytes(), provider);
            }
            else
                pk = new PdfPKCS7(contents.getOriginalBytes(), provider);
            updateByteRange(pk, v);
            PdfString str = (PdfString)PdfReader.getPdfObject(v.get(PdfName.M));
            if (str != null)
                pk.setSignDate(PdfDate.decode(str.toString()));
            str = (PdfString)PdfReader.getPdfObject(v.get(PdfName.NAME));
            if (str != null)
                pk.setSignName(str.toUnicodeString());
            str = (PdfString)PdfReader.getPdfObject(v.get(PdfName.REASON));
            if (str != null)
                pk.setReason(str.toUnicodeString());
            str = (PdfString)PdfReader.getPdfObject(v.get(PdfName.LOCATION));
            if (str != null)
                pk.setLocation(str.toUnicodeString());
            return pk;
        }
        catch (Exception e) {
            throw new ExceptionConverter(e);
        }
    }
    
    private void updateByteRange(PdfPKCS7 pkcs7, PdfDictionary v) throws IOException {
        PdfArray b = (PdfArray)PdfReader.getPdfObject(v.get(PdfName.BYTERANGE));
        RandomAccessFileOrArray rf = reader.getSafeFile();
        try {
            rf.reOpen();
            byte buf[] = new byte[8192];
            ArrayList ar = b.getArrayList();
            for (int k = 0; k < ar.size(); ++k) {
                int start = ((PdfNumber)ar.get(k)).intValue();
                int length = ((PdfNumber)ar.get(++k)).intValue();
                rf.seek(start);
                while (length > 0) {
                    int rd = rf.read(buf, 0, Math.min(length, buf.length));
                    if (rd <= 0)
                        break;
                    length -= rd;
                    pkcs7.update(buf, 0, rd);
                }
            }
        }
        catch (Exception e) {
            throw new ExceptionConverter(e);
        }
        finally {
            try{rf.close();}catch(Exception e){}
        }
    }

    private void markUsed(PdfObject obj) {
        if (!append)
            return;
        ((PdfStamperImp)writer).markUsed(obj);
    }
    
    /**
     * Gets the total number of revisions this document has.
     * @return the total number of revisions
     */
    public int getTotalRevisions() {
        getSignatureNames();
        return this.totalRevisions;
    }
    
    /**
     * Gets this <CODE>field</CODE> revision.
     * @param field the signature field name
     * @return the revision or zero if it's not a signature field
     */    
    public int getRevision(String field) {
        getSignatureNames();
        if (!sigNames.containsKey(field))
            return 0;
        return ((int[])sigNames.get(field))[1];
    }
    
    /**
     * Extracts a revision from the document.
     * @param field the signature field name
     * @return an <CODE>InputStream</CODE> covering the revision. Returns <CODE>null</CODE> if
     * it's not a signature field
     * @throws IOException on error
     */    
    public InputStream extractRevision(String field) throws IOException {
        getSignatureNames();
        int length = ((int[])sigNames.get(field))[0];
        RandomAccessFileOrArray raf = reader.getSafeFile();
        raf.reOpen();
        raf.seek(0);
        return new RevisionStream(raf, length);
    }

    /**
     * Gets the appearances cache.
     * @return the appearances cache
     */
    public HashMap getFieldCache() {
        return this.fieldCache;
    }
    
    /**
     * Sets a cache for field appearances. Parsing the existing PDF to
     * create a new TextField is time expensive. For those tasks that repeatedly
     * fill the same PDF with different field values the use of the cache has dramatic
     * speed advantages. An example usage:
     * <p>
     * <pre>
     * String pdfFile = ...;// the pdf file used as template
     * ArrayList xfdfFiles = ...;// the xfdf file names
     * ArrayList pdfOutFiles = ...;// the output file names, one for each element in xpdfFiles
     * HashMap cache = new HashMap();// the appearances cache
     * PdfReader originalReader = new PdfReader(pdfFile);
     * for (int k = 0; k &lt; xfdfFiles.size(); ++k) {
     *    PdfReader reader = new PdfReader(originalReader);
     *    XfdfReader xfdf = new XfdfReader((String)xfdfFiles.get(k));
     *    PdfStamper stp = new PdfStamper(reader, new FileOutputStream((String)pdfOutFiles.get(k)));
     *    AcroFields af = stp.getAcroFields();
     *    af.setFieldCache(cache);
     *    af.setFields(xfdf);
     *    stp.close();
     * }
     * </pre>
     * @param fieldCache an HasMap that will carry the cached appearances
     */
    public void setFieldCache(HashMap fieldCache) {
        this.fieldCache = fieldCache;
    }
    
    /**
     * Sets extra margins in text fields to better mimic the Acrobat layout.
     * @param extraMarginLeft the extra marging left
     * @param extraMarginTop the extra margin top
     */    
    public void setExtraMargin(float extraMarginLeft, float extraMarginTop) {
        this.extraMarginLeft = extraMarginLeft;
        this.extraMarginTop = extraMarginTop;
    }

    private static final HashMap stdFieldFontNames = new HashMap();
    
    /**
     * Holds value of property totalRevisions.
     */
    private int totalRevisions;
    
    /**
     * Holds value of property fieldCache.
     */
    private HashMap fieldCache;
    
    static {
        stdFieldFontNames.put("CoBO", new String[]{"Courier-BoldOblique"});
        stdFieldFontNames.put("CoBo", new String[]{"Courier-Bold"});
        stdFieldFontNames.put("CoOb", new String[]{"Courier-Oblique"});
        stdFieldFontNames.put("Cour", new String[]{"Courier"});
        stdFieldFontNames.put("HeBO", new String[]{"Helvetica-BoldOblique"});
        stdFieldFontNames.put("HeBo", new String[]{"Helvetica-Bold"});
        stdFieldFontNames.put("HeOb", new String[]{"Helvetica-Oblique"});
        stdFieldFontNames.put("Helv", new String[]{"Helvetica"});
        stdFieldFontNames.put("Symb", new String[]{"Symbol"});
        stdFieldFontNames.put("TiBI", new String[]{"Times-BoldItalic"});
        stdFieldFontNames.put("TiBo", new String[]{"Times-Bold"});
        stdFieldFontNames.put("TiIt", new String[]{"Times-Italic"});
        stdFieldFontNames.put("TiRo", new String[]{"Times-Roman"});
        stdFieldFontNames.put("ZaDb", new String[]{"ZapfDingbats"});
        stdFieldFontNames.put("HySm", new String[]{"HYSMyeongJo-Medium", "UniKS-UCS2-H"});
        stdFieldFontNames.put("HyGo", new String[]{"HYGoThic-Medium", "UniKS-UCS2-H"});
        stdFieldFontNames.put("KaGo", new String[]{"HeiseiKakuGo-W5", "UniKS-UCS2-H"});
        stdFieldFontNames.put("KaMi", new String[]{"HeiseiMin-W3", "UniJIS-UCS2-H"});
        stdFieldFontNames.put("MHei", new String[]{"MHei-Medium", "UniCNS-UCS2-H"});
        stdFieldFontNames.put("MSun", new String[]{"MSung-Light", "UniCNS-UCS2-H"});
        stdFieldFontNames.put("STSo", new String[]{"STSong-Light", "UniGB-UCS2-H"});
    }

    private static class RevisionStream extends InputStream {
        private byte b[] = new byte[1];
        private RandomAccessFileOrArray raf;
        private int length;
        private int rangePosition = 0;
        private boolean closed;
        
        private RevisionStream(RandomAccessFileOrArray raf, int length) {
            this.raf = raf;
            this.length = length;
        }
        
        public int read() throws IOException {
            int n = read(b);
            if (n != 1)
                return -1;
            return b[0] & 0xff;
        }
        
        public int read(byte[] b, int off, int len) throws IOException {
            if (b == null) {
                throw new NullPointerException();
            } else if ((off < 0) || (off > b.length) || (len < 0) ||
            ((off + len) > b.length) || ((off + len) < 0)) {
                throw new IndexOutOfBoundsException();
            } else if (len == 0) {
                return 0;
            }
            if (rangePosition >= length) {
                close();
                return -1;
            }
            int elen = Math.min(len, length - rangePosition);
            raf.readFully(b, off, elen);
            rangePosition += elen;
            return elen;
        }
        
        public void close() throws IOException {
            if (!closed) {
                raf.close();
                closed = true;
            }
        }
    }
    
    private static class SorterComparator implements Comparator {        
        public int compare(Object o1, Object o2) {
            int n1 = ((int[])((Object[])o1)[1])[0];
            int n2 = ((int[])((Object[])o2)[1])[0];
            return n1 - n2;
        }        
    }
}
 /*
 * Copyright 2003 by Paulo Soares.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */
package pdftk.com.lowagie.text.pdf;

/** Shape arabic characters. This code was converted from a C version
 * at www.pango.org.
 *
 * @author Paulo Soares (psoares@consiste.pt)
 */
public class ArabicLigaturizer {
    
    static boolean isVowel(char s) {
        return ((s >= 0x064B) && (s <= 0x0655)) || (s == 0x0670);
    }

    static char charshape(char s, int which)
    /* which 0=isolated 1=final 2=initial 3=medial */
    {
        int l, r, m;
        if ((s >= 0x0621) && (s <= 0x06D3)) {
            l = 0;
            r = chartable.length - 1;
            while (l <= r) {
                m = (l + r) / 2;
                if (s == chartable[m][0]) {
                    return chartable[m][which + 1];
                }
                else if (s < chartable[m][0]) {
                    r = m - 1;
                }
                else {
                    l = m + 1;
                }
            }
        }
        else if (s >= 0xfef5 && s <= 0xfefb)
            return (char)(s + which);
        return s;
    }

    static int shapecount(char s) {
        int l, r, m;
        if ((s >= 0x0621) && (s <= 0x06D3) && !isVowel(s)) {
            l = 0;
            r = chartable.length - 1;
            while (l <= r) {
                m = (l + r) / 2;
                if (s == chartable[m][0]) {
                    return chartable[m].length - 1;
                }
                else if (s < chartable[m][0]) {
                    r = m - 1;
                }
                else {
                    l = m + 1;
                }
            }
        }
        else if (s == ZWJ) {
            return 4;
        }
        return 1;
    }
    
    static int ligature(char newchar, charstruct oldchar) {
    /* 0 == no ligature possible; 1 == vowel; 2 == two chars; 3 == Lam+Alef */
        int retval = 0;
        
        if (oldchar.basechar == 0)
            return 0;
        if (isVowel(newchar)) {
            retval = 1;
            if ((oldchar.vowel != 0) && (newchar != SHADDA)) {
                retval = 2;           /* we eliminate the old vowel .. */
            }
            switch (newchar) {
                case SHADDA:
                    if (oldchar.mark1 == 0) {
                        oldchar.mark1 = SHADDA;
                    }
                    else {
                        return 0;         /* no ligature possible */
                    }
                    break;
                case HAMZABELOW:
                    switch (oldchar.basechar) {
                        case ALEF:
                            oldchar.basechar = ALEFHAMZABELOW;
                            retval = 2;
                            break;
                        case LAM_ALEF:
                            oldchar.basechar = LAM_ALEFHAMZABELOW;
                            retval = 2;
                            break;
                        default:
                            oldchar.mark1 = HAMZABELOW;
                            break;
                    }
                    break;
                case HAMZAABOVE:
                    switch (oldchar.basechar) {
                        case ALEF:
                            oldchar.basechar = ALEFHAMZA;
                            retval = 2;
                            break;
                        case LAM_ALEF:
                            oldchar.basechar = LAM_ALEFHAMZA;
                            retval = 2;
                            break;
                        case WAW:
                            oldchar.basechar = WAWHAMZA;
                            retval = 2;
                            break;
                        case YEH:
                        case ALEFMAKSURA:
                        case FARSIYEH:
                            oldchar.basechar = YEHHAMZA;
                            retval = 2;
                            break;
                        default:           /* whatever sense this may make .. */
                            oldchar.mark1 = HAMZAABOVE;
                            break;
                    }
                    break;
                case MADDA:
                    switch (oldchar.basechar) {
                        case ALEF:
                            oldchar.basechar = ALEFMADDA;
                            retval = 2;
                            break;
                    }
                    break;
                default:
                    oldchar.vowel = newchar;
                    break;
            }
            if (retval == 1) {
                oldchar.lignum++;
            }
            return retval;
        }
        if (oldchar.vowel != 0) {  /* if we already joined a vowel, we can't join a Hamza */
            return 0;
        }
        
        switch (oldchar.basechar) {
            case LAM:
                switch (newchar) {
                    case ALEF:
                        oldchar.basechar = LAM_ALEF;
                        oldchar.numshapes = 2;
                        retval = 3;
                        break;
                    case ALEFHAMZA:
                        oldchar.basechar = LAM_ALEFHAMZA;
                        oldchar.numshapes = 2;
                        retval = 3;
                        break;
                    case ALEFHAMZABELOW:
                        oldchar.basechar = LAM_ALEFHAMZABELOW;
                        oldchar.numshapes = 2;
                        retval = 3;
                        break;
                    case ALEFMADDA:
                        oldchar.basechar = LAM_ALEFMADDA;
                        oldchar.numshapes = 2;
                        retval = 3;
                        break;
                }
                break;
            case 0:
                oldchar.basechar = newchar;
                oldchar.numshapes = shapecount(newchar);
                retval = 1;
                break;
        }
        return retval;
    }
    
    static void copycstostring(StringBuffer string, charstruct s, int level) {
    /* s is a shaped charstruct; i is the index into the string */
        if (s.basechar == 0)
            return;
        
        string.append(s.basechar);
        s.lignum--;
        if (s.mark1 != 0) {
            if ((level & ar_novowel) == 0) {
                string.append(s.mark1);
                s.lignum--;
            }
            else {
                s.lignum--;
            }
        }
        if (s.vowel != 0) {
            if ((level & ar_novowel) == 0) {
                string.append(s.vowel);
                s.lignum--;
            }
            else {                       /* vowel elimination */
                s.lignum--;
            }
        }
//        while (s.lignum > 0) {                           /* NULL-insertion for Langbox-font */
//            string[i] = 0;
//            i++;
//            (s.lignum)--;
//        }
//        return i;
    }

    // return len
    static void doublelig(StringBuffer string, int level)
    /* Ok. We have presentation ligatures in our font. */
    {
        int len;
        int olen = len = string.length();
        int j = 0, si = 1;
        char lapresult;
        
        while (si < olen) {
            lapresult = 0;
            if ((level & ar_composedtashkeel) != 0) {
                switch (string.charAt(j)) {
                    case SHADDA:
                        switch (string.charAt(si)) {
                            case KASRA:
                                lapresult = 0xFC62;
                                break;
                            case FATHA:
                                lapresult = 0xFC60;
                                break;
                            case DAMMA:
                                lapresult = 0xFC61;
                                break;
                            case 0x064C:
                                lapresult = 0xFC5E;
                                break;
                            case 0x064D:
                                lapresult = 0xFC5F;
                                break;
                        }
                        break;
                    case KASRA:
                        if (string.charAt(si) == SHADDA)
                            lapresult = 0xFC62;
                        break;
                    case FATHA:
                        if (string.charAt(si) == SHADDA)
                            lapresult = 0xFC60;
                        break;
                    case DAMMA:
                        if (string.charAt(si) == SHADDA)
                            lapresult = 0xFC61;
                        break;
                }
            }
            
            if ((level & ar_lig) != 0) {
                switch (string.charAt(j)) {
                    case 0xFEDF:       /* LAM initial */
                        switch (string.charAt(si)) {
                            case 0xFE9E:
                                lapresult = 0xFC3F;
                                break;        /* JEEM final */
                            case 0xFEA0:
                                lapresult = 0xFCC9;
                                break;        /* JEEM medial */
                            case 0xFEA2:
                                lapresult = 0xFC40;
                                break;        /* HAH final */
                            case 0xFEA4:
                                lapresult = 0xFCCA;
                                break;        /* HAH medial */
                            case 0xFEA6:
                                lapresult = 0xFC41;
                                break;        /* KHAH final */
                            case 0xFEA8:
                                lapresult = 0xFCCB;
                                break;        /* KHAH medial */
                            case 0xFEE2:
                                lapresult = 0xFC42;
                                break;        /* MEEM final */
                            case 0xFEE4:
                                lapresult = 0xFCCC;
                                break;        /* MEEM medial */
                        }
                        break;
                    case 0xFE97:       /* TEH inital */
                        switch (string.charAt(si)) {
                            case 0xFEA0:
                                lapresult = 0xFCA1;
                                break;        /* JEEM medial */
                            case 0xFEA4:
                                lapresult = 0xFCA2;
                                break;        /* HAH medial */
                            case 0xFEA8:
                                lapresult = 0xFCA3;
                                break;        /* KHAH medial */
                        }
                        break;
                    case 0xFE91:       /* BEH inital */
                        switch (string.charAt(si)) {
                            case 0xFEA0:
                                lapresult = 0xFC9C;
                                break;        /* JEEM medial */
                            case 0xFEA4:
                                lapresult = 0xFC9D;
                                break;        /* HAH medial */
                            case 0xFEA8:
                                lapresult = 0xFC9E;
                                break;        /* KHAH medial */
                        }
                        break;
                    case 0xFEE7:       /* NOON inital */
                        switch (string.charAt(si)) {
                            case 0xFEA0:
                                lapresult = 0xFCD2;
                                break;        /* JEEM initial */
                            case 0xFEA4:
                                lapresult = 0xFCD3;
                                break;        /* HAH medial */
                            case 0xFEA8:
                                lapresult = 0xFCD4;
                                break;        /* KHAH medial */
                        }
                        break;
                        
                    case 0xFEE8:       /* NOON medial */
                        switch (string.charAt(si)) {
                            case 0xFEAE:
                                lapresult = 0xFC8A;
                                break;        /* REH final  */
                            case 0xFEB0:
                                lapresult = 0xFC8B;
                                break;        /* ZAIN final */
                        }
                        break;
                    case 0xFEE3:       /* MEEM initial */
                        switch (string.charAt(si)) {
                            case 0xFEA0:
                                lapresult = 0xFCCE;
                                break;        /* JEEM medial */
                            case 0xFEA4:
                                lapresult = 0xFCCF;
                                break;        /* HAH medial */
                            case 0xFEA8:
                                lapresult = 0xFCD0;
                                break;        /* KHAH medial */
                            case 0xFEE4:
                                lapresult = 0xFCD1;
                                break;        /* MEEM medial */
                        }
                        break;
                        
                    case 0xFED3:       /* FEH initial */
                        switch (string.charAt(si)) {
                            case 0xFEF2:
                                lapresult = 0xFC32;
                                break;        /* YEH final */
                        }
                        break;
                        
                    default:
                        break;
                }                   /* end switch string[si] */
            }
            if (lapresult != 0) {
                string.setCharAt(j, lapresult);
                len--;
                si++;                 /* jump over one character */
                /* we'll have to change this, too. */
            }
            else {
                j++;
                string.setCharAt(j, string.charAt(si));
                si++;
            }
        }
        string.setLength(len);
    }

    static boolean connects_to_left(charstruct a) {
        return a.numshapes > 2;
    }
    
    static void shape(char text[], StringBuffer string, int level) {
  /* string is assumed to be empty and big enough.
   * text is the original text.
   * This routine does the basic arabic reshaping.
   * *len the number of non-null characters.
   *
   * Note: We have to unshape each character first!
   */
        int join;
        int which;
        char nextletter;
        
        int p = 0;                     /* initialize for output */
        charstruct oldchar = new charstruct();
        charstruct curchar = new charstruct();
        while (p < text.length) {
            nextletter = text[p++];
            //nextletter = unshape (nextletter);
            
            join = ligature(nextletter, curchar);
            if (join == 0) {                       /* shape curchar */
                int nc = shapecount(nextletter);
                //(*len)++;
                if (nc == 1) {
                    which = 0;        /* final or isolated */
                }
                else {
                    which = 2;        /* medial or initial */
                }
                if (connects_to_left(oldchar)) {
                    which++;
                }
                
                which = which % (curchar.numshapes);
                curchar.basechar = charshape(curchar.basechar, which);
                
                /* get rid of oldchar */
                copycstostring(string, oldchar, level);
                oldchar = curchar;    /* new values in oldchar */
                
                /* init new curchar */
                curchar = new charstruct();
                curchar.basechar = nextletter;
                curchar.numshapes = nc;
                curchar.lignum++;
                //          (*len) += unligature (&curchar, level);
            }
            else if (join == 1) {
            }
            //      else
            //        {
            //          (*len) += unligature (&curchar, level);
            //        }
            //      p = g_utf8_next_char (p);
        }
        
        /* Handle last char */
        if (connects_to_left(oldchar))
            which = 1;
        else
            which = 0;
        which = which % (curchar.numshapes);
        curchar.basechar = charshape(curchar.basechar, which);
        
        /* get rid of oldchar */
        copycstostring(string, oldchar, level);
        copycstostring(string, curchar, level);
    }

    static int arabic_shape(char src[], int srcoffset, int srclength, char dest[], int destoffset, int destlength, int level) {
        char str[] = new char[srclength];
        for (int k = srclength + srcoffset - 1; k >= srcoffset; --k)
            str[k - srcoffset] = src[k];
        StringBuffer string = new StringBuffer(srclength);
        shape(str, string, level);
        if ((level & (ar_composedtashkeel | ar_lig)) != 0)
            doublelig(string, level);
//        string.reverse();
        System.arraycopy(string.toString().toCharArray(), 0, dest, destoffset, string.length());
        return string.length();
    }

    static void processNumbers(char text[], int offset, int length, int options) {
        int limit = offset + length;
        if ((options & DIGITS_MASK) != 0) {
            char digitBase = '\u0030'; // European digits
            switch (options & DIGIT_TYPE_MASK) {
                case DIGIT_TYPE_AN:
                    digitBase = '\u0660';  // Arabic-Indic digits
                    break;
                    
                case DIGIT_TYPE_AN_EXTENDED:
                    digitBase = '\u06f0';  // Eastern Arabic-Indic digits (Persian and Urdu)
                    break;
                    
                default:
                    break;
            }
            
            switch (options & DIGITS_MASK) {
                case DIGITS_EN2AN: {
                    int digitDelta = digitBase - '\u0030';
                    for (int i = offset; i < limit; ++i) {
                        char ch = text[i];
                        if (ch <= '\u0039' && ch >= '\u0030') {
                            text[i] += digitDelta;
                        }
                    }
                }
                break;
                
                case DIGITS_AN2EN: {
                    char digitTop = (char)(digitBase + 9);
                    int digitDelta = '\u0030' - digitBase;
                    for (int i = offset; i < limit; ++i) {
                        char ch = text[i];
                        if (ch <= digitTop && ch >= digitBase) {
                            text[i] += digitDelta;
                        }
                    }
                }
                break;
                
                case DIGITS_EN2AN_INIT_LR:
                    shapeToArabicDigitsWithContext(text, 0, length, digitBase, false);
                    break;
                    
                case DIGITS_EN2AN_INIT_AL:
                    shapeToArabicDigitsWithContext(text, 0, length, digitBase, true);
                    break;
                    
                default:
                    break;
            }
        }
    }
    
    static void shapeToArabicDigitsWithContext(char[] dest, int start, int length, char digitBase,  boolean lastStrongWasAL) {
        digitBase -= '0'; // move common adjustment out of loop
 
        int limit = start + length;
        for(int i = start; i < limit; ++i) {
            char ch = dest[i];
            switch (BidiOrder.getDirection(ch)) {
            case BidiOrder.L:
            case BidiOrder.R:
                lastStrongWasAL = false;
                break;
            case BidiOrder.AL:
                lastStrongWasAL = true;
                break;
            case BidiOrder.EN:
                if (lastStrongWasAL && ch <= '\u0039') {
                    dest[i] = (char)(ch + digitBase);
                }
                break;
            default:
                break;
            }
        }
    }

    private static final char ALEF = 0x0627;
    private static final char ALEFHAMZA = 0x0623;
    private static final char ALEFHAMZABELOW = 0x0625;
    private static final char ALEFMADDA = 0x0622;
    private static final char LAM = 0x0644;
    private static final char HAMZA = 0x0621;
    private static final char TATWEEL = 0x0640;
    private static final char ZWJ = 0x200D;

    private static final char HAMZAABOVE = 0x0654;
    private static final char HAMZABELOW = 0x0655;

    private static final char WAWHAMZA = 0x0624;
    private static final char YEHHAMZA = 0x0626;
    private static final char WAW = 0x0648;
    private static final char ALEFMAKSURA = 0x0649;
    private static final char YEH = 0x064A;
    private static final char FARSIYEH = 0x06CC;

    private static final char SHADDA = 0x0651;
    private static final char KASRA = 0x0650;
    private static final char FATHA = 0x064E;
    private static final char DAMMA = 0x064F;
    private static final char MADDA = 0x0653;

    private static final char LAM_ALEF = 0xFEFB;
    private static final char LAM_ALEFHAMZA = 0xFEF7;
    private static final char LAM_ALEFHAMZABELOW = 0xFEF9;
    private static final char LAM_ALEFMADDA = 0xFEF5;

    private static final char chartable[][] = {
        {0x0621, 0xFE80}, /* HAMZA */
        {0x0622, 0xFE81, 0xFE82}, /* ALEF WITH MADDA ABOVE */
        {0x0623, 0xFE83, 0xFE84}, /* ALEF WITH HAMZA ABOVE */
        {0x0624, 0xFE85, 0xFE86}, /* WAW WITH HAMZA ABOVE */
        {0x0625, 0xFE87, 0xFE88}, /* ALEF WITH HAMZA BELOW */
        {0x0626, 0xFE89, 0xFE8A, 0xFE8B, 0xFE8C}, /* YEH WITH HAMZA ABOVE */
        {0x0627, 0xFE8D, 0xFE8E}, /* ALEF */
        {0x0628, 0xFE8F, 0xFE90, 0xFE91, 0xFE92}, /* BEH */
        {0x0629, 0xFE93, 0xFE94}, /* TEH MARBUTA */
        {0x062A, 0xFE95, 0xFE96, 0xFE97, 0xFE98}, /* TEH */
        {0x062B, 0xFE99, 0xFE9A, 0xFE9B, 0xFE9C}, /* THEH */
        {0x062C, 0xFE9D, 0xFE9E, 0xFE9F, 0xFEA0}, /* JEEM */
        {0x062D, 0xFEA1, 0xFEA2, 0xFEA3, 0xFEA4}, /* HAH */
        {0x062E, 0xFEA5, 0xFEA6, 0xFEA7, 0xFEA8}, /* KHAH */
        {0x062F, 0xFEA9, 0xFEAA}, /* DAL */
        {0x0630, 0xFEAB, 0xFEAC}, /* THAL */
        {0x0631, 0xFEAD, 0xFEAE}, /* REH */
        {0x0632, 0xFEAF, 0xFEB0}, /* ZAIN */
        {0x0633, 0xFEB1, 0xFEB2, 0xFEB3, 0xFEB4}, /* SEEN */
        {0x0634, 0xFEB5, 0xFEB6, 0xFEB7, 0xFEB8}, /* SHEEN */
        {0x0635, 0xFEB9, 0xFEBA, 0xFEBB, 0xFEBC}, /* SAD */
        {0x0636, 0xFEBD, 0xFEBE, 0xFEBF, 0xFEC0}, /* DAD */
        {0x0637, 0xFEC1, 0xFEC2, 0xFEC3, 0xFEC4}, /* TAH */
        {0x0638, 0xFEC5, 0xFEC6, 0xFEC7, 0xFEC8}, /* ZAH */
        {0x0639, 0xFEC9, 0xFECA, 0xFECB, 0xFECC}, /* AIN */
        {0x063A, 0xFECD, 0xFECE, 0xFECF, 0xFED0}, /* GHAIN */
        {0x0640, 0x0640, 0x0640, 0x0640, 0x0640}, /* TATWEEL */
        {0x0641, 0xFED1, 0xFED2, 0xFED3, 0xFED4}, /* FEH */
        {0x0642, 0xFED5, 0xFED6, 0xFED7, 0xFED8}, /* QAF */
        {0x0643, 0xFED9, 0xFEDA, 0xFEDB, 0xFEDC}, /* KAF */
        {0x0644, 0xFEDD, 0xFEDE, 0xFEDF, 0xFEE0}, /* LAM */
        {0x0645, 0xFEE1, 0xFEE2, 0xFEE3, 0xFEE4}, /* MEEM */
        {0x0646, 0xFEE5, 0xFEE6, 0xFEE7, 0xFEE8}, /* NOON */
        {0x0647, 0xFEE9, 0xFEEA, 0xFEEB, 0xFEEC}, /* HEH */
        {0x0648, 0xFEED, 0xFEEE}, /* WAW */
        {0x0649, 0xFEEF, 0xFEF0, 0xFBE8, 0xFBE9}, /* ALEF MAKSURA */
        {0x064A, 0xFEF1, 0xFEF2, 0xFEF3, 0xFEF4}, /* YEH */
        {0x0671, 0xFB50, 0xFB51}, /* ALEF WASLA */
        {0x0679, 0xFB66, 0xFB67, 0xFB68, 0xFB69}, /* TTEH */
        {0x067A, 0xFB5E, 0xFB5F, 0xFB60, 0xFB61}, /* TTEHEH */
        {0x067B, 0xFB52, 0xFB53, 0xFB54, 0xFB55}, /* BEEH */
        {0x067E, 0xFB56, 0xFB57, 0xFB58, 0xFB59}, /* PEH */
        {0x067F, 0xFB62, 0xFB63, 0xFB64, 0xFB65}, /* TEHEH */
        {0x0680, 0xFB5A, 0xFB5B, 0xFB5C, 0xFB5D}, /* BEHEH */
        {0x0683, 0xFB76, 0xFB77, 0xFB78, 0xFB79}, /* NYEH */
        {0x0684, 0xFB72, 0xFB73, 0xFB74, 0xFB75}, /* DYEH */
        {0x0686, 0xFB7A, 0xFB7B, 0xFB7C, 0xFB7D}, /* TCHEH */
        {0x0687, 0xFB7E, 0xFB7F, 0xFB80, 0xFB81}, /* TCHEHEH */
        {0x0688, 0xFB88, 0xFB89}, /* DDAL */
        {0x068C, 0xFB84, 0xFB85}, /* DAHAL */
        {0x068D, 0xFB82, 0xFB83}, /* DDAHAL */
        {0x068E, 0xFB86, 0xFB87}, /* DUL */
        {0x0691, 0xFB8C, 0xFB8D}, /* RREH */
        {0x0698, 0xFB8A, 0xFB8B}, /* JEH */
        {0x06A4, 0xFB6A, 0xFB6B, 0xFB6C, 0xFB6D}, /* VEH */
        {0x06A6, 0xFB6E, 0xFB6F, 0xFB70, 0xFB71}, /* PEHEH */
        {0x06A9, 0xFB8E, 0xFB8F, 0xFB90, 0xFB91}, /* KEHEH */
        {0x06AD, 0xFBD3, 0xFBD4, 0xFBD5, 0xFBD6}, /* NG */
        {0x06AF, 0xFB92, 0xFB93, 0xFB94, 0xFB95}, /* GAF */
        {0x06B1, 0xFB9A, 0xFB9B, 0xFB9C, 0xFB9D}, /* NGOEH */
        {0x06B3, 0xFB96, 0xFB97, 0xFB98, 0xFB99}, /* GUEH */
        {0x06BA, 0xFB9E, 0xFB9F}, /* NOON GHUNNA */
        {0x06BB, 0xFBA0, 0xFBA1, 0xFBA2, 0xFBA3}, /* RNOON */
        {0x06BE, 0xFBAA, 0xFBAB, 0xFBAC, 0xFBAD}, /* HEH DOACHASHMEE */
        {0x06C0, 0xFBA4, 0xFBA5}, /* HEH WITH YEH ABOVE */
        {0x06C1, 0xFBA6, 0xFBA7, 0xFBA8, 0xFBA9}, /* HEH GOAL */
        {0x06C5, 0xFBE0, 0xFBE1}, /* KIRGHIZ OE */
        {0x06C6, 0xFBD9, 0xFBDA}, /* OE */
        {0x06C7, 0xFBD7, 0xFBD8}, /* U */
        {0x06C8, 0xFBDB, 0xFBDC}, /* YU */
        {0x06C9, 0xFBE2, 0xFBE3}, /* KIRGHIZ YU */
        {0x06CB, 0xFBDE, 0xFBDF}, /* VE */
        {0x06CC, 0xFBFC, 0xFBFD, 0xFBFE, 0xFBFF}, /* FARSI YEH */
        {0x06D0, 0xFBE4, 0xFBE5, 0xFBE6, 0xFBE7}, /* E */
        {0x06D2, 0xFBAE, 0xFBAF}, /* YEH BARREE */
        {0x06D3, 0xFBB0, 0xFBB1} /* YEH BARREE WITH HAMZA ABOVE */
        };

        public static final int ar_nothing  = 0x0;
        public static final int ar_novowel = 0x1;
        public static final int ar_composedtashkeel = 0x4;
        public static final int ar_lig = 0x8;
        /**
         * Digit shaping option: Replace European digits (U+0030...U+0039) by Arabic-Indic digits.
         */
        public static final int DIGITS_EN2AN = 0x20;
        
        /**
         * Digit shaping option: Replace Arabic-Indic digits by European digits (U+0030...U+0039).
         */
        public static final int DIGITS_AN2EN = 0x40;
        
        /**
         * Digit shaping option:
         * Replace European digits (U+0030...U+0039) by Arabic-Indic digits
         * if the most recent strongly directional character
         * is an Arabic letter (its Bidi direction value is RIGHT_TO_LEFT_ARABIC).
         * The initial state at the start of the text is assumed to be not an Arabic,
         * letter, so European digits at the start of the text will not change.
         * Compare to DIGITS_ALEN2AN_INIT_AL.
         */
        public static final int DIGITS_EN2AN_INIT_LR = 0x60;
        
        /**
         * Digit shaping option:
         * Replace European digits (U+0030...U+0039) by Arabic-Indic digits
         * if the most recent strongly directional character
         * is an Arabic letter (its Bidi direction value is RIGHT_TO_LEFT_ARABIC).
         * The initial state at the start of the text is assumed to be an Arabic,
         * letter, so European digits at the start of the text will change.
         * Compare to DIGITS_ALEN2AN_INT_LR.
         */
        public static final int DIGITS_EN2AN_INIT_AL = 0x80;
        
        /** Not a valid option value. */
        private static final int DIGITS_RESERVED = 0xa0;
        
        /**
         * Bit mask for digit shaping options.
         */
        public static final int DIGITS_MASK = 0xe0;
        
        /**
         * Digit type option: Use Arabic-Indic digits (U+0660...U+0669).
         */
        public static final int DIGIT_TYPE_AN = 0;
        
        /**
         * Digit type option: Use Eastern (Extended) Arabic-Indic digits (U+06f0...U+06f9).
         */
        public static final int DIGIT_TYPE_AN_EXTENDED = 0x100;

        /**
         * Bit mask for digit type options.
         */
        public static final int DIGIT_TYPE_MASK = 0x0100; // 0x3f00?

        static class charstruct {
            char basechar;
            char mark1;               /* has to be initialized to zero */
            char vowel;
            int lignum;           /* is a ligature with lignum aditional characters */
            int numshapes = 1;
        };


}
 /*
 * Copyright 2004 by Takenori.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */
package pdftk.com.lowagie.text.pdf;

import java.awt.Font;

import pdftk.com.lowagie.text.pdf.BaseFont;
import pdftk.com.lowagie.text.pdf.DefaultFontMapper;

public class AsianFontMapper extends DefaultFontMapper {
	
	public static String ChineseSimplifiedFont = "STSong-Light";
	public static String ChineseSimplifiedEncoding_H = "UniGB-UCS2-H";
	public static String ChineseSimplifiedEncoding_V = "UniGB-UCS2-V";
	
	public static String ChineseTraditionalFont_MHei = "MHei-Medium";
	public static String ChineseTraditionalFont_MSung = "MSung-Light";
	public static String ChineseTraditionalEncoding_H = "UniCNS-UCS2-H";
	public static String ChineseTraditionalEncoding_V = "UniCNS-UCS2-V";
	
	public static String JapaneseFont_Go = "HeiseiKakuGo-W5";
	public static String JapaneseFont_Min = "HeiseiMin-W3";
	public static String JapaneseEncoding_H = "UniJIS-UCS2-H";
	public static String JapaneseEncoding_V = "UniJIS-UCS2-V";
	public static String JapaneseEncoding_HW_H = "UniJIS-UCS2-HW-H";
	public static String JapaneseEncoding_HW_V = "UniJIS-UCS2-HW-V";
	
	public static String KoreanFont_GoThic = "HYGoThic-Medium";
	public static String KoreanFont_SMyeongJo = "HYSMyeongJo-Medium";
	public static String KoreanEncoding_H = "UniKS-UCS2-H";
	public static String KoreanEncoding_V = "UniKS-UCS2-V";
	
	private String defaultFont;
	private String encoding;

	public AsianFontMapper(String font, String encoding) {
		super();
		
		this.defaultFont = font;
		this.encoding = encoding;
	}

	public BaseFont awtToPdf(Font font) {
		try {
			BaseFontParameters p = getBaseFontParameters(font.getFontName());
			if (p != null){
				return BaseFont.createFont(p.fontName, p.encoding, p.embedded, p.cached, p.ttfAfm, p.pfb);
			}else{
				return BaseFont.createFont(defaultFont, encoding, true);
			}
		}
		catch (Exception e) {
			e.printStackTrace();
		}
		return null;

	}

}
 /*
 * $Id: BadPdfFormatException.java,v 1.22 2002/06/18 13:59:39 blowagie Exp $
 * $Name:  $
 *
 * Copyright 1999, 2000, 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf;

/**
 * Signals that a bad PDF format has been used to construct a <CODE>PdfObject</CODE>.
 *
 * @see		PdfException
 * @see		PdfBoolean
 * @see		PdfNumber
 * @see		PdfString
 * @see		PdfName
 * @see		PdfDictionary
 * @see		PdfFont
 */

public class BadPdfFormatException extends PdfException {
    
    /** A serial version UID */
    private static final long serialVersionUID = 1802317735708833538L;

    // constructors
    
/**
 * Constructs a <CODE>BadPdfFormatException</CODE> whithout a message.
 */
    
    BadPdfFormatException() {
        super();
    }
    
/**
 * Constructs a <code>BadPdfFormatException</code> with a message.
 *
 * @param		message			a message describing the exception
 */
    
    BadPdfFormatException(String message) {
        super(message);
    }
} /*
 * Copyright 2005 by Paulo Soares.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf;

import java.awt.Color;
import pdftk.com.lowagie.text.Element;
import pdftk.com.lowagie.text.DocumentException;
import pdftk.com.lowagie.text.Rectangle;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.HashMap;

/** Common field variables.
 * @author Paulo Soares (psoares@consiste.pt)
 */
public abstract class BaseField {
    
    /** A thin border with 1 point width. */    
    public static final float BORDER_WIDTH_THIN = 1;
    /** A medium border with 2 point width. */    
    public static final float BORDER_WIDTH_MEDIUM = 2;
    /** A thick border with 3 point width. */    
    public static final float BORDER_WIDTH_THICK = 3;
    /** The field is visible. */    
    public static final int VISIBLE = 0;
    /** The field is hidden. */    
    public static final int HIDDEN = 1;
    /** The field is visible but does not print. */    
    public static final int VISIBLE_BUT_DOES_NOT_PRINT = 2;
    /** The field is hidden but is printable. */    
    public static final int HIDDEN_BUT_PRINTABLE = 3;
    /** The user may not change the value of the field. */    
    public static final int READ_ONLY = 1;
    /** The field must have a value at the time it is exported by a submit-form
     * action.
     */    
    public static final int REQUIRED = 2;
    /** The field may contain multiple lines of text.
     * This flag is only meaningful with text fields.
     */    
    public static final int MULTILINE = 4;
    /** The field will not scroll (horizontally for single-line
     * fields, vertically for multiple-line fields) to accommodate more text
     * than will fit within its annotation rectangle. Once the field is full, no
     * further text will be accepted.
     */    
    public static final int DO_NOT_SCROLL = 8;
    /** The field is intended for entering a secure password that should
     * not be echoed visibly to the screen.
     */    
    public static final int PASSWORD = 16;
    /** The text entered in the field represents the pathname of
     * a file whose contents are to be submitted as the value of the field.
     */    
    public static final int FILE_SELECTION = 32;
    /** The text entered in the field will not be spell-checked.
     * This flag is meaningful only in text fields and in combo
     * fields with the <CODE>EDIT</CODE> flag set.
     */    
    public static final int DO_NOT_SPELL_CHECK = 64;
    /** If set the combo box includes an editable text box as well as a drop list; if
     * clear, it includes only a drop list.
     * This flag is only meaningful with combo fields.
     */    
    public static final int EDIT = 128;

    /**
     * combo box flag.
     */
    public static final int COMB = 256;

    protected float borderWidth = BORDER_WIDTH_THIN;
    protected int borderStyle = PdfBorderDictionary.STYLE_SOLID;
    protected Color borderColor;
    protected Color backgroundColor;
    protected Color textColor;
    protected BaseFont font;
    protected float fontSize = 0;
    protected int alignment = Element.ALIGN_LEFT;
    protected PdfWriter writer;
    protected String text;
    protected Rectangle box;
    
    /** Holds value of property rotation. */
    protected int rotation = 0;
    
    /** Holds value of property visibility. */
    protected int visibility;
    
    /** Holds value of property fieldName. */
    protected String fieldName;
    
    /** Holds value of property options. */
    protected int options;
    
    /** Holds value of property maxCharacterLength. */
    protected int maxCharacterLength;
    
    private final static HashMap fieldKeys = new HashMap();
 
    static {
        fieldKeys.putAll(PdfCopyFieldsImp.fieldKeys);
        fieldKeys.put(PdfName.T, new Integer(1));
    }
    /** Creates a new <CODE>TextField</CODE>.
     * @param writer the document <CODE>PdfWriter</CODE>
     * @param box the field location and dimensions
     * @param fieldName the field name. If <CODE>null</CODE> only the widget keys
     * will be included in the field allowing it to be used as a kid field.
     */
    public BaseField(PdfWriter writer, Rectangle box, String fieldName) {
        this.writer = writer;
        this.box = box;
        this.fieldName = fieldName;
    }
    
    protected BaseFont getRealFont() throws IOException, DocumentException {
        if (font == null)
            return BaseFont.createFont(BaseFont.HELVETICA, BaseFont.WINANSI, false);
        else
            return font;
    }
    
    protected PdfAppearance getBorderAppearance() throws IOException, DocumentException {
        PdfAppearance app = writer.getDirectContent().createAppearance(box.width(), box.height());
        switch (rotation) {
            case 90:
                app.setMatrix(0, 1, -1, 0, box.height(), 0);
                break;
            case 180:
                app.setMatrix(-1, 0, 0, -1, box.width(), box.height());
                break;
            case 270:
                app.setMatrix(0, -1, 1, 0, 0, box.width());
                break;
        }
        // background
        if (backgroundColor != null) {
            app.setColorFill(backgroundColor);
            app.rectangle(0, 0, box.width(), box.height());
            app.fill();
        }
        // border
        if (borderStyle == PdfBorderDictionary.STYLE_UNDERLINE) {
            if (borderWidth != 0 && borderColor != null) {
                app.setColorStroke(borderColor);
                app.setLineWidth(borderWidth);
                app.moveTo(0, borderWidth / 2);
                app.lineTo(box.width(), borderWidth / 2);
                app.stroke();
            }
        }
        else if (borderStyle == PdfBorderDictionary.STYLE_BEVELED) {
            if (borderWidth != 0 && borderColor != null) {
                app.setColorStroke(borderColor);
                app.setLineWidth(borderWidth);
                app.rectangle(borderWidth / 2, borderWidth / 2, box.width() - borderWidth, box.height() - borderWidth);
                app.stroke();
            }
            // beveled
            Color actual = backgroundColor;
            if (actual == null)
                actual = Color.white;
            app.setGrayFill(1);
            drawTopFrame(app);
            app.setColorFill(actual.darker());
            drawBottomFrame(app);
        }
        else if (borderStyle == PdfBorderDictionary.STYLE_INSET) {
            if (borderWidth != 0 && borderColor != null) {
                app.setColorStroke(borderColor);
                app.setLineWidth(borderWidth);
                app.rectangle(borderWidth / 2, borderWidth / 2, box.width() - borderWidth, box.height() - borderWidth);
                app.stroke();
            }
            // inset
            app.setGrayFill(0.5f);
            drawTopFrame(app);
            app.setGrayFill(0.75f);
            drawBottomFrame(app);
        }
        else {
            if (borderWidth != 0 && borderColor != null) {
                if (borderStyle == PdfBorderDictionary.STYLE_DASHED)
                    app.setLineDash(3, 0);
                app.setColorStroke(borderColor);
                app.setLineWidth(borderWidth);
                app.rectangle(borderWidth / 2, borderWidth / 2, box.width() - borderWidth, box.height() - borderWidth);
                app.stroke();
                if ((options & COMB) != 0 && maxCharacterLength > 1) {
                    float step = box.width() / maxCharacterLength;
                    float yb = borderWidth / 2;
                    float yt = box.height() - borderWidth / 2;
                    for (int k = 1; k < maxCharacterLength; ++k) {
                        float x = step * k;
                        app.moveTo(x, yb);
                        app.lineTo(x, yt);
                    }
                    app.stroke();
                }
            }
        }
        return app;
    }
    
    protected static ArrayList getHardBreaks(String text) {
        ArrayList arr = new ArrayList();
        char cs[] = text.toCharArray();
        int len = cs.length;
        StringBuffer buf = new StringBuffer();
        for (int k = 0; k < len; ++k) {
            char c = cs[k];
            if (c == '\r') {
                if (k + 1 < len && cs[k + 1] == '\n')
                    ++k;
                arr.add(buf.toString());
                buf = new StringBuffer();
            }
            else if (c == '\n') {
                arr.add(buf.toString());
                buf = new StringBuffer();
            }
            else
                buf.append(c);
        }
        arr.add(buf.toString());
        return arr;
    }
    
    protected static void trimRight(StringBuffer buf) {
        int len = buf.length();
        while (true) {
            if (len == 0)
                return;
            if (buf.charAt(--len) != ' ')
                return;
            buf.setLength(len);
        }
    }
    
    protected static ArrayList breakLines(ArrayList breaks, BaseFont font, float fontSize, float width) {
        ArrayList lines = new ArrayList();
        StringBuffer buf = new StringBuffer();
        for (int ck = 0; ck < breaks.size(); ++ck) {
            buf.setLength(0);
            float w = 0;
            char cs[] = ((String)breaks.get(ck)).toCharArray();
            int len = cs.length;
            // 0 inline first, 1 inline, 2 spaces
            int state = 0;
            int lastspace = -1;
            char c = 0;
            int refk = 0;
            for (int k = 0; k < len; ++k) {
                c = cs[k];
                switch (state) {
                    case 0:
                        w += font.getWidthPoint(c, fontSize);
                        buf.append(c);
                        if (w > width) {
                            w = 0;
                            if (buf.length() > 1) {
                                --k;
                                buf.setLength(buf.length() - 1);
                            }
                            lines.add(buf.toString());
                            buf.setLength(0);
                            refk = k;
                            if (c == ' ')
                                state = 2;
                            else
                                state = 1;
                        }
                        else {
                            if (c != ' ')
                                state = 1;
                        }
                        break;
                    case 1:
                        w += font.getWidthPoint(c, fontSize);
                        buf.append(c);
                        if (c == ' ')
                            lastspace = k;
                        if (w > width) {
                            w = 0;
                            if (lastspace >= 0) {
                                k = lastspace;
                                buf.setLength(lastspace - refk);
                                trimRight(buf);
                                lines.add(buf.toString());
                                buf.setLength(0);
                                refk = k;
                                lastspace = -1;
                                state = 2;
                            }
                            else {
                                if (buf.length() > 1) {
                                    --k;
                                    buf.setLength(buf.length() - 1);
                                }
                                lines.add(buf.toString());
                                buf.setLength(0);
                                refk = k;
                                if (c == ' ')
                                    state = 2;
                            }
                        }
                        break;
                    case 2:
                        if (c != ' ') {
                            w = 0;
                            --k;
                            state = 1;
                        }
                        break;
                }
            }
            trimRight(buf);
            lines.add(buf.toString());
        }
        return lines;
    }
        
    private void drawTopFrame(PdfAppearance app) {
        app.moveTo(borderWidth, borderWidth);
        app.lineTo(borderWidth, box.height() - borderWidth);
        app.lineTo(box.width() - borderWidth, box.height() - borderWidth);
        app.lineTo(box.width() - 2 * borderWidth, box.height() - 2 * borderWidth);
        app.lineTo(2 * borderWidth, box.height() - 2 * borderWidth);
        app.lineTo(2 * borderWidth, 2 * borderWidth);
        app.lineTo(borderWidth, borderWidth);
        app.fill();
    }
    
    private void drawBottomFrame(PdfAppearance app) {
        app.moveTo(borderWidth, borderWidth);
        app.lineTo(box.width() - borderWidth, borderWidth);
        app.lineTo(box.width() - borderWidth, box.height() - borderWidth);
        app.lineTo(box.width() - 2 * borderWidth, box.height() - 2 * borderWidth);
        app.lineTo(box.width() - 2 * borderWidth, 2 * borderWidth);
        app.lineTo(2 * borderWidth, 2 * borderWidth);
        app.lineTo(borderWidth, borderWidth);
        app.fill();
    }
    /** Gets the border width in points.
     * @return the border width in points
     */
    public float getBorderWidth() {
        return this.borderWidth;
    }
    
    /** Sets the border width in points. To eliminate the border
     * set the border color to <CODE>null</CODE>.
     * @param borderWidth the border width in points
     */
    public void setBorderWidth(float borderWidth) {
        this.borderWidth = borderWidth;
    }
    
    /** Gets the border style.
     * @return the border style
     */
    public int getBorderStyle() {
        return this.borderStyle;
    }
    
    /** Sets the border style. The styles are found in <CODE>PdfBorderDictionary</CODE>
     * and can be <CODE>STYLE_SOLID</CODE>, <CODE>STYLE_DASHED</CODE>,
     * <CODE>STYLE_BEVELED</CODE>, <CODE>STYLE_INSET</CODE> and
     * <CODE>STYLE_UNDERLINE</CODE>.
     * @param borderStyle the border style
     */
    public void setBorderStyle(int borderStyle) {
        this.borderStyle = borderStyle;
    }
    
    /** Gets the border color.
     * @return the border color
     */
    public Color getBorderColor() {
        return this.borderColor;
    }
    
    /** Sets the border color. Set to <CODE>null</CODE> to remove
     * the border.
     * @param borderColor the border color
     */
    public void setBorderColor(Color borderColor) {
        this.borderColor = borderColor;
    }
    
    /** Gets the background color.
     * @return the background color
     */
    public Color getBackgroundColor() {
        return this.backgroundColor;
    }
    
    /** Sets the background color. Set to <CODE>null</CODE> for
     * transparent background.
     * @param backgroundColor the background color
     */
    public void setBackgroundColor(Color backgroundColor) {
        this.backgroundColor = backgroundColor;
    }
    
    /** Gets the text color.
     * @return the text color
     */
    public Color getTextColor() {
        return this.textColor;
    }
    
    /** Sets the text color. If <CODE>null</CODE> the color used
     * will be black.
     * @param textColor the text color
     */
    public void setTextColor(Color textColor) {
        this.textColor = textColor;
    }
    
    /** Gets the text font.
     * @return the text font
     */
    public BaseFont getFont() {
        return this.font;
    }
    
    /** Sets the text font. If <CODE>null</CODE> then Helvetica
     * will be used.
     * @param font the text font
     */
    public void setFont(BaseFont font) {
        this.font = font;
    }
    
    /** Gets the font size.
     * @return the font size
     */
    public float getFontSize() {
        return this.fontSize;
    }
    
    /** Sets the font size. If 0 then auto-sizing will be used but
     * only for text fields.
     * @param fontSize the font size
     */
    public void setFontSize(float fontSize) {
        this.fontSize = fontSize;
    }
    
    /** Gets the text horizontal alignment.
     * @return the text horizontal alignment
     */
    public int getAlignment() {
        return this.alignment;
    }
    
    /** Sets the text horizontal alignment. It can be <CODE>Element.ALIGN_LEFT</CODE>,
     * <CODE>Element.ALIGN_CENTER</CODE> and <CODE>Element.ALIGN_RIGHT</CODE>.
     * @param alignment the text horizontal alignment
     */
    public void setAlignment(int alignment) {
        this.alignment = alignment;
    }
    
    /** Gets the text.
     * @return the text
     */
    public String getText() {
        return this.text;
    }
    
    /** Sets the text for text fields.
     * @param text the text
     */
    public void setText(String text) {
        this.text = text;
    }
    
    /** Gets the field dimension and position.
     * @return the field dimension and position
     */
    public Rectangle getBox() {
        return this.box;
    }
    
    /** Sets the field dimension and position.
     * @param box the field dimension and position
     */
    public void setBox(Rectangle box) {
        this.box = box;
    }
    
    /** Gets the field rotation.
     * @return the field rotation
     */
    public int getRotation() {
        return this.rotation;
    }
    
    /** Sets the field rotation. This value should be the same as
     * the page rotation where the field will be shown.
     * @param rotation the field rotation
     */
    public void setRotation(int rotation) {
        if (rotation % 90 != 0)
            throw new IllegalArgumentException("Rotation must be a multiple of 90.");
        rotation %= 360;
        if (rotation < 0)
            rotation += 360;
        this.rotation = rotation;
    }
    
    /** Convenience method to set the field rotation the same as the
     * page rotation.
     * @param page the page
     */    
    public void setRotationFromPage(Rectangle page) {
        setRotation(page.getRotation());
    }
    
    /** Gets the field visibility flag.
     * @return the field visibility flag
     */
    public int getVisibility() {
        return this.visibility;
    }
    
    /** Sets the field visibility flag. This flags can be one of
     * <CODE>VISIBLE</CODE>, <CODE>HIDDEN</CODE>, <CODE>VISIBLE_BUT_DOES_NOT_PRINT</CODE>
     * and <CODE>HIDDEN_BUT_PRINTABLE</CODE>.
     * @param visibility field visibility flag
     */
    public void setVisibility(int visibility) {
        this.visibility = visibility;
    }
    
    /** Gets the field name.
     * @return the field name
     */
    public String getFieldName() {
        return this.fieldName;
    }
    
    /** Sets the field name.
     * @param fieldName the field name. If <CODE>null</CODE> only the widget keys
     * will be included in the field allowing it to be used as a kid field.
     */
    public void setFieldName(String fieldName) {
        this.fieldName = fieldName;
    }
    
    /** Gets the option flags.
     * @return the option flags
     */
    public int getOptions() {
        return this.options;
    }
    
    /** Sets the option flags. The option flags can be a combination by oring of
     * <CODE>READ_ONLY</CODE>, <CODE>REQUIRED</CODE>,
     * <CODE>MULTILINE</CODE>, <CODE>DO_NOT_SCROLL</CODE>,
     * <CODE>PASSWORD</CODE>, <CODE>FILE_SELECTION</CODE>,
     * <CODE>DO_NOT_SPELL_CHECK</CODE> and <CODE>EDIT</CODE>.
     * @param options the option flags
     */
    public void setOptions(int options) {
        this.options = options;
    }
    
    /** Gets the maximum length of the field's text, in characters.
     * @return the maximum length of the field's text, in characters.
     */
    public int getMaxCharacterLength() {
        return this.maxCharacterLength;
    }
    
    /** Sets the maximum length of the field's text, in characters.
     * It is only meaningful for text fields.
     * @param maxCharacterLength the maximum length of the field's text, in characters
     */
    public void setMaxCharacterLength(int maxCharacterLength) {
        this.maxCharacterLength = maxCharacterLength;
    }
    
    /**
     * Getter for property writer.
     * @return Value of property writer.
     */
    public PdfWriter getWriter() {
        return writer;
    }
    
    /**
     * Setter for property writer.
     * @param writer New value of property writer.
     */
    public void setWriter(PdfWriter writer) {
        this.writer = writer;
    }
    
    /**
     * Moves the field keys from <CODE>from</CODE> to <CODE>to</CODE>. The moved keys
     * are removed from <CODE>from</CODE>.
     * @param from the source
     * @param to the destination. It may be <CODE>null</CODE>
     */    
    public static void moveFields(PdfDictionary from, PdfDictionary to) {
        for (Iterator i = from.getKeys().iterator(); i.hasNext();) {
            PdfName key = (PdfName)i.next();
            if (fieldKeys.containsKey(key)) {
                if (to != null)
                    to.put(key, from.get(key));
                i.remove();
            }
        }
    }
} /*
 * $Id: BaseFont.java,v 1.67 2005/07/26 17:32:39 psoares33 Exp $
 * $Name:  $
 *
 * Copyright 2000, 2001, 2002 by Paulo Soares.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf;
import java.io.*;
import pdftk.com.lowagie.text.DocumentException;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;

/**
 * Base class for the several font types supported
 *
 * @author Paulo Soares (psoares@consiste.pt)
 */

public abstract class BaseFont {
    
    /** This is a possible value of a base 14 type 1 font */
    public static final String COURIER = "Courier";
    
    /** This is a possible value of a base 14 type 1 font */
    public static final String COURIER_BOLD = "Courier-Bold";
    
    /** This is a possible value of a base 14 type 1 font */
    public static final String COURIER_OBLIQUE = "Courier-Oblique";
    
    /** This is a possible value of a base 14 type 1 font */
    public static final String COURIER_BOLDOBLIQUE = "Courier-BoldOblique";
    
    /** This is a possible value of a base 14 type 1 font */
    public static final String HELVETICA = "Helvetica";
    
    /** This is a possible value of a base 14 type 1 font */
    public static final String HELVETICA_BOLD = "Helvetica-Bold";
    
    /** This is a possible value of a base 14 type 1 font */
    public static final String HELVETICA_OBLIQUE = "Helvetica-Oblique";
    
    /** This is a possible value of a base 14 type 1 font */
    public static final String HELVETICA_BOLDOBLIQUE = "Helvetica-BoldOblique";
    
    /** This is a possible value of a base 14 type 1 font */
    public static final String SYMBOL = "Symbol";
    
    /** This is a possible value of a base 14 type 1 font */
    public static final String TIMES_ROMAN = "Times-Roman";
    
    /** This is a possible value of a base 14 type 1 font */
    public static final String TIMES_BOLD = "Times-Bold";
    
    /** This is a possible value of a base 14 type 1 font */
    public static final String TIMES_ITALIC = "Times-Italic";
    
    /** This is a possible value of a base 14 type 1 font */
    public static final String TIMES_BOLDITALIC = "Times-BoldItalic";
    
    /** This is a possible value of a base 14 type 1 font */
    public static final String ZAPFDINGBATS = "ZapfDingbats";
    
    /** The maximum height above the baseline reached by glyphs in this
     * font, excluding the height of glyphs for accented characters.
     */    
    public static final int ASCENT = 1;    
    /** The y coordinate of the top of flat capital letters, measured from
     * the baseline.
     */    
    public static final int CAPHEIGHT = 2;
    /** The maximum depth below the baseline reached by glyphs in this
     * font. The value is a negative number.
     */    
    public static final int DESCENT = 3;
    /** The angle, expressed in degrees counterclockwise from the vertical,
     * of the dominant vertical strokes of the font. The value is
     * negative for fonts that slope to the right, as almost all italic fonts do.
     */    
    public static final int ITALICANGLE = 4;
    /** The lower left x glyph coordinate.
     */    
    public static final int BBOXLLX = 5;
    /** The lower left y glyph coordinate.
     */    
    public static final int BBOXLLY = 6;
    /** The upper right x glyph coordinate.
     */    
    public static final int BBOXURX = 7;
    /** The upper right y glyph coordinate.
     */    
    public static final int BBOXURY = 8;
    
    /** java.awt.Font property */
    public static final int AWT_ASCENT = 9;
    /** java.awt.Font property */
    public static final int AWT_DESCENT = 10;
    /** java.awt.Font property */
    public static final int AWT_LEADING = 11;
    /** java.awt.Font property */
    public static final int AWT_MAXADVANCE = 12;
    
    /** The font is Type 1.
     */    
    public static final int FONT_TYPE_T1 = 0;
    /** The font is True Type with a standard encoding.
     */    
    public static final int FONT_TYPE_TT = 1;
    /** The font is CJK.
     */    
    public static final int FONT_TYPE_CJK = 2;
    /** The font is True Type with a Unicode encoding.
     */    
    public static final int FONT_TYPE_TTUNI = 3;
    /** A font already inside the document.
     */    
    public static final int FONT_TYPE_DOCUMENT = 4;
    /** A Type3 font.
     */    
    public static final int FONT_TYPE_T3 = 5;
    /** The Unicode encoding with horizontal writing.
     */    
    public static final String IDENTITY_H = "Identity-H";
    /** The Unicode encoding with vertical writing.
     */    
    public static final String IDENTITY_V = "Identity-V";
    
    /** A possible encoding. */    
    public static final String CP1250 = "Cp1250";
    
    /** A possible encoding. */    
    public static final String CP1252 = "Cp1252";
    
    /** A possible encoding. */    
    public static final String CP1257 = "Cp1257";
    
    /** A possible encoding. */    
    public static final String WINANSI = "Cp1252";
    
    /** A possible encoding. */    
    public static final String MACROMAN = "MacRoman";
    
    
/** if the font has to be embedded */
    public static final boolean EMBEDDED = true;
    
/** if the font doesn't have to be embedded */
    public static final boolean NOT_EMBEDDED = false;
/** if the font has to be cached */
    public static final boolean CACHED = true;
/** if the font doesn't have to be cached */
    public static final boolean NOT_CACHED = false;
    
    /** The path to the font resources. */    
    public static final String RESOURCE_PATH = "pdftk/com/lowagie/text/pdf/fonts/";
    /** The fake CID code that represents a newline. */    
    public static final char CID_NEWLINE = '\u7fff';
    
    /** The font type.
     */    
    int fontType;
/** a not defined character in a custom PDF encoding */
    public static final String notdef = ".notdef";
    
/** table of characters widths for this encoding */
    protected int widths[] = new int[256];
    
/** encoding names */
    protected String differences[] = new String[256];
/** same as differences but with the unicode codes */
    protected char unicodeDifferences[] = new char[256];
    
    protected int charBBoxes[][] = new int[256][];
/** encoding used with this font */
    protected String encoding;
    
/** true if the font is to be embedded in the PDF */
    protected boolean embedded;
    
/**
 * true if the font must use it's built in encoding. In that case the
 * <CODE>encoding</CODE> is only used to map a char to the position inside
 * the font, not to the expected char name.
 */
    protected boolean fontSpecific = true;
    
/** cache for the fonts already used. */
    protected static HashMap fontCache = new HashMap();
    
/** list of the 14 built in fonts. */
    protected static final HashMap BuiltinFonts14 = new HashMap();
    
    /** Forces the output of the width array. Only matters for the 14
     * built-in fonts.
     */
    protected boolean forceWidthsOutput = false;
    
    /** Converts <CODE>char</CODE> directly to <CODE>byte</CODE>
     * by casting.
     */
    protected boolean directTextToByte = false;
    
    /** Indicates if all the glyphs and widths for that particular
     * encoding should be included in the document.
     */
    protected boolean subset = true;
    
    protected boolean fastWinansi = false;
    
    static {
        BuiltinFonts14.put(COURIER, PdfName.COURIER);
        BuiltinFonts14.put(COURIER_BOLD, PdfName.COURIER_BOLD);
        BuiltinFonts14.put(COURIER_BOLDOBLIQUE, PdfName.COURIER_BOLDOBLIQUE);
        BuiltinFonts14.put(COURIER_OBLIQUE, PdfName.COURIER_OBLIQUE);
        BuiltinFonts14.put(HELVETICA, PdfName.HELVETICA);
        BuiltinFonts14.put(HELVETICA_BOLD, PdfName.HELVETICA_BOLD);
        BuiltinFonts14.put(HELVETICA_BOLDOBLIQUE, PdfName.HELVETICA_BOLDOBLIQUE);
        BuiltinFonts14.put(HELVETICA_OBLIQUE, PdfName.HELVETICA_OBLIQUE);
        BuiltinFonts14.put(SYMBOL, PdfName.SYMBOL);
        BuiltinFonts14.put(TIMES_ROMAN, PdfName.TIMES_ROMAN);
        BuiltinFonts14.put(TIMES_BOLD, PdfName.TIMES_BOLD);
        BuiltinFonts14.put(TIMES_BOLDITALIC, PdfName.TIMES_BOLDITALIC);
        BuiltinFonts14.put(TIMES_ITALIC, PdfName.TIMES_ITALIC);
        BuiltinFonts14.put(ZAPFDINGBATS, PdfName.ZAPFDINGBATS);
    }
    
    /** Generates the PDF stream with the Type1 and Truetype fonts returning
     * a PdfStream.
     */
    static class StreamFont extends PdfStream {
        
        /** Generates the PDF stream with the Type1 and Truetype fonts returning
         * a PdfStream.
         * @param contents the content of the stream
         * @param lengths an array of int that describes the several lengths of each part of the font
         * @throws DocumentException error in the stream compression
         */
        public StreamFont(byte contents[], int lengths[]) throws DocumentException {
            try {
                bytes = contents;
                put(PdfName.LENGTH, new PdfNumber(bytes.length));
                for (int k = 0; k < lengths.length; ++k) {
                    put(new PdfName("Length" + (k + 1)), new PdfNumber(lengths[k]));
                }
                flateCompress();
            }
            catch (Exception e) {
                throw new DocumentException(e);
            }
        }
        
        /**
         * Generates the PDF stream for a font.
         * @param contents the content of a stream
         * @param subType the subtype of the font.
         * @throws DocumentException
         */
        public StreamFont(byte contents[], String subType) throws DocumentException {
            try {
                bytes = contents;
                put(PdfName.LENGTH, new PdfNumber(bytes.length));
                if (subType != null)
                    put(PdfName.SUBTYPE, new PdfName(subType));
                flateCompress();
            }
            catch (Exception e) {
                throw new DocumentException(e);
            }
        }
    }
    
    /**
     *Creates new BaseFont
     */
    protected BaseFont() {
    }
    
    /** Creates a new font. This font can be one of the 14 built in types,
     * a Type1 font referred by an AFM file, a TrueType font (simple or collection) or a CJK font from the
     * Adobe Asian Font Pack. TrueType fonts and CJK fonts can have an optional style modifier
     * appended to the name. These modifiers are: Bold, Italic and BoldItalic. An
     * example would be "STSong-Light,Bold". Note that this modifiers do not work if
     * the font is embedded. Fonts in TrueType collections are addressed by index such as "msgothic.ttc,1".
     * This would get the second font (indexes start at 0), in this case "MS PGothic".
     * <P>
     * The fonts are cached and if they already exist they are extracted from the cache,
     * not parsed again.
     * <P>
     * This method calls:<br>
     * <PRE>
     * createFont(name, encoding, embedded, true, null, null);
     * </PRE>
     * @param name the name of the font or it's location on file
     * @param encoding the encoding to be applied to this font
     * @param embedded true if the font is to be embedded in the PDF
     * @return returns a new font. This font may come from the cache
     * @throws DocumentException the font is invalid
     * @throws IOException the font file could not be read
     */
    public static BaseFont createFont(String name, String encoding, boolean embedded) throws DocumentException, IOException {
        return createFont(name, encoding, embedded, true, null, null);
    }
    
    /** Creates a new font. This font can be one of the 14 built in types,
     * a Type1 font referred by an AFM file, a TrueType font (simple or collection) or a CJK font from the
     * Adobe Asian Font Pack. TrueType fonts and CJK fonts can have an optional style modifier
     * appended to the name. These modifiers are: Bold, Italic and BoldItalic. An
     * example would be "STSong-Light,Bold". Note that this modifiers do not work if
     * the font is embedded. Fonts in TrueType collections are addressed by index such as "msgothic.ttc,1".
     * This would get the second font (indexes start at 0), in this case "MS PGothic".
     * <P>
     * The fonts may or may not be cached depending on the flag <CODE>cached</CODE>.
     * If the <CODE>byte</CODE> arrays are present the font will be
     * read from them instead of the name. The name is still required to identify
     * the font type.
     * @param name the name of the font or it's location on file
     * @param encoding the encoding to be applied to this font
     * @param embedded true if the font is to be embedded in the PDF
     * @param cached true if the font comes from the cache or is added to
     * the cache if new, false if the font is always created new
     * @param ttfAfm the true type font or the afm in a byte array
     * @param pfb the pfb in a byte array
     * @return returns a new font. This font may come from the cache but only if cached
     * is true, otherwise it will always be created new
     * @throws DocumentException the font is invalid
     * @throws IOException the font file could not be read
     */
    public static BaseFont createFont(String name, String encoding, boolean embedded, boolean cached, byte ttfAfm[], byte pfb[]) throws DocumentException, IOException {
        String nameBase = getBaseName(name);
        encoding = normalizeEncoding(encoding);
        boolean isBuiltinFonts14 = BuiltinFonts14.containsKey(name);
        boolean isCJKFont = isBuiltinFonts14 ? false : CJKFont.isCJKFont(nameBase, encoding);
        if (isBuiltinFonts14 || isCJKFont)
            embedded = false;
        else if (encoding.equals(IDENTITY_H) || encoding.equals(IDENTITY_V))
            embedded = true;
        BaseFont fontFound = null;
        BaseFont fontBuilt = null;
        String key = name + "\n" + encoding + "\n" + embedded;
        if (cached) {
            synchronized (fontCache) {
                fontFound = (BaseFont)fontCache.get(key);
            }
            if (fontFound != null)
                return fontFound;
        }
        if (isBuiltinFonts14 || name.toLowerCase().endsWith(".afm") || name.toLowerCase().endsWith(".pfm")) {
            fontBuilt = new Type1Font(name, encoding, embedded, ttfAfm, pfb);
            fontBuilt.fastWinansi = encoding.equals(CP1252);
        }
        else if (nameBase.toLowerCase().endsWith(".ttf") || nameBase.toLowerCase().endsWith(".otf") || nameBase.toLowerCase().indexOf(".ttc,") > 0) {
            if (encoding.equals(IDENTITY_H) || encoding.equals(IDENTITY_V))
                fontBuilt = new TrueTypeFontUnicode(name, encoding, embedded, ttfAfm);
            else {
                fontBuilt = new TrueTypeFont(name, encoding, embedded, ttfAfm);
                fontBuilt.fastWinansi = encoding.equals(CP1252);
            }
        }
        else if (isCJKFont)
            fontBuilt = new CJKFont(name, encoding, embedded);
        else
            throw new DocumentException("Font '" + name + "' with '" + encoding + "' is not recognized.");
        if (cached) {
            synchronized (fontCache) {
                fontFound = (BaseFont)fontCache.get(key);
                if (fontFound != null)
                    return fontFound;
                fontCache.put(key, fontBuilt);
            }
        }
        return fontBuilt;
    }
    
    /**
     * Creates a font based on an existing document font. The created font font may not
     * behave as expected, depending on the encoding or subset.
     * @param fontRef the reference to the document font
     * @return the font
     */    
    public static BaseFont createFont(PRIndirectReference fontRef) {
        return new DocumentFont(fontRef);
    }
    
    /**
     * Gets the name without the modifiers Bold, Italic or BoldItalic.
     * @param name the full name of the font
     * @return the name without the modifiers Bold, Italic or BoldItalic
     */
    protected static String getBaseName(String name) {
        if (name.endsWith(",Bold"))
            return name.substring(0, name.length() - 5);
        else if (name.endsWith(",Italic"))
            return name.substring(0, name.length() - 7);
        else if (name.endsWith(",BoldItalic"))
            return name.substring(0, name.length() - 11);
        else
            return name;
    }
    
    /**
     * Normalize the encoding names. "winansi" is changed to "Cp1252" and
     * "macroman" is changed to "MacRoman".
     * @param enc the encoding to be normalized
     * @return the normalized encoding
     */
    protected static String normalizeEncoding(String enc) {
        if (enc.equals("winansi") || enc.equals(""))
            return CP1252;
        else if (enc.equals("macroman"))
            return MACROMAN;
        else
            return enc;
    }
    
    /**
     * Creates the <CODE>widths</CODE> and the <CODE>differences</CODE> arrays
     */
    protected void createEncoding() {
        if (fontSpecific) {
            for (int k = 0; k < 256; ++k) {
                widths[k] = getRawWidth(k, null);
                charBBoxes[k] = getRawCharBBox(k, null);
            }
        }
        else {
            String s;
            String name;
            char c;
            byte b[] = new byte[1];
            for (int k = 0; k < 256; ++k) {
                b[0] = (byte)k;
                s = PdfEncodings.convertToString(b, encoding);
                if (s.length() > 0) {
                    c = s.charAt(0);
                }
                else {
                    c = '?';
                }
                name = GlyphList.unicodeToName(c);
                if (name == null)
                    name = notdef;
                differences[k] = name;
                unicodeDifferences[k] = c;
                widths[k] = getRawWidth(c, name);
                charBBoxes[k] = getRawCharBBox(c, name);
            }
        }
    }
    
    /**
     * Gets the width from the font according to the Unicode char <CODE>c</CODE>
     * or the <CODE>name</CODE>. If the <CODE>name</CODE> is null it's a symbolic font.
     * @param c the unicode char
     * @param name the glyph name
     * @return the width of the char
     */
    abstract int getRawWidth(int c, String name);
    
    /**
     * Gets the kerning between two Unicode chars.
     * @param char1 the first char
     * @param char2 the second char
     * @return the kerning to be applied in normalized 1000 units
     */
    public abstract int getKerning(char char1, char char2);

    /**
     * Sets the kerning between two Unicode chars.
     * @param char1 the first char
     * @param char2 the second char
     * @param kern the kerning to apply in normalized 1000 units
     * @return <code>true</code> if the kerning was applied, <code>false</code> otherwise
     */
    public abstract boolean setKerning(char char1, char char2, int kern);
    
    /**
     * Gets the width of a <CODE>char</CODE> in normalized 1000 units.
     * @param char1 the unicode <CODE>char</CODE> to get the width of
     * @return the width in normalized 1000 units
     */
    public int getWidth(char char1) {
        if (fastWinansi) {
            if (char1 < 128 || (char1 >= 160 && char1 <= 255))
                return widths[char1];
            return widths[PdfEncodings.winansi.get(char1)];
        }
        return getWidth(new String(new char[]{char1}));
    }
    
    /**
     * Gets the width of a <CODE>String</CODE> in normalized 1000 units.
     * @param text the <CODE>String</CODE> to get the witdth of
     * @return the width in normalized 1000 units
     */
    public int getWidth(String text) {
        int total = 0;
        if (fastWinansi) {
            int len = text.length();
            for (int k = 0; k < len; ++k) {
                char char1 = text.charAt(k);
                if (char1 < 128 || (char1 >= 160 && char1 <= 255))
                    total += widths[char1];
                else
                    total += widths[PdfEncodings.winansi.get(char1)];
            }
            return total;
        }
        else {
            byte mbytes[] = convertToBytes(text);
            for (int k = 0; k < mbytes.length; ++k)
                total += widths[0xff & mbytes[k]];
        }
        return total;
    }
    
/**
 * Gets the descent of a <CODE>String</CODE> in normalized 1000 units. The descent will always be
 * less than or equal to zero even if all the characters have an higher descent.
 * @param text the <CODE>String</CODE> to get the descent of
 * @return the dexcent in normalized 1000 units
 */
    public int getDescent(String text) {
        int min = 0;
        char chars[] = text.toCharArray();
        for (int k = 0; k < chars.length; ++k) {
            int bbox[] = getCharBBox(chars[k]);
            if (bbox != null && bbox[1] < min)
                min = bbox[1];
        }
        return min;
    }
    
/**
 * Gets the ascent of a <CODE>String</CODE> in normalized 1000 units. The ascent will always be
 * greater than or equal to zero even if all the characters have a lower ascent.
 * @param text the <CODE>String</CODE> to get the ascent of
 * @return the ascent in normalized 1000 units
 */
    public int getAscent(String text) {
        int max = 0;
        char chars[] = text.toCharArray();
        for (int k = 0; k < chars.length; ++k) {
            int bbox[] = getCharBBox(chars[k]);
            if (bbox != null && bbox[3] > max)
                max = bbox[3];
        }
        return max;
    }

/**
 * Gets the descent of a <CODE>String</CODE> in points. The descent will always be
 * less than or equal to zero even if all the characters have an higher descent.
 * @param text the <CODE>String</CODE> to get the descent of
 * @param fontSize the size of the font
 * @return the dexcent in points
 */
    public float getDescentPoint(String text, float fontSize)
    {
        return 0.001f * getDescent(text) * fontSize;
    }
    
/**
 * Gets the ascent of a <CODE>String</CODE> in points. The ascent will always be
 * greater than or equal to zero even if all the characters have a lower ascent.
 * @param text the <CODE>String</CODE> to get the ascent of
 * @param fontSize the size of the font
 * @return the ascent in points
 */
    public float getAscentPoint(String text, float fontSize)
    {
        return 0.001f * getAscent(text) * fontSize;
    }
// ia>    
    
    /**
     * Gets the width of a <CODE>String</CODE> in points taking kerning
     * into account.
     * @param text the <CODE>String</CODE> to get the witdth of
     * @param fontSize the font size
     * @return the width in points
     */
    public float getWidthPointKerned(String text, float fontSize) {
        float size = 0.001f * getWidth(text) * fontSize;
        if (!hasKernPairs())
            return size;
        int len = text.length() - 1;
        int kern = 0;
        char c[] = text.toCharArray();
        for (int k = 0; k < len; ++k) {
            kern += getKerning(c[k], c[k + 1]);
        }
        return size + kern * 0.001f * fontSize;
    }
    
    /**
     * Gets the width of a <CODE>String</CODE> in points.
     * @param text the <CODE>String</CODE> to get the witdth of
     * @param fontSize the font size
     * @return the width in points
     */
    public float getWidthPoint(String text, float fontSize) {
        return 0.001f * getWidth(text) * fontSize;
    }
    
    /**
     * Gets the width of a <CODE>char</CODE> in points.
     * @param char1 the <CODE>char</CODE> to get the witdth of
     * @param fontSize the font size
     * @return the width in points
     */
    public float getWidthPoint(char char1, float fontSize) {
        return getWidth(char1) * 0.001f * fontSize;
    }
    
    /**
     * Converts a <CODE>String</CODE> to a </CODE>byte</CODE> array according
     * to the font's encoding.
     * @param text the <CODE>String</CODE> to be converted
     * @return an array of <CODE>byte</CODE> representing the conversion according to the font's encoding
     */
    byte[] convertToBytes(String text) {
        if (directTextToByte)
            return PdfEncodings.convertToBytes(text, null);
        return PdfEncodings.convertToBytes(text, encoding);
    }
    
    /** Outputs to the writer the font dictionaries and streams.
     * @param writer the writer for this document
     * @param ref the font indirect reference
     * @param params several parameters that depend on the font type
     * @throws IOException on error
     * @throws DocumentException error in generating the object
     */
    abstract void writeFont(PdfWriter writer, PdfIndirectReference ref, Object params[]) throws DocumentException, IOException;
    
    /** Gets the encoding used to convert <CODE>String</CODE> into <CODE>byte[]</CODE>.
     * @return the encoding name
     */
    public String getEncoding() {
        return encoding;
    }
    
    /** Gets the font parameter identified by <CODE>key</CODE>. Valid values
     * for <CODE>key</CODE> are <CODE>ASCENT</CODE>, <CODE>AWT_ASCENT</CODE>, <CODE>CAPHEIGHT</CODE>, 
     * <CODE>DESCENT</CODE>, <CODE>AWT_DESCENT</CODE>,
     * <CODE>ITALICANGLE</CODE>, <CODE>BBOXLLX</CODE>, <CODE>BBOXLLY</CODE>, <CODE>BBOXURX</CODE>
     * and <CODE>BBOXURY</CODE>.
     * @param key the parameter to be extracted
     * @param fontSize the font size in points
     * @return the parameter in points
     */
    public abstract float getFontDescriptor(int key, float fontSize);
    
    /** Gets the font type. The font types can be: FONT_TYPE_T1,
     * FONT_TYPE_TT, FONT_TYPE_CJK and FONT_TYPE_TTUNI.
     * @return the font type
     */
    public int getFontType() {
        return fontType;
    }
    
    /** Gets the embedded flag.
     * @return <CODE>true</CODE> if the font is embedded.
     */
    public boolean isEmbedded() {
        return embedded;
    }
    
    /** Gets the symbolic flag of the font.
     * @return <CODE>true</CODE> if the font is symbolic
     */
    public boolean isFontSpecific() {
        return fontSpecific;
    }
    
    /** Creates a unique subset prefix to be added to the font name when the font is embedded and subset.
     * @return the subset prefix
     */
    public static String createSubsetPrefix() {
        String s = "";
        for (int k = 0; k < 6; ++k)
            s += (char)(Math.random() * 26 + 'A');
        return s + "+";
    }
    
    /** Gets the Unicode character corresponding to the byte output to the pdf stream.
     * @param index the byte index
     * @return the Unicode character
     */
    char getUnicodeDifferences(int index) {
        return unicodeDifferences[index];
    }
    
    /** Gets the postscript font name.
     * @return the postscript font name
     */
    public abstract String getPostscriptFontName();
    
    /**
     * Sets the font name that will appear in the pdf font dictionary.
     * Use with care as it can easily make a font unreadable if not embedded.
     * @param name the new font name
     */    
    public abstract void setPostscriptFontName(String name);
    
    /** Gets the full name of the font. If it is a True Type font
     * each array element will have {Platform ID, Platform Encoding ID,
     * Language ID, font name}. The interpretation of this values can be
     * found in the Open Type specification, chapter 2, in the 'name' table.<br>
     * For the other fonts the array has a single element with {"", "", "",
     * font name}.
     * @return the full name of the font
     */
    public abstract String[][] getFullFontName();
    
    /** Gets the full name of the font. If it is a True Type font
     * each array element will have {Platform ID, Platform Encoding ID,
     * Language ID, font name}. The interpretation of this values can be
     * found in the Open Type specification, chapter 2, in the 'name' table.<br>
     * For the other fonts the array has a single element with {"", "", "",
     * font name}.
     * @param name the name of the font
     * @param encoding the encoding of the font
     * @param ttfAfm the true type font or the afm in a byte array
     * @throws DocumentException on error
     * @throws IOException on error
     * @return the full name of the font
     */    
    public static String[][] getFullFontName(String name, String encoding, byte ttfAfm[]) throws DocumentException, IOException {
        String nameBase = getBaseName(name);
        BaseFont fontBuilt = null;
        if (nameBase.toLowerCase().endsWith(".ttf") || nameBase.toLowerCase().endsWith(".otf") || nameBase.toLowerCase().indexOf(".ttc,") > 0)
            fontBuilt = new TrueTypeFont(name, CP1252, false, ttfAfm, true);
        else
            fontBuilt = createFont(name, encoding, false, false, ttfAfm, null);
        return fontBuilt.getFullFontName();
    }
    
    /** Gets all the names from the font. Only the required tables are read.
     * @param name the name of the font
     * @param encoding the encoding of the font
     * @param ttfAfm the true type font or the afm in a byte array
     * @throws DocumentException on error
     * @throws IOException on error
     * @return an array of Object[] built with {getPostscriptFontName(), getFamilyFontName(), getFullFontName()}
     */    
    public static Object[] getAllFontNames(String name, String encoding, byte ttfAfm[]) throws DocumentException, IOException {
        String nameBase = getBaseName(name);
        BaseFont fontBuilt = null;
        if (nameBase.toLowerCase().endsWith(".ttf") || nameBase.toLowerCase().endsWith(".otf") || nameBase.toLowerCase().indexOf(".ttc,") > 0)
            fontBuilt = new TrueTypeFont(name, CP1252, false, ttfAfm, true);
        else
            fontBuilt = createFont(name, encoding, false, false, ttfAfm, null);
        return new Object[]{fontBuilt.getPostscriptFontName(), fontBuilt.getFamilyFontName(), fontBuilt.getFullFontName()};
    }
    
    /** Gets the family name of the font. If it is a True Type font
     * each array element will have {Platform ID, Platform Encoding ID,
     * Language ID, font name}. The interpretation of this values can be
     * found in the Open Type specification, chapter 2, in the 'name' table.<br>
     * For the other fonts the array has a single element with {"", "", "",
     * font name}.
     * @return the family name of the font
     */
    public abstract String[][] getFamilyFontName();
    
    /** Gets the code pages supported by the font. This has only meaning
     * with True Type fonts.
     * @return the code pages supported by the font
     */
    public String[] getCodePagesSupported() {
        return new String[0];
    }
    
    /** Enumerates the postscript font names present inside a
     * True Type Collection.
     * @param ttcFile the file name of the font
     * @throws DocumentException on error
     * @throws IOException on error
     * @return the postscript font names
     */    
    public static String[] enumerateTTCNames(String ttcFile) throws DocumentException, IOException {
        return new EnumerateTTC(ttcFile).getNames();
    }

    /** Enumerates the postscript font names present inside a
     * True Type Collection.
     * @param ttcArray the font as a <CODE>byte</CODE> array
     * @throws DocumentException on error
     * @throws IOException on error
     * @return the postscript font names
     */    
    public static String[] enumerateTTCNames(byte ttcArray[]) throws DocumentException, IOException {
        return new EnumerateTTC(ttcArray).getNames();
    }
    
    /** Gets the font width array.
     * @return the font width array
     */    
    public int[] getWidths() {
        return widths;
    }

    /** Gets the array with the names of the characters.
     * @return the array with the names of the characters
     */    
    public String[] getDifferences() {
        return differences;
    }

    /** Gets the array with the unicode characters.
     * @return the array with the unicode characters
     */    
    public char[] getUnicodeDifferences() {
        return unicodeDifferences;
    }
    
    /** Gets the state of the property.
     * @return value of property forceWidthsOutput
     */
    public boolean isForceWidthsOutput() {
        return forceWidthsOutput;
    }
    
    /** Set to <CODE>true</CODE> to force the generation of the
     * widths array.
     * @param forceWidthsOutput <CODE>true</CODE> to force the generation of the
     * widths array
     */
    public void setForceWidthsOutput(boolean forceWidthsOutput) {
        this.forceWidthsOutput = forceWidthsOutput;
    }
    
    /** Gets the direct conversion of <CODE>char</CODE> to <CODE>byte</CODE>.
     * @return value of property directTextToByte.
     * @see #setDirectTextToByte(boolean directTextToByte)
     */
    public boolean isDirectTextToByte() {
        return directTextToByte;
    }
    
    /** Sets the conversion of <CODE>char</CODE> directly to <CODE>byte</CODE>
     * by casting. This is a low level feature to put the bytes directly in
     * the content stream without passing through String.getBytes().
     * @param directTextToByte New value of property directTextToByte.
     */
    public void setDirectTextToByte(boolean directTextToByte) {
        this.directTextToByte = directTextToByte;
    }
    
    /** Indicates if all the glyphs and widths for that particular
     * encoding should be included in the document.
     * @return <CODE>false</CODE> to include all the glyphs and widths.
     */
    public boolean isSubset() {
        return subset;
    }
    
    /** Indicates if all the glyphs and widths for that particular
     * encoding should be included in the document. Set to <CODE>false</CODE>
     * to include all.
     * @param subset new value of property subset
     */
    public void setSubset(boolean subset) {
        this.subset = subset;
    }

    /** Gets the font resources.
     * @param key the full name of the resource
     * @return the <CODE>InputStream</CODE> to get the resource or
     * <CODE>null</CODE> if not found
     */    
    public static InputStream getResourceStream(String key) {
        return getResourceStream(key, null);
    }
    
    /** Gets the font resources.
     * @param key the full name of the resource
     * @param loader the ClassLoader to load the resource or null to try the ones available
     * @return the <CODE>InputStream</CODE> to get the resource or
     * <CODE>null</CODE> if not found
     */    
    public static InputStream getResourceStream(String key, ClassLoader loader) {
        if (key.startsWith("/"))
            key = key.substring(1);
        InputStream is = null;
        if (loader != null) {
            is = loader.getResourceAsStream(key);
            if (is != null)
                return is;
        }
        // Try to use Context Class Loader to load the properties file.
        try {
            java.lang.reflect.Method getCCL =
                Thread.class.getMethod("getContextClassLoader", new Class[0]);
            if (getCCL != null) {
                ClassLoader contextClassLoader =
                    (ClassLoader)getCCL.invoke(Thread.currentThread(),
                                               new Object[0]);
                if (contextClassLoader != null)
                    is = contextClassLoader.getResourceAsStream(key);
            }
        } catch (Throwable e) {}

        if (is == null) {
            is = BaseFont.class.getResourceAsStream("/" + key);
        }
        if (is == null) {
            is = ClassLoader.getSystemResourceAsStream(key);
        }
        return is;
    }
    
    /** Gets the Unicode equivalent to a CID.
     * The (inexistent) CID <FF00> is translated as '\n'. 
     * It has only meaning with CJK fonts with Identity encoding.
     * @param c the CID code
     * @return the Unicode equivalent
     */    
    public char getUnicodeEquivalent(char c) {
        return c;
    }
    
    /** Gets the CID code given an Unicode.
     * It has only meaning with CJK fonts.
     * @param c the Unicode
     * @return the CID equivalent
     */    
    public char getCidCode(char c) {
        return c;
    }

    /** Checks if the font has any kerning pairs.
     * @return <CODE>true</CODE> if the font has any kerning pairs
     */    
    public abstract boolean hasKernPairs();
    
    /**
     * Checks if a character exists in this font.
     * @param c the character to check
     * @return <CODE>true</CODE> if the character has a glyph,
     * <CODE>false</CODE> otherwise
     */    
    public boolean charExists(char c) {
        byte b[] = convertToBytes(new String(new char[]{c}));
        return b.length > 0;
    }
    
    /**
     * Sets the character advance.
     * @param c the character
     * @param advance the character advance normalized to 1000 units
     * @return <CODE>true</CODE> if the advance was set,
     * <CODE>false</CODE> otherwise
     */    
    public boolean setCharAdvance(char c, int advance) {
        byte b[] = convertToBytes(new String(new char[]{c}));
        if (b.length == 0)
            return false;
        widths[0xff & b[0]] = advance;
        return true;
    }
    
    private static void addFont(PRIndirectReference fontRef, IntHashtable hits, ArrayList fonts) {
        PdfObject obj = PdfReader.getPdfObject(fontRef);
        if (!obj.isDictionary())
            return;
        PdfDictionary font = (PdfDictionary)obj;
        PdfName subtype = (PdfName)PdfReader.getPdfObject(font.get(PdfName.SUBTYPE));
        if (!PdfName.TYPE1.equals(subtype) && !PdfName.TRUETYPE.equals(subtype))
            return;
        PdfName name = (PdfName)PdfReader.getPdfObject(font.get(PdfName.BASEFONT));
        fonts.add(new Object[]{PdfName.decodeName(name.toString()), fontRef});
        hits.put(fontRef.getNumber(), 1);
    }
    
    private static void recourseFonts(PdfDictionary page, IntHashtable hits, ArrayList fonts, int level) {
        ++level;
        if (level > 50) // in case we have an endless loop
            return;
        PdfDictionary resources = (PdfDictionary)PdfReader.getPdfObject(page.get(PdfName.RESOURCES));
        if (resources == null)
            return;
        PdfDictionary font = (PdfDictionary)PdfReader.getPdfObject(resources.get(PdfName.FONT));
        if (font != null) {
            for (Iterator it = font.getKeys().iterator(); it.hasNext();) {
                PdfObject ft = font.get((PdfName)it.next());        
                if (ft == null || !ft.isIndirect())
                    continue;
                int hit = ((PRIndirectReference)ft).getNumber();
                if (hits.containsKey(hit))
                    continue;
                addFont((PRIndirectReference)ft, hits, fonts);
            }
        }
        PdfDictionary xobj = (PdfDictionary)PdfReader.getPdfObject(resources.get(PdfName.XOBJECT));
        if (xobj != null) {
            for (Iterator it = xobj.getKeys().iterator(); it.hasNext();) {
                recourseFonts((PdfDictionary)PdfReader.getPdfObject(xobj.get((PdfName)it.next())), hits, fonts, level);
            }
        }
    }
    
    /**
     * Gets a list of all document fonts. Each element of the <CODE>ArrayList</CODE>
     * contains a <CODE>Object[]{String,PRIndirectReference}</CODE> with the font name
     * and the indirect reference to it.
     * @param reader the document where the fonts are to be listed from
     * @return the list of fonts and references
     */    
    public static ArrayList getDocumentFonts(PdfReader reader) {
        IntHashtable hits = new IntHashtable();
        ArrayList fonts = new ArrayList();
        int npages = reader.getNumberOfPages();
        for (int k = 1; k <= npages; ++k)
            recourseFonts(reader.getPageN(k), hits, fonts, 1);
        return fonts;
    }
    
    /**
     * Gets a list of the document fonts in a particular page. Each element of the <CODE>ArrayList</CODE>
     * contains a <CODE>Object[]{String,PRIndirectReference}</CODE> with the font name
     * and the indirect reference to it.
     * @param reader the document where the fonts are to be listed from
     * @param page the page to list the fonts from
     * @return the list of fonts and references
     */    
    public static ArrayList getDocumentFonts(PdfReader reader, int page) {
        IntHashtable hits = new IntHashtable();
        ArrayList fonts = new ArrayList();
        recourseFonts(reader.getPageN(page), hits, fonts, 1);
        return fonts;
    }
    
    /**
     * Gets the smallest box enclosing the character contours. It will return
     * <CODE>null</CODE> if the font has not the information or the character has no
     * contours, as in the case of the space, for example. Characters with no contours may
     * also return [0,0,0,0].
     * @param c the character to get the contour bounding box from
     * @return an array of four floats with the bounding box in the format [llx,lly,urx,ury] or
     * <code>null</code>
     */    
    public int[] getCharBBox(char c) {
        byte b[] = convertToBytes(new String(new char[]{c}));
        if (b.length == 0)
            return null;
        else
            return charBBoxes[b[0] & 0xff];
    }
    
    protected abstract int[] getRawCharBBox(int c, String name);

    /**
     * iText expects Arabic Diactrics (tashkeel) to have zero advance but some fonts,
     * most notably those that come with Windows, like times.ttf, have non-zero
     * advance for those characters. This method makes those character to have zero
     * width advance and work correctly in the iText Arabic shaping and reordering
     * context.
     */    
    public void correctArabicAdvance() {
        for (char c = '\u064b'; c <= '\u0658'; ++c)
            setCharAdvance(c, 0);
        setCharAdvance('\u0670', 0);
        for (char c = '\u06d6'; c <= '\u06dc'; ++c)
            setCharAdvance(c, 0);
        for (char c = '\u06df'; c <= '\u06e4'; ++c)
            setCharAdvance(c, 0);
        for (char c = '\u06e7'; c <= '\u06e8'; ++c)
            setCharAdvance(c, 0);
        for (char c = '\u06ea'; c <= '\u06ed'; ++c)
            setCharAdvance(c, 0);
    }
}
 /*
 *
 * Copyright 2002 Paulo Soares
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf;

import java.util.ArrayList;

import pdftk.com.lowagie.text.Chunk;

/** Does all the line bidirectional processing with PdfChunk assembly.
 *
 * @author Paulo Soares (psoares@consiste.pt)
 */
public class BidiLine {
    
    protected int runDirection;
    protected int pieceSize = 2048;
    protected char text[] = new char[pieceSize];
    protected PdfChunk detailChunks[] = new PdfChunk[pieceSize];
    protected int totalTextLength = 0;
    
    protected byte orderLevels[] = new byte[pieceSize];
    protected int indexChars[] = new int[pieceSize];
    
    protected ArrayList chunks = new ArrayList();
    protected int indexChunk = 0;
    protected int indexChunkChar = 0;
    protected int currentChar = 0;
    
    protected int storedRunDirection;
    protected char storedText[] = new char[0];
    protected PdfChunk storedDetailChunks[] = new PdfChunk[0];
    protected int storedTotalTextLength = 0;
    
    protected byte storedOrderLevels[] = new byte[0];
    protected int storedIndexChars[] = new int[0];
    
    protected int storedIndexChunk = 0;
    protected int storedIndexChunkChar = 0;
    protected int storedCurrentChar = 0;
    
    protected boolean shortStore;
//    protected ArabicShaping arabic = new ArabicShaping(ArabicShaping.LETTERS_SHAPE | ArabicShaping.LENGTH_GROW_SHRINK | ArabicShaping.TEXT_DIRECTION_LOGICAL);
    protected static final IntHashtable mirrorChars = new IntHashtable();
    protected int arabicOptions;

    /** Creates new BidiLine */
    public BidiLine() {
    }
    
    public BidiLine(BidiLine org) {
        runDirection = org.runDirection;
        pieceSize = org.pieceSize;
        text = (char[])org.text.clone();
        detailChunks = (PdfChunk[])org.detailChunks.clone();
        totalTextLength = org.totalTextLength;

        orderLevels = (byte[])org.orderLevels.clone();
        indexChars = (int[])org.indexChars.clone();

        chunks = new ArrayList(org.chunks);
        indexChunk = org.indexChunk;
        indexChunkChar = org.indexChunkChar;
        currentChar = org.currentChar;

        storedRunDirection = org.storedRunDirection;
        storedText = (char[])org.storedText.clone();
        storedDetailChunks = (PdfChunk[])org.storedDetailChunks.clone();
        storedTotalTextLength = org.storedTotalTextLength;

        storedOrderLevels = (byte[])org.storedOrderLevels.clone();
        storedIndexChars = (int[])org.storedIndexChars.clone();

        storedIndexChunk = org.storedIndexChunk;
        storedIndexChunkChar = org.storedIndexChunkChar;
        storedCurrentChar = org.storedCurrentChar;

        shortStore = org.shortStore;
        arabicOptions = org.arabicOptions;
    }
    
    public boolean isEmpty() {
        return (currentChar >= totalTextLength && indexChunk >= chunks.size());
    }
    
    public void clearChunks() {
        chunks.clear();
        totalTextLength = 0;
        currentChar = 0;
    }

    public boolean getParagraph(int runDirection) {
        this.runDirection = runDirection;
        currentChar = 0;
        totalTextLength = 0;
        boolean hasText = false;
        char c;
        char uniC;
        BaseFont bf;
        for (; indexChunk < chunks.size(); ++indexChunk) {
            PdfChunk ck = (PdfChunk)chunks.get(indexChunk);
            bf = ck.font().getFont();
            String s = ck.toString();
            int len = s.length();
            for (; indexChunkChar < len; ++indexChunkChar) {
                c = s.charAt(indexChunkChar);
                uniC = bf.getUnicodeEquivalent(c);
                if (uniC == '\r' || uniC == '\n') {
                    // next condition is never true for CID
                    if (uniC == '\r' && indexChunkChar + 1 < len && s.charAt(indexChunkChar + 1) == '\n')
                        ++indexChunkChar;
                    ++indexChunkChar;
                    if (indexChunkChar >= len) {
                        indexChunkChar = 0;
                        ++indexChunk;
                    }
                    hasText = true;
                    if (totalTextLength == 0)
                        detailChunks[0] = ck;
                    break;
                }
                addPiece(c, ck);
            }
            if (hasText)
                break;
            indexChunkChar = 0;
        }
        if (totalTextLength == 0)
            return hasText;

        // remove trailing WS
        totalTextLength = trimRight(0, totalTextLength - 1) + 1;
        if (totalTextLength == 0)
            return true;
        
        if (runDirection == PdfWriter.RUN_DIRECTION_LTR || runDirection == PdfWriter.RUN_DIRECTION_RTL) {
            if (orderLevels.length < totalTextLength) {
                orderLevels = new byte[pieceSize];
                indexChars = new int[pieceSize];
            }
            ArabicLigaturizer.processNumbers(text, 0, totalTextLength, arabicOptions);
            BidiOrder order = new BidiOrder(text, 0, totalTextLength, (byte)(runDirection == PdfWriter.RUN_DIRECTION_RTL ? 1 : 0));
            byte od[] = order.getLevels();
            for (int k = 0; k < totalTextLength; ++k) {
                orderLevels[k] = od[k];
                indexChars[k] = k;
            }
            doArabicShapping();
            mirrorGlyphs();
        }
        totalTextLength = trimRightEx(0, totalTextLength - 1) + 1;
        return true;
    }
    
    public void addChunk(PdfChunk chunk) {
        chunks.add(chunk);
    }
    
    public void addChunks(ArrayList chunks) {
        this.chunks.addAll(chunks);
    }
    
    public void addPiece(char c, PdfChunk chunk) {
        if (totalTextLength >= pieceSize) {
            char tempText[] = text;
            PdfChunk tempDetailChunks[] = detailChunks;
            pieceSize *= 2;
            text = new char[pieceSize];
            detailChunks = new PdfChunk[pieceSize];
            System.arraycopy(tempText, 0, text, 0, totalTextLength);
            System.arraycopy(tempDetailChunks, 0, detailChunks, 0, totalTextLength);
        }
        text[totalTextLength] = c;
        detailChunks[totalTextLength++] = chunk;
    }
    
    public void save() {
        if (indexChunk > 0) {
            if (indexChunk >= chunks.size())
                chunks.clear();
            else {
                for (--indexChunk; indexChunk >= 0; --indexChunk)
                    chunks.remove(indexChunk);
            }
            indexChunk = 0;
        }
        storedRunDirection = runDirection;
        storedTotalTextLength = totalTextLength;
        storedIndexChunk = indexChunk;
        storedIndexChunkChar = indexChunkChar;
        storedCurrentChar = currentChar;
        shortStore = (currentChar < totalTextLength);
        if (!shortStore) {
            // long save
            if (storedText.length < totalTextLength) {
                storedText = new char[totalTextLength];
                storedDetailChunks = new PdfChunk[totalTextLength];
            }
            System.arraycopy(text, 0, storedText, 0, totalTextLength);
            System.arraycopy(detailChunks, 0, storedDetailChunks, 0, totalTextLength);
        }
        if (runDirection == PdfWriter.RUN_DIRECTION_LTR || runDirection == PdfWriter.RUN_DIRECTION_RTL) {
            if (storedOrderLevels.length < totalTextLength) {
                storedOrderLevels = new byte[totalTextLength];
                storedIndexChars = new int[totalTextLength];
            }
            System.arraycopy(orderLevels, currentChar, storedOrderLevels, currentChar, totalTextLength - currentChar);
            System.arraycopy(indexChars, currentChar, storedIndexChars, currentChar, totalTextLength - currentChar);
        }
    }
    
    public void restore() {
        runDirection = storedRunDirection;
        totalTextLength = storedTotalTextLength;
        indexChunk = storedIndexChunk;
        indexChunkChar = storedIndexChunkChar;
        currentChar = storedCurrentChar;
        if (!shortStore) {
            // long restore
            System.arraycopy(storedText, 0, text, 0, totalTextLength);
            System.arraycopy(storedDetailChunks, 0, detailChunks, 0, totalTextLength);
        }
        if (runDirection == PdfWriter.RUN_DIRECTION_LTR || runDirection == PdfWriter.RUN_DIRECTION_RTL) {
            System.arraycopy(storedOrderLevels, currentChar, orderLevels, currentChar, totalTextLength - currentChar);
            System.arraycopy(storedIndexChars, currentChar, indexChars, currentChar, totalTextLength - currentChar);
        }
    }
    
    public void mirrorGlyphs() {
        for (int k = 0; k < totalTextLength; ++k) {
            if ((orderLevels[k] & 1) == 1) {
                int mirror = mirrorChars.get(text[k]);
                if (mirror != 0)
                    text[k] = (char)mirror;
            }
        }
    }
    
    public void doArabicShapping() {
        int src = 0;
        int dest = 0;
        for (;;) {
            while (src < totalTextLength) {
                char c = text[src];
                if (c >= 0x0600 && c <= 0x06ff)
                    break;
                if (src != dest) {
                    text[dest] = text[src];
                    detailChunks[dest] = detailChunks[src];
                    orderLevels[dest] = orderLevels[src];
                }
                ++src;
                ++dest;
            }
            if (src >= totalTextLength) {
                totalTextLength = dest;
                return;
            }
            int startArabicIdx = src;
            ++src;
            while (src < totalTextLength) {
                char c = text[src];
                if (c < 0x0600 || c > 0x06ff)
                    break;
                ++src;
            }
            int arabicWordSize = src - startArabicIdx;
            int size = ArabicLigaturizer.arabic_shape(text, startArabicIdx, arabicWordSize, text, dest, arabicWordSize, arabicOptions /*PangoArabicShapping.ar_novowel PangoArabicShapping.ar_lig | PangoArabicShapping.ar_composedtashkeel*/);
            if (startArabicIdx != dest) {
                for (int k = 0; k < size; ++k) {
                    detailChunks[dest] = detailChunks[startArabicIdx];
                    orderLevels[dest++] = orderLevels[startArabicIdx++];
                }
            }
            else
                dest += size;
        }
    }
       
    public PdfLine processLine(float width, int alignment, int runDirection, int arabicOptions) {
        this.arabicOptions = arabicOptions;
        save();
        boolean isRTL = (runDirection == PdfWriter.RUN_DIRECTION_RTL);
        if (currentChar >= totalTextLength) {
            boolean hasText = getParagraph(runDirection);
            if (!hasText)
                return null;
            if (totalTextLength == 0) {
                ArrayList ar = new ArrayList();
                PdfChunk ck = new PdfChunk("", detailChunks[0]);
                ar.add(ck);
                return new PdfLine(0, 0, alignment, true, ar, isRTL);
            }
        }
        float originalWidth = width;
        int lastSplit = -1;
        if (currentChar != 0)
            currentChar = trimLeftEx(currentChar, totalTextLength - 1);
        int oldCurrentChar = currentChar;
        char c = 0;
        char uniC = 0;
        PdfChunk ck = null;
        float charWidth = 0;
        PdfChunk lastValidChunk = null;
        for (; currentChar < totalTextLength; ++currentChar) {
            c = text[currentChar];
            ck = detailChunks[currentChar];
            uniC = ck.getUnicodeEquivalent(c);
            if (PdfChunk.noPrint(uniC))
                continue;
            charWidth = ck.getCharWidth(c);
            if (ck.isExtSplitCharacter(oldCurrentChar, currentChar, totalTextLength, text, detailChunks))
                lastSplit = currentChar;
            if (width - charWidth < 0)
                break;
            width -= charWidth;
            lastValidChunk = ck;
        }
        if (lastValidChunk == null) {
            // not even a single char fit; must output the first char
            ++currentChar;
            return new PdfLine(0, 0, alignment, false, createArrayOfPdfChunks(currentChar - 1, currentChar - 1), isRTL);
        }
        if (currentChar >= totalTextLength) {
            // there was more line than text
            return new PdfLine(0, width, alignment, true, createArrayOfPdfChunks(oldCurrentChar, totalTextLength - 1), isRTL);
        }
        int newCurrentChar = trimRightEx(oldCurrentChar, currentChar - 1);
        if (newCurrentChar < oldCurrentChar) {
            // only WS
            return new PdfLine(0, width, alignment, false, createArrayOfPdfChunks(oldCurrentChar, currentChar - 1), isRTL);
        }
        if (newCurrentChar == currentChar - 1) { // middle of word
            HyphenationEvent he = (HyphenationEvent)lastValidChunk.getAttribute(Chunk.HYPHENATION);
            if (he != null) {
                int word[] = getWord(oldCurrentChar, newCurrentChar);
                if (word != null) {
                    float testWidth = width + getWidth(word[0], currentChar - 1);
                    String pre = he.getHyphenatedWordPre(new String(text, word[0], word[1] - word[0]), lastValidChunk.font().getFont(), lastValidChunk.font().size(), testWidth);
                    String post = he.getHyphenatedWordPost();
                    if (pre.length() > 0) {
                        PdfChunk extra = new PdfChunk(pre, lastValidChunk);
                        currentChar = word[1] - post.length();
                        return new PdfLine(0, testWidth - lastValidChunk.font().width(pre), alignment, false, createArrayOfPdfChunks(oldCurrentChar, word[0] - 1, extra), isRTL);
                    }
                }
            }
        }
        if (lastSplit == -1 || lastSplit >= newCurrentChar) {
            // no split point or split point ahead of end
            return new PdfLine(0, width + getWidth(newCurrentChar + 1, currentChar - 1), alignment, false, createArrayOfPdfChunks(oldCurrentChar, newCurrentChar), isRTL);
        }
        // standard split
        currentChar = lastSplit + 1;
        newCurrentChar = trimRightEx(oldCurrentChar, lastSplit);
        if (newCurrentChar < oldCurrentChar) {
            // only WS again
            newCurrentChar = currentChar - 1;
        }
        return new PdfLine(0, originalWidth - getWidth(oldCurrentChar, newCurrentChar), alignment, false, createArrayOfPdfChunks(oldCurrentChar, newCurrentChar), isRTL);
    }
    
    /** Gets the width of a range of characters.
     * @param startIdx the first index to calculate
     * @param lastIdx the last inclusive index to calculate
     * @return the sum of all widths
     */    
    public float getWidth(int startIdx, int lastIdx) {
        char c = 0;
        char uniC;
        PdfChunk ck = null;
        float width = 0;
        for (; startIdx <= lastIdx; ++startIdx) {
            c = text[startIdx];
            ck = detailChunks[startIdx];
            uniC = ck.getUnicodeEquivalent(c);
            if (PdfChunk.noPrint(uniC))
                continue;
            width += detailChunks[startIdx].getCharWidth(c);
        }
        return width;
    }
    
    public ArrayList createArrayOfPdfChunks(int startIdx, int endIdx) {
        return createArrayOfPdfChunks(startIdx, endIdx, null);
    }
    
    public ArrayList createArrayOfPdfChunks(int startIdx, int endIdx, PdfChunk extraPdfChunk) {
        boolean bidi = (runDirection == PdfWriter.RUN_DIRECTION_LTR || runDirection == PdfWriter.RUN_DIRECTION_RTL);
        if (bidi)
            reorder(startIdx, endIdx);
        ArrayList ar = new ArrayList();
        PdfChunk refCk = detailChunks[startIdx];
        PdfChunk ck = null;
        StringBuffer buf = new StringBuffer();
        char c;
        int idx = 0;
        for (; startIdx <= endIdx; ++startIdx) {
            idx = bidi ? indexChars[startIdx] : startIdx;
            c = text[idx];
            ck = detailChunks[idx];
            if (PdfChunk.noPrint(ck.getUnicodeEquivalent(c)))
                continue;
	    /* ssteward: dropped in 1.44
            if (ck.isImage()) {
                if (buf.length() > 0) {
                    ar.add(new PdfChunk(buf.toString(), refCk));
                    buf = new StringBuffer();
                }
                ar.add(ck);
            }
            else */
	    if (ck == refCk) {
                buf.append(c);
            }
            else {
                if (buf.length() > 0) {
                    ar.add(new PdfChunk(buf.toString(), refCk));
                    buf = new StringBuffer();
                }
		/* ssteward: dropped in 1.44
                if (!ck.isImage())
                    buf.append(c);
                refCk = ck;
		*/
            }
        }
        if (buf.length() > 0) {
            ar.add(new PdfChunk(buf.toString(), refCk));
        }
        if (extraPdfChunk != null)
            ar.add(extraPdfChunk);
        return ar;
    }
    
    public int[] getWord(int startIdx, int idx) {
        int last = idx;
        int first = idx;
        // forward
        for (; last < totalTextLength; ++last) {
            if (!Character.isLetter(text[last]))
                break;            
        }
        if (last == idx)
            return null;
        // backward
        for (; first >= startIdx; --first) {
            if (!Character.isLetter(text[first]))
                break;            
        }
        ++first;
        return new int[]{first, last};
    }
    
    public int trimRight(int startIdx, int endIdx) {
        int idx = endIdx;
        char c;
        for (; idx >= startIdx; --idx) {
            c = detailChunks[idx].getUnicodeEquivalent(text[idx]);
            if (!isWS(c))
                break;
        }
        return idx;
    }
    
    public int trimLeft(int startIdx, int endIdx) {
        int idx = startIdx;
        char c;
        for (; idx <= endIdx; ++idx) {
            c = detailChunks[idx].getUnicodeEquivalent(text[idx]);
            if (!isWS(c))
                break;
        }
        return idx;
    }
    
    public int trimRightEx(int startIdx, int endIdx) {
        int idx = endIdx;
        char c = 0;
        for (; idx >= startIdx; --idx) {
            c = detailChunks[idx].getUnicodeEquivalent(text[idx]);
            if (!isWS(c) && !PdfChunk.noPrint(c))
                break;
        }
        return idx;
    }
    
    public int trimLeftEx(int startIdx, int endIdx) {
        int idx = startIdx;
        char c = 0;
        for (; idx <= endIdx; ++idx) {
            c = detailChunks[idx].getUnicodeEquivalent(text[idx]);
            if (!isWS(c) && !PdfChunk.noPrint(c))
                break;
        }
        return idx;
    }
    
    public void reorder(int start, int end) {
        byte maxLevel = orderLevels[start];
        byte minLevel = maxLevel;
        byte onlyOddLevels = maxLevel;
        byte onlyEvenLevels = maxLevel;
        for (int k = start + 1; k <= end; ++k) {
            byte b = orderLevels[k];
            if (b > maxLevel)
                maxLevel = b;
            else if (b < minLevel)
                minLevel = b;
            onlyOddLevels &= b;
            onlyEvenLevels |= b;
        }
        if ((onlyEvenLevels & 1) == 0) // nothing to do
            return;
        if ((onlyOddLevels & 1) == 1) { // single inversion
            flip(start, end + 1);
            return;
        }
        minLevel |= 1;
        for (; maxLevel >= minLevel; --maxLevel) {
            int pstart = start;
            for (;;) {
                for (;pstart <= end; ++pstart) {
                    if (orderLevels[pstart] >= maxLevel)
                        break;
                }
                if (pstart > end)
                    break;
                int pend = pstart + 1;
                for (; pend <= end; ++pend) {
                    if (orderLevels[pend] < maxLevel)
                        break;
                }
                flip(pstart, pend);
                pstart = pend + 1;
            }
        }
    }
    
    public void flip(int start, int end) {
        int mid = (start + end) / 2;
        --end;
        for (; start < mid; ++start, --end) {
            int temp = indexChars[start];
            indexChars[start] = indexChars[end];
            indexChars[end] = temp;
        }
    }
    
    public static boolean isWS(char c) {
        return (c <= ' ');
    }

    static {
        mirrorChars.put(0x0028, 0x0029); // LEFT PARENTHESIS
        mirrorChars.put(0x0029, 0x0028); // RIGHT PARENTHESIS
        mirrorChars.put(0x003C, 0x003E); // LESS-THAN SIGN
        mirrorChars.put(0x003E, 0x003C); // GREATER-THAN SIGN
        mirrorChars.put(0x005B, 0x005D); // LEFT SQUARE BRACKET
        mirrorChars.put(0x005D, 0x005B); // RIGHT SQUARE BRACKET
        mirrorChars.put(0x007B, 0x007D); // LEFT CURLY BRACKET
        mirrorChars.put(0x007D, 0x007B); // RIGHT CURLY BRACKET
        mirrorChars.put(0x00AB, 0x00BB); // LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
        mirrorChars.put(0x00BB, 0x00AB); // RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
        mirrorChars.put(0x2039, 0x203A); // SINGLE LEFT-POINTING ANGLE QUOTATION MARK
        mirrorChars.put(0x203A, 0x2039); // SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
        mirrorChars.put(0x2045, 0x2046); // LEFT SQUARE BRACKET WITH QUILL
        mirrorChars.put(0x2046, 0x2045); // RIGHT SQUARE BRACKET WITH QUILL
        mirrorChars.put(0x207D, 0x207E); // SUPERSCRIPT LEFT PARENTHESIS
        mirrorChars.put(0x207E, 0x207D); // SUPERSCRIPT RIGHT PARENTHESIS
        mirrorChars.put(0x208D, 0x208E); // SUBSCRIPT LEFT PARENTHESIS
        mirrorChars.put(0x208E, 0x208D); // SUBSCRIPT RIGHT PARENTHESIS
        mirrorChars.put(0x2208, 0x220B); // ELEMENT OF
        mirrorChars.put(0x2209, 0x220C); // NOT AN ELEMENT OF
        mirrorChars.put(0x220A, 0x220D); // SMALL ELEMENT OF
        mirrorChars.put(0x220B, 0x2208); // CONTAINS AS MEMBER
        mirrorChars.put(0x220C, 0x2209); // DOES NOT CONTAIN AS MEMBER
        mirrorChars.put(0x220D, 0x220A); // SMALL CONTAINS AS MEMBER
        mirrorChars.put(0x2215, 0x29F5); // DIVISION SLASH
        mirrorChars.put(0x223C, 0x223D); // TILDE OPERATOR
        mirrorChars.put(0x223D, 0x223C); // REVERSED TILDE
        mirrorChars.put(0x2243, 0x22CD); // ASYMPTOTICALLY EQUAL TO
        mirrorChars.put(0x2252, 0x2253); // APPROXIMATELY EQUAL TO OR THE IMAGE OF
        mirrorChars.put(0x2253, 0x2252); // IMAGE OF OR APPROXIMATELY EQUAL TO
        mirrorChars.put(0x2254, 0x2255); // COLON EQUALS
        mirrorChars.put(0x2255, 0x2254); // EQUALS COLON
        mirrorChars.put(0x2264, 0x2265); // LESS-THAN OR EQUAL TO
        mirrorChars.put(0x2265, 0x2264); // GREATER-THAN OR EQUAL TO
        mirrorChars.put(0x2266, 0x2267); // LESS-THAN OVER EQUAL TO
        mirrorChars.put(0x2267, 0x2266); // GREATER-THAN OVER EQUAL TO
        mirrorChars.put(0x2268, 0x2269); // [BEST FIT] LESS-THAN BUT NOT EQUAL TO
        mirrorChars.put(0x2269, 0x2268); // [BEST FIT] GREATER-THAN BUT NOT EQUAL TO
        mirrorChars.put(0x226A, 0x226B); // MUCH LESS-THAN
        mirrorChars.put(0x226B, 0x226A); // MUCH GREATER-THAN
        mirrorChars.put(0x226E, 0x226F); // [BEST FIT] NOT LESS-THAN
        mirrorChars.put(0x226F, 0x226E); // [BEST FIT] NOT GREATER-THAN
        mirrorChars.put(0x2270, 0x2271); // [BEST FIT] NEITHER LESS-THAN NOR EQUAL TO
        mirrorChars.put(0x2271, 0x2270); // [BEST FIT] NEITHER GREATER-THAN NOR EQUAL TO
        mirrorChars.put(0x2272, 0x2273); // [BEST FIT] LESS-THAN OR EQUIVALENT TO
        mirrorChars.put(0x2273, 0x2272); // [BEST FIT] GREATER-THAN OR EQUIVALENT TO
        mirrorChars.put(0x2274, 0x2275); // [BEST FIT] NEITHER LESS-THAN NOR EQUIVALENT TO
        mirrorChars.put(0x2275, 0x2274); // [BEST FIT] NEITHER GREATER-THAN NOR EQUIVALENT TO
        mirrorChars.put(0x2276, 0x2277); // LESS-THAN OR GREATER-THAN
        mirrorChars.put(0x2277, 0x2276); // GREATER-THAN OR LESS-THAN
        mirrorChars.put(0x2278, 0x2279); // NEITHER LESS-THAN NOR GREATER-THAN
        mirrorChars.put(0x2279, 0x2278); // NEITHER GREATER-THAN NOR LESS-THAN
        mirrorChars.put(0x227A, 0x227B); // PRECEDES
        mirrorChars.put(0x227B, 0x227A); // SUCCEEDS
        mirrorChars.put(0x227C, 0x227D); // PRECEDES OR EQUAL TO
        mirrorChars.put(0x227D, 0x227C); // SUCCEEDS OR EQUAL TO
        mirrorChars.put(0x227E, 0x227F); // [BEST FIT] PRECEDES OR EQUIVALENT TO
        mirrorChars.put(0x227F, 0x227E); // [BEST FIT] SUCCEEDS OR EQUIVALENT TO
        mirrorChars.put(0x2280, 0x2281); // [BEST FIT] DOES NOT PRECEDE
        mirrorChars.put(0x2281, 0x2280); // [BEST FIT] DOES NOT SUCCEED
        mirrorChars.put(0x2282, 0x2283); // SUBSET OF
        mirrorChars.put(0x2283, 0x2282); // SUPERSET OF
        mirrorChars.put(0x2284, 0x2285); // [BEST FIT] NOT A SUBSET OF
        mirrorChars.put(0x2285, 0x2284); // [BEST FIT] NOT A SUPERSET OF
        mirrorChars.put(0x2286, 0x2287); // SUBSET OF OR EQUAL TO
        mirrorChars.put(0x2287, 0x2286); // SUPERSET OF OR EQUAL TO
        mirrorChars.put(0x2288, 0x2289); // [BEST FIT] NEITHER A SUBSET OF NOR EQUAL TO
        mirrorChars.put(0x2289, 0x2288); // [BEST FIT] NEITHER A SUPERSET OF NOR EQUAL TO
        mirrorChars.put(0x228A, 0x228B); // [BEST FIT] SUBSET OF WITH NOT EQUAL TO
        mirrorChars.put(0x228B, 0x228A); // [BEST FIT] SUPERSET OF WITH NOT EQUAL TO
        mirrorChars.put(0x228F, 0x2290); // SQUARE IMAGE OF
        mirrorChars.put(0x2290, 0x228F); // SQUARE ORIGINAL OF
        mirrorChars.put(0x2291, 0x2292); // SQUARE IMAGE OF OR EQUAL TO
        mirrorChars.put(0x2292, 0x2291); // SQUARE ORIGINAL OF OR EQUAL TO
        mirrorChars.put(0x2298, 0x29B8); // CIRCLED DIVISION SLASH
        mirrorChars.put(0x22A2, 0x22A3); // RIGHT TACK
        mirrorChars.put(0x22A3, 0x22A2); // LEFT TACK
        mirrorChars.put(0x22A6, 0x2ADE); // ASSERTION
        mirrorChars.put(0x22A8, 0x2AE4); // TRUE
        mirrorChars.put(0x22A9, 0x2AE3); // FORCES
        mirrorChars.put(0x22AB, 0x2AE5); // DOUBLE VERTICAL BAR DOUBLE RIGHT TURNSTILE
        mirrorChars.put(0x22B0, 0x22B1); // PRECEDES UNDER RELATION
        mirrorChars.put(0x22B1, 0x22B0); // SUCCEEDS UNDER RELATION
        mirrorChars.put(0x22B2, 0x22B3); // NORMAL SUBGROUP OF
        mirrorChars.put(0x22B3, 0x22B2); // CONTAINS AS NORMAL SUBGROUP
        mirrorChars.put(0x22B4, 0x22B5); // NORMAL SUBGROUP OF OR EQUAL TO
        mirrorChars.put(0x22B5, 0x22B4); // CONTAINS AS NORMAL SUBGROUP OR EQUAL TO
        mirrorChars.put(0x22B6, 0x22B7); // ORIGINAL OF
        mirrorChars.put(0x22B7, 0x22B6); // IMAGE OF
        mirrorChars.put(0x22C9, 0x22CA); // LEFT NORMAL FACTOR SEMIDIRECT PRODUCT
        mirrorChars.put(0x22CA, 0x22C9); // RIGHT NORMAL FACTOR SEMIDIRECT PRODUCT
        mirrorChars.put(0x22CB, 0x22CC); // LEFT SEMIDIRECT PRODUCT
        mirrorChars.put(0x22CC, 0x22CB); // RIGHT SEMIDIRECT PRODUCT
        mirrorChars.put(0x22CD, 0x2243); // REVERSED TILDE EQUALS
        mirrorChars.put(0x22D0, 0x22D1); // DOUBLE SUBSET
        mirrorChars.put(0x22D1, 0x22D0); // DOUBLE SUPERSET
        mirrorChars.put(0x22D6, 0x22D7); // LESS-THAN WITH DOT
        mirrorChars.put(0x22D7, 0x22D6); // GREATER-THAN WITH DOT
        mirrorChars.put(0x22D8, 0x22D9); // VERY MUCH LESS-THAN
        mirrorChars.put(0x22D9, 0x22D8); // VERY MUCH GREATER-THAN
        mirrorChars.put(0x22DA, 0x22DB); // LESS-THAN EQUAL TO OR GREATER-THAN
        mirrorChars.put(0x22DB, 0x22DA); // GREATER-THAN EQUAL TO OR LESS-THAN
        mirrorChars.put(0x22DC, 0x22DD); // EQUAL TO OR LESS-THAN
        mirrorChars.put(0x22DD, 0x22DC); // EQUAL TO OR GREATER-THAN
        mirrorChars.put(0x22DE, 0x22DF); // EQUAL TO OR PRECEDES
        mirrorChars.put(0x22DF, 0x22DE); // EQUAL TO OR SUCCEEDS
        mirrorChars.put(0x22E0, 0x22E1); // [BEST FIT] DOES NOT PRECEDE OR EQUAL
        mirrorChars.put(0x22E1, 0x22E0); // [BEST FIT] DOES NOT SUCCEED OR EQUAL
        mirrorChars.put(0x22E2, 0x22E3); // [BEST FIT] NOT SQUARE IMAGE OF OR EQUAL TO
        mirrorChars.put(0x22E3, 0x22E2); // [BEST FIT] NOT SQUARE ORIGINAL OF OR EQUAL TO
        mirrorChars.put(0x22E4, 0x22E5); // [BEST FIT] SQUARE IMAGE OF OR NOT EQUAL TO
        mirrorChars.put(0x22E5, 0x22E4); // [BEST FIT] SQUARE ORIGINAL OF OR NOT EQUAL TO
        mirrorChars.put(0x22E6, 0x22E7); // [BEST FIT] LESS-THAN BUT NOT EQUIVALENT TO
        mirrorChars.put(0x22E7, 0x22E6); // [BEST FIT] GREATER-THAN BUT NOT EQUIVALENT TO
        mirrorChars.put(0x22E8, 0x22E9); // [BEST FIT] PRECEDES BUT NOT EQUIVALENT TO
        mirrorChars.put(0x22E9, 0x22E8); // [BEST FIT] SUCCEEDS BUT NOT EQUIVALENT TO
        mirrorChars.put(0x22EA, 0x22EB); // [BEST FIT] NOT NORMAL SUBGROUP OF
        mirrorChars.put(0x22EB, 0x22EA); // [BEST FIT] DOES NOT CONTAIN AS NORMAL SUBGROUP
        mirrorChars.put(0x22EC, 0x22ED); // [BEST FIT] NOT NORMAL SUBGROUP OF OR EQUAL TO
        mirrorChars.put(0x22ED, 0x22EC); // [BEST FIT] DOES NOT CONTAIN AS NORMAL SUBGROUP OR EQUAL
        mirrorChars.put(0x22F0, 0x22F1); // UP RIGHT DIAGONAL ELLIPSIS
        mirrorChars.put(0x22F1, 0x22F0); // DOWN RIGHT DIAGONAL ELLIPSIS
        mirrorChars.put(0x22F2, 0x22FA); // ELEMENT OF WITH LONG HORIZONTAL STROKE
        mirrorChars.put(0x22F3, 0x22FB); // ELEMENT OF WITH VERTICAL BAR AT END OF HORIZONTAL STROKE
        mirrorChars.put(0x22F4, 0x22FC); // SMALL ELEMENT OF WITH VERTICAL BAR AT END OF HORIZONTAL STROKE
        mirrorChars.put(0x22F6, 0x22FD); // ELEMENT OF WITH OVERBAR
        mirrorChars.put(0x22F7, 0x22FE); // SMALL ELEMENT OF WITH OVERBAR
        mirrorChars.put(0x22FA, 0x22F2); // CONTAINS WITH LONG HORIZONTAL STROKE
        mirrorChars.put(0x22FB, 0x22F3); // CONTAINS WITH VERTICAL BAR AT END OF HORIZONTAL STROKE
        mirrorChars.put(0x22FC, 0x22F4); // SMALL CONTAINS WITH VERTICAL BAR AT END OF HORIZONTAL STROKE
        mirrorChars.put(0x22FD, 0x22F6); // CONTAINS WITH OVERBAR
        mirrorChars.put(0x22FE, 0x22F7); // SMALL CONTAINS WITH OVERBAR
        mirrorChars.put(0x2308, 0x2309); // LEFT CEILING
        mirrorChars.put(0x2309, 0x2308); // RIGHT CEILING
        mirrorChars.put(0x230A, 0x230B); // LEFT FLOOR
        mirrorChars.put(0x230B, 0x230A); // RIGHT FLOOR
        mirrorChars.put(0x2329, 0x232A); // LEFT-POINTING ANGLE BRACKET
        mirrorChars.put(0x232A, 0x2329); // RIGHT-POINTING ANGLE BRACKET
        mirrorChars.put(0x2768, 0x2769); // MEDIUM LEFT PARENTHESIS ORNAMENT
        mirrorChars.put(0x2769, 0x2768); // MEDIUM RIGHT PARENTHESIS ORNAMENT
        mirrorChars.put(0x276A, 0x276B); // MEDIUM FLATTENED LEFT PARENTHESIS ORNAMENT
        mirrorChars.put(0x276B, 0x276A); // MEDIUM FLATTENED RIGHT PARENTHESIS ORNAMENT
        mirrorChars.put(0x276C, 0x276D); // MEDIUM LEFT-POINTING ANGLE BRACKET ORNAMENT
        mirrorChars.put(0x276D, 0x276C); // MEDIUM RIGHT-POINTING ANGLE BRACKET ORNAMENT
        mirrorChars.put(0x276E, 0x276F); // HEAVY LEFT-POINTING ANGLE QUOTATION MARK ORNAMENT
        mirrorChars.put(0x276F, 0x276E); // HEAVY RIGHT-POINTING ANGLE QUOTATION MARK ORNAMENT
        mirrorChars.put(0x2770, 0x2771); // HEAVY LEFT-POINTING ANGLE BRACKET ORNAMENT
        mirrorChars.put(0x2771, 0x2770); // HEAVY RIGHT-POINTING ANGLE BRACKET ORNAMENT
        mirrorChars.put(0x2772, 0x2773); // LIGHT LEFT TORTOISE SHELL BRACKET
        mirrorChars.put(0x2773, 0x2772); // LIGHT RIGHT TORTOISE SHELL BRACKET
        mirrorChars.put(0x2774, 0x2775); // MEDIUM LEFT CURLY BRACKET ORNAMENT
        mirrorChars.put(0x2775, 0x2774); // MEDIUM RIGHT CURLY BRACKET ORNAMENT
        mirrorChars.put(0x27D5, 0x27D6); // LEFT OUTER JOIN
        mirrorChars.put(0x27D6, 0x27D5); // RIGHT OUTER JOIN
        mirrorChars.put(0x27DD, 0x27DE); // LONG RIGHT TACK
        mirrorChars.put(0x27DE, 0x27DD); // LONG LEFT TACK
        mirrorChars.put(0x27E2, 0x27E3); // WHITE CONCAVE-SIDED DIAMOND WITH LEFTWARDS TICK
        mirrorChars.put(0x27E3, 0x27E2); // WHITE CONCAVE-SIDED DIAMOND WITH RIGHTWARDS TICK
        mirrorChars.put(0x27E4, 0x27E5); // WHITE SQUARE WITH LEFTWARDS TICK
        mirrorChars.put(0x27E5, 0x27E4); // WHITE SQUARE WITH RIGHTWARDS TICK
        mirrorChars.put(0x27E6, 0x27E7); // MATHEMATICAL LEFT WHITE SQUARE BRACKET
        mirrorChars.put(0x27E7, 0x27E6); // MATHEMATICAL RIGHT WHITE SQUARE BRACKET
        mirrorChars.put(0x27E8, 0x27E9); // MATHEMATICAL LEFT ANGLE BRACKET
        mirrorChars.put(0x27E9, 0x27E8); // MATHEMATICAL RIGHT ANGLE BRACKET
        mirrorChars.put(0x27EA, 0x27EB); // MATHEMATICAL LEFT DOUBLE ANGLE BRACKET
        mirrorChars.put(0x27EB, 0x27EA); // MATHEMATICAL RIGHT DOUBLE ANGLE BRACKET
        mirrorChars.put(0x2983, 0x2984); // LEFT WHITE CURLY BRACKET
        mirrorChars.put(0x2984, 0x2983); // RIGHT WHITE CURLY BRACKET
        mirrorChars.put(0x2985, 0x2986); // LEFT WHITE PARENTHESIS
        mirrorChars.put(0x2986, 0x2985); // RIGHT WHITE PARENTHESIS
        mirrorChars.put(0x2987, 0x2988); // Z NOTATION LEFT IMAGE BRACKET
        mirrorChars.put(0x2988, 0x2987); // Z NOTATION RIGHT IMAGE BRACKET
        mirrorChars.put(0x2989, 0x298A); // Z NOTATION LEFT BINDING BRACKET
        mirrorChars.put(0x298A, 0x2989); // Z NOTATION RIGHT BINDING BRACKET
        mirrorChars.put(0x298B, 0x298C); // LEFT SQUARE BRACKET WITH UNDERBAR
        mirrorChars.put(0x298C, 0x298B); // RIGHT SQUARE BRACKET WITH UNDERBAR
        mirrorChars.put(0x298D, 0x2990); // LEFT SQUARE BRACKET WITH TICK IN TOP CORNER
        mirrorChars.put(0x298E, 0x298F); // RIGHT SQUARE BRACKET WITH TICK IN BOTTOM CORNER
        mirrorChars.put(0x298F, 0x298E); // LEFT SQUARE BRACKET WITH TICK IN BOTTOM CORNER
        mirrorChars.put(0x2990, 0x298D); // RIGHT SQUARE BRACKET WITH TICK IN TOP CORNER
        mirrorChars.put(0x2991, 0x2992); // LEFT ANGLE BRACKET WITH DOT
        mirrorChars.put(0x2992, 0x2991); // RIGHT ANGLE BRACKET WITH DOT
        mirrorChars.put(0x2993, 0x2994); // LEFT ARC LESS-THAN BRACKET
        mirrorChars.put(0x2994, 0x2993); // RIGHT ARC GREATER-THAN BRACKET
        mirrorChars.put(0x2995, 0x2996); // DOUBLE LEFT ARC GREATER-THAN BRACKET
        mirrorChars.put(0x2996, 0x2995); // DOUBLE RIGHT ARC LESS-THAN BRACKET
        mirrorChars.put(0x2997, 0x2998); // LEFT BLACK TORTOISE SHELL BRACKET
        mirrorChars.put(0x2998, 0x2997); // RIGHT BLACK TORTOISE SHELL BRACKET
        mirrorChars.put(0x29B8, 0x2298); // CIRCLED REVERSE SOLIDUS
        mirrorChars.put(0x29C0, 0x29C1); // CIRCLED LESS-THAN
        mirrorChars.put(0x29C1, 0x29C0); // CIRCLED GREATER-THAN
        mirrorChars.put(0x29C4, 0x29C5); // SQUARED RISING DIAGONAL SLASH
        mirrorChars.put(0x29C5, 0x29C4); // SQUARED FALLING DIAGONAL SLASH
        mirrorChars.put(0x29CF, 0x29D0); // LEFT TRIANGLE BESIDE VERTICAL BAR
        mirrorChars.put(0x29D0, 0x29CF); // VERTICAL BAR BESIDE RIGHT TRIANGLE
        mirrorChars.put(0x29D1, 0x29D2); // BOWTIE WITH LEFT HALF BLACK
        mirrorChars.put(0x29D2, 0x29D1); // BOWTIE WITH RIGHT HALF BLACK
        mirrorChars.put(0x29D4, 0x29D5); // TIMES WITH LEFT HALF BLACK
        mirrorChars.put(0x29D5, 0x29D4); // TIMES WITH RIGHT HALF BLACK
        mirrorChars.put(0x29D8, 0x29D9); // LEFT WIGGLY FENCE
        mirrorChars.put(0x29D9, 0x29D8); // RIGHT WIGGLY FENCE
        mirrorChars.put(0x29DA, 0x29DB); // LEFT DOUBLE WIGGLY FENCE
        mirrorChars.put(0x29DB, 0x29DA); // RIGHT DOUBLE WIGGLY FENCE
        mirrorChars.put(0x29F5, 0x2215); // REVERSE SOLIDUS OPERATOR
        mirrorChars.put(0x29F8, 0x29F9); // BIG SOLIDUS
        mirrorChars.put(0x29F9, 0x29F8); // BIG REVERSE SOLIDUS
        mirrorChars.put(0x29FC, 0x29FD); // LEFT-POINTING CURVED ANGLE BRACKET
        mirrorChars.put(0x29FD, 0x29FC); // RIGHT-POINTING CURVED ANGLE BRACKET
        mirrorChars.put(0x2A2B, 0x2A2C); // MINUS SIGN WITH FALLING DOTS
        mirrorChars.put(0x2A2C, 0x2A2B); // MINUS SIGN WITH RISING DOTS
        mirrorChars.put(0x2A2D, 0x2A2C); // PLUS SIGN IN LEFT HALF CIRCLE
        mirrorChars.put(0x2A2E, 0x2A2D); // PLUS SIGN IN RIGHT HALF CIRCLE
        mirrorChars.put(0x2A34, 0x2A35); // MULTIPLICATION SIGN IN LEFT HALF CIRCLE
        mirrorChars.put(0x2A35, 0x2A34); // MULTIPLICATION SIGN IN RIGHT HALF CIRCLE
        mirrorChars.put(0x2A3C, 0x2A3D); // INTERIOR PRODUCT
        mirrorChars.put(0x2A3D, 0x2A3C); // RIGHTHAND INTERIOR PRODUCT
        mirrorChars.put(0x2A64, 0x2A65); // Z NOTATION DOMAIN ANTIRESTRICTION
        mirrorChars.put(0x2A65, 0x2A64); // Z NOTATION RANGE ANTIRESTRICTION
        mirrorChars.put(0x2A79, 0x2A7A); // LESS-THAN WITH CIRCLE INSIDE
        mirrorChars.put(0x2A7A, 0x2A79); // GREATER-THAN WITH CIRCLE INSIDE
        mirrorChars.put(0x2A7D, 0x2A7E); // LESS-THAN OR SLANTED EQUAL TO
        mirrorChars.put(0x2A7E, 0x2A7D); // GREATER-THAN OR SLANTED EQUAL TO
        mirrorChars.put(0x2A7F, 0x2A80); // LESS-THAN OR SLANTED EQUAL TO WITH DOT INSIDE
        mirrorChars.put(0x2A80, 0x2A7F); // GREATER-THAN OR SLANTED EQUAL TO WITH DOT INSIDE
        mirrorChars.put(0x2A81, 0x2A82); // LESS-THAN OR SLANTED EQUAL TO WITH DOT ABOVE
        mirrorChars.put(0x2A82, 0x2A81); // GREATER-THAN OR SLANTED EQUAL TO WITH DOT ABOVE
        mirrorChars.put(0x2A83, 0x2A84); // LESS-THAN OR SLANTED EQUAL TO WITH DOT ABOVE RIGHT
        mirrorChars.put(0x2A84, 0x2A83); // GREATER-THAN OR SLANTED EQUAL TO WITH DOT ABOVE LEFT
        mirrorChars.put(0x2A8B, 0x2A8C); // LESS-THAN ABOVE DOUBLE-LINE EQUAL ABOVE GREATER-THAN
        mirrorChars.put(0x2A8C, 0x2A8B); // GREATER-THAN ABOVE DOUBLE-LINE EQUAL ABOVE LESS-THAN
        mirrorChars.put(0x2A91, 0x2A92); // LESS-THAN ABOVE GREATER-THAN ABOVE DOUBLE-LINE EQUAL
        mirrorChars.put(0x2A92, 0x2A91); // GREATER-THAN ABOVE LESS-THAN ABOVE DOUBLE-LINE EQUAL
        mirrorChars.put(0x2A93, 0x2A94); // LESS-THAN ABOVE SLANTED EQUAL ABOVE GREATER-THAN ABOVE SLANTED EQUAL
        mirrorChars.put(0x2A94, 0x2A93); // GREATER-THAN ABOVE SLANTED EQUAL ABOVE LESS-THAN ABOVE SLANTED EQUAL
        mirrorChars.put(0x2A95, 0x2A96); // SLANTED EQUAL TO OR LESS-THAN
        mirrorChars.put(0x2A96, 0x2A95); // SLANTED EQUAL TO OR GREATER-THAN
        mirrorChars.put(0x2A97, 0x2A98); // SLANTED EQUAL TO OR LESS-THAN WITH DOT INSIDE
        mirrorChars.put(0x2A98, 0x2A97); // SLANTED EQUAL TO OR GREATER-THAN WITH DOT INSIDE
        mirrorChars.put(0x2A99, 0x2A9A); // DOUBLE-LINE EQUAL TO OR LESS-THAN
        mirrorChars.put(0x2A9A, 0x2A99); // DOUBLE-LINE EQUAL TO OR GREATER-THAN
        mirrorChars.put(0x2A9B, 0x2A9C); // DOUBLE-LINE SLANTED EQUAL TO OR LESS-THAN
        mirrorChars.put(0x2A9C, 0x2A9B); // DOUBLE-LINE SLANTED EQUAL TO OR GREATER-THAN
        mirrorChars.put(0x2AA1, 0x2AA2); // DOUBLE NESTED LESS-THAN
        mirrorChars.put(0x2AA2, 0x2AA1); // DOUBLE NESTED GREATER-THAN
        mirrorChars.put(0x2AA6, 0x2AA7); // LESS-THAN CLOSED BY CURVE
        mirrorChars.put(0x2AA7, 0x2AA6); // GREATER-THAN CLOSED BY CURVE
        mirrorChars.put(0x2AA8, 0x2AA9); // LESS-THAN CLOSED BY CURVE ABOVE SLANTED EQUAL
        mirrorChars.put(0x2AA9, 0x2AA8); // GREATER-THAN CLOSED BY CURVE ABOVE SLANTED EQUAL
        mirrorChars.put(0x2AAA, 0x2AAB); // SMALLER THAN
        mirrorChars.put(0x2AAB, 0x2AAA); // LARGER THAN
        mirrorChars.put(0x2AAC, 0x2AAD); // SMALLER THAN OR EQUAL TO
        mirrorChars.put(0x2AAD, 0x2AAC); // LARGER THAN OR EQUAL TO
        mirrorChars.put(0x2AAF, 0x2AB0); // PRECEDES ABOVE SINGLE-LINE EQUALS SIGN
        mirrorChars.put(0x2AB0, 0x2AAF); // SUCCEEDS ABOVE SINGLE-LINE EQUALS SIGN
        mirrorChars.put(0x2AB3, 0x2AB4); // PRECEDES ABOVE EQUALS SIGN
        mirrorChars.put(0x2AB4, 0x2AB3); // SUCCEEDS ABOVE EQUALS SIGN
        mirrorChars.put(0x2ABB, 0x2ABC); // DOUBLE PRECEDES
        mirrorChars.put(0x2ABC, 0x2ABB); // DOUBLE SUCCEEDS
        mirrorChars.put(0x2ABD, 0x2ABE); // SUBSET WITH DOT
        mirrorChars.put(0x2ABE, 0x2ABD); // SUPERSET WITH DOT
        mirrorChars.put(0x2ABF, 0x2AC0); // SUBSET WITH PLUS SIGN BELOW
        mirrorChars.put(0x2AC0, 0x2ABF); // SUPERSET WITH PLUS SIGN BELOW
        mirrorChars.put(0x2AC1, 0x2AC2); // SUBSET WITH MULTIPLICATION SIGN BELOW
        mirrorChars.put(0x2AC2, 0x2AC1); // SUPERSET WITH MULTIPLICATION SIGN BELOW
        mirrorChars.put(0x2AC3, 0x2AC4); // SUBSET OF OR EQUAL TO WITH DOT ABOVE
        mirrorChars.put(0x2AC4, 0x2AC3); // SUPERSET OF OR EQUAL TO WITH DOT ABOVE
        mirrorChars.put(0x2AC5, 0x2AC6); // SUBSET OF ABOVE EQUALS SIGN
        mirrorChars.put(0x2AC6, 0x2AC5); // SUPERSET OF ABOVE EQUALS SIGN
        mirrorChars.put(0x2ACD, 0x2ACE); // SQUARE LEFT OPEN BOX OPERATOR
        mirrorChars.put(0x2ACE, 0x2ACD); // SQUARE RIGHT OPEN BOX OPERATOR
        mirrorChars.put(0x2ACF, 0x2AD0); // CLOSED SUBSET
        mirrorChars.put(0x2AD0, 0x2ACF); // CLOSED SUPERSET
        mirrorChars.put(0x2AD1, 0x2AD2); // CLOSED SUBSET OR EQUAL TO
        mirrorChars.put(0x2AD2, 0x2AD1); // CLOSED SUPERSET OR EQUAL TO
        mirrorChars.put(0x2AD3, 0x2AD4); // SUBSET ABOVE SUPERSET
        mirrorChars.put(0x2AD4, 0x2AD3); // SUPERSET ABOVE SUBSET
        mirrorChars.put(0x2AD5, 0x2AD6); // SUBSET ABOVE SUBSET
        mirrorChars.put(0x2AD6, 0x2AD5); // SUPERSET ABOVE SUPERSET
        mirrorChars.put(0x2ADE, 0x22A6); // SHORT LEFT TACK
        mirrorChars.put(0x2AE3, 0x22A9); // DOUBLE VERTICAL BAR LEFT TURNSTILE
        mirrorChars.put(0x2AE4, 0x22A8); // VERTICAL BAR DOUBLE LEFT TURNSTILE
        mirrorChars.put(0x2AE5, 0x22AB); // DOUBLE VERTICAL BAR DOUBLE LEFT TURNSTILE
        mirrorChars.put(0x2AEC, 0x2AED); // DOUBLE STROKE NOT SIGN
        mirrorChars.put(0x2AED, 0x2AEC); // REVERSED DOUBLE STROKE NOT SIGN
        mirrorChars.put(0x2AF7, 0x2AF8); // TRIPLE NESTED LESS-THAN
        mirrorChars.put(0x2AF8, 0x2AF7); // TRIPLE NESTED GREATER-THAN
        mirrorChars.put(0x2AF9, 0x2AFA); // DOUBLE-LINE SLANTED LESS-THAN OR EQUAL TO
        mirrorChars.put(0x2AFA, 0x2AF9); // DOUBLE-LINE SLANTED GREATER-THAN OR EQUAL TO
        mirrorChars.put(0x3008, 0x3009); // LEFT ANGLE BRACKET
        mirrorChars.put(0x3009, 0x3008); // RIGHT ANGLE BRACKET
        mirrorChars.put(0x300A, 0x300B); // LEFT DOUBLE ANGLE BRACKET
        mirrorChars.put(0x300B, 0x300A); // RIGHT DOUBLE ANGLE BRACKET
        mirrorChars.put(0x300C, 0x300D); // [BEST FIT] LEFT CORNER BRACKET
        mirrorChars.put(0x300D, 0x300C); // [BEST FIT] RIGHT CORNER BRACKET
        mirrorChars.put(0x300E, 0x300F); // [BEST FIT] LEFT WHITE CORNER BRACKET
        mirrorChars.put(0x300F, 0x300E); // [BEST FIT] RIGHT WHITE CORNER BRACKET
        mirrorChars.put(0x3010, 0x3011); // LEFT BLACK LENTICULAR BRACKET
        mirrorChars.put(0x3011, 0x3010); // RIGHT BLACK LENTICULAR BRACKET
        mirrorChars.put(0x3014, 0x3015); // LEFT TORTOISE SHELL BRACKET
        mirrorChars.put(0x3015, 0x3014); // RIGHT TORTOISE SHELL BRACKET
        mirrorChars.put(0x3016, 0x3017); // LEFT WHITE LENTICULAR BRACKET
        mirrorChars.put(0x3017, 0x3016); // RIGHT WHITE LENTICULAR BRACKET
        mirrorChars.put(0x3018, 0x3019); // LEFT WHITE TORTOISE SHELL BRACKET
        mirrorChars.put(0x3019, 0x3018); // RIGHT WHITE TORTOISE SHELL BRACKET
        mirrorChars.put(0x301A, 0x301B); // LEFT WHITE SQUARE BRACKET
        mirrorChars.put(0x301B, 0x301A); // RIGHT WHITE SQUARE BRACKET
        mirrorChars.put(0xFF08, 0xFF09); // FULLWIDTH LEFT PARENTHESIS
        mirrorChars.put(0xFF09, 0xFF08); // FULLWIDTH RIGHT PARENTHESIS
        mirrorChars.put(0xFF1C, 0xFF1E); // FULLWIDTH LESS-THAN SIGN
        mirrorChars.put(0xFF1E, 0xFF1C); // FULLWIDTH GREATER-THAN SIGN
        mirrorChars.put(0xFF3B, 0xFF3D); // FULLWIDTH LEFT SQUARE BRACKET
        mirrorChars.put(0xFF3D, 0xFF3B); // FULLWIDTH RIGHT SQUARE BRACKET
        mirrorChars.put(0xFF5B, 0xFF5D); // FULLWIDTH LEFT CURLY BRACKET
        mirrorChars.put(0xFF5D, 0xFF5B); // FULLWIDTH RIGHT CURLY BRACKET
        mirrorChars.put(0xFF5F, 0xFF60); // FULLWIDTH LEFT WHITE PARENTHESIS
        mirrorChars.put(0xFF60, 0xFF5F); // FULLWIDTH RIGHT WHITE PARENTHESIS
        mirrorChars.put(0xFF62, 0xFF63); // [BEST FIT] HALFWIDTH LEFT CORNER BRACKET
        mirrorChars.put(0xFF63, 0xFF62); // [BEST FIT] HALFWIDTH RIGHT CORNER BRACKET
    }
} package pdftk.com.lowagie.text.pdf;

/*
 *
 * Copyright 2003 Paulo Soares
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */
/*
 * (C) Copyright IBM Corp. 1999, All Rights Reserved
 *
 * version 1.1
 */

/**
 * Reference implementation of the Unicode 3.0 Bidi algorithm.
 *
 * <p>
 * This implementation is not optimized for performance.  It is intended
 * as a reference implementation that closely follows the specification
 * of the Bidirectional Algorithm in The Unicode Standard version 3.0.
 * <p>
 * <b>Input:</b><br>
 * There are two levels of input to the algorithm, since clients may prefer
 * to supply some information from out-of-band sources rather than relying on
 * the default behavior.
 * <ol>
 * <li>unicode type array
 * <li>unicode type array, with externally supplied base line direction
 * </ol>
 * <p><b>Output:</b><br>
 * Output is separated into several stages as well, to better enable clients
 * to evaluate various aspects of implementation conformance.
 * <ol>
 * <li>levels array over entire paragraph
 * <li>reordering array over entire paragraph
 * <li>levels array over line
 * <li>reordering array over line
 * </ol>
 * Note that for conformance, algorithms are only required to generate correct
 * reordering and character directionality (odd or even levels) over a line.
 * Generating identical level arrays over a line is not required.  Bidi
 * explicit format codes (LRE, RLE, LRO, RLO, PDF) and BN can be assigned
 * arbitrary levels and positions as long as the other text matches.
 * <p>
 * As the algorithm is defined to operate on a single paragraph at a time,
 * this implementation is written to handle single paragraphs.  Thus
 * rule P1 is presumed by this implementation-- the data provided to the
 * implementation is assumed to be a single paragraph, and either contains no
 * 'B' codes, or a single 'B' code at the end of the input.  'B' is allowed
 * as input to illustrate how the algorithm assigns it a level.
 * <p>
 * Also note that rules L3 and L4 depend on the rendering engine that uses
 * the result of the bidi algorithm.  This implementation assumes that the
 * rendering engine expects combining marks in visual order (e.g. to the
 * left of their base character in RTL runs) and that it adjust the glyphs
 * used to render mirrored characters that are in RTL runs so that they
 * render appropriately.
 *
 * @author Doug Felt
 */

public final class BidiOrder {
    private byte[] initialTypes;
    private byte[] embeddings; // generated from processing format codes
    private byte paragraphEmbeddingLevel = -1; // undefined
    
    private int textLength; // for convenience
    private byte[] resultTypes; // for paragraph, not lines
    private byte[] resultLevels; // for paragraph, not lines
    
    // The bidi types
    
    /** Left-to-right*/
    public static final byte L = 0;
    
    /** Left-to-Right Embedding */
    public static final byte LRE = 1;
    
    /** Left-to-Right Override */
    public static final byte LRO = 2;
    
    /** Right-to-Left */
    public static final byte R = 3;
    
    /** Right-to-Left Arabic */
    public static final byte AL = 4;
    
    /** Right-to-Left Embedding */
    public static final byte RLE = 5;
    
    /** Right-to-Left Override */
    public static final byte RLO = 6;
    
    /** Pop Directional Format */
    public static final byte PDF = 7;
    
    /** European Number */
    public static final byte EN = 8;
    
    /** European Number Separator */
    public static final byte ES = 9;
    
    /** European Number Terminator */
    public static final byte ET = 10;
    
    /** Arabic Number */
    public static final byte AN = 11;
    
    /** Common Number Separator */
    public static final byte CS = 12;
    
    /** Non-Spacing Mark */
    public static final byte NSM = 13;
    
    /** Boundary Neutral */
    public static final byte BN = 14;
    
    /** Paragraph Separator */
    public static final byte B = 15;
    
    /** Segment Separator */
    public static final byte S = 16;
    
    /** Whitespace */
    public static final byte WS = 17;
    
    /** Other Neutrals */
    public static final byte ON = 18;
    
    /** Minimum bidi type value. */
    public static final byte TYPE_MIN = 0;
    
    /** Maximum bidi type value. */
    public static final byte TYPE_MAX = 18;
    
    //
    // Input
    //
    
    /**
     * Initialize using an array of direction types.  Types range from TYPE_MIN to TYPE_MAX inclusive
     * and represent the direction codes of the characters in the text.
     *
     * @param types the types array
     */
    public BidiOrder(byte[] types) {
        validateTypes(types);
        
        this.initialTypes = (byte[])types.clone(); // client type array remains unchanged
        
        runAlgorithm();
    }
    
    /**
     * Initialize using an array of direction types and an externally supplied paragraph embedding level.
     * The embedding level may be -1, 0, or 1.  -1 means to apply the default algorithm (rules P2 and P3),
     * 0 is for LTR paragraphs, and 1 is for RTL paragraphs.
     *
     * @param types the types array
     * @param paragraphEmbeddingLevel the externally supplied paragraph embedding level.
     */
    public BidiOrder(byte[] types, byte paragraphEmbeddingLevel) {
        validateTypes(types);
        validateParagraphEmbeddingLevel(paragraphEmbeddingLevel);
        
        this.initialTypes = (byte[])types.clone(); // client type array remains unchanged
        this.paragraphEmbeddingLevel = paragraphEmbeddingLevel;
        
        runAlgorithm();
    }
    
    public BidiOrder(char text[], int offset, int length, byte paragraphEmbeddingLevel) {
        initialTypes = new byte[length];
        for (int k = 0; k < length; ++k) {
            initialTypes[k] = rtypes[text[offset + k]];
        }
        validateParagraphEmbeddingLevel(paragraphEmbeddingLevel);
        
        this.paragraphEmbeddingLevel = paragraphEmbeddingLevel;
        
        runAlgorithm();
    }
    
    public final static byte getDirection(char c) {
        return rtypes[c];
    }
    
    /**
     * The algorithm.
     * Does not include line-based processing (Rules L1, L2).
     * These are applied later in the line-based phase of the algorithm.
     */
    private void runAlgorithm() {
        textLength = initialTypes.length;
        
        // Initialize output types.
        // Result types initialized to input types.
        resultTypes = (byte[])initialTypes.clone();
        
        
        // 1) determining the paragraph level
        // Rule P1 is the requirement for entering this algorithm.
        // Rules P2, P3.
        // If no externally supplied paragraph embedding level, use default.
        if (paragraphEmbeddingLevel == -1) {
            determineParagraphEmbeddingLevel();
        }
        
        // Initialize result levels to paragraph embedding level.
        resultLevels = new byte[textLength];
        setLevels(0, textLength, paragraphEmbeddingLevel);
        
        // 2) Explicit levels and directions
        // Rules X1-X8.
        determineExplicitEmbeddingLevels();
        
        // Rule X9.
        textLength = removeExplicitCodes();
        
        // Rule X10.
        // Run remainder of algorithm one level run at a time
        byte prevLevel = paragraphEmbeddingLevel;
        int start = 0;
        while (start < textLength) {
            byte level = resultLevels[start];
            byte prevType = typeForLevel(Math.max(prevLevel, level));
            
            int limit = start + 1;
            while (limit < textLength && resultLevels[limit] == level) {
                ++limit;
            }
            
            byte succLevel = limit < textLength ? resultLevels[limit] : paragraphEmbeddingLevel;
            byte succType = typeForLevel(Math.max(succLevel, level));
            
            // 3) resolving weak types
            // Rules W1-W7.
            resolveWeakTypes(start, limit, level, prevType, succType);
            
            // 4) resolving neutral types
            // Rules N1-N3.
            resolveNeutralTypes(start, limit, level, prevType, succType);
            
            // 5) resolving implicit embedding levels
            // Rules I1, I2.
            resolveImplicitLevels(start, limit, level, prevType, succType);
            
            prevLevel = level;
            start = limit;
        }
        
        // Reinsert explicit codes and assign appropriate levels to 'hide' them.
        // This is for convenience, so the resulting level array maps 1-1
        // with the initial array.
        // See the implementation suggestions section of TR#9 for guidelines on
        // how to implement the algorithm without removing and reinserting the codes.
        textLength = reinsertExplicitCodes(textLength);
    }
    
    /**
     * 1) determining the paragraph level.
     * <p>
     * Rules P2, P3.
     * <p>
     * At the end of this function, the member variable paragraphEmbeddingLevel is set to either 0 or 1.
     */
    private void determineParagraphEmbeddingLevel() {
        byte strongType = -1; // unknown
        
        // Rule P2.
        for (int i = 0; i < textLength; ++i) {
            byte t = resultTypes[i];
            if (t == L || t == AL || t == R) {
                strongType = t;
                break;
            }
        }
        
        // Rule P3.
        if (strongType == -1) { // none found
            // default embedding level when no strong types found is 0.
            paragraphEmbeddingLevel = 0;
        } else if (strongType == L) {
            paragraphEmbeddingLevel = 0;
        } else { // AL, R
            paragraphEmbeddingLevel = 1;
        }
    }
    
    /**
     * Process embedding format codes.
     * <p>
     * Calls processEmbeddings to generate an embedding array from the explicit format codes.  The
     * embedding overrides in the array are then applied to the result types, and the result levels are
     * initialized.
     * @see #processEmbeddings
     */
    private void determineExplicitEmbeddingLevels() {
        embeddings = processEmbeddings(resultTypes, paragraphEmbeddingLevel);
        
        for (int i = 0; i < textLength; ++i) {
            byte level = embeddings[i];
            if ((level & 0x80) != 0) {
                level &= 0x7f;
                resultTypes[i] = typeForLevel(level);
            }
            resultLevels[i] = level;
        }
    }
    
    /**
     * Rules X9.
     * Remove explicit codes so that they may be ignored during the remainder
     * of the main portion of the algorithm.  The length of the resulting text
     * is returned.
     * @return the length of the data excluding explicit codes and BN.
     */
    private int removeExplicitCodes() {
        int w = 0;
        for (int i = 0; i < textLength; ++i) {
            byte t = initialTypes[i];
            if (!(t == LRE || t == RLE || t == LRO || t == RLO || t == PDF || t == BN)) {
                embeddings[w] = embeddings[i];
                resultTypes[w] = resultTypes[i];
                resultLevels[w] = resultLevels[i];
                w++;
            }
        }
        return w; // new textLength while explicit levels are removed
    }
    
    /**
     * Reinsert levels information for explicit codes.
     * This is for ease of relating the level information
     * to the original input data.  Note that the levels
     * assigned to these codes are arbitrary, they're
     * chosen so as to avoid breaking level runs.
     * @param textLength the length of the data after compression
     * @return the length of the data (original length of
     * types array supplied to constructor)
     */
    private int reinsertExplicitCodes(int textLength) {
        for (int i = initialTypes.length; --i >= 0;) {
            byte t = initialTypes[i];
            if (t == LRE || t == RLE || t == LRO || t == RLO || t == PDF || t == BN) {
                embeddings[i] = 0;
                resultTypes[i] = t;
                resultLevels[i] = -1;
            } else {
                --textLength;
                embeddings[i] = embeddings[textLength];
                resultTypes[i] = resultTypes[textLength];
                resultLevels[i] = resultLevels[textLength];
            }
        }
        
        // now propagate forward the levels information (could have
        // propagated backward, the main thing is not to introduce a level
        // break where one doesn't already exist).
        
        if (resultLevels[0] == -1) {
            resultLevels[0] = paragraphEmbeddingLevel;
        }
        for (int i = 1; i < initialTypes.length; ++i) {
            if (resultLevels[i] == -1) {
                resultLevels[i] = resultLevels[i-1];
            }
        }
        
        // Embedding information is for informational purposes only
        // so need not be adjusted.
        
        return initialTypes.length;
    }
    
    /**
     * 2) determining explicit levels
     * Rules X1 - X8
     *
     * The interaction of these rules makes handling them a bit complex.
     * This examines resultTypes but does not modify it.  It returns embedding and
     * override information in the result array.  The low 7 bits are the level, the high
     * bit is set if the level is an override, and clear if it is an embedding.
     */
    private static byte[] processEmbeddings(byte[] resultTypes, byte paragraphEmbeddingLevel) {
        final int EXPLICIT_LEVEL_LIMIT = 62;
        
        int textLength = resultTypes.length;
        byte[] embeddings = new byte[textLength];
        
        // This stack will store the embedding levels and override status in a single byte
        // as described above.
        byte[] embeddingValueStack = new byte[EXPLICIT_LEVEL_LIMIT];
        int stackCounter = 0;
        
        // An LRE or LRO at level 60 is invalid, since the new level 62 is invalid.  But
        // an RLE at level 60 is valid, since the new level 61 is valid.  The current wording
        // of the rules requires that the RLE remain valid even if a previous LRE is invalid.
        // This keeps track of ignored LRE or LRO codes at level 60, so that the matching PDFs
        // will not try to pop the stack.
        int overflowAlmostCounter = 0;
        
        // This keeps track of ignored pushes at level 61 or higher, so that matching PDFs will
        // not try to pop the stack.
        int overflowCounter = 0;
        
        // Rule X1.
        
        // Keep the level separate from the value (level | override status flag) for ease of access.
        byte currentEmbeddingLevel = paragraphEmbeddingLevel;
        byte currentEmbeddingValue = paragraphEmbeddingLevel;
        
        // Loop through types, handling all remaining rules
        for (int i = 0; i < textLength; ++i) {
            
            embeddings[i] = currentEmbeddingValue;
            
            byte t = resultTypes[i];
            
            // Rules X2, X3, X4, X5
            switch (t) {
                case RLE:
                case LRE:
                case RLO:
                case LRO:
                    // Only need to compute new level if current level is valid
                    if (overflowCounter == 0) {
                        byte newLevel;
                        if (t == RLE || t == RLO) {
                            newLevel = (byte)((currentEmbeddingLevel + 1) | 1); // least greater odd
                        } else { // t == LRE || t == LRO
                            newLevel = (byte)((currentEmbeddingLevel + 2) & ~1); // least greater even
                        }
                        
                        // If the new level is valid, push old embedding level and override status
                        // No check for valid stack counter, since the level check suffices.
                        if (newLevel < EXPLICIT_LEVEL_LIMIT) {
                            embeddingValueStack[stackCounter] = currentEmbeddingValue;
                            stackCounter++;
                            
                            currentEmbeddingLevel = newLevel;
                            if (t == LRO || t == RLO) { // override
                                currentEmbeddingValue = (byte)(newLevel | 0x80);
                            } else {
                                currentEmbeddingValue = newLevel;
                            }
                            
                            // Adjust level of format mark (for expositional purposes only, this gets
                            // removed later).
                            embeddings[i] = currentEmbeddingValue;
                            break;
                        }
                        
                        // Otherwise new level is invalid, but a valid level can still be achieved if this
                        // level is 60 and we encounter an RLE or RLO further on.  So record that we
                        // 'almost' overflowed.
                        if (currentEmbeddingLevel == 60) {
                            overflowAlmostCounter++;
                            break;
                        }
                    }
                    
                    // Otherwise old or new level is invalid.
                    overflowCounter++;
                    break;
                    
                case PDF:
                    // The only case where this did not actually overflow but may have almost overflowed
                    // is when there was an RLE or RLO on level 60, which would result in level 61.  So we
                    // only test the almost overflow condition in that case.
                    //
                    // Also note that there may be a PDF without any pushes at all.
                    
                    if (overflowCounter > 0) {
                        --overflowCounter;
                    } else if (overflowAlmostCounter > 0 && currentEmbeddingLevel != 61) {
                        --overflowAlmostCounter;
                    } else if (stackCounter > 0) {
                        --stackCounter;
                        currentEmbeddingValue = embeddingValueStack[stackCounter];
                        currentEmbeddingLevel = (byte)(currentEmbeddingValue & 0x7f);
                    }
                    break;
                    
                case B:
                    // Rule X8.
                    
                    // These values are reset for clarity, in this implementation B can only
                    // occur as the last code in the array.
                    stackCounter = 0;
                    overflowCounter = 0;
                    overflowAlmostCounter = 0;
                    currentEmbeddingLevel = paragraphEmbeddingLevel;
                    currentEmbeddingValue = paragraphEmbeddingLevel;
                    
                    embeddings[i] = paragraphEmbeddingLevel;
                    break;
                    
                default:
                    break;
            }
        }
        
        return embeddings;
    }
    
    
    /**
     * 3) resolving weak types
     * Rules W1-W7.
     *
     * Note that some weak types (EN, AN) remain after this processing is complete.
     */
    private void resolveWeakTypes(int start, int limit, byte level, byte sor, byte eor) {
        
        // Rule W1.
        // Changes all NSMs.
        byte preceedingCharacterType = sor;
        for (int i = start; i < limit; ++i) {
            byte t = resultTypes[i];
            if (t == NSM) {
                resultTypes[i] = preceedingCharacterType;
            } else {
                preceedingCharacterType = t;
            }
        }
        
        // Rule W2.
        // EN does not change at the start of the run, because sor != AL.
        for (int i = start; i < limit; ++i) {
            if (resultTypes[i] == EN) {
                for (int j = i - 1; j >= start; --j) {
                    byte t = resultTypes[j];
                    if (t == L || t == R || t == AL) {
                        if (t == AL) {
                            resultTypes[i] = AN;
                        }
                        break;
                    }
                }
            }
        }
        
        // Rule W3.
        for (int i = start; i < limit; ++i) {
            if (resultTypes[i] == AL) {
                resultTypes[i] = R;
            }
        }
        
        // Rule W4.
        // Since there must be values on both sides for this rule to have an
        // effect, the scan skips the first and last value.
        //
        // Although the scan proceeds left to right, and changes the type values
        // in a way that would appear to affect the computations later in the scan,
        // there is actually no problem.  A change in the current value can only
        // affect the value to its immediate right, and only affect it if it is
        // ES or CS.  But the current value can only change if the value to its
        // right is not ES or CS.  Thus either the current value will not change,
        // or its change will have no effect on the remainder of the analysis.
        
        for (int i = start + 1; i < limit - 1; ++i) {
            if (resultTypes[i] == ES || resultTypes[i] == CS) {
                byte prevSepType = resultTypes[i-1];
                byte succSepType = resultTypes[i+1];
                if (prevSepType == EN && succSepType == EN) {
                    resultTypes[i] = EN;
                } else if (resultTypes[i] == CS && prevSepType == AN && succSepType == AN) {
                    resultTypes[i] = AN;
                }
            }
        }
        
        // Rule W5.
        for (int i = start; i < limit; ++i) {
            if (resultTypes[i] == ET) {
                // locate end of sequence
                int runstart = i;
                int runlimit = findRunLimit(runstart, limit, new byte[] { ET });
                
                // check values at ends of sequence
                byte t = runstart == start ? sor : resultTypes[runstart - 1];
                
                if (t != EN) {
                    t = runlimit == limit ? eor : resultTypes[runlimit];
                }
                
                if (t == EN) {
                    setTypes(runstart, runlimit, EN);
                }
                
                // continue at end of sequence
                i = runlimit;
            }
        }
        
        // Rule W6.
        for (int i = start; i < limit; ++i) {
            byte t = resultTypes[i];
            if (t == ES || t == ET || t == CS) {
                resultTypes[i] = ON;
            }
        }
        
        // Rule W7.
        for (int i = start; i < limit; ++i) {
            if (resultTypes[i] == EN) {
                // set default if we reach start of run
                byte prevStrongType = sor;
                for (int j = i - 1; j >= start; --j) {
                    byte t = resultTypes[j];
                    if (t == L || t == R) { // AL's have been removed
                        prevStrongType = t;
                        break;
                    }
                }
                if (prevStrongType == L) {
                    resultTypes[i] = L;
                }
            }
        }
    }
    
    /**
     * 6) resolving neutral types
     * Rules N1-N2.
     */
    private void resolveNeutralTypes(int start, int limit, byte level, byte sor, byte eor) {
        
        for (int i = start; i < limit; ++i) {
            byte t = resultTypes[i];
            if (t == WS || t == ON || t == B || t == S) {
                // find bounds of run of neutrals
                int runstart = i;
                int runlimit = findRunLimit(runstart, limit, new byte[] {B, S, WS, ON});
                
                // determine effective types at ends of run
                byte leadingType;
                byte trailingType;
                
                if (runstart == start) {
                    leadingType = sor;
                } else {
                    leadingType = resultTypes[runstart - 1];
                    if (leadingType == L || leadingType == R) {
                        // found the strong type
                    } else if (leadingType == AN) {
                        leadingType = R;
                    } else if (leadingType == EN) {
                        // Since EN's with previous strong L types have been changed
                        // to L in W7, the leadingType must be R.
                        leadingType = R;
                    }
                }
                
                if (runlimit == limit) {
                    trailingType = eor;
                } else {
                    trailingType = resultTypes[runlimit];
                    if (trailingType == L || trailingType == R) {
                        // found the strong type
                    } else if (trailingType == AN) {
                        trailingType = R;
                    } else if (trailingType == EN) {
                        trailingType = R;
                    }
                }
                
                byte resolvedType;
                if (leadingType == trailingType) {
                    // Rule N1.
                    resolvedType = leadingType;
                } else {
                    // Rule N2.
                    // Notice the embedding level of the run is used, not
                    // the paragraph embedding level.
                    resolvedType = typeForLevel(level);
                }
                
                setTypes(runstart, runlimit, resolvedType);
                
                // skip over run of (former) neutrals
                i = runlimit;
            }
        }
    }
    
    /**
     * 7) resolving implicit embedding levels
     * Rules I1, I2.
     */
    private void resolveImplicitLevels(int start, int limit, byte level, byte sor, byte eor) {
        if ((level & 1) == 0) { // even level
            for (int i = start; i < limit; ++i) {
                byte t = resultTypes[i];
                // Rule I1.
                if (t == L ) {
                    // no change
                } else if (t == R) {
                    resultLevels[i] += 1;
                } else { // t == AN || t == EN
                    resultLevels[i] += 2;
                }
            }
        } else { // odd level
            for (int i = start; i < limit; ++i) {
                byte t = resultTypes[i];
                // Rule I2.
                if (t == R) {
                    // no change
                } else { // t == L || t == AN || t == EN
                    resultLevels[i] += 1;
                }
            }
        }
    }
    
    //
    // Output
    //
    
    public byte[] getLevels() {
        return getLevels(new int[]{textLength});
    }
    
    /**
     * Return levels array breaking lines at offsets in linebreaks. <br>
     * Rule L1.
     * <p>
     * The returned levels array contains the resolved level for each
     * bidi code passed to the constructor.
     * <p>
     * The linebreaks array must include at least one value.
     * The values must be in strictly increasing order (no duplicates)
     * between 1 and the length of the text, inclusive.  The last value
     * must be the length of the text.
     *
     * @param linebreaks the offsets at which to break the paragraph
     * @return the resolved levels of the text
     */
    public byte[] getLevels(int[] linebreaks) {
        
        // Note that since the previous processing has removed all
        // P, S, and WS values from resultTypes, the values referred to
        // in these rules are the initial types, before any processing
        // has been applied (including processing of overrides).
        //
        // This example implementation has reinserted explicit format codes
        // and BN, in order that the levels array correspond to the
        // initial text.  Their final placement is not normative.
        // These codes are treated like WS in this implementation,
        // so they don't interrupt sequences of WS.
        
        validateLineBreaks(linebreaks, textLength);
        
        byte[] result = (byte[])resultLevels.clone(); // will be returned to caller
        
        // don't worry about linebreaks since if there is a break within
        // a series of WS values preceeding S, the linebreak itself
        // causes the reset.
        for (int i = 0; i < result.length; ++i) {
            byte t = initialTypes[i];
            if (t == B || t == S) {
                // Rule L1, clauses one and two.
                result[i] = paragraphEmbeddingLevel;
                
                // Rule L1, clause three.
                for (int j = i - 1; j >= 0; --j) {
                    if (isWhitespace(initialTypes[j])) { // including format codes
                        result[j] = paragraphEmbeddingLevel;
                    } else {
                        break;
                    }
                }
            }
        }
        
        // Rule L1, clause four.
        int start = 0;
        for (int i = 0; i < linebreaks.length; ++i) {
            int limit = linebreaks[i];
            for (int j = limit - 1; j >= start; --j) {
                if (isWhitespace(initialTypes[j])) { // including format codes
                    result[j] = paragraphEmbeddingLevel;
                } else {
                    break;
                }
            }
            
            start = limit;
        }
        
        return result;
    }
    
    /**
     * Return reordering array breaking lines at offsets in linebreaks.
     * <p>
     * The reordering array maps from a visual index to a logical index.
     * Lines are concatenated from left to right.  So for example, the
     * fifth character from the left on the third line is
     * <pre> getReordering(linebreaks)[linebreaks[1] + 4]</pre>
     * (linebreaks[1] is the position after the last character of the
     * second line, which is also the index of the first character on the
     * third line, and adding four gets the fifth character from the left).
     * <p>
     * The linebreaks array must include at least one value.
     * The values must be in strictly increasing order (no duplicates)
     * between 1 and the length of the text, inclusive.  The last value
     * must be the length of the text.
     *
     * @param linebreaks the offsets at which to break the paragraph.
     */
    public int[] getReordering(int[] linebreaks) {
        validateLineBreaks(linebreaks, textLength);
        
        byte[] levels = getLevels(linebreaks);
        
        return computeMultilineReordering(levels, linebreaks);
    }
    
    /**
     * Return multiline reordering array for a given level array.
     * Reordering does not occur across a line break.
     */
    private static int[] computeMultilineReordering(byte[] levels, int[] linebreaks) {
        int[] result = new int[levels.length];
        
        int start = 0;
        for (int i = 0; i < linebreaks.length; ++i) {
            int limit = linebreaks[i];
            
            byte[] templevels = new byte[limit - start];
            System.arraycopy(levels, start, templevels, 0, templevels.length);
            
            int[] temporder = computeReordering(templevels);
            for (int j = 0; j < temporder.length; ++j) {
                result[start + j] = temporder[j] + start;
            }
            
            start = limit;
        }
        
        return result;
    }
    
    /**
     * Return reordering array for a given level array.  This reorders a single line.
     * The reordering is a visual to logical map.  For example,
     * the leftmost char is string.charAt(order[0]).
     * Rule L2.
     */
    private static int[] computeReordering(byte[] levels) {
        int lineLength = levels.length;
        
        int[] result = new int[lineLength];
        
        // initialize order
        for (int i = 0; i < lineLength; ++i) {
            result[i] = i;
        }
        
        // locate highest level found on line.
        // Note the rules say text, but no reordering across line bounds is performed,
        // so this is sufficient.
        byte highestLevel = 0;
        byte lowestOddLevel = 63;
        for (int i = 0; i < lineLength; ++i) {
            byte level = levels[i];
            if (level > highestLevel) {
                highestLevel = level;
            }
            if (((level & 1) != 0) && level < lowestOddLevel) {
                lowestOddLevel = level;
            }
        }
        
        for (int level = highestLevel; level >= lowestOddLevel; --level) {
            for (int i = 0; i < lineLength; ++i) {
                if (levels[i] >= level) {
                    // find range of text at or above this level
                    int start = i;
                    int limit = i + 1;
                    while (limit < lineLength && levels[limit] >= level) {
                        ++limit;
                    }
                    
                    // reverse run
                    for (int j = start, k = limit - 1; j < k; ++j, --k) {
                        int temp = result[j];
                        result[j] = result[k];
                        result[k] = temp;
                    }
                    
                    // skip to end of level run
                    i = limit;
                }
            }
        }
        
        return result;
    }
    
    /**
     * Return the base level of the paragraph.
     */
    public byte getBaseLevel() {
        return paragraphEmbeddingLevel;
    }
    
    // --- internal utilities -------------------------------------------------
    
    /**
     * Return true if the type is considered a whitespace type for the line break rules.
     */
    private static boolean isWhitespace(byte biditype) {
        switch (biditype) {
            case LRE:
            case RLE:
            case LRO:
            case RLO:
            case PDF:
            case BN:
            case WS:
                return true;
            default:
                return false;
        }
    }
    
    /**
     * Return the strong type (L or R) corresponding to the level.
     */
    private static byte typeForLevel(int level) {
        return ((level & 0x1) == 0) ? L : R;
    }
    
    /**
     * Return the limit of the run starting at index that includes only resultTypes in validSet.
     * This checks the value at index, and will return index if that value is not in validSet.
     */
    private int findRunLimit(int index, int limit, byte[] validSet) {
        --index;
        loop:
            while (++index < limit) {
                byte t = resultTypes[index];
                for (int i = 0; i < validSet.length; ++i) {
                    if (t == validSet[i]) {
                        continue loop;
                    }
                }
                // didn't find a match in validSet
                return index;
            }
            return limit;
    }
    
    /**
     * Return the start of the run including index that includes only resultTypes in validSet.
     * This assumes the value at index is valid, and does not check it.
     */
    private int findRunStart(int index, byte[] validSet) {
        loop:
            while (--index >= 0) {
                byte t = resultTypes[index];
                for (int i = 0; i < validSet.length; ++i) {
                    if (t == validSet[i]) {
                        continue loop;
                    }
                }
                return index + 1;
            }
            return 0;
    }
    
    /**
     * Set resultTypes from start up to (but not including) limit to newType.
     */
    private void setTypes(int start, int limit, byte newType) {
        for (int i = start; i < limit; ++i) {
            resultTypes[i] = newType;
        }
    }
    
    /**
     * Set resultLevels from start up to (but not including) limit to newLevel.
     */
    private void setLevels(int start, int limit, byte newLevel) {
        for (int i = start; i < limit; ++i) {
            resultLevels[i] = newLevel;
        }
    }
    
    // --- input validation ---------------------------------------------------
    
    /**
     * Throw exception if type array is invalid.
     */
    private static void validateTypes(byte[] types) {
        if (types == null) {
            throw new IllegalArgumentException("types is null");
        }
        for (int i = 0; i < types.length; ++i) {
            if (types[i] < TYPE_MIN || types[i] > TYPE_MAX) {
                throw new IllegalArgumentException("illegal type value at " + i + ": " + types[i]);
            }
        }
        for (int i = 0; i < types.length - 1; ++i) {
            if (types[i] == B) {
                throw new IllegalArgumentException("B type before end of paragraph at index: " + i);
            }
        }
    }
    
    /**
     * Throw exception if paragraph embedding level is invalid. Special allowance for -1 so that
     * default processing can still be performed when using this API.
     */
    private static void validateParagraphEmbeddingLevel(byte paragraphEmbeddingLevel) {
        if (paragraphEmbeddingLevel != -1 &&
        paragraphEmbeddingLevel != 0 &&
        paragraphEmbeddingLevel != 1) {
            throw new IllegalArgumentException("illegal paragraph embedding level: " + paragraphEmbeddingLevel);
        }
    }
    
    /**
     * Throw exception if line breaks array is invalid.
     */
    private static void validateLineBreaks(int[] linebreaks, int textLength) {
        int prev = 0;
        for (int i = 0; i < linebreaks.length; ++i) {
            int next = linebreaks[i];
            if (next <= prev) {
                throw new IllegalArgumentException("bad linebreak: " + next + " at index: " + i);
            }
            prev = next;
        }
        if (prev != textLength) {
            throw new IllegalArgumentException("last linebreak must be at " + textLength);
        }
    }
    
    private static final byte rtypes[] = new byte[0x10000];
    
    private static char baseTypes[] = {
        0, 8, (char)BN, 9, 9, (char)S, 10, 10, (char)B, 11, 11, (char)S, 12, 12, (char)WS, 13, 13, (char)B,
        14, 27, (char)BN, 28, 30, (char)B, 31, 31, (char)S, 32, 32, (char)WS, 33, 34, (char)ON, 35, 37, (char)ET,
        38, 42, (char)ON, 43, 43, (char)ET, 44, 44, (char)CS, 45, 45, (char)ET, 46, 46, (char)CS, 47, 47, (char)ES,
        48, 57, (char)EN, 58, 58, (char)CS, 59, 64, (char)ON, 65, 90, (char)L, 91, 96, (char)ON, 97, 122, (char)L,
        123, 126, (char)ON, 127, 132, (char)BN, 133, 133, (char)B, 134, 159, (char)BN, 160, 160, (char)CS,
        161, 161, (char)ON, 162, 165, (char)ET, 166, 169, (char)ON, 170, 170, (char)L, 171, 175, (char)ON,
        176, 177, (char)ET, 178, 179, (char)EN, 180, 180, (char)ON, 181, 181, (char)L, 182, 184, (char)ON,
        185, 185, (char)EN, 186, 186, (char)L, 187, 191, (char)ON, 192, 214, (char)L, 215, 215, (char)ON,
        216, 246, (char)L, 247, 247, (char)ON, 248, 696, (char)L, 697, 698, (char)ON, 699, 705, (char)L,
        706, 719, (char)ON, 720, 721, (char)L, 722, 735, (char)ON, 736, 740, (char)L, 741, 749, (char)ON,
        750, 750, (char)L, 751, 767, (char)ON, 768, 855, (char)NSM, 856, 860, (char)L, 861, 879, (char)NSM,
        880, 883, (char)L, 884, 885, (char)ON, 886, 893, (char)L, 894, 894, (char)ON, 895, 899, (char)L,
        900, 901, (char)ON, 902, 902, (char)L, 903, 903, (char)ON, 904, 1013, (char)L, 1014, 1014, (char)ON,
        1015, 1154, (char)L, 1155, 1158, (char)NSM, 1159, 1159, (char)L, 1160, 1161, (char)NSM,
        1162, 1417, (char)L, 1418, 1418, (char)ON, 1419, 1424, (char)L, 1425, 1441, (char)NSM,
        1442, 1442, (char)L, 1443, 1465, (char)NSM, 1466, 1466, (char)L, 1467, 1469, (char)NSM,
        1470, 1470, (char)R, 1471, 1471, (char)NSM, 1472, 1472, (char)R, 1473, 1474, (char)NSM,
        1475, 1475, (char)R, 1476, 1476, (char)NSM, 1477, 1487, (char)L, 1488, 1514, (char)R,
        1515, 1519, (char)L, 1520, 1524, (char)R, 1525, 1535, (char)L, 1536, 1539, (char)AL,
        1540, 1547, (char)L, 1548, 1548, (char)CS, 1549, 1549, (char)AL, 1550, 1551, (char)ON,
        1552, 1557, (char)NSM, 1558, 1562, (char)L, 1563, 1563, (char)AL, 1564, 1566, (char)L,
        1567, 1567, (char)AL, 1568, 1568, (char)L, 1569, 1594, (char)AL, 1595, 1599, (char)L,
        1600, 1610, (char)AL, 1611, 1624, (char)NSM, 1625, 1631, (char)L, 1632, 1641, (char)AN,
        1642, 1642, (char)ET, 1643, 1644, (char)AN, 1645, 1647, (char)AL, 1648, 1648, (char)NSM,
        1649, 1749, (char)AL, 1750, 1756, (char)NSM, 1757, 1757, (char)AL, 1758, 1764, (char)NSM,
        1765, 1766, (char)AL, 1767, 1768, (char)NSM, 1769, 1769, (char)ON, 1770, 1773, (char)NSM,
        1774, 1775, (char)AL, 1776, 1785, (char)EN, 1786, 1805, (char)AL, 1806, 1806, (char)L,
        1807, 1807, (char)BN, 1808, 1808, (char)AL, 1809, 1809, (char)NSM, 1810, 1839, (char)AL,
        1840, 1866, (char)NSM, 1867, 1868, (char)L, 1869, 1871, (char)AL, 1872, 1919, (char)L,
        1920, 1957, (char)AL, 1958, 1968, (char)NSM, 1969, 1969, (char)AL, 1970, 2304, (char)L,
        2305, 2306, (char)NSM, 2307, 2363, (char)L, 2364, 2364, (char)NSM, 2365, 2368, (char)L,
        2369, 2376, (char)NSM, 2377, 2380, (char)L, 2381, 2381, (char)NSM, 2382, 2384, (char)L,
        2385, 2388, (char)NSM, 2389, 2401, (char)L, 2402, 2403, (char)NSM, 2404, 2432, (char)L,
        2433, 2433, (char)NSM, 2434, 2491, (char)L, 2492, 2492, (char)NSM, 2493, 2496, (char)L,
        2497, 2500, (char)NSM, 2501, 2508, (char)L, 2509, 2509, (char)NSM, 2510, 2529, (char)L,
        2530, 2531, (char)NSM, 2532, 2545, (char)L, 2546, 2547, (char)ET, 2548, 2560, (char)L,
        2561, 2562, (char)NSM, 2563, 2619, (char)L, 2620, 2620, (char)NSM, 2621, 2624, (char)L,
        2625, 2626, (char)NSM, 2627, 2630, (char)L, 2631, 2632, (char)NSM, 2633, 2634, (char)L,
        2635, 2637, (char)NSM, 2638, 2671, (char)L, 2672, 2673, (char)NSM, 2674, 2688, (char)L,
        2689, 2690, (char)NSM, 2691, 2747, (char)L, 2748, 2748, (char)NSM, 2749, 2752, (char)L,
        2753, 2757, (char)NSM, 2758, 2758, (char)L, 2759, 2760, (char)NSM, 2761, 2764, (char)L,
        2765, 2765, (char)NSM, 2766, 2785, (char)L, 2786, 2787, (char)NSM, 2788, 2800, (char)L,
        2801, 2801, (char)ET, 2802, 2816, (char)L, 2817, 2817, (char)NSM, 2818, 2875, (char)L,
        2876, 2876, (char)NSM, 2877, 2878, (char)L, 2879, 2879, (char)NSM, 2880, 2880, (char)L,
        2881, 2883, (char)NSM, 2884, 2892, (char)L, 2893, 2893, (char)NSM, 2894, 2901, (char)L,
        2902, 2902, (char)NSM, 2903, 2945, (char)L, 2946, 2946, (char)NSM, 2947, 3007, (char)L,
        3008, 3008, (char)NSM, 3009, 3020, (char)L, 3021, 3021, (char)NSM, 3022, 3058, (char)L,
        3059, 3064, (char)ON, 3065, 3065, (char)ET, 3066, 3066, (char)ON, 3067, 3133, (char)L,
        3134, 3136, (char)NSM, 3137, 3141, (char)L, 3142, 3144, (char)NSM, 3145, 3145, (char)L,
        3146, 3149, (char)NSM, 3150, 3156, (char)L, 3157, 3158, (char)NSM, 3159, 3259, (char)L,
        3260, 3260, (char)NSM, 3261, 3275, (char)L, 3276, 3277, (char)NSM, 3278, 3392, (char)L,
        3393, 3395, (char)NSM, 3396, 3404, (char)L, 3405, 3405, (char)NSM, 3406, 3529, (char)L,
        3530, 3530, (char)NSM, 3531, 3537, (char)L, 3538, 3540, (char)NSM, 3541, 3541, (char)L,
        3542, 3542, (char)NSM, 3543, 3632, (char)L, 3633, 3633, (char)NSM, 3634, 3635, (char)L,
        3636, 3642, (char)NSM, 3643, 3646, (char)L, 3647, 3647, (char)ET, 3648, 3654, (char)L,
        3655, 3662, (char)NSM, 3663, 3760, (char)L, 3761, 3761, (char)NSM, 3762, 3763, (char)L,
        3764, 3769, (char)NSM, 3770, 3770, (char)L, 3771, 3772, (char)NSM, 3773, 3783, (char)L,
        3784, 3789, (char)NSM, 3790, 3863, (char)L, 3864, 3865, (char)NSM, 3866, 3892, (char)L,
        3893, 3893, (char)NSM, 3894, 3894, (char)L, 3895, 3895, (char)NSM, 3896, 3896, (char)L,
        3897, 3897, (char)NSM, 3898, 3901, (char)ON, 3902, 3952, (char)L, 3953, 3966, (char)NSM,
        3967, 3967, (char)L, 3968, 3972, (char)NSM, 3973, 3973, (char)L, 3974, 3975, (char)NSM,
        3976, 3983, (char)L, 3984, 3991, (char)NSM, 3992, 3992, (char)L, 3993, 4028, (char)NSM,
        4029, 4037, (char)L, 4038, 4038, (char)NSM, 4039, 4140, (char)L, 4141, 4144, (char)NSM,
        4145, 4145, (char)L, 4146, 4146, (char)NSM, 4147, 4149, (char)L, 4150, 4151, (char)NSM,
        4152, 4152, (char)L, 4153, 4153, (char)NSM, 4154, 4183, (char)L, 4184, 4185, (char)NSM,
        4186, 5759, (char)L, 5760, 5760, (char)WS, 5761, 5786, (char)L, 5787, 5788, (char)ON,
        5789, 5905, (char)L, 5906, 5908, (char)NSM, 5909, 5937, (char)L, 5938, 5940, (char)NSM,
        5941, 5969, (char)L, 5970, 5971, (char)NSM, 5972, 6001, (char)L, 6002, 6003, (char)NSM,
        6004, 6070, (char)L, 6071, 6077, (char)NSM, 6078, 6085, (char)L, 6086, 6086, (char)NSM,
        6087, 6088, (char)L, 6089, 6099, (char)NSM, 6100, 6106, (char)L, 6107, 6107, (char)ET,
        6108, 6108, (char)L, 6109, 6109, (char)NSM, 6110, 6127, (char)L, 6128, 6137, (char)ON,
        6138, 6143, (char)L, 6144, 6154, (char)ON, 6155, 6157, (char)NSM, 6158, 6158, (char)WS,
        6159, 6312, (char)L, 6313, 6313, (char)NSM, 6314, 6431, (char)L, 6432, 6434, (char)NSM,
        6435, 6438, (char)L, 6439, 6443, (char)NSM, 6444, 6449, (char)L, 6450, 6450, (char)NSM,
        6451, 6456, (char)L, 6457, 6459, (char)NSM, 6460, 6463, (char)L, 6464, 6464, (char)ON,
        6465, 6467, (char)L, 6468, 6469, (char)ON, 6470, 6623, (char)L, 6624, 6655, (char)ON,
        6656, 8124, (char)L, 8125, 8125, (char)ON, 8126, 8126, (char)L, 8127, 8129, (char)ON,
        8130, 8140, (char)L, 8141, 8143, (char)ON, 8144, 8156, (char)L, 8157, 8159, (char)ON,
        8160, 8172, (char)L, 8173, 8175, (char)ON, 8176, 8188, (char)L, 8189, 8190, (char)ON,
        8191, 8191, (char)L, 8192, 8202, (char)WS, 8203, 8205, (char)BN, 8206, 8206, (char)L,
        8207, 8207, (char)R, 8208, 8231, (char)ON, 8232, 8232, (char)WS, 8233, 8233, (char)B,
        8234, 8234, (char)LRE, 8235, 8235, (char)RLE, 8236, 8236, (char)PDF, 8237, 8237, (char)LRO,
        8238, 8238, (char)RLO, 8239, 8239, (char)WS, 8240, 8244, (char)ET, 8245, 8276, (char)ON,
        8277, 8278, (char)L, 8279, 8279, (char)ON, 8280, 8286, (char)L, 8287, 8287, (char)WS,
        8288, 8291, (char)BN, 8292, 8297, (char)L, 8298, 8303, (char)BN, 8304, 8304, (char)EN,
        8305, 8307, (char)L, 8308, 8313, (char)EN, 8314, 8315, (char)ET, 8316, 8318, (char)ON,
        8319, 8319, (char)L, 8320, 8329, (char)EN, 8330, 8331, (char)ET, 8332, 8334, (char)ON,
        8335, 8351, (char)L, 8352, 8369, (char)ET, 8370, 8399, (char)L, 8400, 8426, (char)NSM,
        8427, 8447, (char)L, 8448, 8449, (char)ON, 8450, 8450, (char)L, 8451, 8454, (char)ON,
        8455, 8455, (char)L, 8456, 8457, (char)ON, 8458, 8467, (char)L, 8468, 8468, (char)ON,
        8469, 8469, (char)L, 8470, 8472, (char)ON, 8473, 8477, (char)L, 8478, 8483, (char)ON,
        8484, 8484, (char)L, 8485, 8485, (char)ON, 8486, 8486, (char)L, 8487, 8487, (char)ON,
        8488, 8488, (char)L, 8489, 8489, (char)ON, 8490, 8493, (char)L, 8494, 8494, (char)ET,
        8495, 8497, (char)L, 8498, 8498, (char)ON, 8499, 8505, (char)L, 8506, 8507, (char)ON,
        8508, 8511, (char)L, 8512, 8516, (char)ON, 8517, 8521, (char)L, 8522, 8523, (char)ON,
        8524, 8530, (char)L, 8531, 8543, (char)ON, 8544, 8591, (char)L, 8592, 8721, (char)ON,
        8722, 8723, (char)ET, 8724, 9013, (char)ON, 9014, 9082, (char)L, 9083, 9108, (char)ON,
        9109, 9109, (char)L, 9110, 9168, (char)ON, 9169, 9215, (char)L, 9216, 9254, (char)ON,
        9255, 9279, (char)L, 9280, 9290, (char)ON, 9291, 9311, (char)L, 9312, 9371, (char)EN,
        9372, 9449, (char)L, 9450, 9450, (char)EN, 9451, 9751, (char)ON, 9752, 9752, (char)L,
        9753, 9853, (char)ON, 9854, 9855, (char)L, 9856, 9873, (char)ON, 9874, 9887, (char)L,
        9888, 9889, (char)ON, 9890, 9984, (char)L, 9985, 9988, (char)ON, 9989, 9989, (char)L,
        9990, 9993, (char)ON, 9994, 9995, (char)L, 9996, 10023, (char)ON, 10024, 10024, (char)L,
        10025, 10059, (char)ON, 10060, 10060, (char)L, 10061, 10061, (char)ON, 10062, 10062, (char)L,
        10063, 10066, (char)ON, 10067, 10069, (char)L, 10070, 10070, (char)ON, 10071, 10071, (char)L,
        10072, 10078, (char)ON, 10079, 10080, (char)L, 10081, 10132, (char)ON, 10133, 10135, (char)L,
        10136, 10159, (char)ON, 10160, 10160, (char)L, 10161, 10174, (char)ON, 10175, 10191, (char)L,
        10192, 10219, (char)ON, 10220, 10223, (char)L, 10224, 11021, (char)ON, 11022, 11903, (char)L,
        11904, 11929, (char)ON, 11930, 11930, (char)L, 11931, 12019, (char)ON, 12020, 12031, (char)L,
        12032, 12245, (char)ON, 12246, 12271, (char)L, 12272, 12283, (char)ON, 12284, 12287, (char)L,
        12288, 12288, (char)WS, 12289, 12292, (char)ON, 12293, 12295, (char)L, 12296, 12320, (char)ON,
        12321, 12329, (char)L, 12330, 12335, (char)NSM, 12336, 12336, (char)ON, 12337, 12341, (char)L,
        12342, 12343, (char)ON, 12344, 12348, (char)L, 12349, 12351, (char)ON, 12352, 12440, (char)L,
        12441, 12442, (char)NSM, 12443, 12444, (char)ON, 12445, 12447, (char)L, 12448, 12448, (char)ON,
        12449, 12538, (char)L, 12539, 12539, (char)ON, 12540, 12828, (char)L, 12829, 12830, (char)ON,
        12831, 12879, (char)L, 12880, 12895, (char)ON, 12896, 12923, (char)L, 12924, 12925, (char)ON,
        12926, 12976, (char)L, 12977, 12991, (char)ON, 12992, 13003, (char)L, 13004, 13007, (char)ON,
        13008, 13174, (char)L, 13175, 13178, (char)ON, 13179, 13277, (char)L, 13278, 13279, (char)ON,
        13280, 13310, (char)L, 13311, 13311, (char)ON, 13312, 19903, (char)L, 19904, 19967, (char)ON,
        19968, 42127, (char)L, 42128, 42182, (char)ON, 42183, 64284, (char)L, 64285, 64285, (char)R,
        64286, 64286, (char)NSM, 64287, 64296, (char)R, 64297, 64297, (char)ET, 64298, 64310, (char)R,
        64311, 64311, (char)L, 64312, 64316, (char)R, 64317, 64317, (char)L, 64318, 64318, (char)R,
        64319, 64319, (char)L, 64320, 64321, (char)R, 64322, 64322, (char)L, 64323, 64324, (char)R,
        64325, 64325, (char)L, 64326, 64335, (char)R, 64336, 64433, (char)AL, 64434, 64466, (char)L,
        64467, 64829, (char)AL, 64830, 64831, (char)ON, 64832, 64847, (char)L, 64848, 64911, (char)AL,
        64912, 64913, (char)L, 64914, 64967, (char)AL, 64968, 65007, (char)L, 65008, 65020, (char)AL,
        65021, 65021, (char)ON, 65022, 65023, (char)L, 65024, 65039, (char)NSM, 65040, 65055, (char)L,
        65056, 65059, (char)NSM, 65060, 65071, (char)L, 65072, 65103, (char)ON, 65104, 65104, (char)CS,
        65105, 65105, (char)ON, 65106, 65106, (char)CS, 65107, 65107, (char)L, 65108, 65108, (char)ON,
        65109, 65109, (char)CS, 65110, 65118, (char)ON, 65119, 65119, (char)ET, 65120, 65121, (char)ON,
        65122, 65123, (char)ET, 65124, 65126, (char)ON, 65127, 65127, (char)L, 65128, 65128, (char)ON,
        65129, 65130, (char)ET, 65131, 65131, (char)ON, 65132, 65135, (char)L, 65136, 65140, (char)AL,
        65141, 65141, (char)L, 65142, 65276, (char)AL, 65277, 65278, (char)L, 65279, 65279, (char)BN,
        65280, 65280, (char)L, 65281, 65282, (char)ON, 65283, 65285, (char)ET, 65286, 65290, (char)ON,
        65291, 65291, (char)ET, 65292, 65292, (char)CS, 65293, 65293, (char)ET, 65294, 65294, (char)CS,
        65295, 65295, (char)ES, 65296, 65305, (char)EN, 65306, 65306, (char)CS, 65307, 65312, (char)ON,
        65313, 65338, (char)L, 65339, 65344, (char)ON, 65345, 65370, (char)L, 65371, 65381, (char)ON,
        65382, 65503, (char)L, 65504, 65505, (char)ET, 65506, 65508, (char)ON, 65509, 65510, (char)ET,
        65511, 65511, (char)L, 65512, 65518, (char)ON, 65519, 65528, (char)L, 65529, 65531, (char)BN,
        65532, 65533, (char)ON, 65534, 65535, (char)L};
        
    static {
        for (int k = 0; k < baseTypes.length; ++k) {
            int start = baseTypes[k];
            int end = baseTypes[++k];
            byte b = (byte)baseTypes[++k];
            while (start <= end)
                rtypes[start++] = b;
        }
    }        
} /*
 * $Id: ByteBuffer.java,v 1.34 2002/06/18 13:59:39 blowagie Exp $
 * $Name:  $
 *
 * Copyright 2000, 2001, 2002 by Paulo Soares.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf;
import java.io.UnsupportedEncodingException;
import java.io.OutputStream;
import java.io.IOException;
import pdftk.com.lowagie.text.DocWriter;

/**
 * Acts like a <CODE>StringBuffer</CODE> but works with <CODE>byte</CODE> arrays.
 * Floating point is converted to a format suitable to the PDF.
 * @author Paulo Soares (psoares@consiste.pt)
 */

public class ByteBuffer extends OutputStream {
    /** The count of bytes in the buffer. */
    protected int count;
    
    /** The buffer where the bytes are stored. */
    protected byte buf[];
    
    private static int byteCacheSize = 0;
    
    private static byte[][] byteCache = new byte[byteCacheSize][];
    public static byte ZERO = (byte)'0';
    private static final char[] chars = new char[] {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};
    private static final byte[] bytes = new byte[] {48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 97, 98, 99, 100, 101, 102};
    
    /** Creates new ByteBuffer with capacity 128 */
    public ByteBuffer() {
        this(128);
    }
    
    /**
     * Creates a byte buffer with a certain capacity.
     * @param size the initial capacity
     */
    public ByteBuffer(int size) {
        if (size < 1)
            size = 128;
        buf = new byte[size];
    }
    
    /**
     * Sets the cache size.
     * <P>
     * This can only be used to increment the size.
     * If the size that is passed through is smaller than the current size, nothing happens.
     *
     * @param   size    the size of the cache
     */
    
    public static void setCacheSize(int size) {
        if (size > 3276700) size = 3276700;
        if (size <= byteCacheSize) return;
        byte[][] tmpCache = new byte[size][];
        for (int i = 0; i < byteCacheSize; i++) {
            tmpCache[i] = byteCache[i];
        }
        byteCache = tmpCache;
        byteCacheSize = size;
    }
    
    /**
     * You can fill the cache in advance if you want to.
     *
     * @param   decimals
     */
    
    public static void fillCache(int decimals) {
        int step = 1;
        switch(decimals) {
            case 0:
                step = 100;
                break;
            case 1:
                step = 10;
                break;
        }
        for (int i = 1; i < byteCacheSize; i += step) {
            if (byteCache[i] != null) continue;
            byteCache[i] = convertToBytes(i);
        }
    }
    
    /**
     * Converts an double (multiplied by 100 and cast to an int) into an array of bytes.
     *
     * @param   i   the int
     * @return  a bytearray
     */
    
    private static byte[] convertToBytes(int i) {
        int size = (int)Math.floor(Math.log(i) / Math.log(10));
        if (i % 100 != 0) {
            size += 2;
        }
        if (i % 10 != 0) {
            size++;
        }
        if (i < 100) {
            size++;
            if (i < 10) {
                size++;
            }
        }
        size--;
        byte[] cache = new byte[size];
        size --;
        if (i < 100) {
            cache[0] = (byte)'0';
        }
        if (i % 10 != 0) {
            cache[size--] = bytes[i % 10];
        }
        if (i % 100 != 0) {
            cache[size--] = bytes[(i / 10) % 10];
            cache[size--] = (byte)'.';
        }
        size = (int)Math.floor(Math.log(i) / Math.log(10)) - 1;
        int add = 0;
        while (add < size) {
            cache[add] = bytes[(i / (int)Math.pow(10, size - add + 1)) % 10];
            add++;
        }
        return cache;
    }
    
    /**
     * Appends an <CODE>int</CODE>. The size of the array will grow by one.
     * @param b the int to be appended
     * @return a reference to this <CODE>ByteBuffer</CODE> object
     */
    public ByteBuffer append_i(int b) {
        int newcount = count + 1;
        if (newcount > buf.length) {
            byte newbuf[] = new byte[Math.max(buf.length << 1, newcount)];
            System.arraycopy(buf, 0, newbuf, 0, count);
            buf = newbuf;
        }
        buf[count] = (byte)b;
        count = newcount;
        return this;
    }
    
    /**
     * Appends the subarray of the <CODE>byte</CODE> array. The buffer will grow by
     * <CODE>len</CODE> bytes.
     * @param b the array to be appended
     * @param off the offset to the start of the array
     * @param len the length of bytes to append
     * @return a reference to this <CODE>ByteBuffer</CODE> object
     */
    public ByteBuffer append(byte b[], int off, int len) {
        if ((off < 0) || (off > b.length) || (len < 0) ||
        ((off + len) > b.length) || ((off + len) < 0) || len == 0)
            return this;
        int newcount = count + len;
        if (newcount > buf.length) {
            byte newbuf[] = new byte[Math.max(buf.length << 1, newcount)];
            System.arraycopy(buf, 0, newbuf, 0, count);
            buf = newbuf;
        }
        System.arraycopy(b, off, buf, count, len);
        count = newcount;
        return this;
    }
    
    /**
     * Appends an array of bytes.
     * @param b the array to be appended
     * @return a reference to this <CODE>ByteBuffer</CODE> object
     */
    public ByteBuffer append(byte b[]) {
        return append(b, 0, b.length);
    }
    
    /**
     * Appends a <CODE>String</CODE> to the buffer. The <CODE>String</CODE> is
     * converted according to the encoding ISO-8859-1.
     * @param str the <CODE>String</CODE> to be appended
     * @return a reference to this <CODE>ByteBuffer</CODE> object
     */
    public ByteBuffer append(String str) {
        if (str != null)
            return append(DocWriter.getISOBytes(str));
        return this;
    }
    
    /**
     * Appends a <CODE>char</CODE> to the buffer. The <CODE>char</CODE> is
     * converted according to the encoding ISO-8859-1.
     * @param c the <CODE>char</CODE> to be appended
     * @return a reference to this <CODE>ByteBuffer</CODE> object
     */
    public ByteBuffer append(char c) {
        return append_i(c);
    }
    
    /**
     * Appends another <CODE>ByteBuffer</CODE> to this buffer.
     * @param buf the <CODE>ByteBuffer</CODE> to be appended
     * @return a reference to this <CODE>ByteBuffer</CODE> object
     */
    public ByteBuffer append(ByteBuffer buf) {
        return append(buf.buf, 0, buf.count);
    }
    
    /**
     * Appends the string representation of an <CODE>int</CODE>.
     * @param i the <CODE>int</CODE> to be appended
     * @return a reference to this <CODE>ByteBuffer</CODE> object
     */
    public ByteBuffer append(int i) {
        return append((double)i);
    }
    
    public ByteBuffer append(byte b) {
        return append_i(b);
    }
    
    public ByteBuffer appendHex(byte b) {
        append(bytes[(b >> 4) & 0x0f]);
        return append(bytes[b & 0x0f]);
    }
    
    /**
     * Appends a string representation of a <CODE>float</CODE> according
     * to the Pdf conventions.
     * @param i the <CODE>float</CODE> to be appended
     * @return a reference to this <CODE>ByteBuffer</CODE> object
     */
    public ByteBuffer append(float i) {
        return append((double)i);
    }
    
    /**
     * Appends a string representation of a <CODE>double</CODE> according
     * to the Pdf conventions.
     * @param d the <CODE>double</CODE> to be appended
     * @return a reference to this <CODE>ByteBuffer</CODE> object
     */
    public ByteBuffer append(double d) {
        append(formatDouble(d, this));
        return this;
    }
    
    /**
     * Outputs a <CODE>double</CODE> into a format suitable for the PDF.
     * @param d a double
     * @return the <CODE>String</CODE> representation of the <CODE>double</CODE>
     */
    public static String formatDouble(double d) {
        return formatDouble(d, null);
    }
    
    /**
     * Outputs a <CODE>double</CODE> into a format suitable for the PDF.
     * @param d a double
     * @return the <CODE>String</CODE> representation of the <CODE>double</CODE> if
     * <CODE>d</CODE> is <CODE>null</CODE>. If <CODE>d</CODE> is <B>not</B> <CODE>null</CODE>,
     * then the double is appended directly to the buffer and this methods returns <CODE>null</CODE>.
     */
    public static String formatDouble(double d, ByteBuffer buf) {
        boolean negative = false;
        if (Math.abs(d) < 0.000015) {
            if (buf != null) {
                buf.append((byte)ZERO);
                return null;
            } else {
                return "0";
            }
        }
        if (d < 0) {
            negative = true;
            d = -d;
        }
        if (d < 1.0) {
            d += 0.000005;
            if (d >= 1) {
                if (negative) {
                    if (buf != null) {
                        buf.append((byte)'-');
                        buf.append((byte)'1');
                        return null;
                    } else {
                        return "-1";
                    }
                } else {
                    if (buf != null) {
                        buf.append((byte)'1');
                        return null;
                    } else {
                        return "1";
                    }
                }
            }
            if (buf != null) {
                int v = (int) (d * 100000);
                
                if (negative) buf.append((byte)'-');
                buf.append((byte)'0');
                buf.append((byte)'.');
                
                buf.append( (byte)(v / 10000 + ZERO) );
                if (v % 10000 != 0) {
                    buf.append( (byte)((v / 1000) % 10 + ZERO) );
                    if (v % 1000 != 0) {
                        buf.append( (byte)((v / 100) % 10 + ZERO) );
                        if (v % 100 != 0) {
                            buf.append((byte)((v / 10) % 10 + ZERO) );
                            if (v % 10 != 0) {
                                buf.append((byte)((v) % 10 + ZERO) );
                            }
                        }
                    }
                }
                return null;
            } else {
                int x = 100000;
                int v = (int) (d * x);
                
                StringBuffer res = new StringBuffer();
                if (negative) res.append('-');
                res.append("0.");
                
                while( v < x/10 ) {
                    res.append('0');
                    x /= 10;
                }
                res.append(v);
                int cut = res.length() - 1;
                while (res.charAt(cut) == '0') {
                    --cut;
                }
                res.setLength(cut + 1);
                return res.toString();
            }
        } else if (d <= 32767) {
            d += 0.005;
            int v = (int) (d * 100);
            
            if (v < byteCacheSize && byteCache[v] != null) {
                if (buf != null) {
                    if (negative) buf.append((byte)'-');
                    buf.append(byteCache[v]);
                    return null;
                } else {
                    String tmp = PdfEncodings.convertToString(byteCache[v], null);
                    if (negative) tmp = "-" + tmp;
                    return tmp;
                }
            }
            if (buf != null) {
                if (v < byteCacheSize) {
                    //create the cachebyte[]
                    byte[] cache;
                    int size = 0;
                    if (v >= 1000000) {
                        //the original number is >=10000, we need 5 more bytes
                        size += 5;
                    } else if (v >= 100000) {
                        //the original number is >=1000, we need 4 more bytes
                        size += 4;
                    } else if (v >= 10000) {
                        //the original number is >=100, we need 3 more bytes
                        size += 3;
                    } else if (v >= 1000) {
                        //the original number is >=10, we need 2 more bytes
                        size += 2;
                    } else if (v >= 100) {
                        //the original number is >=1, we need 1 more bytes
                        size += 1;
                    }
                    
                    //now we must check if we have a decimal number
                    if (v % 100 != 0) {
                        //yes, do not forget the "."
                        size += 2;
                    }
                    if (v % 10 != 0) {
                        size++;
                    }
                    cache = new byte[size];
                    int add = 0;
                    if (v >= 1000000) {
                        cache[add++] = bytes[(v / 1000000)];
                    }
                    if (v >= 100000) {
                        cache[add++] = bytes[(v / 100000) % 10];
                    }
                    if (v >= 10000) {
                        cache[add++] = bytes[(v / 10000) % 10];
                    }
                    if (v >= 1000) {
                        cache[add++] = bytes[(v / 1000) % 10];
                    }
                    if (v >= 100) {
                        cache[add++] = bytes[(v / 100) % 10];
                    }
                    
                    if (v % 100 != 0) {
                        cache[add++] = (byte)'.';
                        cache[add++] = bytes[(v / 10) % 10];
                        if (v % 10 != 0) {
                            cache[add++] = bytes[v % 10];
                        }
                    }
                    byteCache[v] = cache;
                }
                
                if (negative) buf.append((byte)'-');
                if (v >= 1000000) {
                    buf.append( bytes[(v / 1000000)] );
                }
                if (v >= 100000) {
                    buf.append( bytes[(v / 100000) % 10] );
                }
                if (v >= 10000) {
                    buf.append( bytes[(v / 10000) % 10] );
                }
                if (v >= 1000) {
                    buf.append( bytes[(v / 1000) % 10] );
                }
                if (v >= 100) {
                    buf.append( bytes[(v / 100) % 10] );
                }
                
                if (v % 100 != 0) {
                    buf.append((byte)'.');
                    buf.append( bytes[(v / 10) % 10] );
                    if (v % 10 != 0) {
                        buf.append( bytes[v % 10] );
                    }
                }
                return null;
            } else {
                StringBuffer res = new StringBuffer();
                if (negative) res.append((char)'-');
                if (v >= 1000000) {
                    res.append( chars[(v / 1000000)] );
                }
                if (v >= 100000) {
                    res.append( chars[(v / 100000) % 10] );
                }
                if (v >= 10000) {
                    res.append( chars[(v / 10000) % 10] );
                }
                if (v >= 1000) {
                    res.append( chars[(v / 1000) % 10] );
                }
                if (v >= 100) {
                    res.append( chars[(v / 100) % 10] );
                }
                
                if (v % 100 != 0) {
                    res.append((char)'.');
                    res.append( chars[(v / 10) % 10] );
                    if (v % 10 != 0) {
                        res.append( chars[v % 10] );
                    }
                }
                return res.toString();
            }
        } else {
            StringBuffer res = new StringBuffer();
            if (negative) res.append('-');
            d += 0.5;
            long v = (long) d;
            return res.append(v).toString();
        }
    }
    
    /**
     * Sets the size to zero.
     */
    public void reset() {
        count = 0;
    }
    
    /**
     * Creates a newly allocated byte array. Its size is the current
     * size of this output stream and the valid contents of the buffer
     * have been copied into it.
     *
     * @return  the current contents of this output stream, as a byte array.
     */
    public byte[] toByteArray() {
        byte newbuf[] = new byte[count];
        System.arraycopy(buf, 0, newbuf, 0, count);
        return newbuf;
    }
    
    /**
     * Returns the current size of the buffer.
     *
     * @return the value of the <code>count</code> field, which is the number of valid bytes in this byte buffer.
     */
    public int size() {
        return count;
    }
    
    /**
     * Converts the buffer's contents into a string, translating bytes into
     * characters according to the platform's default character encoding.
     *
     * @return String translated from the buffer's contents.
     */
    public String toString() {
        return new String(buf, 0, count);
    }
    
    /**
     * Converts the buffer's contents into a string, translating bytes into
     * characters according to the specified character encoding.
     *
     * @param   enc  a character-encoding name.
     * @return String translated from the buffer's contents.
     * @throws UnsupportedEncodingException
     *         If the named encoding is not supported.
     */
    public String toString(String enc) throws UnsupportedEncodingException {
        return new String(buf, 0, count, enc);
    }
    
    /**
     * Writes the complete contents of this byte buffer output to
     * the specified output stream argument, as if by calling the output
     * stream's write method using <code>out.write(buf, 0, count)</code>.
     *
     * @param      out   the output stream to which to write the data.
     * @exception  IOException  if an I/O error occurs.
     */
    public void writeTo(OutputStream out) throws IOException {
        out.write(buf, 0, count);
    }
    
    public void write(int b) throws IOException {
        append((byte)b);
    }
    
    public void write(byte[] b, int off, int len) {
        append(b, off, len);
    }
    
    public byte[] getBuffer() {
        return buf;
    }
} /*
 *
 * Copyright 2003 Sivan Toledo
 *
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 */

/*
 * Comments by Sivan Toledo:
 * I created this class in order to add to iText the ability to utilize
 * OpenType fonts with CFF glyphs (these usually have an .otf extension).
 * The CFF font within the CFF table of the OT font might be either a CID
 * or a Type1 font. (CFF fonts may also contain multiple fonts; I do not
 * know if this is allowed in an OT table). The PDF spec, however, only
 * allow a CID font with an Identity-H or Identity-V encoding. Otherwise,
 * you are limited to an 8-bit encoding.
 * Adobe fonts come in both flavors. That is, the OTFs sometimes have
 * a CID CFF inside (for Japanese fonts), and sometimes a Type1 CFF
 * (virtually all the others, Latin/Greek/Cyrillic). So to easily use
 * all the glyphs in the latter, without creating multiple 8-bit encoding,
 * I wrote this class, whose main purpose is to convert a Type1 font inside
 * a CFF container (which might include other fonts) into a CID CFF font
 * that can be directly embeded in the PDF.
 *
 * Limitations of the current version:
 * 1. It does not extract a single CID font from a CFF that contains that
 *    particular CID along with other fonts. The Adobe Japanese OTF's that
 *    I have only have one font in the CFF table, so these can be
 *    embeded in the PDF as is.
 * 2. It does not yet subset fonts.
 * 3. It may or may not work on CFF fonts that are not within OTF's.
 *    I didn't try that. In any case, that would probably only be
 *    useful for subsetting CID fonts, not for CFF Type1 fonts (I don't
 *    think there are any available.
 * I plan to extend the class to support these three features at some
 * future time.
 */

package pdftk.com.lowagie.text.pdf;

/**
 * @author stoledo
 */

import java.util.Iterator;
import java.util.LinkedList;
import pdftk.com.lowagie.text.ExceptionConverter;

public class CFFFont {
    
    static final String operatorNames[] = {
        "version", "Notice", "FullName", "FamilyName",
        "Weight", "FontBBox", "BlueValues", "OtherBlues",
        "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW",
        "UNKNOWN_12", "UniqueID", "XUID", "charset",
        "Encoding", "CharStrings", "Private", "Subrs",
        "defaultWidthX", "nominalWidthX", "UNKNOWN_22", "UNKNOWN_23",
        "UNKNOWN_24", "UNKNOWN_25", "UNKNOWN_26", "UNKNOWN_27",
        "UNKNOWN_28", "UNKNOWN_29", "UNKNOWN_30", "UNKNOWN_31",
        "Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition",
        "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix",
        "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz",
        "StemSnapH", "StemSnapV", "ForceBold", "UNKNOWN_12_15",
        "UNKNOWN_12_16", "LanguageGroup", "ExpansionFactor", "initialRandomSeed",
        "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend",
        "UNKNOWN_12_24", "UNKNOWN_12_25", "UNKNOWN_12_26", "UNKNOWN_12_27",
        "UNKNOWN_12_28", "UNKNOWN_12_29", "ROS", "CIDFontVersion",
        "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase",
        "FDArray", "FDSelect", "FontName"
    };
    
    static final String standardStrings[] = {
        // Automatically generated from Appendix A of the CFF specification; do
        // not edit. Size should be 391.
        ".notdef", "space", "exclam", "quotedbl", "numbersign", "dollar",
        "percent", "ampersand", "quoteright", "parenleft", "parenright",
        "asterisk", "plus", "comma", "hyphen", "period", "slash", "zero", "one",
        "two", "three", "four", "five", "six", "seven", "eight", "nine", "colon",
        "semicolon", "less", "equal", "greater", "question", "at", "A", "B", "C",
        "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R",
        "S", "T", "U", "V", "W", "X", "Y", "Z", "bracketleft", "backslash",
        "bracketright", "asciicircum", "underscore", "quoteleft", "a", "b", "c",
        "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r",
        "s", "t", "u", "v", "w", "x", "y", "z", "braceleft", "bar", "braceright",
        "asciitilde", "exclamdown", "cent", "sterling", "fraction", "yen",
        "florin", "section", "currency", "quotesingle", "quotedblleft",
        "guillemotleft", "guilsinglleft", "guilsinglright", "fi", "fl", "endash",
        "dagger", "daggerdbl", "periodcentered", "paragraph", "bullet",
        "quotesinglbase", "quotedblbase", "quotedblright", "guillemotright",
        "ellipsis", "perthousand", "questiondown", "grave", "acute", "circumflex",
        "tilde", "macron", "breve", "dotaccent", "dieresis", "ring", "cedilla",
        "hungarumlaut", "ogonek", "caron", "emdash", "AE", "ordfeminine", "Lslash",
        "Oslash", "OE", "ordmasculine", "ae", "dotlessi", "lslash", "oslash", "oe",
        "germandbls", "onesuperior", "logicalnot", "mu", "trademark", "Eth",
        "onehalf", "plusminus", "Thorn", "onequarter", "divide", "brokenbar",
        "degree", "thorn", "threequarters", "twosuperior", "registered", "minus",
        "eth", "multiply", "threesuperior", "copyright", "Aacute", "Acircumflex",
        "Adieresis", "Agrave", "Aring", "Atilde", "Ccedilla", "Eacute",
        "Ecircumflex", "Edieresis", "Egrave", "Iacute", "Icircumflex", "Idieresis",
        "Igrave", "Ntilde", "Oacute", "Ocircumflex", "Odieresis", "Ograve",
        "Otilde", "Scaron", "Uacute", "Ucircumflex", "Udieresis", "Ugrave",
        "Yacute", "Ydieresis", "Zcaron", "aacute", "acircumflex", "adieresis",
        "agrave", "aring", "atilde", "ccedilla", "eacute", "ecircumflex",
        "edieresis", "egrave", "iacute", "icircumflex", "idieresis", "igrave",
        "ntilde", "oacute", "ocircumflex", "odieresis", "ograve", "otilde",
        "scaron", "uacute", "ucircumflex", "udieresis", "ugrave", "yacute",
        "ydieresis", "zcaron", "exclamsmall", "Hungarumlautsmall",
        "dollaroldstyle", "dollarsuperior", "ampersandsmall", "Acutesmall",
        "parenleftsuperior", "parenrightsuperior", "twodotenleader",
        "onedotenleader", "zerooldstyle", "oneoldstyle", "twooldstyle",
        "threeoldstyle", "fouroldstyle", "fiveoldstyle", "sixoldstyle",
        "sevenoldstyle", "eightoldstyle", "nineoldstyle", "commasuperior",
        "threequartersemdash", "periodsuperior", "questionsmall", "asuperior",
        "bsuperior", "centsuperior", "dsuperior", "esuperior", "isuperior",
        "lsuperior", "msuperior", "nsuperior", "osuperior", "rsuperior",
        "ssuperior", "tsuperior", "ff", "ffi", "ffl", "parenleftinferior",
        "parenrightinferior", "Circumflexsmall", "hyphensuperior", "Gravesmall",
        "Asmall", "Bsmall", "Csmall", "Dsmall", "Esmall", "Fsmall", "Gsmall",
        "Hsmall", "Ismall", "Jsmall", "Ksmall", "Lsmall", "Msmall", "Nsmall",
        "Osmall", "Psmall", "Qsmall", "Rsmall", "Ssmall", "Tsmall", "Usmall",
        "Vsmall", "Wsmall", "Xsmall", "Ysmall", "Zsmall", "colonmonetary",
        "onefitted", "rupiah", "Tildesmall", "exclamdownsmall", "centoldstyle",
        "Lslashsmall", "Scaronsmall", "Zcaronsmall", "Dieresissmall", "Brevesmall",
        "Caronsmall", "Dotaccentsmall", "Macronsmall", "figuredash",
        "hypheninferior", "Ogoneksmall", "Ringsmall", "Cedillasmall",
        "questiondownsmall", "oneeighth", "threeeighths", "fiveeighths",
        "seveneighths", "onethird", "twothirds", "zerosuperior", "foursuperior",
        "fivesuperior", "sixsuperior", "sevensuperior", "eightsuperior",
        "ninesuperior", "zeroinferior", "oneinferior", "twoinferior",
        "threeinferior", "fourinferior", "fiveinferior", "sixinferior",
        "seveninferior", "eightinferior", "nineinferior", "centinferior",
        "dollarinferior", "periodinferior", "commainferior", "Agravesmall",
        "Aacutesmall", "Acircumflexsmall", "Atildesmall", "Adieresissmall",
        "Aringsmall", "AEsmall", "Ccedillasmall", "Egravesmall", "Eacutesmall",
        "Ecircumflexsmall", "Edieresissmall", "Igravesmall", "Iacutesmall",
        "Icircumflexsmall", "Idieresissmall", "Ethsmall", "Ntildesmall",
        "Ogravesmall", "Oacutesmall", "Ocircumflexsmall", "Otildesmall",
        "Odieresissmall", "OEsmall", "Oslashsmall", "Ugravesmall", "Uacutesmall",
        "Ucircumflexsmall", "Udieresissmall", "Yacutesmall", "Thornsmall",
        "Ydieresissmall", "001.000", "001.001", "001.002", "001.003", "Black",
        "Bold", "Book", "Light", "Medium", "Regular", "Roman", "Semibold"
    };
    
    //private String[] strings;
    public String getString(char sid) {
        if (sid < standardStrings.length) return standardStrings[sid];
        if (sid >= standardStrings.length+(stringOffsets.length-1)) return null;
        int j = sid - standardStrings.length;
        //java.lang.System.err.println("going for "+j);
        int p = getPosition();
        seek(stringOffsets[j]);
        StringBuffer s = new StringBuffer();
        for (int k=stringOffsets[j]; k<stringOffsets[j+1]; k++) {
            s.append(getCard8());
        }
        seek(p);
        return s.toString();
    }
    
    char getCard8() {
        try {
            byte i = buf.readByte();
            return (char)(i & 0xff);
        }
        catch (Exception e) {
            throw new ExceptionConverter(e);
        }
    }
    
    char getCard16() {
        try {
            return buf.readChar();
        }
        catch (Exception e) {
            throw new ExceptionConverter(e);
        }
    }
    
    int getOffset(int offSize) {
        int offset = 0;
        for (int i=0; i<offSize; i++) {
            offset *= 256;
            offset += getCard8();
        }
        return offset;
    }
    
    void seek(int offset) {
        try {
            buf.seek(offset);
        }
        catch (Exception e) {
            throw new ExceptionConverter(e);
        }
    }
    
    short getShort() {
        try {
            return buf.readShort();
        }
        catch (Exception e) {
            throw new ExceptionConverter(e);
        }
    }
    
    int getInt() {
        try {
            return buf.readInt();
        }
        catch (Exception e) {
            throw new ExceptionConverter(e);
        }
    }
    
    int getPosition() {
        try {
            return buf.getFilePointer();
        }
        catch (Exception e) {
            throw new ExceptionConverter(e);
        }
    }
    int nextIndexOffset;
    // read the offsets in the next index
    // data structure, convert to global
    // offsets, and return them.
    // Sets the nextIndexOffset.
    int[] getIndex(int nextIndexOffset) {
        int count, indexOffSize;
        
        seek(nextIndexOffset);
        count = getCard16();
        int[] offsets = new int[count+1];
        
        if (count==0) {
            offsets[0] = -1;
            nextIndexOffset += 2;
            return offsets;
        }
        
        indexOffSize = getCard8();
        
        for (int j=0; j<=count; j++) {
        	//nextIndexOffset = ofset to relative segment
            offsets[j] = nextIndexOffset
			//2-> count in the index header. 1->offset size in index header
            + 2+1
			//offset array size * offset size 
            + (count+1)*indexOffSize
			//???zero <-> one base
            - 1
			// read object offset relative to object array base 
            + getOffset(indexOffSize);
        }
        //nextIndexOffset = offsets[count];
        return offsets;
    }
    
    protected String   key;
    protected Object[] args      = new Object[48];
    protected int      arg_count = 0;
    
    protected void getDictItem() {
        for (int i=0; i<arg_count; i++) args[i]=null;
        arg_count = 0;
        key = null;
        boolean gotKey = false;
        
        while (!gotKey) {
            char b0 = getCard8();
            if (b0 == 29) {
                int item = getInt();
                args[arg_count] = new Integer(item);
                arg_count++;
                //System.err.println(item+" ");
                continue;
            }
            if (b0 == 28) {
                short item = getShort();
                args[arg_count] = new Integer(item);
                arg_count++;
                //System.err.println(item+" ");
                continue;
            }
            if (b0 >= 32 && b0 <= 246) {
                byte item = (byte) (b0-139);
                args[arg_count] = new Integer(item);
                arg_count++;
                //System.err.println(item+" ");
                continue;
            }
            if (b0 >= 247 && b0 <= 250) {
                char b1 = getCard8();
                short item = (short) ((b0-247)*256+b1+108);
                args[arg_count] = new Integer(item);
                arg_count++;
                //System.err.println(item+" ");
                continue;
            }
            if (b0 >= 251 && b0 <= 254) {
                char b1 = getCard8();
                short item = (short) (-(b0-251)*256-b1-108);
                args[arg_count] = new Integer(item);
                arg_count++;
                //System.err.println(item+" ");
                continue;
            }
            if (b0 == 30) {
                String item = "";
                boolean done = false;
                char buffer = 0;
                byte avail = 0;
                int  nibble = 0;
                while (!done) {
                    // get a nibble
                    if (avail==0) { buffer = getCard8(); avail=2; }
                    if (avail==1) { nibble = (buffer / 16); avail--; }
                    if (avail==2) { nibble = (buffer % 16); avail--; }
                    switch (nibble) {
                        case 0xa: item += "." ; break;
                        case 0xb: item += "E" ; break;
                        case 0xc: item += "E-"; break;
                        case 0xe: item += "-" ; break;
                        case 0xf: done=true   ; break;
                        default:
                            if (nibble >= 0 && nibble <= 9)
                                item += String.valueOf(nibble);
                            else {
                                item += "<NIBBLE ERROR: "+String.valueOf(nibble)+">";
                                done = true;
                            }
                            break;
                    }
                }
                args[arg_count] = item;
                arg_count++;
                //System.err.println(" real=["+item+"]");
                continue;
            }
            if (b0 <= 21) {
                gotKey=true;
                if (b0 != 12) key = operatorNames[b0];
                else key = operatorNames[32 + getCard8()];
                //for (int i=0; i<arg_count; i++)
                //  System.err.print(args[i].toString()+" ");
                //System.err.println(key+" ;");
                continue;
            }
        }
    }
    
    /** List items for the linked list that builds the new CID font.
     */
    
    protected static abstract class Item {
        protected int myOffset = -1;
        /** remember the current offset and increment by item's size in bytes. */
        public void increment(int[] currentOffset) {
            myOffset = currentOffset[0];
        }
        /** Emit the byte stream for this item. */
        public void emit(byte[] buffer) {}
        /** Fix up cross references to this item (applies only to markers). */
        public void xref() {}
    }
    
    protected static abstract class OffsetItem extends Item {
        public int value;
        /** set the value of an offset item that was initially unknown.
         * It will be fixed up latex by a call to xref on some marker.
         */
        public void set(int offset) { this.value = offset; }
    }
    
    
    /** A range item.
     */
    
    protected static final class RangeItem extends Item {
        public int offset, length;
        private RandomAccessFileOrArray buf;
        public RangeItem(RandomAccessFileOrArray buf, int offset, int length) {
            this.offset = offset;
            this.length = length;
            this.buf = buf;
        }
        public void increment(int[] currentOffset) {
            super.increment(currentOffset);
            currentOffset[0] += length;
        }
        public void emit(byte[] buffer) {
            //System.err.println("range emit offset "+offset+" size="+length);
            try {
                buf.seek(offset);
                for (int i=myOffset; i<myOffset+length; i++)
                    buffer[i] = buf.readByte();
            }
            catch (Exception e) {
                throw new ExceptionConverter(e);
            }
            //System.err.println("finished range emit");
        }
    }
    
    /** An index-offset item for the list.
     * The size denotes the required size in the CFF. A positive
     * value means that we need a specific size in bytes (for offset arrays)
     * and a negative value means that this is a dict item that uses a
     * variable-size representation.
     */
    static protected final class IndexOffsetItem extends OffsetItem {
        public final int size;
        public IndexOffsetItem(int size, int value) {this.size=size; this.value=value;}
        public IndexOffsetItem(int size) {this.size=size; }
        
        public void increment(int[] currentOffset) {
            super.increment(currentOffset);
            currentOffset[0] += size;
        }
        public void emit(byte[] buffer) {
            int i=0;
            switch (size) {
                case 4:
                    buffer[myOffset+i] = (byte) ((value >>> 24) & 0xff);
                    i++;
                case 3:
                    buffer[myOffset+i] = (byte) ((value >>> 16) & 0xff);
                    i++;
                case 2:
                    buffer[myOffset+i] = (byte) ((value >>>  8) & 0xff);
                    i++;
                case 1:
                    buffer[myOffset+i] = (byte) ((value >>>  0) & 0xff);
                    i++;
            }
            /*
            int mask = 0xff;
            for (int i=size-1; i>=0; i--) {
                buffer[myOffset+i] = (byte) (value & mask);
                mask <<= 8;
            }
             */
        }
    }
    
    static protected final class IndexBaseItem extends Item {
        public IndexBaseItem() {}
    }
    
    static protected final class IndexMarkerItem extends Item {
        private OffsetItem offItem;
        private IndexBaseItem indexBase;
        public IndexMarkerItem(OffsetItem offItem, IndexBaseItem indexBase) {
            this.offItem   = offItem;
            this.indexBase = indexBase;
        }
        public void xref() {
            //System.err.println("index marker item, base="+indexBase.myOffset+" my="+this.myOffset);
            offItem.set(this.myOffset-indexBase.myOffset+1);
        }
    }
    /**
     * 
     * @author orly manor
     *
     * TODO To change the template for this generated type comment go to
     * Window - Preferences - Java - Code Generation - Code and Comments
     */
    static protected final class SubrMarkerItem extends Item {
        private OffsetItem offItem;
        private IndexBaseItem indexBase;
        public SubrMarkerItem(OffsetItem offItem, IndexBaseItem indexBase) {
            this.offItem   = offItem;
            this.indexBase = indexBase;
        }
        public void xref() {
            //System.err.println("index marker item, base="+indexBase.myOffset+" my="+this.myOffset);
            offItem.set(this.myOffset-indexBase.myOffset);
        }
    }
    
    
    /** an unknown offset in a dictionary for the list.
     * We will fix up the offset later; for now, assume it's large.
     */
    static protected final class DictOffsetItem extends OffsetItem {
        public final int size;
        public DictOffsetItem() {this.size=5; }
        
        public void increment(int[] currentOffset) {
            super.increment(currentOffset);
            currentOffset[0] += size;
        }
        // this is incomplete!
        public void emit(byte[] buffer) {
            if (size==5) {
                buffer[myOffset]   = 29;
                buffer[myOffset+1] = (byte) ((value >>> 24) & 0xff);
                buffer[myOffset+2] = (byte) ((value >>> 16) & 0xff);
                buffer[myOffset+3] = (byte) ((value >>>  8) & 0xff);
                buffer[myOffset+4] = (byte) ((value >>>  0) & 0xff);
            }
        }
    }
    
	/** Card24 item.
     */
    
    static protected final class UInt24Item extends Item {
        public int value;
        public UInt24Item(int value) {this.value=value;}
        
        public void increment(int[] currentOffset) {
            super.increment(currentOffset);
            currentOffset[0] += 3;
        }
        // this is incomplete!
        public void emit(byte[] buffer) {
        	buffer[myOffset+0] = (byte) ((value >>> 16) & 0xff);
            buffer[myOffset+1] = (byte) ((value >>> 8) & 0xff);
            buffer[myOffset+2] = (byte) ((value >>> 0) & 0xff);
        }
    }
    
    /** Card32 item.
     */
    
    static protected final class UInt32Item extends Item {
        public int value;
        public UInt32Item(int value) {this.value=value;}
        
        public void increment(int[] currentOffset) {
            super.increment(currentOffset);
            currentOffset[0] += 4;
        }
        // this is incomplete!
        public void emit(byte[] buffer) {
        	buffer[myOffset+0] = (byte) ((value >>> 24) & 0xff);
        	buffer[myOffset+1] = (byte) ((value >>> 16) & 0xff);
            buffer[myOffset+2] = (byte) ((value >>> 8) & 0xff);
            buffer[myOffset+3] = (byte) ((value >>> 0) & 0xff);
        }
    }

    /** A SID or Card16 item.
     */
    
    static protected final class UInt16Item extends Item {
        public char value;
        public UInt16Item(char value) {this.value=value;}
        
        public void increment(int[] currentOffset) {
            super.increment(currentOffset);
            currentOffset[0] += 2;
        }
        // this is incomplete!
        public void emit(byte[] buffer) {
            buffer[myOffset+0] = (byte) ((value >>> 8) & 0xff);
            buffer[myOffset+1] = (byte) ((value >>> 0) & 0xff);
        }
    }
    
    /** A Card8 item.
     */
    
    static protected final class UInt8Item extends Item {
        public char value;
        public UInt8Item(char value) {this.value=value;}
        
        public void increment(int[] currentOffset) {
            super.increment(currentOffset);
            currentOffset[0] += 1;
        }
        // this is incomplete!
        public void emit(byte[] buffer) {
            buffer[myOffset+0] = (byte) ((value >>> 0) & 0xff);
        }
    }
    
    static protected final class StringItem extends Item {
        public String s;
        public StringItem(String s) {this.s=s;}
        
        public void increment(int[] currentOffset) {
            super.increment(currentOffset);
            currentOffset[0] += s.length();
        }
        public void emit(byte[] buffer) {
            for (int i=0; i<s.length(); i++)
                buffer[myOffset+i] = (byte) (s.charAt(i) & 0xff);
        }
    }
    
    
    /** A dictionary number on the list.
     * This implementation is inefficient: it doesn't use the variable-length
     * representation.
     */
    
    static protected final class DictNumberItem extends Item {
        public final int value;
        public int size = 5;
        public DictNumberItem(int value) {this.value=value;}
        public void increment(int[] currentOffset) {
            super.increment(currentOffset);
            currentOffset[0] += size;
        }
        // this is imcomplete!
        public void emit(byte[] buffer) {
            if (size==5) {
                buffer[myOffset]   = 29;
                buffer[myOffset+1] = (byte) ((value >>> 24) & 0xff);
                buffer[myOffset+2] = (byte) ((value >>> 16) & 0xff);
                buffer[myOffset+3] = (byte) ((value >>>  8) & 0xff);
                buffer[myOffset+4] = (byte) ((value >>>  0) & 0xff);
            }
        }
    }
    
    /** An offset-marker item for the list.
     * It is used to mark an offset and to set the offset list item.
     */
    
    static protected final class MarkerItem extends Item {
        OffsetItem p;
        public MarkerItem(OffsetItem pointerToMarker) {p=pointerToMarker;}
        public void xref() {
            p.set(this.myOffset);
        }
    }
    
    /** a utility that creates a range item for an entire index
     *
     * @param indexOffset where the index is
     * @return a range item representing the entire index
     */
    
    protected RangeItem getEntireIndexRange(int indexOffset) {
        seek(indexOffset);
        int count = getCard16();
        if (count==0) {
            return new RangeItem(buf,indexOffset,2);
        } else {
            int indexOffSize = getCard8();
            seek(indexOffset+2+1+count*indexOffSize);
            int size = getOffset(indexOffSize)-1;
            return new RangeItem(buf,indexOffset,
            2+1+(count+1)*indexOffSize+size);
        }
    }
    
    
    /** get a single CID font. The PDF architecture (1.4)
     * supports 16-bit strings only with CID CFF fonts, not
     * in Type-1 CFF fonts, so we convert the font to CID if
     * it is in the Type-1 format.
     * Two other tasks that we need to do are to select
     * only a single font from the CFF package (this again is
     * a PDF restriction) and to subset the CharStrings glyph
     * description.
     */
    
    
    public byte[] getCID(String fontName)
    //throws java.io.FileNotFoundException
    {
        int j;
        for (j=0; j<fonts.length; j++)
            if (fontName.equals(fonts[j].name)) break;
        if (j==fonts.length) return null;
        
        LinkedList l = new LinkedList();
        
        // copy the header
        
        seek(0);
        
        // ssteward omit: int major = getCard8();
        // ssteward omit: int minor = getCard8();
        int hdrSize = getCard8();
        // ssteward omit: int offSize = getCard8();
        nextIndexOffset = hdrSize;
        
        l.addLast(new RangeItem(buf,0,hdrSize));
        
        int nglyphs=-1, nstrings=-1;
        if ( ! fonts[j].isCID ) {
            // count the glyphs
            seek(fonts[j].charstringsOffset);
            nglyphs = getCard16();
            seek(stringIndexOffset);
            nstrings = getCard16()+standardStrings.length;
            //System.err.println("number of glyphs = "+nglyphs);
        }
        
        // create a name index
        
        l.addLast(new UInt16Item((char)1)); // count
        l.addLast(new UInt8Item((char)1)); // offSize
        l.addLast(new UInt8Item((char)1)); // first offset
        l.addLast(new UInt8Item((char)( 1+fonts[j].name.length() )));
        l.addLast(new StringItem(fonts[j].name));
        
        // create the topdict Index
        
        
        l.addLast(new UInt16Item((char)1)); // count
        l.addLast(new UInt8Item((char)2)); // offSize
        l.addLast(new UInt16Item((char)1)); // first offset
        OffsetItem topdictIndex1Ref = new IndexOffsetItem(2);
        l.addLast(topdictIndex1Ref);
        IndexBaseItem topdictBase = new IndexBaseItem();
        l.addLast(topdictBase);
        
        /*
        int maxTopdictLen = (topdictOffsets[j+1]-topdictOffsets[j])
                            + 9*2 // at most 9 new keys
                            + 8*5 // 8 new integer arguments
                            + 3*2;// 3 new SID arguments
         */
        
        //int    topdictNext = 0;
        //byte[] topdict = new byte[maxTopdictLen];
        
        OffsetItem charsetRef     = new DictOffsetItem();
        OffsetItem charstringsRef = new DictOffsetItem();
        OffsetItem fdarrayRef     = new DictOffsetItem();
        OffsetItem fdselectRef    = new DictOffsetItem();
        
        if ( !fonts[j].isCID ) {
            // create a ROS key
            l.addLast(new DictNumberItem(nstrings));
            l.addLast(new DictNumberItem(nstrings+1));
            l.addLast(new DictNumberItem(0));
            l.addLast(new UInt8Item((char)12));
            l.addLast(new UInt8Item((char)30));
            // create a CIDCount key
            l.addLast(new DictNumberItem(nglyphs));
            l.addLast(new UInt8Item((char)12));
            l.addLast(new UInt8Item((char)34));
            // What about UIDBase (12,35)? Don't know what is it.
            // I don't think we need FontName; the font I looked at didn't have it.
        }
        
        // create an FDArray key
        l.addLast(fdarrayRef);
        l.addLast(new UInt8Item((char)12));
        l.addLast(new UInt8Item((char)36));
        // create an FDSelect key
        l.addLast(fdselectRef);
        l.addLast(new UInt8Item((char)12));
        l.addLast(new UInt8Item((char)37));
        // create an charset key
        l.addLast(charsetRef);
        l.addLast(new UInt8Item((char)15));
        // create a CharStrings key
        l.addLast(charstringsRef);
        l.addLast(new UInt8Item((char)17));
        
        seek(topdictOffsets[j]);
        while (getPosition() < topdictOffsets[j+1]) {
            int p1 = getPosition();
            getDictItem();
            int p2 = getPosition();
            if (key=="Encoding"
            || key=="Private"
            || key=="FDSelect"
            || key=="FDArray"
            || key=="charset"
            || key=="CharStrings"
            ) {
                // just drop them
            } else {
                l.add(new RangeItem(buf,p1,p2-p1));
            }
        }
        
        l.addLast(new IndexMarkerItem(topdictIndex1Ref,topdictBase));
        
        // Copy the string index and append new strings.
        // We need 3 more strings: Registry, Ordering, and a FontName for one FD.
        // The total length is at most "Adobe"+"Identity"+63 = 76
        
        if (fonts[j].isCID) {
            l.addLast(getEntireIndexRange(stringIndexOffset));
        } else {
            String fdFontName = fonts[j].name+"-OneRange";
            if (fdFontName.length() > 127)
                fdFontName = fdFontName.substring(0,127);
            String extraStrings = "Adobe"+"Identity"+fdFontName;
            
            int origStringsLen = stringOffsets[stringOffsets.length-1]
            - stringOffsets[0];
            int stringsBaseOffset = stringOffsets[0]-1;
            
            byte stringsIndexOffSize;
            if (origStringsLen+extraStrings.length() <= 0xff) stringsIndexOffSize = 1;
            else if (origStringsLen+extraStrings.length() <= 0xffff) stringsIndexOffSize = 2;
            else if (origStringsLen+extraStrings.length() <= 0xffffff) stringsIndexOffSize = 3;
            else stringsIndexOffSize = 4;
            
            l.addLast(new UInt16Item((char)((stringOffsets.length-1)+3))); // count
            l.addLast(new UInt8Item((char)stringsIndexOffSize)); // offSize
            for (int i=0; i<stringOffsets.length; i++)
                l.addLast(new IndexOffsetItem(stringsIndexOffSize,
                stringOffsets[i]-stringsBaseOffset));
            int currentStringsOffset = stringOffsets[stringOffsets.length-1]
            - stringsBaseOffset;
            //l.addLast(new IndexOffsetItem(stringsIndexOffSize,currentStringsOffset));
            currentStringsOffset += ("Adobe").length();
            l.addLast(new IndexOffsetItem(stringsIndexOffSize,currentStringsOffset));
            currentStringsOffset += ("Identity").length();
            l.addLast(new IndexOffsetItem(stringsIndexOffSize,currentStringsOffset));
            currentStringsOffset += fdFontName.length();
            l.addLast(new IndexOffsetItem(stringsIndexOffSize,currentStringsOffset));
            
            l.addLast(new RangeItem(buf,stringOffsets[0],origStringsLen));
            l.addLast(new StringItem(extraStrings));
        }
        
        // copy the global subroutine index
        
        l.addLast(getEntireIndexRange(gsubrIndexOffset));
        
        // deal with fdarray, fdselect, and the font descriptors
        
        if (fonts[j].isCID) {
            // copy the FDArray, FDSelect, charset
        } else {
            // create FDSelect
            l.addLast(new MarkerItem(fdselectRef));
            l.addLast(new UInt8Item((char)3)); // format identifier
            l.addLast(new UInt16Item((char)1)); // nRanges
            
            l.addLast(new UInt16Item((char)0)); // Range[0].firstGlyph
            l.addLast(new UInt8Item((char)0)); // Range[0].fd
            
            l.addLast(new UInt16Item((char)nglyphs)); // sentinel
            
            // recreate a new charset
            // This format is suitable only for fonts without subsetting
            
            l.addLast(new MarkerItem(charsetRef));
            l.addLast(new UInt8Item((char)2)); // format identifier
            
            l.addLast(new UInt16Item((char)1)); // first glyph in range (ignore .notdef)
            l.addLast(new UInt16Item((char)(nglyphs-1))); // nLeft
            // now all are covered, the data structure is complete.
            
            // create a font dict index (fdarray)
            
            l.addLast(new MarkerItem(fdarrayRef));
            l.addLast(new UInt16Item((char)1));
            l.addLast(new UInt8Item((char)1)); // offSize
            l.addLast(new UInt8Item((char)1)); // first offset
            
            OffsetItem privateIndex1Ref = new IndexOffsetItem(1);
            l.addLast(privateIndex1Ref);
            IndexBaseItem privateBase = new IndexBaseItem();
            l.addLast(privateBase);
            
            // looking at the PS that acrobat generates from a PDF with
            // a CFF opentype font embeded with an identity-H encoding,
            // it seems that it does not need a FontName.
            //l.addLast(new DictNumberItem((standardStrings.length+(stringOffsets.length-1)+2)));
            //l.addLast(new UInt8Item((char)12));
            //l.addLast(new UInt8Item((char)38)); // FontName
            
            l.addLast(new DictNumberItem(fonts[j].privateLength));
            OffsetItem privateRef = new DictOffsetItem();
            l.addLast(privateRef);
            l.addLast(new UInt8Item((char)18)); // Private
            
            l.addLast(new IndexMarkerItem(privateIndex1Ref,privateBase));
            
            // copy the private index & local subroutines
            
            l.addLast(new MarkerItem(privateRef));
            // copy the private dict and the local subroutines.
            // the length of the private dict seems to NOT include
            // the local subroutines.
            l.addLast(new RangeItem(buf,fonts[j].privateOffset,fonts[j].privateLength));
            if (fonts[j].privateSubrs >= 0) {
                //System.err.println("has subrs="+fonts[j].privateSubrs+" ,len="+fonts[j].privateLength);
                l.addLast(getEntireIndexRange(fonts[j].privateSubrs));
            }
        }
        
        // copy the charstring index
        
        l.addLast(new MarkerItem(charstringsRef));
        l.addLast(getEntireIndexRange(fonts[j].charstringsOffset));
        
        // now create the new CFF font
        
        int[] currentOffset = new int[1];
        currentOffset[0] = 0;
        
        Iterator listIter = l.iterator();
        while ( listIter.hasNext() ) {
            Item item = (Item) listIter.next();
            item.increment(currentOffset);
        }
        
        listIter = l.iterator();
        while ( listIter.hasNext() ) {
            Item item = (Item) listIter.next();
            item.xref();
        }
        
        int size = currentOffset[0];
        byte[] b = new byte[size];
        
        listIter = l.iterator();
        while ( listIter.hasNext() ) {
            Item item = (Item) listIter.next();
            item.emit(b);
        }
        
        return b;
    }
    
    
    public boolean isCID(String fontName) {
        int j;
        for (j=0; j<fonts.length; j++)
            if (fontName.equals(fonts[j].name)) return fonts[j].isCID;
        return false;
    }
    
    public boolean exists(String fontName) {
        int j;
        for (j=0; j<fonts.length; j++)
            if (fontName.equals(fonts[j].name)) return true;
        return false;
    }
    
    
    public String[] getNames() {
        String[] names = new String[ fonts.length ];
        for (int i=0; i<fonts.length; i++)
            names[i] = fonts[i].name;
        return names;
    }
    /**
     * A random Access File or an array
     * (contributed by orly manor)
     */
    protected RandomAccessFileOrArray buf;
    
    protected int nameIndexOffset;
    protected int topdictIndexOffset;
    protected int stringIndexOffset;
    protected int gsubrIndexOffset;
    protected int[] nameOffsets;
    protected int[] topdictOffsets;
    protected int[] stringOffsets;
    protected int[] gsubrOffsets;
    
    /**
     * @author orly manor
     * TODO Changed from private to protected by Ygal&Oren
     */
    protected final class Font {
        public String    name;
        public String    fullName;
        public boolean   isCID = false;
        public int       privateOffset     = -1; // only if not CID
        public int       privateLength     = -1; // only if not CID
        public int       privateSubrs      = -1;
        public int       charstringsOffset = -1;
        public int       encodingOffset    = -1;
        public int       charsetOffset     = -1;
        public int       fdarrayOffset     = -1; // only if CID
        public int       fdselectOffset    = -1; // only if CID
        public int[]     fdprivateOffsets;
        public int[]     fdprivateLengths;
        public int[]     fdprivateSubrs;
        
        // Added by Oren & Ygal
        public int nglyphs;
        public int nstrings;
        public int CharsetLength;
        public int[]    charstringsOffsets;
        public int[]    charset;
        public int[] 	FDSelect;
        public int FDSelectLength;
        public int FDSelectFormat;
        public int 		CharstringType = 2;
        public int FDArrayCount;
        public int FDArrayOffsize;
        public int[] FDArrayOffsets;
        public int[] PrivateSubrsOffset;
        public int[][] PrivateSubrsOffsetsArray;
        public int[]       SubrsOffsets;
    }
    // Changed from private to protected by Ygal&Oren
    protected Font[] fonts;
    
    public CFFFont(RandomAccessFileOrArray inputbuffer) {
        
        //System.err.println("CFF: nStdString = "+standardStrings.length);
        buf = inputbuffer;
        seek(0);
        
        // ssteward omit: int major = getCard8();
        // ssteward omit: int minor = getCard8();
        
        //System.err.println("CFF Major-Minor = "+major+"-"+minor);
        
        int hdrSize = getCard8();
	// ssteward omit: int offSize = getCard8();
        
        //System.err.println("offSize = "+offSize);
        
        //int count, indexOffSize, indexOffset, nextOffset;
        
        nameIndexOffset    = hdrSize;
        nameOffsets        = getIndex(nameIndexOffset);
        topdictIndexOffset = nameOffsets[nameOffsets.length-1];
        topdictOffsets     = getIndex(topdictIndexOffset);
        stringIndexOffset  = topdictOffsets[topdictOffsets.length-1];
        stringOffsets      = getIndex(stringIndexOffset);
        gsubrIndexOffset   = stringOffsets[stringOffsets.length-1];
        gsubrOffsets       = getIndex(gsubrIndexOffset);
        
        fonts = new Font[nameOffsets.length-1];
        
        // now get the name index
        
        /*
        names             = new String[nfonts];
        privateOffset     = new int[nfonts];
        charsetOffset     = new int[nfonts];
        encodingOffset    = new int[nfonts];
        charstringsOffset = new int[nfonts];
        fdarrayOffset     = new int[nfonts];
        fdselectOffset    = new int[nfonts];
         */
        
        for (int j=0; j<nameOffsets.length-1; j++) {
            fonts[j] = new Font();
            seek(nameOffsets[j]);
            fonts[j].name = "";
            for (int k=nameOffsets[j]; k<nameOffsets[j+1]; k++) {
                fonts[j].name += (char)getCard8();
            }
            //System.err.println("name["+j+"]=<"+fonts[j].name+">");
        }
        
        // string index
        
        //strings = new String[stringOffsets.length-1];
        /*
        System.err.println("std strings = "+standardStrings.length);
        System.err.println("fnt strings = "+(stringOffsets.length-1));
        for (char j=0; j<standardStrings.length+(stringOffsets.length-1); j++) {
            //seek(stringOffsets[j]);
            //strings[j] = "";
            //for (int k=stringOffsets[j]; k<stringOffsets[j+1]; k++) {
            //	strings[j] += (char)getCard8();
            //}
            System.err.println("j="+(int)j+" <? "+(standardStrings.length+(stringOffsets.length-1)));
            System.err.println("strings["+(int)j+"]=<"+getString(j)+">");
        }
         */
        
        // top dict
        
        for (int j=0; j<topdictOffsets.length-1; j++) {
            seek(topdictOffsets[j]);
            while (getPosition() < topdictOffsets[j+1]) {            	
                getDictItem();
                if (key=="FullName") {
                    //System.err.println("getting fullname sid = "+((Integer)args[0]).intValue());
                    fonts[j].fullName = getString((char)((Integer)args[0]).intValue());
                    //System.err.println("got it");
                } else if (key=="ROS")
                    fonts[j].isCID = true;
                else if (key=="Private") {
                    fonts[j].privateLength  = ((Integer)args[0]).intValue();
                    fonts[j].privateOffset  = ((Integer)args[1]).intValue();
                }
                else if (key=="charset"){
                    fonts[j].charsetOffset = ((Integer)args[0]).intValue();
                    
                }
                else if (key=="Encoding"){
                    fonts[j].encodingOffset = ((Integer)args[0]).intValue();
                    ReadEncoding(fonts[j].encodingOffset);
                }
                else if (key=="CharStrings") {
                    fonts[j].charstringsOffset = ((Integer)args[0]).intValue();
                    //System.err.println("charstrings "+fonts[j].charstringsOffset);
                    // Added by Oren & Ygal
                    int p = getPosition();
                    fonts[j].charstringsOffsets = getIndex(fonts[j].charstringsOffset);
                    seek(p);
                } else if (key=="FDArray")
                    fonts[j].fdarrayOffset = ((Integer)args[0]).intValue();
                else if (key=="FDSelect")
                    fonts[j].fdselectOffset = ((Integer)args[0]).intValue();
                else if (key=="CharstringType")
                	fonts[j].CharstringType = ((Integer)args[0]).intValue();
            }
            
            // private dict
            if (fonts[j].privateOffset >= 0) {
                //System.err.println("PRIVATE::");
                seek(fonts[j].privateOffset);
                while (getPosition() < fonts[j].privateOffset+fonts[j].privateLength) {
                    getDictItem();
                    if (key=="Subrs")
                    	//Add the private offset to the lsubrs since the offset is 
                    	// relative to the begining of the PrivateDict
                        fonts[j].privateSubrs = ((Integer)args[0]).intValue()+fonts[j].privateOffset;
                }
            }
            
            // fdarray index
            if (fonts[j].fdarrayOffset >= 0) {
                int[] fdarrayOffsets = getIndex(fonts[j].fdarrayOffset);
                
                fonts[j].fdprivateOffsets = new int[fdarrayOffsets.length-1];
                fonts[j].fdprivateLengths = new int[fdarrayOffsets.length-1];
                
                //System.err.println("FD Font::");
                
                for (int k=0; k<fdarrayOffsets.length-1; k++) {
                    seek(fdarrayOffsets[k]);
                    while (getPosition() < fdarrayOffsets[k+1])
                        getDictItem();
                    if (key=="Private") {
                        fonts[j].fdprivateLengths[k]  = ((Integer)args[0]).intValue();
                        fonts[j].fdprivateOffsets[k]  = ((Integer)args[1]).intValue();
                    }
                    
                }
            }
        }
        //System.err.println("CFF: done");
    }
    
    // ADDED BY Oren & Ygal
    
    void ReadEncoding(int nextIndexOffset){
    	seek(nextIndexOffset);
    	// ssteward omit: int format = getCard8();
    }    
} /*
 * $Id: CFFFontSubset.java,v 1.3 2005/02/17 09:20:54 blowagie Exp $
 * $Name:  $
 *
 * Copyright 2004 Oren Manor and Ygal Blum
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999-2005 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000-2005 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */
package pdftk.com.lowagie.text.pdf;

import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.ArrayList;
import java.io.*;

/**
 * This Class subsets a CFF Type Font. The subset is preformed for CID fonts and NON CID fonts.
 * The Charstring is subseted for both types. For CID fonts only the FDArray which are used are embedded. 
 * The Lsubroutines of the FDArrays used are subsetted as well. The Subroutine subset supports both Type1 and Type2
 * formatting altough only tested on Type2 Format.
 * For Non CID the Lsubroutines are subsetted. On both types the Gsubroutines is subsetted. 
 * A font which was not of CID type is transformed into CID as a part of the subset process. 
 * The CID synthetic creation was written by Sivan Toledo <sivan@math.tau.ac.il> 
 * @author Oren Manor <manorore@post.tau.ac.il> & Ygal Blum <blumygal@post.tau.ac.il>
 */
public class CFFFontSubset extends CFFFont {
	
	/**
	 *  The Strings in this array represent Type1/Type2 operator names
	 */
	static final String SubrsFunctions[] = {
			"RESERVED_0","hstem","RESERVED_2","vstem","vmoveto","rlineto","hlineto","vlineto",
			"rrcurveto","RESERVED_9","callsubr","return","escape","RESERVED_13",
			"endchar","RESERVED_15","RESERVED_16","RESERVED_17","hstemhm","hintmask",
			"cntrmask","rmoveto","hmoveto","vstemhm","rcurveline","rlinecurve","vvcurveto",
			"hhcurveto","shortint","callgsubr","vhcurveto","hvcurveto"
			};
	/**
	 * The Strings in this array represent Type1/Type2 escape operator names
	 */
	static final String SubrsEscapeFuncs[] = {
			"RESERVED_0","RESERVED_1","RESERVED_2","and","or","not","RESERVED_6",
			"RESERVED_7","RESERVED_8","abs","add","sub","div","RESERVED_13","neg",
			"eq","RESERVED_16","RESERVED_17","drop","RESERVED_19","put","get","ifelse",
			"random","mul","RESERVED_25","sqrt","dup","exch","index","roll","RESERVED_31",
			"RESERVED_32","RESERVED_33","hflex","flex","hflex1","flex1","RESERVED_REST"
	};
	
	/**
	 * A HashMap containing the glyphs used in the text after being converted
	 * to glyph number by the CMap 
	 */
	HashMap GlyphsUsed = null;
	/**
	 * The GlyphsUsed keys as an ArrayList
	 */
	ArrayList glyphsInList = null;
	/**
	 * A HashMap for keeping the FDArrays being used by the font
	 */
	HashMap FDArrayUsed = new HashMap();
	/**
	 * A HashMaps array for keeping the subroutines used in each FontDict
	 */
	HashMap[] hSubrsUsed = null;
	/**
	 * The SubroutinesUsed HashMaps as ArrayLists
	 */
	ArrayList[] lSubrsUsed = null;
	/**
	 * A HashMap for keeping the Global subroutines used in the font
	 */
	HashMap hGSubrsUsed  = new HashMap();
	/**
	 * The Global SubroutinesUsed HashMaps as ArrayLists
	 */
	ArrayList lGSubrsUsed = new ArrayList();
	/**
	 * A HashMap for keeping the subroutines used in a non-cid font
	 */
	HashMap hSubrsUsedNonCID  = new HashMap();
	/**
	 * The SubroutinesUsed HashMap as ArrayList
	 */
	ArrayList lSubrsUsedNonCID = new ArrayList();
	/**
	 * An array of the new Indexs for the local Subr. One index for each FontDict
	 */
	byte[][] NewLSubrsIndex = null;
	/**
	 * The new subroutines index for a non-cid font
	 */
	byte[] NewSubrsIndexNonCID = null;
	/**
	 * The new global subroutines index of the font
	 */
	byte[] NewGSubrsIndex = null;
	/**
	 * The new CharString of the font
	 */
	byte[] NewCharStringsIndex = null;
	
	/**
	 * The bias for the global subroutines
	 */
	int GBias = 0;
	
	/**
	 * The linked list for generating the new font stream
	 */
	LinkedList OutputList = null;
	
	/**
	 * Number of arguments to the stem operators in a subroutine calculated recursivly
	 */
	int NumOfHints = 0;

	
	/**	 
	 * C'tor for CFFFontSubset
	 * @param rf - The font file
	 * @param GlyphsUsed - a HashMap that contains the glyph used in the subset 
	 */
    public CFFFontSubset(RandomAccessFileOrArray rf,HashMap GlyphsUsed){
		// Use CFFFont c'tor in order to parse the font file.
    	super(rf);
		this.GlyphsUsed = GlyphsUsed;
		//Put the glyphs into a list
		glyphsInList = new ArrayList(GlyphsUsed.keySet());
		
		
		for (int i=0;i<fonts.length;++i)
		{
			// Read the number of glyphs in the font
			seek(fonts[i].charstringsOffset);
	        fonts[i].nglyphs = getCard16();
	        
	    	// Jump to the count field of the String Index
	        seek(stringIndexOffset);
	        fonts[i].nstrings = getCard16()+standardStrings.length;
	        
	        // For each font save the offset array of the charstring
			fonts[i].charstringsOffsets = getIndex(fonts[i].charstringsOffset);
			
			// Proces the FDSelect if exist 
			if (fonts[i].fdselectOffset>=0)
			{
				// Proces the FDSelect
	            readFDSelect(i);
	            // Build the FDArrayUsed hashmap
            	BuildFDArrayUsed(i);
			}
			if (fonts[i].isCID)
				// Build the FD Array used Hash Map
				ReadFDArray(i);
			// compute the charset length 
			fonts[i].CharsetLength = CountCharset(fonts[i].charsetOffset,fonts[i].nglyphs);
		}
	}

    /**
     * Calculates the length of the charset according to its format
     * @param Offset The Charset Offset
     * @param NumofGlyphs Number of glyphs in the font
     * @return the length of the Charset
     */
    int CountCharset(int Offset,int NumofGlyphs){
    	int format;
    	int Length=0;
    	seek(Offset);
    	// Read the format
    	format = getCard8();
    	// Calc according to format
    	switch (format){
    		case 0:
    			Length = 1+2*NumofGlyphs;
    			break;
    		case 1:
    			Length = 1+3*CountRange(NumofGlyphs,1);
    			break;
    		case 2:
    			Length = 1+4*CountRange(NumofGlyphs,2);
    			break;
    		default:
    			break;
    	}
    	return Length;
    }
    
    /**
     * Function calculates the number of ranges in the Charset
     * @param NumofGlyphs The number of glyphs in the font
     * @param Type The format of the Charset
     * @return The number of ranges in the Charset data structure
     */
    int CountRange(int NumofGlyphs,int Type){
    	int num=0;
    	// ssteward: int i=1,Sid,nLeft;
    	int i=1,nLeft;
    	while (i<NumofGlyphs){
    		num++;
    		// ssteward omit: Sid = getCard16();
    		if (Type==1)
    			nLeft = getCard8();
    		else
    			nLeft = getCard16();
    		i += nLeft+1;
    	}
    	return num;
    }


	/**
	 * Read the FDSelect of the font and compute the array and its length
	 * @param Font The index of the font being processed
	 * @return The Processed FDSelect of the font
	 */
	protected void readFDSelect(int Font)
	{
		// Restore the number of glyphs
		int NumOfGlyphs = fonts[Font].nglyphs;
		int[] FDSelect = new int[NumOfGlyphs];
		// Go to the beginning of the FDSelect
		seek(fonts[Font].fdselectOffset);
		// Read the FDSelect's format
		fonts[Font].FDSelectFormat = getCard8();
		
		switch(fonts[Font].FDSelectFormat){
			// Format==0 means each glyph has an entry that indicated
			// its FD.
			case 0:
				for (int i=0;i<NumOfGlyphs;i++)
				{
					FDSelect[i] = getCard8();
				}
				// The FDSelect's Length is one for each glyph + the format
				// for later use
				fonts[Font].FDSelectLength = fonts[Font].nglyphs+1;
				break;
			case 3:
				// Format==3 means the ranges version
				// The number of ranges
				int nRanges = getCard16();
				int l=0;
				// Read the first in the first range
				int first = getCard16();
				for (int i=0;i<nRanges;i++)
				{
					// Read the FD index
					int fd = getCard8();
					// Read the first of the next range
					int last = getCard16();
					// Calc the steps and write to the array
					int steps = last-first;
					for (int k=0;k<steps;k++)
					{
						FDSelect[l] = fd;
						l++;
					}
					// The last from this iteration is the first of the next
					first = last;
				}
				// Store the length for later use
				fonts[Font].FDSelectLength = 1+2+nRanges*3+2;
				break;
			default:
				break;
		}
		// Save the FDSelect of the font 
		fonts[Font].FDSelect = FDSelect; 
	}
	
	/**
	 * Function reads the FDSelect and builds the FDArrayUsed HashMap According to the glyphs used
	 * @param Font the Number of font being processed
	 */
	protected void BuildFDArrayUsed(int Font)
	{
		int[] FDSelect = fonts[Font].FDSelect;
		// For each glyph used
		for (int i=0;i<glyphsInList.size();i++)
		{
			// Pop the glyphs index
			int glyph = ((Integer)glyphsInList.get(i)).intValue();
			// Pop the glyph's FD
			int FD = FDSelect[glyph];
			// Put the FD index into the FDArrayUsed HashMap
			FDArrayUsed.put(new Integer(FD),null);
		}
	}

	/**
	 * Read the FDArray count, offsize and Offset array
	 * @param Font
	 */
	protected void ReadFDArray(int Font)
	{
		seek(fonts[Font].fdarrayOffset);
		fonts[Font].FDArrayCount = getCard16();
		fonts[Font].FDArrayOffsize = getCard8();
		// Since we will change values inside the FDArray objects
		// We increase its offsize to prevent errors 
		if (fonts[Font].FDArrayOffsize < 4)
			fonts[Font].FDArrayOffsize++;
		fonts[Font].FDArrayOffsets = getIndex(fonts[Font].fdarrayOffset);
	}

    
	/**
	 * The Process function extracts one font out of the CFF file and returns a
	 * subset version of the original.
	 * @param fontName - The name of the font to be taken out of the CFF
	 * @return The new font stream
	 * @throws IOException
	 */
	public byte[] Process(String fontName)throws IOException{
		try
		{	
			// Verify that the file is open
			buf.reOpen();
			// Find the Font that we will be dealing with
			int j;
	        for (j=0; j<fonts.length; j++)
	            if (fontName.equals(fonts[j].name)) break;
	        if (j==fonts.length) return null;
	        
			// Calc the bias for the global subrs
			if (gsubrIndexOffset >= 0)
				GBias = CalcBias(gsubrIndexOffset,j);

	        // Prepare the new CharStrings Index
			BuildNewCharString(j);
			 // Prepare the new Global and Local Subrs Indices
			BuildNewLGSubrs(j);
			// Build the new file 
			byte[] Ret = BuildNewFile(j);
			return Ret;
		}
		finally {
            try {
                buf.close();
            }
            catch (Exception e) {
                // empty on purpose
            }
		}
	}

	/**
	 * Function calcs bias according to the CharString type and the count
	 * of the subrs
	 * @param Offset The offset to the relevent subrs index
	 * @param Font the font
	 * @return The calculated Bias
	 */
	protected int CalcBias(int Offset,int Font)
	{
		seek(Offset);
		int nSubrs = getCard16();
		// If type==1 -> bias=0 
		if (fonts[Font].CharstringType == 1)
			return 0;
		// else calc according to the count
		else if (nSubrs < 1240)
			return 107;
		else if (nSubrs < 33900)
			return 1131;
		else
			return 32768;
	}

	/**
	 *Function uses BuildNewIndex to create the new index of the subset charstrings
	 * @param FontIndex the font
	 * @throws IOException
	 */
	protected void BuildNewCharString(int FontIndex) throws IOException 
	{
		NewCharStringsIndex = BuildNewIndex(fonts[FontIndex].charstringsOffsets,GlyphsUsed);
	}
	
	/**
	 * Function builds the new local & global subsrs indices. IF CID then All of 
	 * the FD Array lsubrs will be subsetted. 
	 * @param Font the font
	 * @throws IOException
	 */
	protected void BuildNewLGSubrs(int Font)throws IOException
	{
		// If the font is CID then the lsubrs are divided into FontDicts.
		// for each FD array the lsubrs will be subsetted.
		if(fonts[Font].isCID)
		{
			// Init the hasmap-array and the arraylist-array to hold the subrs used
			// in each private dict.
			hSubrsUsed = new HashMap[fonts[Font].fdprivateOffsets.length];
			lSubrsUsed = new ArrayList[fonts[Font].fdprivateOffsets.length];
			// A [][] which will store the byte array for each new FD Array lsubs index
			NewLSubrsIndex = new byte[fonts[Font].fdprivateOffsets.length][];
			// An array to hold the offset for each Lsubr index 
			fonts[Font].PrivateSubrsOffset = new int[fonts[Font].fdprivateOffsets.length];
			// A [][] which will store the offset array for each lsubr index			
			fonts[Font].PrivateSubrsOffsetsArray = new int[fonts[Font].fdprivateOffsets.length][];
			
			// Put the FDarrayUsed into a list
			ArrayList FDInList = new ArrayList(FDArrayUsed.keySet());
			// For each FD array which is used subset the lsubr 
			for (int j=0;j<FDInList.size();j++)
			{
				// The FDArray index, Hash Map, Arrat List to work on
				int FD = ((Integer)FDInList.get(j)).intValue();
				hSubrsUsed[FD] = new HashMap();
				lSubrsUsed[FD] = new ArrayList();
				//Reads the private dicts looking for the subr operator and 
				// store both the offest for the index and its offset array
				BuildFDSubrsOffsets(Font,FD);
				// Verify that FDPrivate has a LSubrs index
				if(fonts[Font].PrivateSubrsOffset[FD]>=0)
				{
					//Scans the Charsting data storing the used Local and Global subroutines 
					// by the glyphs. Scans the Subrs recursivley. 
					BuildSubrUsed(Font,FD,fonts[Font].PrivateSubrsOffset[FD],fonts[Font].PrivateSubrsOffsetsArray[FD],hSubrsUsed[FD],lSubrsUsed[FD]);
					// Builds the New Local Subrs index
					NewLSubrsIndex[FD] = BuildNewIndex(fonts[Font].PrivateSubrsOffsetsArray[FD],hSubrsUsed[FD]);
				}
			}
		}
		// If the font is not CID && the Private Subr exists then subset:
		else if (fonts[Font].privateSubrs>=0)
		{
			// Build the subrs offsets;
			fonts[Font].SubrsOffsets = getIndex(fonts[Font].privateSubrs);
			//Scans the Charsting data storing the used Local and Global subroutines 
			// by the glyphs. Scans the Subrs recursivley.
			BuildSubrUsed(Font,-1,fonts[Font].privateSubrs,fonts[Font].SubrsOffsets,hSubrsUsedNonCID,lSubrsUsedNonCID);
		}
		// For all fonts susbset the Global Subroutines
		// Scan the Global Subr Hashmap recursivly on the Gsubrs
		BuildGSubrsUsed(Font);
		if (fonts[Font].privateSubrs>=0)
			// Builds the New Local Subrs index
			NewSubrsIndexNonCID = BuildNewIndex(fonts[Font].SubrsOffsets,hSubrsUsedNonCID);
		//Builds the New Global Subrs index
		NewGSubrsIndex = BuildNewIndex(gsubrOffsets,hGSubrsUsed);
	}

	/**
	 * The function finds for the FD array processed the local subr offset and its 
	 * offset array.  
	 * @param Font the font
	 * @param FD The FDARRAY processed
	 */
	protected void BuildFDSubrsOffsets(int Font,int FD)
	{
		// Initiate to -1 to indicate lsubr operator present
		fonts[Font].PrivateSubrsOffset[FD] = -1;
		// Goto begining of objects
        seek(fonts[Font].fdprivateOffsets[FD]);
        // While in the same object:
        while (getPosition() < fonts[Font].fdprivateOffsets[FD]+fonts[Font].fdprivateLengths[FD])
        {
        	getDictItem();
        	// If the dictItem is the "Subrs" then find and store offset, 
        	if (key=="Subrs")
        		fonts[Font].PrivateSubrsOffset[FD] = ((Integer)args[0]).intValue()+fonts[Font].fdprivateOffsets[FD];
        }
        //Read the lsub index if the lsubr was found
        if (fonts[Font].PrivateSubrsOffset[FD] >= 0)
        	fonts[Font].PrivateSubrsOffsetsArray[FD] = getIndex(fonts[Font].PrivateSubrsOffset[FD]); 
	}

	/**
	 * Function uses ReadAsubr on the glyph used to build the LSubr & Gsubr HashMap.
	 * The HashMap (of the lsub only) is then scaned recursivly for Lsubr & Gsubrs
	 * calls.  
	 * @param Font the font
	 * @param FD FD array processed. 0 indicates function was called by non CID font
	 * @param SubrOffset the offset to the subr index to calc the bias
	 * @param SubrsOffsets the offset array of the subr index
	 * @param hSubr HashMap of the subrs used
	 * @param lSubr ArrayList of the subrs used
	 */
	protected void BuildSubrUsed(int Font,int FD,int SubrOffset,int[] SubrsOffsets,HashMap hSubr,ArrayList lSubr)
	{

		// Calc the Bias for the subr index
		int LBias = CalcBias(SubrOffset,Font);
		
		// For each glyph used find its GID, start & end pos
		for (int i=0;i<glyphsInList.size();i++)
		{
			int glyph = ((Integer)glyphsInList.get(i)).intValue();
			int Start = fonts[Font].charstringsOffsets[glyph];
			int End = fonts[Font].charstringsOffsets[glyph+1];
			
			// IF CID:
			if (FD >= 0)
			{
				EmptyStack();
				NumOfHints=0;
				// Using FDSELECT find the FD Array the glyph belongs to.
				int GlyphFD = fonts[Font].FDSelect[glyph];
				// If the Glyph is part of the FD being processed 
				if (GlyphFD == FD)
					// Find the Subrs called by the glyph and insert to hash:
					ReadASubr(Start,End,GBias,LBias,hSubr,lSubr,SubrsOffsets);
			}
			else
				// If the font is not CID 
				//Find the Subrs called by the glyph and insert to hash:
				ReadASubr(Start,End,GBias,LBias,hSubr,lSubr,SubrsOffsets);
		}
		// For all Lsubrs used, check recusrivly for Lsubr & Gsubr used
		for (int i=0;i<lSubr.size();i++)
		{
			// Pop the subr value from the hash
			int Subr = ((Integer)lSubr.get(i)).intValue();
			// Ensure the Lsubr call is valid
			if (Subr < SubrsOffsets.length-1 && Subr>=0)
			{
				// Read and process the subr
				int Start = SubrsOffsets[Subr];
				int End = SubrsOffsets[Subr+1];
				ReadASubr(Start,End,GBias,LBias,hSubr,lSubr,SubrsOffsets);
			}
		}
	}
	
	/**
	 * Function scans the Glsubr used ArrayList to find recursive calls 
	 * to Gsubrs and adds to Hashmap & ArrayList
	 * @param Font the font
	 */
	protected void BuildGSubrsUsed(int Font)
	{
		int LBias = 0;
		int SizeOfNonCIDSubrsUsed = 0;
		if (fonts[Font].privateSubrs>=0)
		{
			LBias = CalcBias(fonts[Font].privateSubrs,Font);
			SizeOfNonCIDSubrsUsed = lSubrsUsedNonCID.size();
		}
		
		// For each global subr used 
		for (int i=0;i<lGSubrsUsed.size();i++)
		{
			//Pop the value + check valid 
			int Subr = ((Integer)lGSubrsUsed.get(i)).intValue();
			if (Subr < gsubrOffsets.length-1 && Subr>=0)
			{
				// Read the subr and process
				int Start = gsubrOffsets[Subr];
				int End = gsubrOffsets[Subr+1];
				
				if (fonts[Font].isCID)
					ReadASubr(Start,End,GBias,0,hGSubrsUsed,lGSubrsUsed,null);
				else
				{
					ReadASubr(Start,End,GBias,LBias,hSubrsUsedNonCID,lSubrsUsedNonCID,fonts[Font].SubrsOffsets);
					if (SizeOfNonCIDSubrsUsed < lSubrsUsedNonCID.size())
					{
						for (int j=SizeOfNonCIDSubrsUsed;j<lSubrsUsedNonCID.size();j++)
						{
							//Pop the value + check valid 
							int LSubr = ((Integer)lSubrsUsedNonCID.get(j)).intValue();
							if (LSubr < fonts[Font].SubrsOffsets.length-1 && LSubr>=0)
							{
								// Read the subr and process
								int LStart = fonts[Font].SubrsOffsets[LSubr];
								int LEnd = fonts[Font].SubrsOffsets[LSubr+1];
								ReadASubr(LStart,LEnd,GBias,LBias,hSubrsUsedNonCID,lSubrsUsedNonCID,fonts[Font].SubrsOffsets);
							}
						}
						SizeOfNonCIDSubrsUsed = lSubrsUsedNonCID.size();
					}
				}
			}
		}
	}

	/**
	 * The function reads a subrs (glyph info) between begin and end.
	 * Adds calls to a Lsubr to the hSubr and lSubrs.
	 * Adds calls to a Gsubr to the hGSubr and lGSubrs.
	 * @param begin the start point of the subr
	 * @param end the end point of the subr
	 * @param GBias the bias of the Global Subrs
	 * @param LBias the bias of the Local Subrs
	 * @param hSubr the HashMap for the lSubrs
	 * @param lSubr the ArrayList for the lSubrs
	 */
	protected void ReadASubr(int begin,int end,int GBias,int LBias,HashMap hSubr,ArrayList lSubr,int[] LSubrsOffsets)
	{
		// Clear the stack for the subrs
		EmptyStack();
		NumOfHints = 0;
		// Goto begining of the subr
        seek(begin);
        while (getPosition() < end)
        {
        	// Read the next command
        	ReadCommand();
        	int pos = getPosition();
        	Object TopElement=null;
        	if (arg_count > 0)
        		TopElement = args[arg_count-1];
        	int NumOfArgs = arg_count;
        	// Check the modification needed on the Argument Stack according to key;
        	HandelStack();
        	// a call to a Lsubr
        	if (key=="callsubr") 
        	{
        		// Verify that arguments are passed 
        		if (NumOfArgs > 0)
        		{
            		// Calc the index of the Subrs
            		int Subr = ((Integer)TopElement).intValue() + LBias;
            		// If the subr isn't in the HashMap -> Put in
        			if (!hSubr.containsKey(new Integer (Subr)))
            		{
            			hSubr.put(new Integer(Subr),null);
            			lSubr.add(new Integer(Subr));
            		}
        			CalcHints(LSubrsOffsets[Subr],LSubrsOffsets[Subr+1],LBias,GBias,LSubrsOffsets);
        			seek(pos);
        		}        		
        	}
        	// a call to a Gsubr
        	else if (key=="callgsubr")
        	{
        		// Verify that arguments are passed 
        		if (NumOfArgs > 0)
        		{
	        		// Calc the index of the Subrs
	        		int Subr = ((Integer)TopElement).intValue() + GBias;
	        		// If the subr isn't in the HashMap -> Put in
	        		if (!hGSubrsUsed.containsKey(new Integer (Subr)))
	        		{
	        			hGSubrsUsed.put(new Integer(Subr),null);
	        			lGSubrsUsed.add(new Integer(Subr));
	        		}
	        		CalcHints(gsubrOffsets[Subr],gsubrOffsets[Subr+1],LBias,GBias,LSubrsOffsets);
	        		seek(pos);
        		}
        	}
        	// A call to "stem"
        	else if (key == "hstem" || key == "vstem" || key == "hstemhm" || key == "vstemhm")
        		// Increment the NumOfHints by the number couples of of arguments
        		NumOfHints += NumOfArgs/2;
        	// A call to "mask"
        	else if (key == "hintmask" || key == "cntrmask")
        	{
        		// Compute the size of the mask
        		int SizeOfMask = NumOfHints/8;
        		if (NumOfHints%8 != 0 || SizeOfMask == 0)
        			SizeOfMask++;
        		// Continue the pointer in SizeOfMask steps
        		for (int i=0;i<SizeOfMask;i++)
        			getCard8();
        	}
        }
	}

	/**
	 * Function Checks how the current operator effects the run time stack after being run 
	 * An operator may increase or decrease the stack size
	 */
	protected void HandelStack()
	{
    	// Findout what the operator does to the stack
    	int StackHandel = StackOpp();
    	if (StackHandel < 2)
    	{
    		// The operators that enlarge the stack by one
    		if (StackHandel==1)
    			PushStack();
    		// The operators that pop the stack
    		else
    		{
    			// Abs value for the for loop
    			StackHandel *= -1;
    			for (int i=0;i<StackHandel;i++)
    				PopStack();
    		}
    		
    	}
    	// All other flush the stack
    	else
    		EmptyStack();		
	}
	
	/**
	 * Function checks the key and return the change to the stack after the operator
	 * @return The change in the stack. 2-> flush the stack
	 */
	protected int StackOpp()
	{
		if (key == "ifelse")
			return -3;
		if (key == "roll" || key == "put")
			return -2;
		if (key == "callsubr" || key == "callgsubr" || key == "add" || key == "sub" ||
			key == "div" || key == "mul" || key == "drop" || key == "and" || 
			key == "or" || key == "eq")
			return -1;
		if (key == "abs" || key == "neg" || key == "sqrt" || key == "exch" || 
			key == "index" || key == "get" || key == "not" || key == "return")
			return 0;
		if (key == "random" || key == "dup")
			return 1;
		return 2;
	}
	
	/**
	 * Empty the Type2 Stack
	 *
	 */
	protected void EmptyStack()
	{
		// Null the arguments
    	for (int i=0; i<arg_count; i++) args[i]=null;
        arg_count = 0;		
	}
	
	/**
	 * Pop one element from the stack 
	 *
	 */
	protected void PopStack()
	{
		if (arg_count>0)
		{
			args[arg_count-1]=null;
			arg_count--;
		}
	}
	
	/**
	 * Add an item to the stack
	 *
	 */
	protected void PushStack()
	{
		arg_count++;
	}
	
	/**
	 * The function reads the next command after the file pointer is set
	 */
	protected void ReadCommand()
	{
        key = null;
        boolean gotKey = false;
        // Until a key is found
        while (!gotKey) {
        	// Read the first Char
            char b0 = getCard8();
            // decode according to the type1/type2 format
            if (b0 == 28) // the two next bytes represent a short int;
            {
            	int first = getCard8();
            	int second = getCard8();
            	args[arg_count] = new Integer(first<<8 | second);
            	arg_count++;
            	continue;
            }
            if (b0 >= 32 && b0 <= 246) // The byte read is the byte;
            {
            	args[arg_count] = new Integer(b0 - 139);
            	arg_count++;
            	continue;
            }
            if (b0 >= 247 && b0 <= 250) // The byte read and the next byte constetute a short int
            {
            	int w = getCard8();
            	args[arg_count] = new Integer((b0-247)*256 + w + 108);
            	arg_count++;
            	continue;
            }
            if (b0 >= 251 && b0 <= 254)// Same as above except negative
            {
            	int w = getCard8();
            	args[arg_count] = new Integer(-(b0-251)*256 - w - 108);
            	arg_count++;
            	continue;
            }
            if (b0 == 255)// The next for bytes represent a double.
            {
            	int first = getCard8();
            	int second = getCard8();
            	int third = getCard8();
            	int fourth = getCard8();
            	args[arg_count] = new Integer(first<<24 | second<<16 | third<<8 | fourth);
            	arg_count++;
            	continue;
            }
            if (b0<=31 && b0 != 28) // An operator was found.. Set Key.
            {
            	gotKey=true;
            	// 12 is an escape command therefor the next byte is a part
            	// of this command
            	if (b0 == 12)
            	{
            		int b1 = getCard8();
            		if (b1>SubrsEscapeFuncs.length-1)
            			b1 = SubrsEscapeFuncs.length-1;
            		key = SubrsEscapeFuncs[b1];
            	}
            	else
            		key = SubrsFunctions[b0];
                continue;
            }
        }		
	}
	
	/**
	 * The function reads the subroutine and returns the number of the hint in it.
	 * If a call to another subroutine is found the function calls recursively.
	 * @param begin the start point of the subr
	 * @param end the end point of the subr
	 * @param LBias the bias of the Local Subrs
	 * @param GBias the bias of the Global Subrs
	 * @param LSubrsOffsets The Offsets array of the subroutines
	 * @return The number of hints in the subroutine read.
	 */
	protected int CalcHints(int begin,int end,int LBias,int GBias,int[] LSubrsOffsets)
	{
		// Goto begining of the subr
        seek(begin);
        while (getPosition() < end)
        {
        	// Read the next command
        	ReadCommand();
        	int pos = getPosition();
        	Object TopElement = null;
        	if (arg_count>0)
        		TopElement = args[arg_count-1];
        	int NumOfArgs = arg_count;
            //Check the modification needed on the Argument Stack according to key;
        	HandelStack();
        	// a call to a Lsubr
        	if (key=="callsubr") 
        	{
        		if (NumOfArgs>0)
        		{
            		int Subr = ((Integer)TopElement).intValue() + LBias;
            		CalcHints(LSubrsOffsets[Subr],LSubrsOffsets[Subr+1],LBias,GBias,LSubrsOffsets);
            		seek(pos);        			
        		}
        	}
        	// a call to a Gsubr
        	else if (key=="callgsubr")
        	{
        		if (NumOfArgs>0)
        		{
            		int Subr = ((Integer)TopElement).intValue() + GBias;
            		CalcHints(gsubrOffsets[Subr],gsubrOffsets[Subr+1],LBias,GBias,LSubrsOffsets);
            		seek(pos);        			
        		}
        	}
        	// A call to "stem"
        	else if (key == "hstem" || key == "vstem" || key == "hstemhm" || key == "vstemhm")
        		// Increment the NumOfHints by the number couples of of arguments
        		NumOfHints += NumOfArgs/2;
        	// A call to "mask"
        	else if (key == "hintmask" || key == "cntrmask")
        	{
        		// Compute the size of the mask
        		int SizeOfMask = NumOfHints/8;
        		if (NumOfHints%8 != 0 || SizeOfMask == 0)
        			SizeOfMask++;
        		// Continue the pointer in SizeOfMask steps
        		for (int i=0;i<SizeOfMask;i++)
        			getCard8();
        	}
        }
        return NumOfHints;
	}


	/**
	 * Function builds the new offset array, object array and assembles the index.
	 * used for creating the glyph and subrs subsetted index 
	 * @param Offsets the offset array of the original index  
	 * @param Used the hashmap of the used objects
	 * @return the new index subset version 
	 * @throws IOException
	 */
	protected byte[] BuildNewIndex(int[] Offsets,HashMap Used) throws IOException 
	{
		int Offset=0;
		int[] NewOffsets = new int[Offsets.length];
		// Build the Offsets Array for the Subset
		for (int i=0;i<Offsets.length;++i)
		{
			NewOffsets[i] = Offset;
			// If the object in the offset is also present in the used
			// HashMap then increment the offset var by its size
			if (Used.containsKey(new Integer(i)))
				Offset += Offsets[i+1] - Offsets[i];
				// Else the same offset is kept in i+1.
		}
		// Offset var determines the size of the object array
		byte[] NewObjects = new byte[Offset];
		// Build the new Object array
		for (int i=0;i<Offsets.length-1;++i)
		{
			int start = NewOffsets[i];
			int end = NewOffsets[i+1];
			// If start != End then the Object is used
			// So, we will copy the object data from the font file
			if (start != end)
			{
				// All offsets are Global Offsets relative to the begining of the font file.
				// Jump the file pointer to the start address to read from.
				buf.seek(Offsets[i]);
				// Read from the buffer and write into the array at start.  
                buf.readFully(NewObjects, start, end-start);
			}
		}
		// Use AssembleIndex to build the index from the offset & object arrays
		return AssembleIndex(NewOffsets,NewObjects);
	}

	/**
	 * Function creates the new index, inserting the count,offsetsize,offset array
	 * and object array.
	 * @param NewOffsets the subsetted offset array
	 * @param NewObjects the subsetted object array
	 * @return the new index created
	 */
	protected byte[] AssembleIndex(int[] NewOffsets,byte[] NewObjects)
	{
		// Calc the index' count field
		char Count = (char)(NewOffsets.length-1);
		// Calc the size of the object array
		int Size = NewOffsets[NewOffsets.length-1];
		// Calc the Offsize
		byte Offsize;
        if (Size <= 0xff) Offsize = 1;
        else if (Size <= 0xffff) Offsize = 2;
        else if (Size <= 0xffffff) Offsize = 3;
        else Offsize = 4;
        // The byte array for the new index. The size is calc by
        // Count=2, Offsize=1, OffsetArray = Offsize*(Count+1), The object array
        byte[] NewIndex = new byte[2+1+Offsize*(Count+1)+NewObjects.length];
        // The counter for writing
        int Place = 0;
        // Write the count field
        NewIndex[Place++] = (byte) ((Count >>> 8) & 0xff);
        NewIndex[Place++] = (byte) ((Count >>> 0) & 0xff);
        // Write the offsize field
        NewIndex[Place++] = Offsize;
        // Write the offset array according to the offsize
        for (int i=0;i<NewOffsets.length;i++)
        {
        	// The value to be written
        	int Num = NewOffsets[i]-NewOffsets[0]+1;
        	// Write in bytes according to the offsize
        	switch (Offsize) {
                case 4:
                	NewIndex[Place++] = (byte) ((Num >>> 24) & 0xff);
                case 3:
                	NewIndex[Place++] = (byte) ((Num >>> 16) & 0xff);
                case 2:
                	NewIndex[Place++] = (byte) ((Num >>>  8) & 0xff);
                case 1:
                	NewIndex[Place++] = (byte) ((Num >>>  0) & 0xff);
        	}                	
        }
        // Write the new object array one by one
        for (int i=0;i<NewObjects.length;i++)
        {
        	NewIndex[Place++] = NewObjects[i];
        }
        // Return the new index
        return NewIndex;
	}
	
	/**
	 * The function builds the new output stream according to the subset process
	 * @param Font the font
	 * @return the subseted font stream
	 * @throws IOException
	 */
	protected byte[] BuildNewFile(int Font)throws IOException
    {
		// Prepare linked list for new font components
		OutputList = new LinkedList();

        // copy the header of the font
        CopyHeader();
                
        // create a name index
        BuildIndexHeader(1,1,1);
        OutputList.addLast(new UInt8Item((char)( 1+fonts[Font].name.length() )));
        OutputList.addLast(new StringItem(fonts[Font].name));
        
        // create the topdict Index
        BuildIndexHeader(1,2,1);
        OffsetItem topdictIndex1Ref = new IndexOffsetItem(2);
        OutputList.addLast(topdictIndex1Ref);
        IndexBaseItem topdictBase = new IndexBaseItem();
        OutputList.addLast(topdictBase);
                
        // Initialise the Dict Items for later use
        OffsetItem charsetRef     = new DictOffsetItem();
        OffsetItem charstringsRef = new DictOffsetItem();
        OffsetItem fdarrayRef     = new DictOffsetItem();
        OffsetItem fdselectRef    = new DictOffsetItem();
        OffsetItem privateRef     = new DictOffsetItem();
        
        // If the font is not CID create the following keys
        if ( !fonts[Font].isCID ) {
            // create a ROS key
        	OutputList.addLast(new DictNumberItem(fonts[Font].nstrings));
        	OutputList.addLast(new DictNumberItem(fonts[Font].nstrings+1));
        	OutputList.addLast(new DictNumberItem(0));
        	OutputList.addLast(new UInt8Item((char)12));
        	OutputList.addLast(new UInt8Item((char)30));
            // create a CIDCount key
        	OutputList.addLast(new DictNumberItem(fonts[Font].nglyphs));
        	OutputList.addLast(new UInt8Item((char)12));
            OutputList.addLast(new UInt8Item((char)34));
            // Sivan's comments
            // What about UIDBase (12,35)? Don't know what is it.
            // I don't think we need FontName; the font I looked at didn't have it.
        }
        // Go to the TopDict of the font being processed
        seek(topdictOffsets[Font]);
        // Run untill the end of the TopDict
        while (getPosition() < topdictOffsets[Font+1]) {
            int p1 = getPosition();
            getDictItem();
            int p2 = getPosition();
            // The encoding key is disregarded since CID has no encoding
            if (key=="Encoding"
            // These keys will be added manualy by the process.
            || key=="Private" 
            || key=="FDSelect"
            || key=="FDArray" 
            || key=="charset" 
            || key=="CharStrings"
            ) {
            }else {
            //OtherWise copy key "as is" to the output list
                OutputList.add(new RangeItem(buf,p1,p2-p1));
            }
        }
        // Create the FDArray, FDSelect, Charset and CharStrings Keys
        CreateKeys(fdarrayRef,fdselectRef,charsetRef,charstringsRef);
        
        // Mark the end of the top dict area
        OutputList.addLast(new IndexMarkerItem(topdictIndex1Ref,topdictBase));
        
        // Copy the string index

        if (fonts[Font].isCID) 
            OutputList.addLast(getEntireIndexRange(stringIndexOffset));
        // If the font is not CID we need to append new strings.
        // We need 3 more strings: Registry, Ordering, and a FontName for one FD.
        // The total length is at most "Adobe"+"Identity"+63 = 76
        else
        	CreateNewStringIndex(Font);
        
        // copy the new subsetted global subroutine index       
        OutputList.addLast(new RangeItem(new RandomAccessFileOrArray(NewGSubrsIndex),0,NewGSubrsIndex.length));
        
        // deal with fdarray, fdselect, and the font descriptors
        // If the font is CID:
        if (fonts[Font].isCID) {
            // copy the FDArray, FDSelect, charset
       
            // Copy FDSelect
        	// Mark the beginning
            OutputList.addLast(new MarkerItem(fdselectRef));
            // If an FDSelect exists copy it
            if (fonts[Font].fdselectOffset>=0)
        		OutputList.addLast(new RangeItem(buf,fonts[Font].fdselectOffset,fonts[Font].FDSelectLength));
            // Else create a new one
            else
            	CreateFDSelect(fdselectRef,fonts[Font].nglyphs);
            	           
          	// Copy the Charset
            // Mark the beginning and copy entirly 
            OutputList.addLast(new MarkerItem(charsetRef));
            OutputList.addLast(new RangeItem(buf,fonts[Font].charsetOffset,fonts[Font].CharsetLength));
            
            // Copy the FDArray
            // If an FDArray exists
            if (fonts[Font].fdarrayOffset>=0)
            {
                // Mark the beginning
	            OutputList.addLast(new MarkerItem(fdarrayRef));
	            // Build a new FDArray with its private dicts and their LSubrs
	            Reconstruct(Font);
            }
            else
            	// Else create a new one
            	CreateFDArray(fdarrayRef,privateRef,Font);
           
        }
        // If the font is not CID
        else 
        {
            // create FDSelect
        	CreateFDSelect(fdselectRef,fonts[Font].nglyphs);            
            // recreate a new charset
        	CreateCharset(charsetRef,fonts[Font].nglyphs);            
            // create a font dict index (fdarray)
        	CreateFDArray(fdarrayRef,privateRef,Font);            
        }
        
        // if a private dict exists insert its subsetted version
        if (fonts[Font].privateOffset>=0)
        {
        	// Mark the beginning of the private dict
        	IndexBaseItem PrivateBase = new IndexBaseItem();
	        OutputList.addLast(PrivateBase);
        	OutputList.addLast(new MarkerItem(privateRef));

        	OffsetItem Subr = new DictOffsetItem();
        	// Build and copy the new private dict
        	CreateNonCIDPrivate(Font,Subr);
        	// Copy the new LSubrs index
        	CreateNonCIDSubrs(Font,PrivateBase,Subr);
        }
        
        // copy the charstring index
        OutputList.addLast(new MarkerItem(charstringsRef));

        // Add the subsetted charstring
        OutputList.addLast(new RangeItem(new RandomAccessFileOrArray(NewCharStringsIndex),0,NewCharStringsIndex.length));
        
        // now create the new CFF font        
        int[] currentOffset = new int[1];
        currentOffset[0] = 0;
        // Count and save the offset for each item
        Iterator listIter = OutputList.iterator();
        while ( listIter.hasNext() ) {
            Item item = (Item) listIter.next();
            item.increment(currentOffset);
        }
        // Compute the Xref for each of the offset items
        listIter = OutputList.iterator();
        while ( listIter.hasNext() ) {
            Item item = (Item) listIter.next();
            item.xref();
        }
        
        int size = currentOffset[0];
        byte[] b = new byte[size];
        
        // Emit all the items into the new byte array
        listIter = OutputList.iterator();
        while ( listIter.hasNext() ) {
            Item item = (Item) listIter.next();
            item.emit(b);
        }
        // Return the new stream
        return b;
    }

	/**
	 * Function Copies the header from the original fileto the output list
	 */
	protected void CopyHeader()
	{
		seek(0);
        // ssteward omit: int major = getCard8();
        // ssteward omit: int minor = getCard8();
        int hdrSize = getCard8();
        // ssteward omit: int offSize = getCard8();
        nextIndexOffset = hdrSize;
        OutputList.addLast(new RangeItem(buf,0,hdrSize));
	}

	/**
	 * Function Build the header of an index
	 * @param Count the count field of the index
	 * @param Offsize the offsize field of the index
	 * @param First the first offset of the index
	 */
	protected void BuildIndexHeader(int Count,int Offsize,int First)
	{
		// Add the count field
		OutputList.addLast(new UInt16Item((char)Count)); // count
		// Add the offsize field
		OutputList.addLast(new UInt8Item((char)Offsize)); // offSize
		// Add the first offset according to the offsize
        switch(Offsize){
        	case 1:
        		OutputList.addLast(new UInt8Item((char)First)); // first offset
        		break;
        	case 2:
        		OutputList.addLast(new UInt16Item((char)First)); // first offset
        		break;
        	case 3:
        		OutputList.addLast(new UInt24Item((char)First)); // first offset
        		break;
        	case 4:
        		OutputList.addLast(new UInt32Item((char)First)); // first offset
        		break;
    		default:
    			break;	
        }
	}
	
	/**
	 * Function adds the keys into the TopDict
	 * @param fdarrayRef OffsetItem for the FDArray
	 * @param fdselectRef OffsetItem for the FDSelect
	 * @param charsetRef OffsetItem for the CharSet
	 * @param charstringsRef OffsetItem for the CharString
	 */
	protected void CreateKeys(OffsetItem fdarrayRef,OffsetItem fdselectRef,OffsetItem charsetRef,OffsetItem charstringsRef)
	{
	    // create an FDArray key
        OutputList.addLast(fdarrayRef);
        OutputList.addLast(new UInt8Item((char)12));
        OutputList.addLast(new UInt8Item((char)36));
        // create an FDSelect key
        OutputList.addLast(fdselectRef);
        OutputList.addLast(new UInt8Item((char)12));
        OutputList.addLast(new UInt8Item((char)37));
        // create an charset key
        OutputList.addLast(charsetRef);
        OutputList.addLast(new UInt8Item((char)15));
        // create a CharStrings key
        OutputList.addLast(charstringsRef);
        OutputList.addLast(new UInt8Item((char)17));
	}
	
	/**
	 * Function takes the original string item and adds the new strings
	 * to accomodate the CID rules
	 * @param Font the font
	 */
	protected void CreateNewStringIndex(int Font)
	{
        String fdFontName = fonts[Font].name+"-OneRange";
        if (fdFontName.length() > 127)
            fdFontName = fdFontName.substring(0,127);
        String extraStrings = "Adobe"+"Identity"+fdFontName;
        
        int origStringsLen = stringOffsets[stringOffsets.length-1]
        - stringOffsets[0];
        int stringsBaseOffset = stringOffsets[0]-1;
        
        byte stringsIndexOffSize;
        if (origStringsLen+extraStrings.length() <= 0xff) stringsIndexOffSize = 1;
        else if (origStringsLen+extraStrings.length() <= 0xffff) stringsIndexOffSize = 2;
        else if (origStringsLen+extraStrings.length() <= 0xffffff) stringsIndexOffSize = 3;
        else stringsIndexOffSize = 4;
        
        OutputList.addLast(new UInt16Item((char)((stringOffsets.length-1)+3))); // count
        OutputList.addLast(new UInt8Item((char)stringsIndexOffSize)); // offSize
        for (int i=0; i<stringOffsets.length; i++)
            OutputList.addLast(new IndexOffsetItem(stringsIndexOffSize,
            stringOffsets[i]-stringsBaseOffset));
        int currentStringsOffset = stringOffsets[stringOffsets.length-1]
        - stringsBaseOffset;
        //l.addLast(new IndexOffsetItem(stringsIndexOffSize,currentStringsOffset));
        currentStringsOffset += ("Adobe").length();
        OutputList.addLast(new IndexOffsetItem(stringsIndexOffSize,currentStringsOffset));
        currentStringsOffset += ("Identity").length();
        OutputList.addLast(new IndexOffsetItem(stringsIndexOffSize,currentStringsOffset));
        currentStringsOffset += fdFontName.length();
        OutputList.addLast(new IndexOffsetItem(stringsIndexOffSize,currentStringsOffset));
        
        OutputList.addLast(new RangeItem(buf,stringOffsets[0],origStringsLen));
        OutputList.addLast(new StringItem(extraStrings));
    }
     
	/**
	 * Function creates new FDSelect for non-CID fonts.
	 * The FDSelect built uses a single range for all glyphs
	 * @param fdselectRef OffsetItem for the FDSelect
	 * @param nglyphs the number of glyphs in the font
	 */
	protected void CreateFDSelect(OffsetItem fdselectRef,int nglyphs)
	{
		OutputList.addLast(new MarkerItem(fdselectRef));
	    OutputList.addLast(new UInt8Item((char)3)); // format identifier
	    OutputList.addLast(new UInt16Item((char)1)); // nRanges
	    
	    OutputList.addLast(new UInt16Item((char)0)); // Range[0].firstGlyph
	    OutputList.addLast(new UInt8Item((char)0)); // Range[0].fd
	    
	    OutputList.addLast(new UInt16Item((char)nglyphs)); // sentinel
	}

	/**
	 * Function creates new CharSet for non-CID fonts.
	 * The CharSet built uses a single range for all glyphs
	 * @param charsetRef OffsetItem for the CharSet
	 * @param nglyphs the number of glyphs in the font
	 */
	protected void CreateCharset(OffsetItem charsetRef,int nglyphs)
	{
		OutputList.addLast(new MarkerItem(charsetRef));
	    OutputList.addLast(new UInt8Item((char)2)); // format identifier
	    OutputList.addLast(new UInt16Item((char)1)); // first glyph in range (ignore .notdef)
	    OutputList.addLast(new UInt16Item((char)(nglyphs-1))); // nLeft
	}
    
	/**
	 * Function creates new FDArray for non-CID fonts.
	 * The FDArray built has only the "Private" operator that points to the font's
	 * original private dict 
	 * @param fdarrayRef OffsetItem for the FDArray
	 * @param privateRef OffsetItem for the Private Dict
	 * @param Font the font
	 */
	protected void CreateFDArray(OffsetItem fdarrayRef,OffsetItem privateRef,int Font)
	{
		OutputList.addLast(new MarkerItem(fdarrayRef));
		// Build the header (count=offsize=first=1)
		BuildIndexHeader(1,1,1);
	    
		// Mark
	    OffsetItem privateIndex1Ref = new IndexOffsetItem(1);
	    OutputList.addLast(privateIndex1Ref);
	    IndexBaseItem privateBase = new IndexBaseItem();
	    // Insert the private operands and operator
	    OutputList.addLast(privateBase);
	    // Calc the new size of the private after subsetting
	    // Origianl size
	    int NewSize = fonts[Font].privateLength;
	    // Calc the original size of the Subr offset in the private
		int OrgSubrsOffsetSize = CalcSubrOffsetSize(fonts[Font].privateOffset,fonts[Font].privateLength);
		// Increase the ptivate's size
		if (OrgSubrsOffsetSize != 0)
			NewSize += 5-OrgSubrsOffsetSize;
	    OutputList.addLast(new DictNumberItem(NewSize));
	    OutputList.addLast(privateRef);
	    OutputList.addLast(new UInt8Item((char)18)); // Private
	    
	    OutputList.addLast(new IndexMarkerItem(privateIndex1Ref,privateBase));
	}
    
	/**
	 * Function reconstructs the FDArray, PrivateDict and LSubr for CID fonts
	 * @param Font the font
	 * @throws IOException
	 */
	void Reconstruct(int Font)throws IOException
	{
		// Init for later use
		OffsetItem[] fdPrivate = new DictOffsetItem[fonts[Font].FDArrayOffsets.length-1];
		IndexBaseItem[] fdPrivateBase = new IndexBaseItem[fonts[Font].fdprivateOffsets.length]; 
		OffsetItem[] fdSubrs = new DictOffsetItem[fonts[Font].fdprivateOffsets.length];
		// Reconstruct each type
		ReconstructFDArray(Font,fdPrivate);
		ReconstructPrivateDict(Font,fdPrivate,fdPrivateBase,fdSubrs);
		ReconstructPrivateSubrs(Font,fdPrivateBase,fdSubrs);
	}

	/**
	 * Function subsets the FDArray and builds the new one with new offsets
	 * @param Font The font
	 * @param fdPrivate OffsetItem Array (one for each FDArray)
	 * @throws IOException
	 */
	void ReconstructFDArray(int Font,OffsetItem[] fdPrivate)throws IOException
	{
		// Build the header of the index
		BuildIndexHeader(fonts[Font].FDArrayCount,fonts[Font].FDArrayOffsize,1);

		// For each offset create an Offset Item
		OffsetItem[] fdOffsets = new IndexOffsetItem[fonts[Font].FDArrayOffsets.length-1];
		for (int i=0;i<fonts[Font].FDArrayOffsets.length-1;i++)
		{
			fdOffsets[i] = new IndexOffsetItem(fonts[Font].FDArrayOffsize);
			OutputList.addLast(fdOffsets[i]);
		}
		
		// Declare beginning of the object array
		IndexBaseItem fdArrayBase = new IndexBaseItem();
	    OutputList.addLast(fdArrayBase);
	    
		// For each object check if that FD is used.
	    // if is used build a new one by changing the private object
	    // Else do nothing
	    // At the end of each object mark its ending (Even if wasn't written)
		for (int k=0; k<fonts[Font].FDArrayOffsets.length-1; k++) {
			if (FDArrayUsed.containsKey(new Integer (k)))
			{
				// Goto begining of objects
	            seek(fonts[Font].FDArrayOffsets[k]);
	            while (getPosition() < fonts[Font].FDArrayOffsets[k+1])
	            {
	            	int p1 = getPosition();
	            	getDictItem();
	            	int p2 = getPosition();
	            	// If the dictItem is the "Private" then compute and copy length, 
	            	// use marker for offset and write operator number
	            	if (key=="Private") {
	            		// Save the original length of the private dict
	            		int NewSize = ((Integer)args[0]).intValue();
	            		// Save the size of the offset to the subrs in that private
	            		int OrgSubrsOffsetSize = CalcSubrOffsetSize(fonts[Font].fdprivateOffsets[k],fonts[Font].fdprivateLengths[k]);
	            		// Increase the private's length accordingly
	            		if (OrgSubrsOffsetSize != 0)
	            			NewSize += 5-OrgSubrsOffsetSize;
	            		// Insert the new size, OffsetItem and operator key number
	            		OutputList.addLast(new DictNumberItem(NewSize));
	            		fdPrivate[k] = new DictOffsetItem();
	            		OutputList.addLast(fdPrivate[k]);
	            	    OutputList.addLast(new UInt8Item((char)18)); // Private
	            	    // Go back to place 
	            	    seek(p2);
	            	}
	            	// Else copy the entire range
	            	else  // other than private
	            		OutputList.addLast(new RangeItem(buf,p1,p2-p1));
	            }
			}
            // Mark the ending of the object (even if wasn't written)
            OutputList.addLast(new IndexMarkerItem(fdOffsets[k],fdArrayBase));
        }
	}
	/**
	 * Function Adds the new private dicts (only for the FDs used) to the list
	 * @param Font the font
	 * @param fdPrivate OffsetItem array one element for each private
	 * @param fdPrivateBase IndexBaseItem array one element for each private
	 * @param fdSubrs OffsetItem array one element for each private
	 * @throws IOException
	 */
	void ReconstructPrivateDict(int Font,OffsetItem[] fdPrivate,IndexBaseItem[] fdPrivateBase,
			OffsetItem[] fdSubrs)throws IOException
	{
		
		// For each fdarray private dict check if that FD is used.
	    // if is used build a new one by changing the subrs offset
	    // Else do nothing
		for (int i=0;i<fonts[Font].fdprivateOffsets.length;i++)
		{
			if (FDArrayUsed.containsKey(new Integer (i)))
			{
				// Mark beginning
		        OutputList.addLast(new MarkerItem(fdPrivate[i]));
		        fdPrivateBase[i] = new IndexBaseItem();
		        OutputList.addLast(fdPrivateBase[i]);
				// Goto begining of objects
	            seek(fonts[Font].fdprivateOffsets[i]);
	            while (getPosition() < fonts[Font].fdprivateOffsets[i]+fonts[Font].fdprivateLengths[i])
	            {
	            	int p1 = getPosition();
	            	getDictItem();
	            	int p2 = getPosition();
	            	// If the dictItem is the "Subrs" then, 
	            	// use marker for offset and write operator number
	            	if (key=="Subrs") {
	            		fdSubrs[i] = new DictOffsetItem();
	            		OutputList.addLast(fdSubrs[i]);
	            	    OutputList.addLast(new UInt8Item((char)19)); // Subrs
	            	}
	            	// Else copy the entire range
	            	else
	            		OutputList.addLast(new RangeItem(buf,p1,p2-p1));
	            }
			}
		}
	}
	
	/**
	 * Function Adds the new LSubrs dicts (only for the FDs used) to the list
	 * @param Font  The index of the font
	 * @param fdPrivateBase The IndexBaseItem array for the linked list
	 * @param fdSubrs OffsetItem array for the linked list
	 * @throws IOException
	 */
	
	void ReconstructPrivateSubrs(int Font,IndexBaseItem[] fdPrivateBase,
			OffsetItem[] fdSubrs)throws IOException
	{
		// For each private dict
        for (int i=0;i<fonts[Font].fdprivateLengths.length;i++)
        {
        	// If that private dict's Subrs are used insert the new LSubrs
        	// computed earlier
        	if (fdSubrs[i]!= null && fonts[Font].PrivateSubrsOffset[i] >= 0)
        	{        		
        		OutputList.addLast(new SubrMarkerItem(fdSubrs[i],fdPrivateBase[i]));
        		OutputList.addLast(new RangeItem(new RandomAccessFileOrArray(NewLSubrsIndex[i]),0,NewLSubrsIndex[i].length));
        	}
        }
    }

	/**
	 * Calculates how many byte it took to write the offset for the subrs in a specific
	 * private dict.
	 * @param Offset The Offset for the private dict
	 * @param Size The size of the private dict
	 * @return The size of the offset of the subrs in the private dict
	 */
	int CalcSubrOffsetSize(int Offset,int Size)
	{
		// Set the size to 0
		int OffsetSize = 0;
		// Go to the beginning of the private dict
		seek(Offset);
		// Go until the end of the private dict 
		while (getPosition() < Offset+Size)
        {
        	int p1 = getPosition();
        	getDictItem();
        	int p2 = getPosition();
        	// When reached to the subrs offset
        	if (key=="Subrs") {
        		// The Offsize (minus the subrs key)
        		OffsetSize = p2-p1-1;
        	}
        	// All other keys are ignored
        }
		// return the size
		return OffsetSize;
	}
	
	/**
	 * Function computes the size of an index
	 * @param indexOffset The offset for the computed index
	 * @return The size of the index
	 */
	protected int countEntireIndexRange(int indexOffset) 
	{
		// Go to the beginning of the index 
	    seek(indexOffset);
	    // Read the count field
	    int count = getCard16();
	    // If count==0 -> size=2
	    if (count==0) 
	        return 2;
	    else 
	    {
	    	// Read the offsize field
	        int indexOffSize = getCard8();
	        // Go to the last element of the offset array
	        seek(indexOffset+2+1+count*indexOffSize);
	        // The size of the object array is the value of the last element-1
	        int size = getOffset(indexOffSize)-1;
	        // Return the size of the entire index
	        return 2+1+(count+1)*indexOffSize+size;
	    }
	}
	
	/**
	 * The function creates a private dict for a font that was not CID
	 * All the keys are copied as is except for the subrs key 
	 * @param Font the font
	 * @param Subr The OffsetItem for the subrs of the private 
	 */
	void CreateNonCIDPrivate(int Font,OffsetItem Subr)
	{
		// Go to the beginning of the private dict and read untill the end
		seek(fonts[Font].privateOffset);
        while (getPosition() < fonts[Font].privateOffset+fonts[Font].privateLength)
        {
        	int p1 = getPosition();
        	getDictItem();
        	int p2 = getPosition();
        	// If the dictItem is the "Subrs" then, 
        	// use marker for offset and write operator number
        	if (key=="Subrs") {
        		OutputList.addLast(Subr);
        	    OutputList.addLast(new UInt8Item((char)19)); // Subrs
        	}
        	// Else copy the entire range
        	else
        		OutputList.addLast(new RangeItem(buf,p1,p2-p1));
        }
	}
	
	/**
	 * the function marks the beginning of the subrs index and adds the subsetted subrs
	 * index to the output list. 
	 * @param Font the font
	 * @param PrivateBase IndexBaseItem for the private that's referencing to the subrs
	 * @param Subrs OffsetItem for the subrs
	 * @throws IOException
	 */
	void CreateNonCIDSubrs(int Font,IndexBaseItem PrivateBase,OffsetItem Subrs)throws IOException
	{
		// Mark the beginning of the Subrs index
		OutputList.addLast(new SubrMarkerItem(Subrs,PrivateBase));
		// Put the subsetted new subrs index
		OutputList.addLast(new RangeItem(new RandomAccessFileOrArray(NewSubrsIndexNonCID),0,NewSubrsIndexNonCID.length));
    }	
} /*
 * $Id: CJKFont.java,v 1.29 2002/07/09 11:28:22 blowagie Exp $
 * $Name:  $
 *
 * Copyright 2000, 2001, 2002 by Paulo Soares.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf;

import pdftk.com.lowagie.text.DocumentException;
import java.io.*;
import java.util.HashMap;
import java.util.Properties;
import java.util.Hashtable;
import java.util.StringTokenizer;
import java.util.Enumeration;

/**
 * Creates a CJK font compatible with the fonts in the Adobe Asian font Pack.
 *
 * @author  Paulo Soares (psoares@consiste.pt)
 */

class CJKFont extends BaseFont {
    /** The encoding used in the PDF document for CJK fonts
     */
    static final String CJK_ENCODING = "UnicodeBigUnmarked";
    private static final int FIRST = 0;
    private static final int BRACKET = 1;
    private static final int SERIAL = 2;
    private static final int V1Y = 880;
        
    static Properties cjkFonts = new Properties();
    static Properties cjkEncodings = new Properties();
    static Hashtable allCMaps = new Hashtable();
    static Hashtable allFonts = new Hashtable();
    private static boolean propertiesLoaded = false;
    
    /** The font name */
    private String fontName;
    /** The style modifier */
    private String style = "";
    /** The CMap name associated with this font */
    private String CMap;
    
    private boolean cidDirect = false;
    
    private char[] translationMap;
    private IntHashtable vMetrics;
    private IntHashtable hMetrics;
    private HashMap fontDesc;
    private boolean vertical = false;
    
    private static void loadProperties() {
        if (propertiesLoaded)
            return;
        synchronized (allFonts) {
            if (propertiesLoaded)
                return;
            try {
                InputStream is = getResourceStream(RESOURCE_PATH + "cjkfonts.properties");
                cjkFonts.load(is);
                is.close();
                is = getResourceStream(RESOURCE_PATH + "cjkencodings.properties");
                cjkEncodings.load(is);
                is.close();
            }
            catch (Exception e) {
                cjkFonts = new Properties();
                cjkEncodings = new Properties();
            }
            propertiesLoaded = true;
        }
    }
    
    /** Creates a CJK font.
     * @param fontName the name of the font
     * @param enc the encoding of the font
     * @param emb always <CODE>false</CODE>. CJK font and not embedded
     * @throws DocumentException on error
     * @throws IOException on error
     */
    CJKFont(String fontName, String enc, boolean emb) throws DocumentException, IOException {
        loadProperties();
        fontType = FONT_TYPE_CJK;
        String nameBase = getBaseName(fontName);
        if (!isCJKFont(nameBase, enc))
            throw new DocumentException("Font '" + fontName + "' with '" + enc + "' encoding is not a CJK font.");
        if (nameBase.length() < fontName.length()) {
            style = fontName.substring(nameBase.length());
            fontName = nameBase;
        }
        this.fontName = fontName;
        encoding = CJK_ENCODING;
        vertical = enc.endsWith("V");
        CMap = enc;
        if (enc.startsWith("Identity-")) {
            cidDirect = true;
            String s = cjkFonts.getProperty(fontName);
            s = s.substring(0, s.indexOf('_'));
            char c[] = (char[])allCMaps.get(s);
            if (c == null) {
                c = readCMap(s);
                if (c == null)
                    throw new DocumentException("The cmap " + s + " does not exist as a resource.");
                c[CID_NEWLINE] = '\n';
                allCMaps.put(s, c);
            }
            translationMap = c;
        }
        else {
            char c[] = (char[])allCMaps.get(enc);
            if (c == null) {
                String s = cjkEncodings.getProperty(enc);
                if (s == null)
                    throw new DocumentException("The resource cjkencodings.properties does not contain the encoding " + enc);
                StringTokenizer tk = new StringTokenizer(s);
                String nt = tk.nextToken();
                c = (char[])allCMaps.get(nt);
                if (c == null) {
                    c = readCMap(nt);
                    allCMaps.put(nt, c);
                }
                if (tk.hasMoreTokens()) {
                    String nt2 = tk.nextToken();
                    char m2[] = readCMap(nt2);
                    for (int k = 0; k < 0x10000; ++k) {
                        if (m2[k] == 0)
                            m2[k] = c[k];
                    }
                    allCMaps.put(enc, m2);
                    c = m2;
                }
            }
            translationMap = c;
        }
        fontDesc = (HashMap)allFonts.get(fontName);
        if (fontDesc == null) {
            fontDesc = readFontProperties(fontName);
            allFonts.put(fontName, fontDesc);
        }
        hMetrics = (IntHashtable)fontDesc.get("W");
        vMetrics = (IntHashtable)fontDesc.get("W2");
    }
    
    /** Checks if its a valid CJK font.
     * @param fontName the font name
     * @param enc the encoding
     * @return <CODE>true</CODE> if it is CJK font
     */
    public static boolean isCJKFont(String fontName, String enc) {
        loadProperties();
        String encodings = cjkFonts.getProperty(fontName);
        return (encodings != null && (enc.equals("Identity-H") || enc.equals("Identity-V") || encodings.indexOf("_" + enc + "_") >= 0));
    }
        
    public int getWidth(String text) {
        int total = 0;
        for (int k = 0; k < text.length(); ++k) {
            int c = text.charAt(k);
            if (!cidDirect)
                c = translationMap[c];
            int v;
            if (vertical)
                v = vMetrics.get(c);
            else
                v = hMetrics.get(c);
            if (v > 0)
                total += v;
            else
                total += 1000;
        }
        return total;
    }
    
    int getRawWidth(int c, String name) {
        return 0;
    }
  
    public int getKerning(char char1, char char2) {
        return 0;
    }

    private PdfDictionary getFontDescriptor() {
        PdfDictionary dic = new PdfDictionary(PdfName.FONTDESCRIPTOR);
        dic.put(PdfName.ASCENT, new PdfLiteral((String)fontDesc.get("Ascent")));
        dic.put(PdfName.CAPHEIGHT, new PdfLiteral((String)fontDesc.get("CapHeight")));
        dic.put(PdfName.DESCENT, new PdfLiteral((String)fontDesc.get("Descent")));
        dic.put(PdfName.FLAGS, new PdfLiteral((String)fontDesc.get("Flags")));
        dic.put(PdfName.FONTBBOX, new PdfLiteral((String)fontDesc.get("FontBBox")));
        dic.put(PdfName.FONTNAME, new PdfName(fontName + style));
        dic.put(PdfName.ITALICANGLE, new PdfLiteral((String)fontDesc.get("ItalicAngle")));
        dic.put(PdfName.STEMV, new PdfLiteral((String)fontDesc.get("StemV")));
        PdfDictionary pdic = new PdfDictionary();
        pdic.put(PdfName.PANOSE, new PdfString((String)fontDesc.get("Panose"), null));
        dic.put(PdfName.STYLE, pdic);
        return dic;
    }
    
    private PdfDictionary getCIDFont(PdfIndirectReference fontDescriptor, IntHashtable cjkTag) {
        PdfDictionary dic = new PdfDictionary(PdfName.FONT);
        dic.put(PdfName.SUBTYPE, PdfName.CIDFONTTYPE0);
        dic.put(PdfName.BASEFONT, new PdfName(fontName + style));
        dic.put(PdfName.FONTDESCRIPTOR, fontDescriptor);
        int keys[] = cjkTag.toOrderedKeys();
        String w = convertToHCIDMetrics(keys, hMetrics);
        if (w != null)
            dic.put(PdfName.W, new PdfLiteral(w));
        if (vertical) {
            w = convertToVCIDMetrics(keys, vMetrics, hMetrics);;
            if (w != null)
                dic.put(PdfName.W2, new PdfLiteral(w));
        }
        else
            dic.put(PdfName.DW, new PdfNumber(1000));
        PdfDictionary cdic = new PdfDictionary();
        cdic.put(PdfName.REGISTRY, new PdfString((String)fontDesc.get("Registry"), null));
        cdic.put(PdfName.ORDERING, new PdfString((String)fontDesc.get("Ordering"), null));
        cdic.put(PdfName.SUPPLEMENT, new PdfLiteral((String)fontDesc.get("Supplement")));
        dic.put(PdfName.CIDSYSTEMINFO, cdic);
        return dic;
    }
    
    private PdfDictionary getFontBaseType(PdfIndirectReference CIDFont) {
        PdfDictionary dic = new PdfDictionary(PdfName.FONT);
        dic.put(PdfName.SUBTYPE, PdfName.TYPE0);
        String name = fontName;
        if (style.length() > 0)
            name += "-" + style.substring(1);
        name += "-" + CMap;
        dic.put(PdfName.BASEFONT, new PdfName(name));
        dic.put(PdfName.ENCODING, new PdfName(CMap));
        dic.put(PdfName.DESCENDANTFONTS, new PdfArray(CIDFont));
        return dic;
    }
    
    void writeFont(PdfWriter writer, PdfIndirectReference ref, Object params[]) throws DocumentException, IOException {
        IntHashtable cjkTag = (IntHashtable)params[0];
        PdfIndirectReference ind_font = null;
        PdfObject pobj = null;
        PdfIndirectObject obj = null;
        pobj = getFontDescriptor();
        if (pobj != null){
            obj = writer.addToBody(pobj);
            ind_font = obj.getIndirectReference();
        }
        pobj = getCIDFont(ind_font, cjkTag);
        if (pobj != null){
            obj = writer.addToBody(pobj);
            ind_font = obj.getIndirectReference();
        }
        pobj = getFontBaseType(ind_font);
        writer.addToBody(pobj, ref);
    }
    
    private float getDescNumber(String name) {
        return Integer.parseInt((String)fontDesc.get(name));
    }
    
    private float getBBox(int idx) {
        String s = (String)fontDesc.get("FontBBox");
        StringTokenizer tk = new StringTokenizer(s, " []\r\n\t\f");
        String ret = tk.nextToken();
        for (int k = 0; k < idx; ++k)
            ret = tk.nextToken();
        return Integer.parseInt(ret);
    }
    
    /** Gets the font parameter identified by <CODE>key</CODE>. Valid values
     * for <CODE>key</CODE> are <CODE>ASCENT</CODE>, <CODE>CAPHEIGHT</CODE>, <CODE>DESCENT</CODE>
     * and <CODE>ITALICANGLE</CODE>.
     * @param key the parameter to be extracted
     * @param fontSize the font size in points
     * @return the parameter in points
     */
    public float getFontDescriptor(int key, float fontSize) {
        switch (key) {
            case AWT_ASCENT:
            case ASCENT:
                return getDescNumber("Ascent") * fontSize / 1000;
            case CAPHEIGHT:
                return getDescNumber("CapHeight") * fontSize / 1000;
            case AWT_DESCENT:
            case DESCENT:
                return getDescNumber("Descent") * fontSize / 1000;
            case ITALICANGLE:
                return getDescNumber("ItalicAngle");
            case BBOXLLX:
                return fontSize * getBBox(0) / 1000;
            case BBOXLLY:
                return fontSize * getBBox(1) / 1000;
            case BBOXURX:
                return fontSize * getBBox(2) / 1000;
            case BBOXURY:
                return fontSize * getBBox(3) / 1000;
            case AWT_LEADING:
                return 0;
            case AWT_MAXADVANCE:
                return fontSize * (getBBox(2) - getBBox(0)) / 1000;
        }
        return 0;
    }
    
    public String getPostscriptFontName() {
        return fontName;
    }
    
    /** Gets the full name of the font. If it is a True Type font
     * each array element will have {Platform ID, Platform Encoding ID,
     * Language ID, font name}. The interpretation of this values can be
     * found in the Open Type specification, chapter 2, in the 'name' table.<br>
     * For the other fonts the array has a single element with {"", "", "",
     * font name}.
     * @return the full name of the font
     */
    public String[][] getFullFontName() {
        return new String[][]{{"", "", "", fontName}};
    }
    
    /** Gets the family name of the font. If it is a True Type font
     * each array element will have {Platform ID, Platform Encoding ID,
     * Language ID, font name}. The interpretation of this values can be
     * found in the Open Type specification, chapter 2, in the 'name' table.<br>
     * For the other fonts the array has a single element with {"", "", "",
     * font name}.
     * @return the family name of the font
     */
    public String[][] getFamilyFontName() {
        return getFullFontName();
    }
    
    static char[] readCMap(String name) {
        try {
            name = name + ".cmap";
            InputStream is = getResourceStream(RESOURCE_PATH + name);
            char c[] = new char[0x10000];
            for (int k = 0; k < 0x10000; ++k)
                c[k] = (char)((is.read() << 8) + is.read());
            return c;
        }
        catch (Exception e) {
            // empty on purpose
        }
        return null;
    }
    
    static IntHashtable createMetric(String s) {
        IntHashtable h = new IntHashtable();
        StringTokenizer tk = new StringTokenizer(s);
        while (tk.hasMoreTokens()) {
            int n1 = Integer.parseInt(tk.nextToken());
            h.put(n1, Integer.parseInt(tk.nextToken()));
        }
        return h;
    }
    
    static String convertToHCIDMetrics(int keys[], IntHashtable h) {
        if (keys.length == 0)
            return null;
        int lastCid = 0;
        int lastValue = 0;
        int start;
        for (start = 0; start < keys.length; ++start) {
            lastCid = keys[start];
            lastValue = h.get(lastCid);
            if (lastValue != 0) {
                ++start;
                break;
            }
        }
        if (lastValue == 0)
            return null;
        StringBuffer buf = new StringBuffer();
        buf.append('[');
        buf.append(lastCid);
        int state = FIRST;
        for (int k = start; k < keys.length; ++k) {
            int cid = keys[k];
            int value = h.get(cid);
            if (value == 0)
                continue;
            switch (state) {
                case FIRST: {
                    if (cid == lastCid + 1 && value == lastValue) {
                        state = SERIAL;
                    }
                    else if (cid == lastCid + 1) {
                        state = BRACKET;
                        buf.append('[').append(lastValue);
                    }
                    else {
                        buf.append('[').append(lastValue).append(']').append(cid);
                    }
                    break;
                }
                case BRACKET: {
                    if (cid == lastCid + 1 && value == lastValue) {
                        state = SERIAL;
                        buf.append(']').append(lastCid);
                    }
                    else if (cid == lastCid + 1) {
                        buf.append(' ').append(lastValue);
                    }
                    else {
                        state = FIRST;
                        buf.append(' ').append(lastValue).append(']').append(cid);
                    }
                    break;
                }
                case SERIAL: {
                    if (cid != lastCid + 1 || value != lastValue) {
                        buf.append(' ').append(lastCid).append(' ').append(lastValue).append(' ').append(cid);
                        state = FIRST;
                    }
                    break;
                }
            }
            lastValue = value;
            lastCid = cid;
        }
        switch (state) {
            case FIRST: {
                buf.append('[').append(lastValue).append("]]");
                break;
            }
            case BRACKET: {
                buf.append(' ').append(lastValue).append("]]");
                break;
            }
            case SERIAL: {
                buf.append(' ').append(lastCid).append(' ').append(lastValue).append(']');
                break;
            }
        }
        return buf.toString();
    }
    
    static String convertToVCIDMetrics(int keys[], IntHashtable v, IntHashtable h) {
        if (keys.length == 0)
            return null;
        int lastCid = 0;
        int lastValue = 0;
        int lastHValue = 0;
        int start;
        for (start = 0; start < keys.length; ++start) {
            lastCid = keys[start];
            lastValue = v.get(lastCid);
            if (lastValue != 0) {
                ++start;
                break;
            }
            else
                lastHValue = h.get(lastCid);
        }
        if (lastValue == 0)
            return null;
        if (lastHValue == 0)
            lastHValue = 1000;
        StringBuffer buf = new StringBuffer();
        buf.append('[');
        buf.append(lastCid);
        int state = FIRST;
        for (int k = start; k < keys.length; ++k) {
            int cid = keys[k];
            int value = v.get(cid);
            if (value == 0)
                continue;
            int hValue = h.get(lastCid);
            if (hValue == 0)
                hValue = 1000;
            switch (state) {
                case FIRST: {
                    if (cid == lastCid + 1 && value == lastValue && hValue == lastHValue) {
                        state = SERIAL;
                    }
                    else {
                        buf.append(' ').append(lastCid).append(' ').append(-lastValue).append(' ').append(lastHValue / 2).append(' ').append(V1Y).append(' ').append(cid);
                    }
                    break;
                }
                case SERIAL: {
                    if (cid != lastCid + 1 || value != lastValue || hValue != lastHValue) {
                        buf.append(' ').append(lastCid).append(' ').append(-lastValue).append(' ').append(lastHValue / 2).append(' ').append(V1Y).append(' ').append(cid);
                        state = FIRST;
                    }
                    break;
                }
            }
            lastValue = value;
            lastCid = cid;
            lastHValue = hValue;
        }
        buf.append(' ').append(lastCid).append(' ').append(-lastValue).append(' ').append(lastHValue / 2).append(' ').append(V1Y).append(" ]");
        return buf.toString();
    }
    
    static HashMap readFontProperties(String name) {
        try {
            name += ".properties";
            InputStream is = getResourceStream(RESOURCE_PATH + name);
            Properties p = new Properties();
            p.load(is);
            is.close();
            IntHashtable W = createMetric(p.getProperty("W"));
            p.remove("W");
            IntHashtable W2 = createMetric(p.getProperty("W2"));
            p.remove("W2");
            HashMap map = new HashMap();
            for (Enumeration e = p.keys(); e.hasMoreElements();) {
                Object obj = e.nextElement();
                map.put(obj, p.getProperty((String)obj));
            }
            map.put("W", W);
            map.put("W2", W2);
            return map;
        }
        catch (Exception e) {
            // empty on purpose
        }
        return null;
    }

    public char getUnicodeEquivalent(char c) {
        if (cidDirect)
            return translationMap[c];
        return c;
    }
    
    public char getCidCode(char c) {
        if (cidDirect)
            return c;
        return translationMap[c];
    }
    
    /** Checks if the font has any kerning pairs.
     * @return always <CODE>false</CODE>
     */    
    public boolean hasKernPairs() {
        return false;
    }
    
    /**
     * Checks if a character exists in this font.
     * @param c the character to check
     * @return <CODE>true</CODE> if the character has a glyph,
     * <CODE>false</CODE> otherwise
     */
    public boolean charExists(char c) {
        return translationMap[c] != 0;
    }
    
    /**
     * Sets the character advance.
     * @param c the character
     * @param advance the character advance normalized to 1000 units
     * @return <CODE>true</CODE> if the advance was set,
     * <CODE>false</CODE> otherwise. Will always return <CODE>false</CODE>
     */
    public boolean setCharAdvance(char c, int advance) {
        return false;
    }
    
    /**
     * Sets the font name that will appear in the pdf font dictionary.
     * Use with care as it can easily make a font unreadable if not embedded.
     * @param name the new font name
     */    
    public void setPostscriptFontName(String name) {
        fontName = name;
    }   
    
    public boolean setKerning(char char1, char char2, int kern) {
        return false;
    }
    
    public int[] getCharBBox(char c) {
        return null;
    }
    
    protected int[] getRawCharBBox(int c, String name) {
        return null;
    }
} /*
 * $Id: CMYKColor.java,v 1.43 2005/05/02 11:12:44 blowagie Exp $
 * $Name:  $
 *
 * Copyright 2001, 2002 by Paulo Soares.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf;

/**
 *
 * @author  Paulo Soares (psoares@consiste.pt)
 */
public class CMYKColor extends ExtendedColor {

    /** A serial version UID */
    private static final long serialVersionUID = 5940378778276468452L;

    float cyan;
    float magenta;
    float yellow;
    float black;

    /**
     * Constructs a CMYK Color beased on 4 colorvalues (values are integers from 0 to 255).
     * @param intCyan
     * @param intMagenta
     * @param intYellow
     * @param intBlack
     */
    public CMYKColor(int intCyan, int intMagenta, int intYellow, int intBlack) {
        this((float)intCyan / 255f, (float)intMagenta / 255f, (float)intYellow / 255f, (float)intBlack / 255f);
    }

    /**
     * Construct a CMYK Color.
     * @param floatCyan
     * @param floatMagenta
     * @param floatYellow
     * @param floatBlack
     */
    public CMYKColor(float floatCyan, float floatMagenta, float floatYellow, float floatBlack) {
        super(TYPE_CMYK, 1f - floatCyan - floatBlack, 1f - floatMagenta - floatBlack, 1f - floatYellow - floatBlack);
        cyan = normalize(floatCyan);
        magenta = normalize(floatMagenta);
        yellow = normalize(floatYellow);
        black = normalize(floatBlack);
    }
    
    /**
     * @return the cyan value
     */
    public float getCyan() {
        return cyan;
    }

    /**
     * @return the magenta value
     */
    public float getMagenta() {
        return magenta;
    }

    /**
     * @return the yellow value
     */
    public float getYellow() {
        return yellow;
    }

    /**
     * @return the black value
     */
    public float getBlack() {
        return black;
    }

}
 /*
 * $Id: ColorDetails.java,v 1.11 2002/06/20 13:06:47 blowagie Exp $
 * $Name:  $
 *
 * Copyright 2001, 2002 by Paulo Soares.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf;

import java.io.IOException;
/** Each spotcolor in the document will have an instance of this class
 *
 * @author Phillip Pan (phillip@formstar.com)
 */
class ColorDetails {

    /** The indirect reference to this color
     */
    PdfIndirectReference indirectReference;
    /** The color name that appears in the document body stream
     */
    PdfName colorName;
    /** The color
     */
    PdfSpotColor spotcolor;

    /** Each spot color used in a document has an instance of this class.
     * @param colorName the color name
     * @param indirectReference the indirect reference to the font
     * @param scolor the <CODE>PDfSpotColor</CODE>
     */
    ColorDetails(PdfName colorName, PdfIndirectReference indirectReference, PdfSpotColor scolor) {
        this.colorName = colorName;
        this.indirectReference = indirectReference;
        this.spotcolor = scolor;
    }

    /** Gets the indirect reference to this color.
     * @return the indirect reference to this color
     */
    PdfIndirectReference getIndirectReference() {
        return indirectReference;
    }

    /** Gets the color name as it appears in the document body.
     * @return the color name
     */
    PdfName getColorName() {
        return colorName;
    }

    /** Gets the <CODE>SpotColor</CODE> object.
     * @return the <CODE>PdfSpotColor</CODE>
     */
    PdfObject getSpotColor(PdfWriter writer) throws IOException {
        return spotcolor.getSpotObject(writer);
    }
}
 /*
 * $Id: ColumnText.java,v 1.58 2005/01/11 14:14:58 blowagie Exp $
 * $Name:  $
 *
 * Copyright 2001, 2002 by Paulo Soares.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text.pdf;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Stack;
import java.util.Iterator;
import pdftk.com.lowagie.text.Phrase;
import pdftk.com.lowagie.text.Chunk;
import pdftk.com.lowagie.text.Paragraph;
// import pdftk.com.lowagie.text.Graphic; ssteward: dropped in 1.44
import pdftk.com.lowagie.text.ListItem;
import pdftk.com.lowagie.text.Element;
import pdftk.com.lowagie.text.DocumentException;
import pdftk.com.lowagie.text.ExceptionConverter;
// import pdftk.com.lowagie.text.Image; ssteward: dropped in 1.44

/**
 * Formats text in a columnwise form. The text is bound
 * on the left and on the right by a sequence of lines. This allows the column
 * to have any shape, not only rectangular.
 * <P>
 * Several parameters can be set like the first paragraph line indent and
 * extra space between paragraphs.
 * <P>
 * A call to the method <CODE>go</CODE> will return one of the following
 * situations: the column ended or the text ended.
 * <P>
 * I the column ended, a new column definition can be loaded with the method
 * <CODE>setColumns</CODE> and the method <CODE>go</CODE> can be called again.
 * <P>
 * If the text ended, more text can be loaded with <CODE>addText</CODE>
 * and the method <CODE>go</CODE> can be called again.<BR>
 * The only limitation is that one or more complete paragraphs must be loaded
 * each time.
 * <P>
 * Full bidirectional reordering is supported. If the run direction is
 * <CODE>PdfWriter.RUN_DIRECTION_RTL</CODE> the meaning of the horizontal
 * alignments and margins is mirrored.
 * @author Paulo Soares (psoares@consiste.pt)
 */

public class ColumnText {
    /** Eliminate the arabic vowels */    
    public static final int AR_NOVOWEL = ArabicLigaturizer.ar_novowel;
    /** Compose the tashkeel in the ligatures. */    
    public static final int AR_COMPOSEDTASHKEEL = ArabicLigaturizer.ar_composedtashkeel;
    /** Do some extra double ligatures. */    
    public static final int AR_LIG = ArabicLigaturizer.ar_lig;
    /**
     * Digit shaping option: Replace European digits (U+0030...U+0039) by Arabic-Indic digits.
     */
    public static final int DIGITS_EN2AN = ArabicLigaturizer.DIGITS_EN2AN;
    
    /**
     * Digit shaping option: Replace Arabic-Indic digits by European digits (U+0030...U+0039).
     */
    public static final int DIGITS_AN2EN = ArabicLigaturizer.DIGITS_AN2EN;
    
    /**
     * Digit shaping option:
     * Replace European digits (U+0030...U+0039) by Arabic-Indic digits
     * if the most recent strongly directional character
     * is an Arabic letter (its Bidi direction value is RIGHT_TO_LEFT_ARABIC).
     * The initial state at the start of the text is assumed to be not an Arabic,
     * letter, so European digits at the start of the text will not change.
     * Compare to DIGITS_ALEN2AN_INIT_AL.
     */
    public static final int DIGITS_EN2AN_INIT_LR = ArabicLigaturizer.DIGITS_EN2AN_INIT_LR;
    
    /**
     * Digit shaping option:
     * Replace European digits (U+0030...U+0039) by Arabic-Indic digits
     * if the most recent strongly directional character
     * is an Arabic letter (its Bidi direction value is RIGHT_TO_LEFT_ARABIC).
     * The initial state at the start of the text is assumed to be an Arabic,
     * letter, so European digits at the start of the text will change.
     * Compare to DIGITS_ALEN2AN_INT_LR.
     */
    public static final int DIGITS_EN2AN_INIT_AL = ArabicLigaturizer.DIGITS_EN2AN_INIT_AL;
    
    /**
     * Digit type option: Use Arabic-Indic digits (U+0660...U+0669).
     */
    public static final int DIGIT_TYPE_AN = ArabicLigaturizer.DIGIT_TYPE_AN;
    
    /**
     * Digit type option: Use Eastern (Extended) Arabic-Indic digits (U+06f0...U+06f9).
     */
    public static final int DIGIT_TYPE_AN_EXTENDED = ArabicLigaturizer.DIGIT_TYPE_AN_EXTENDED;
    
    protected int runDirection = PdfWriter.RUN_DIRECTION_DEFAULT;
    
    /** the space char ratio */
    public static final float GLOBAL_SPACE_CHAR_RATIO = 0;
    
    /** Signals that there is no more text available. */
    public static final int NO_MORE_TEXT = 1;
    
    /** Signals that there is no more column. */
    public static final int NO_MORE_COLUMN = 2;
    
    /** The column is valid. */
    protected static final int LINE_STATUS_OK = 0;
    
    /** The line is out the column limits. */
    protected static final int LINE_STATUS_OFFLIMITS = 1;
    
    /** The line cannot fit this column position. */
    protected static final int LINE_STATUS_NOLINE = 2;
    
    /** Upper bound of the column. */
    protected float maxY;
    
    /** Lower bound of the column. */
    protected float minY;
    
    protected float leftX;
    
    protected float rightX;
    
    /** The column alignment. Default is left alignment. */
    protected int alignment = Element.ALIGN_LEFT;
    
    /** The left column bound. */
    protected ArrayList leftWall;
    
    /** The right column bound. */
    protected ArrayList rightWall;
    
    /** The chunks that form the text. */
//    protected ArrayList chunks = new ArrayList();
    protected BidiLine bidiLine;
    
    /** The current y line location. Text will be written at this line minus the leading. */
    protected float yLine;
    
    /** The leading for the current line. */
    protected float currentLeading = 16;
    
    /** The fixed text leading. */
    protected float fixedLeading = 16;
    
    /** The text leading that is multiplied by the biggest font size in the line. */
    protected float multipliedLeading = 0;
    
    /** The <CODE>PdfContent</CODE> where the text will be written to. */
    protected PdfContentByte canvas;
    
    /** The line status when trying to fit a line to a column. */
    protected int lineStatus;
    
    /** The first paragraph line indent. */
    protected float indent = 0;
    
    /** The following paragraph lines indent. */
    protected float followingIndent = 0;
    
    /** The right paragraph lines indent. */
    protected float rightIndent = 0;
    
    /** The extra space between paragraphs. */
    protected float extraParagraphSpace = 0;
    
    /** The width of the line when the column is defined as a simple rectangle. */
    protected float rectangularWidth = -1;
    
    protected boolean rectangularMode = false;
    /** Holds value of property spaceCharRatio. */
    private float spaceCharRatio = GLOBAL_SPACE_CHAR_RATIO;

    private boolean lastWasNewline = true;
    
    /** Holds value of property linesWritten. */
    private int linesWritten;
    
    private float firstLineY;
    private boolean firstLineYDone = false;
    
    /** Holds value of property arabicOptions. */
    private int arabicOptions = 0;
    
    protected float descender;
    
    protected boolean composite = false;
    
    protected ColumnText compositeColumn;
    
    protected LinkedList compositeElements;
    
    protected int listIdx = 0;
    
    private boolean splittedRow;
    
    protected Phrase waitPhrase;
    
    /** if true, first line height is adjusted so that the max ascender touches the top */
    private boolean useAscender = false;

    /**
     * Creates a <CODE>ColumnText</CODE>.
     * @param canvas the place where the text will be written to. Can
     * be a template.
     */
    public ColumnText(PdfContentByte canvas) {
        this.canvas = canvas;
    }
    
    /** Creates an independent duplicated of the instance <CODE>org</CODE>.
     * @param org the original <CODE>ColumnText</CODE>
     * @return the duplicated
     */    
    public static ColumnText duplicate(ColumnText org) {
        ColumnText ct = new ColumnText(null);
        ct.setACopy(org);
        return ct;
    }
    
    /** Makes this instance an independent copy of <CODE>org</CODE>.
     * @param org the original <CODE>ColumnText</CODE>
     * @return itself
     */    
    public ColumnText setACopy(ColumnText org) {
        setSimpleVars(org);
        if (org.bidiLine != null)
            bidiLine = new BidiLine(org.bidiLine);
        return this;
    }
    
    protected void setSimpleVars(ColumnText org) {
        maxY = org.maxY;
        minY = org.minY;
        alignment = org.alignment;
        leftWall = null;
        if (org.leftWall != null)
            leftWall = new ArrayList(org.leftWall);
        rightWall = null;
        if (org.rightWall != null)
            rightWall = new ArrayList(org.rightWall);
        yLine = org.yLine;
        currentLeading = org.currentLeading;
        fixedLeading = org.fixedLeading;
        multipliedLeading = org.multipliedLeading;
        canvas = org.canvas;
        lineStatus = org.lineStatus;
        indent = org.indent;
        followingIndent = org.followingIndent;
        rightIndent = org.rightIndent;
        extraParagraphSpace = org.extraParagraphSpace;
        rectangularWidth = org.rectangularWidth;
        rectangularMode = org.rectangularMode;
        spaceCharRatio = org.spaceCharRatio;
        lastWasNewline = org.lastWasNewline;
        linesWritten = org.linesWritten;
        arabicOptions = org.arabicOptions;
        runDirection = org.runDirection;
        descender = org.descender;
        composite = org.composite;
        splittedRow = org.splittedRow;
        if (org.composite) {
            compositeElements = new LinkedList(org.compositeElements);
	    /* ssteward: dropped in 1.44 
            if (splittedRow) {
                PdfPTable table = (PdfPTable)compositeElements.getFirst();
                compositeElements.set(0, new PdfPTable(table));
            }
	    */
            if (org.compositeColumn != null)
                compositeColumn = duplicate(org.compositeColumn);
        }
        listIdx = org.listIdx;
        firstLineY = org.firstLineY;
        leftX = org.leftX;
        rightX = org.rightX;
        firstLineYDone = org.firstLineYDone;
        waitPhrase = org.waitPhrase;
        useAscender = org.useAscender;
    }
    
    private void addWaitingPhrase() {
        if (bidiLine == null && waitPhrase != null) {
            bidiLine = new BidiLine();
            for (Iterator j = waitPhrase.getChunks().iterator(); j.hasNext();) {
                bidiLine.addChunk(new PdfChunk((Chunk)j.next(), null));
            }
            waitPhrase = null;
        }
    }
    
    /**
     * Adds a <CODE>Phrase</CODE> to the current text array.
     * Will not have any effect if addElement() was called before.
     * @param phrase the text
     */
    public void addText(Phrase phrase) {
        if (phrase == null || composite)
            return;
        addWaitingPhrase();
        if (bidiLine == null) {
            waitPhrase = phrase;
            return;
        }
        for (Iterator j = phrase.getChunks().iterator(); j.hasNext();) {
            bidiLine.addChunk(new PdfChunk((Chunk)j.next(), null));
        }
    }
    
    /**
     * Replaces the current text array with this <CODE>Phrase</CODE>.
     * Anything added previously with addElement() is lost.
     * @param phrase the text
     */
    public void setText(Phrase phrase) {
        bidiLine = null;
        composite = false;
        compositeColumn = null;
        compositeElements = null;
        listIdx = 0;
        splittedRow = false;
        waitPhrase = phrase;
    }
    
    /**
     * Adds a <CODE>Chunk</CODE> to the current text array.
     * Will not have any effect if addElement() was called before.
     * @param chunk the text
     */
    public void addText(Chunk chunk) {
        if (chunk == null || composite)
            return;
        addText(new Phrase(chunk));
    }
    
    /**
     * Adds an element. Elements supported are <CODE>Paragraph</CODE>,
     * <CODE>List</CODE>, <CODE>PdfPTable</CODE>, <CODE>Image</CODE> and
     * <CODE>Graphic</CODE>.
     * <p>
     * It removes all the text placed with <CODE>addText()</CODE>.
     * @param element the <CODE>Element</CODE>
     */    
    public void addElement(Element element) {
        if (element == null)
            return;
	/* ssteward: dropped in 1.44
        if (element instanceof Image) {
            Image img = (Image)element;
            PdfPTable t = new PdfPTable(1);
            float w = img.getWidthPercentage();
            if (w == 0) {
                t.setTotalWidth(img.scaledWidth());
                t.setLockedWidth(true);
            }
            else
                t.setWidthPercentage(w);
            t.setSpacingAfter(img.spacingAfter());
            t.setSpacingBefore(img.spacingBefore());
            switch (img.alignment()) {
                case Image.LEFT:
                    t.setHorizontalAlignment(Element.ALIGN_LEFT);
                    break;
                case Image.RIGHT:
                    t.setHorizontalAlignment(Element.ALIGN_RIGHT);
                    break;
                default:
                    t.setHorizontalAlignment(Element.ALIGN_CENTER);
                    break;
            }
            PdfPCell c = new PdfPCell(img, true);
            c.setPadding(0);
            c.setBorder(img.border());
            c.setBorderColor(img.borderColor());
            c.setBorderWidth(img.borderWidth());
            c.setBackgroundColor(img.backgroundColor());
            c.setGrayFill(img.grayFill());
            t.addCell(c);
            element = t;
        }
	*/
        if (element.type() == Element.CHUNK) {
        	element = new Paragraph((Chunk)element);
        }
        else if (element.type() == Element.PHRASE) {
        	element = new Paragraph((Phrase)element);
        }
        if (element.type() != Element.PARAGRAPH && element.type() != Element.LIST && element.type() != Element.PTABLE && element.type() != Element.GRAPHIC)
            throw new IllegalArgumentException("Element not allowed.");
        if (!composite) {
            composite = true;
            compositeElements = new LinkedList();
            bidiLine = null;
            waitPhrase = null;
        }
        compositeElements.add(element);
    }
    
    /**
     * Converts a sequence of lines representing one of the column bounds into
     * an internal format.
     * <p>
     * Each array element will contain a <CODE>float[4]</CODE> representing
     * the line x = ax + b.
     * @param cLine the column array
     * @return the converted array
     */
    protected ArrayList convertColumn(float cLine[]) {
        if (cLine.length < 4)
            throw new RuntimeException("No valid column line found.");
        ArrayList cc = new ArrayList();
        for (int k = 0; k < cLine.length - 2; k += 2) {
            float x1 = cLine[k];
            float y1 = cLine[k + 1];
            float x2 = cLine[k + 2];
            float y2 = cLine[k + 3];
            if (y1 == y2)
                continue;
            // x = ay + b
            float a = (x1 - x2) / (y1 - y2);
            float b = x1 - a * y1;
            float r[] = new float[4];
            r[0] = Math.min(y1, y2);
            r[1] = Math.max(y1, y2);
            r[2] = a;
            r[3] = b;
            cc.add(r);
            maxY = Math.max(maxY, r[1]);
            minY = Math.min(minY, r[0]);
        }
        if (cc.size() == 0)
            throw new RuntimeException("No valid column line found.");
        return cc;
    }
    
    /**
     * Finds the intersection between the <CODE>yLine</CODE> and the column. It will
     * set the <CODE>lineStatus</CODE> apropriatly.
     * @param wall the column to intersect
     * @return the x coordinate of the intersection
     */
    protected float findLimitsPoint(ArrayList wall) {
        lineStatus = LINE_STATUS_OK;
        if (yLine < minY || yLine > maxY) {
            lineStatus = LINE_STATUS_OFFLIMITS;
            return 0;
        }
        for (int k = 0; k < wall.size(); ++k) {
            float r[] = (float[])wall.get(k);
            if (yLine < r[0] || yLine > r[1])
                continue;
            return r[2] * yLine + r[3];
        }
        lineStatus = LINE_STATUS_NOLINE;
        return 0;
    }
    
    /**
     * Finds the intersection between the <CODE>yLine</CODE> and the two
     * column bounds. It will set the <CODE>lineStatus</CODE> apropriatly.
     * @return a <CODE>float[2]</CODE>with the x coordinates of the intersection
     */
    protected float[] findLimitsOneLine() {
        float x1 = findLimitsPoint(leftWall);
        if (lineStatus == LINE_STATUS_OFFLIMITS || lineStatus == LINE_STATUS_NOLINE)
            return null;
        float x2 = findLimitsPoint(rightWall);
        if (lineStatus == LINE_STATUS_NOLINE)
            return null;
        return new float[]{x1, x2};
    }
    
    /**
     * Finds the intersection between the <CODE>yLine</CODE>,
     * the <CODE>yLine-leading</CODE>and the two
     * column bounds. It will set the <CODE>lineStatus</CODE> apropriatly.
     * @return a <CODE>float[4]</CODE>with the x coordinates of the intersection
     */
    protected float[] findLimitsTwoLines() {
        boolean repeat = false;
        for (;;) {
            if (repeat && currentLeading == 0)
                return null;
            repeat = true;
            float x1[] = findLimitsOneLine();
            if (lineStatus == LINE_STATUS_OFFLIMITS)
                return null;
            yLine -= currentLeading;
            if (lineStatus == LINE_STATUS_NOLINE) {
                continue;
            }
            float x2[] = findLimitsOneLine();
            if (lineStatus == LINE_STATUS_OFFLIMITS)
                return null;
            if (lineStatus == LINE_STATUS_NOLINE) {
                yLine -= currentLeading;
                continue;
            }
            if (x1[0] >= x2[1] || x2[0] >= x1[1])
                continue;
            return new float[]{x1[0], x1[1], x2[0], x2[1]};
        }
    }
    
    /**
     * Sets the columns bounds. Each column bound is described by a
     * <CODE>float[]</CODE> with the line points [x1,y1,x2,y2,...].
     * The array must have at least 4 elements.
     * @param leftLine the left column bound
     * @param rightLine the right column bound
     */
    public void setColumns(float leftLine[], float rightLine[]) {
        maxY = -10e20f;
        minY = 10e20f;
        rightWall = convertColumn(rightLine);
        leftWall = convertColumn(leftLine);
        rectangularWidth = -1;
        rectangularMode = false;
    }
    
    /**
     * Simplified method for rectangular columns.
     * @param phrase a <CODE>Phrase</CODE>
     * @param llx the lower left x corner
     * @param lly the lower left y corner
     * @param urx the upper right x corner
     * @param ury the upper right y corner
     * @param leading the leading
     * @param alignment the column alignment
     */
    public void setSimpleColumn(Phrase phrase, float llx, float lly, float urx, float ury, float leading, int alignment) {
        addText(phrase);
        setSimpleColumn(llx, lly, urx, ury, leading, alignment);
    }
    
    /**
     * Simplified method for rectangular columns.
     * @param llx the lower left x corner
     * @param lly the lower left y corner
     * @param urx the upper right x corner
     * @param ury the upper right y corner
     * @param leading the leading
     * @param alignment the column alignment
     */
    public void setSimpleColumn(float llx, float lly, float urx, float ury, float leading, int alignment) {
        setLeading(leading);
        this.alignment = alignment;
        setSimpleColumn(llx, lly, urx, ury);
    }
    
    /**
     * Simplified method for rectangular columns.
     * @param llx
     * @param lly
     * @param urx
     * @param ury
     */
    public void setSimpleColumn(float llx, float lly, float urx, float ury) {
        leftX = Math.min(llx, urx);
        maxY = Math.max(lly, ury);
        minY = Math.min(lly, ury);
        rightX = Math.max(llx, urx);
        yLine = maxY;
        rectangularWidth = rightX - leftX;
        if (rectangularWidth < 0)
            rectangularWidth = 0;
        rectangularMode = true;
    }
    /**
     * Sets the leading to fixed
     * @param leading the leading
     */
    public void setLeading(float leading) {
        fixedLeading = leading;
        multipliedLeading = 0;
    }
    
    /**
     * Sets the leading fixed and variable. The resultant leading will be
     * fixedLeading+multipliedLeading*maxFontSize where maxFontSize is the
     * size of the bigest font in the line.
     * @param fixedLeading the fixed leading
     * @param multipliedLeading the variable leading
     */
    public void setLeading(float fixedLeading, float multipliedLeading) {
        this.fixedLeading = fixedLeading;
        this.multipliedLeading = multipliedLeading;
    }
    
    /**
     * Gets the fixed leading
     * @return the leading
     */
    public float getLeading() {
        return fixedLeading;
    }
    
    /**
     * Gets the variable leading
     * @return the leading
     */
    public float getMultipliedLeading() {
        return multipliedLeading;
    }
    
    /**
     * Sets the yLine. The line will be written to yLine-leading.
     * @param yLine the yLine
     */
    public void setYLine(float yLine) {
        this.yLine = yLine;
    }
    
    /**
     * Gets the yLine.
     * @return the yLine
     */
    public float getYLine() {
        return yLine;
    }
    
    /**
     * Sets the alignment.
     * @param alignment the alignment
     */
    public void setAlignment(int alignment) {
        this.alignment = alignment;
    }
    
    /**
     * Gets the alignment.
     * @return the alignment
     */
    public int getAlignment() {
        return alignment;
    }
    
    /**
     * Sets the first paragraph line indent.
     * @param indent the indent
     */
    public void setIndent(float indent) {
        this.indent = indent;
        lastWasNewline = true;
    }
    
    /**
     * Gets the first paragraph line indent.
     * @return the indent
     */
    public float getIndent() {
        return indent;
    }
    
    /**
     * Sets the following paragraph lines indent.
     * @param indent the indent
     */
    public void setFollowingIndent(float indent) {
        this.followingIndent = indent;
        lastWasNewline = true;
    }
    
    /**
     * Gets the following paragraph lines indent.
     * @return the indent
     */
    public float getFollowingIndent() {
        return followingIndent;
    }
    
    /**
     * Sets the right paragraph lines indent.
     * @param indent the indent
     */
    public void setRightIndent(float indent) {
        this.rightIndent = indent;
        lastWasNewline = true;
    }
    
    /**
     * Gets the right paragraph lines indent.
     * @return the indent
     */
    public float getRightIndent() {
        return rightIndent;
    }
    
    /**
     * Outputs the lines to the document. It is equivalent to <CODE>go(false)</CODE>.
     * @return returns the result of the operation. It can be <CODE>NO_MORE_TEXT</CODE>
     * and/or <CODE>NO_MORE_COLUMN</CODE>
     * @throws DocumentException on error
     */
    public int go() throws DocumentException {
        return go(false);
    }
    
    /**
     * Outputs the lines to the document. The output can be simulated.
     * @param simulate <CODE>true</CODE> to simulate the writting to the document
     * @return returns the result of the operation. It can be <CODE>NO_MORE_TEXT</CODE>
     * and/or <CODE>NO_MORE_COLUMN</CODE>
     * @throws DocumentException on error
     */
    public int go(boolean simulate) throws DocumentException {
        if (composite)
            return goComposite(simulate);
        addWaitingPhrase();
        if (bidiLine == null)
            return NO_MORE_TEXT;
        descender = 0;
        linesWritten = 0;
        boolean dirty = false;
        float ratio = spaceCharRatio;
        Object currentValues[] = new Object[2];
        PdfFont currentFont = null;
        Float lastBaseFactor = new Float(0);
        currentValues[1] = lastBaseFactor;
        PdfDocument pdf = null;
        PdfContentByte graphics = null;
        PdfContentByte text = null;
        firstLineY = Float.NaN;
        int localRunDirection = PdfWriter.RUN_DIRECTION_NO_BIDI;
        if (runDirection != PdfWriter.RUN_DIRECTION_DEFAULT)
            localRunDirection = runDirection;
        if (canvas != null) {
            graphics = canvas;
            pdf = canvas.getPdfDocument();
            text = canvas.getDuplicate();
        }
        else if (!simulate)
            throw new NullPointerException("ColumnText.go with simulate==false and text==null.");
        if (!simulate) {
            if (ratio == GLOBAL_SPACE_CHAR_RATIO)
                ratio = text.getPdfWriter().getSpaceCharRatio();
            else if (ratio < 0.001f)
                ratio = 0.001f;
        }
        float firstIndent = 0;
        
        int status = 0;
        if (rectangularMode) {
            for (;;) {
                firstIndent = (lastWasNewline ? indent : followingIndent);
                if (rectangularWidth <= firstIndent + rightIndent) {
                    status = NO_MORE_COLUMN;
                    if (bidiLine.isEmpty())
                        status |= NO_MORE_TEXT;
                    break;
                }
                if (bidiLine.isEmpty()) {
                    status = NO_MORE_TEXT;
                    break;
                }
                PdfLine line = bidiLine.processLine(rectangularWidth - firstIndent - rightIndent, alignment, localRunDirection, arabicOptions);
                if (line == null) {
                    status = NO_MORE_TEXT;
                    break;
                }
                float maxSize = line.getMaxSizeSimple();
                if (isUseAscender() && Float.isNaN(firstLineY)) {
                    currentLeading = line.getAscender();
                }
                else {
                    currentLeading = fixedLeading + maxSize * multipliedLeading;
                }
                if (yLine > maxY || yLine - currentLeading < minY ) {
                    status = NO_MORE_COLUMN;
                    bidiLine.restore();
                    break;
                }
                yLine -= currentLeading;
                if (!simulate && !dirty) {
                    text.beginText();
                    dirty = true;
                }
                if (Float.isNaN(firstLineY)) {
                    firstLineY = yLine;
                }
                if (!simulate) {
                    currentValues[0] = currentFont;
                    text.setTextMatrix(leftX + (line.isRTL() ? rightIndent : firstIndent) + line.indentLeft(), yLine);
                    pdf.writeLineToContent(line, text, graphics, currentValues, ratio);
                    currentFont = (PdfFont)currentValues[0];
                }
                lastWasNewline = line.isNewlineSplit();
                yLine -= line.isNewlineSplit() ? extraParagraphSpace : 0;
                ++linesWritten;
                descender = line.getDescender();
            }
        }
        else {
            currentLeading = fixedLeading;
            for (;;) {
                firstIndent = (lastWasNewline ? indent : followingIndent);
                float yTemp = yLine;
                float xx[] = findLimitsTwoLines();
                if (xx == null) {
                    status = NO_MORE_COLUMN;
                    if (bidiLine.isEmpty())
                        status |= NO_MORE_TEXT;
                    yLine = yTemp;
                    break;
                }
                if (bidiLine.isEmpty()) {
                    status = NO_MORE_TEXT;
                    yLine = yTemp;
                    break;
                }
                float x1 = Math.max(xx[0], xx[2]);
                float x2 = Math.min(xx[1], xx[3]);
                if (x2 - x1 <= firstIndent + rightIndent)
                    continue;
                if (!simulate && !dirty) {
                    text.beginText();
                    dirty = true;
                }
                PdfLine line = bidiLine.processLine(x2 - x1 - firstIndent - rightIndent, alignment, localRunDirection, arabicOptions);
                if (line == null) {
                    status = NO_MORE_TEXT;
                    yLine = yTemp;
                    break;
                }
                if (!simulate) {
                    currentValues[0] = currentFont;
                    text.setTextMatrix(x1 + (line.isRTL() ? rightIndent : firstIndent) + line.indentLeft(), yLine);
                    pdf.writeLineToContent(line, text, graphics, currentValues, ratio);
                    currentFont = (PdfFont)currentValues[0];
                }
                lastWasNewline = line.isNewlineSplit();
                yLine -= line.isNewlineSplit() ? extraParagraphSpace : 0;
                ++linesWritten;
                descender = line.getDescender();
            }
        }
        if (dirty) {
            text.endText();
            canvas.add(text);
        }
        return status;
    }
    
    /**
     * Sets the extra space between paragraphs.
     * @return the extra space between paragraphs
     */
    public float getExtraParagraphSpace() {
        return extraParagraphSpace;
    }
    
    /**
     * Sets the extra space between paragraphs.
     * @param extraParagraphSpace the extra space between paragraphs
     */
    public void setExtraParagraphSpace(float extraParagraphSpace) {
        this.extraParagraphSpace = extraParagraphSpace;
    }
    
    /**
     * Clears the chunk array. A call to <CODE>go()</CODE> will always return
     * NO_MORE_TEXT.
     */
    public void clearChunks() {
        if (bidiLine != null)
            bidiLine.clearChunks();
    }
    
    /** Gets the space/character extra spacing ratio for
     * fully justified text.
     * @return the space/character extra spacing ratio
     */    
    public float getSpaceCharRatio() {
        return spaceCharRatio;
    }
    
    /** Sets the ratio between the extra word spacing and the extra character spacing
     * when the text is fully justified.
     * Extra word spacing will grow <CODE>spaceCharRatio</CODE> times more than extra character spacing.
     * If the ratio is <CODE>PdfWriter.NO_SPACE_CHAR_RATIO</CODE> then the extra character spacing
     * will be zero.
     * @param spaceCharRatio the ratio between the extra word spacing and the extra character spacing
     */
    public void setSpaceCharRatio(float spaceCharRatio) {
        this.spaceCharRatio = spaceCharRatio;
    }

    /** Sets the run direction. 
     * @param runDirection the run direction
     */    
    public void setRunDirection(int runDirection) {
        if (runDirection < PdfWriter.RUN_DIRECTION_DEFAULT || runDirection > PdfWriter.RUN_DIRECTION_RTL)
            throw new RuntimeException("Invalid run direction: " + runDirection);
        this.runDirection = runDirection;
    }
    
    /** Gets the run direction.
     * @return the run direction
     */    
    public int getRunDirection() {
        return runDirection;
    }
    
    /** Gets the number of lines written.
     * @return the number of lines written
     */
    public int getLinesWritten() {
        return this.linesWritten;
    }
    
    /** Gets the arabic shaping options.
     * @return the arabic shaping options
     */
    public int getArabicOptions() {
        return this.arabicOptions;
    }
    
    /** Sets the arabic shaping options. The option can be AR_NOVOWEL,
     * AR_COMPOSEDTASHKEEL and AR_LIG.
     * @param arabicOptions the arabic shaping options
     */
    public void setArabicOptions(int arabicOptions) {
        this.arabicOptions = arabicOptions;
    }
    
    /** Gets the biggest descender value of the last line written.
     * @return the biggest descender value of the last line written
     */    
    public float getDescender() {
        return descender;
    }
    
    /** Gets the width that the line will occupy after writing.
     * Only the width of the first line is returned.
     * @param phrase the <CODE>Phrase</CODE> containing the line
     * @param runDirection the run direction
     * @param arabicOptions the options for the arabic shaping
     * @return the width of the line
     */    
    public static float getWidth(Phrase phrase, int runDirection, int arabicOptions) {
        ColumnText ct = new ColumnText(null);
        ct.addText(phrase);
        ct.addWaitingPhrase();
        PdfLine line = ct.bidiLine.processLine(20000, Element.ALIGN_LEFT, runDirection, arabicOptions);
        if (line == null)
            return 0;
        else
            return 20000 - line.widthLeft();
    }
    
    /** Gets the width that the line will occupy after writing.
     * Only the width of the first line is returned.
     * @param phrase the <CODE>Phrase</CODE> containing the line
     * @return the width of the line
     */    
    public static float getWidth(Phrase phrase) {
        return getWidth(phrase, PdfWriter.RUN_DIRECTION_NO_BIDI, 0);
    }
    
    /** Shows a line of text. Only the first line is written.
     * @param canvas where the text is to be written to
     * @param alignment the alignment. It is not influenced by the run direction
     * @param phrase the <CODE>Phrase</CODE> with the text
     * @param x the x reference position
     * @param y the y reference position
     * @param rotation the rotation to be applied in degrees counterclockwise
     * @param runDirection the run direction
     * @param arabicOptions the options for the arabic shaping
     */    
    public static void showTextAligned(PdfContentByte canvas, int alignment, Phrase phrase, float x, float y, float rotation, int runDirection, int arabicOptions) {
        if (alignment != Element.ALIGN_LEFT && alignment != Element.ALIGN_CENTER
            && alignment != Element.ALIGN_RIGHT)
            alignment = Element.ALIGN_LEFT;
        canvas.saveState();
        ColumnText ct = new ColumnText(canvas);
        if (rotation == 0) {
            if (alignment == Element.ALIGN_LEFT)
                ct.setSimpleColumn(phrase, x, y - 1, 20000 + x, y + 2, 2, alignment);
            else if (alignment == Element.ALIGN_RIGHT)
                ct.setSimpleColumn(phrase, x-20000, y-1, x, y+2, 2, alignment);
            else
                ct.setSimpleColumn(phrase, x-20000, y-1, x+20000, y+2, 2, alignment);
        }
        else {
            double alpha = rotation * Math.PI / 180.0;
            float cos = (float)Math.cos(alpha);
            float sin = (float)Math.sin(alpha);
            canvas.concatCTM(cos, sin, -sin, cos, x, y);
            if (alignment == Element.ALIGN_LEFT)
                ct.setSimpleColumn(phrase, 0, -1, 20000, 2, 2, alignment);
            else if (alignment == Element.ALIGN_RIGHT)
                ct.setSimpleColumn(phrase, -20000, -1, 0, 2, 2, alignment);
            else
                ct.setSimpleColumn(phrase, -20000, -1, 20000, 2, 2, alignment);
        }
        if (runDirection == PdfWriter.RUN_DIRECTION_RTL) {
            if (alignment == Element.ALIGN_LEFT)
                alignment = Element.ALIGN_RIGHT;
            else if (alignment == Element.ALIGN_RIGHT)
                alignment = Element.ALIGN_LEFT;
        }
        ct.setAlignment(alignment);
        ct.setArabicOptions(arabicOptions);
        ct.setRunDirection(runDirection);
        try {
            ct.go();
        }
        catch (DocumentException e) {
            throw new ExceptionConverter(e);
        }
        canvas.restoreState();
    }

    /** Shows a line of text. Only the first line is written.
     * @param canvas where the text is to be written to
     * @param alignment the alignment
     * @param phrase the <CODE>Phrase</CODE> with the text
     * @param x the x reference position
     * @param y the y reference position
     * @param rotation the rotation to be applied in degrees counterclockwise
     */    
    public static void showTextAligned(PdfContentByte canvas, int alignment, Phrase phrase, float x, float y, float rotation) {
        showTextAligned(canvas, alignment, phrase, x, y, rotation, PdfWriter.RUN_DIRECTION_NO_BIDI, 0);
    }

    protected int goComposite(boolean simulate) throws DocumentException {
        if (!rectangularMode)
            throw new DocumentException("Irregular columns are not supported in composite mode.");
        linesWritten = 0;
        descender = 0;
        boolean firstPass = true;
        main_loop:
        while (true) {
            if (compositeElements.isEmpty())
                return NO_MORE_TEXT;
            Element element = (Element)compositeElements.getFirst();
            if (element.type() == Element.PARAGRAPH) {
                Paragraph para = (Paragraph)element;
                int status = 0;
                for (int keep = 0; keep < 2; ++keep) {
                    float lastY = yLine;
                    boolean createHere = false;
                    if (compositeColumn == null) {
                        compositeColumn = new ColumnText(canvas);
                        compositeColumn.setUseAscender(firstPass ? useAscender : false);
                        compositeColumn.setAlignment(para.alignment());
                        compositeColumn.setIndent(para.indentationLeft() + para.getFirstLineIndent());
                        compositeColumn.setExtraParagraphSpace(para.getExtraParagraphSpace());
                        compositeColumn.setFollowingIndent(para.indentationLeft());
                        compositeColumn.setRightIndent(para.indentationRight());
                        compositeColumn.setLeading(para.leading(), para.getMultipliedLeading());
                        compositeColumn.setRunDirection(runDirection);
                        compositeColumn.setArabicOptions(arabicOptions);
                        compositeColumn.setSpaceCharRatio(spaceCharRatio);
                        compositeColumn.addText(para);
                        if (!firstPass) {
                            yLine -= para.spacingBefore();
                        }
                        createHere = true;
                    }
                    compositeColumn.leftX = leftX;
                    compositeColumn.rightX = rightX;
                    compositeColumn.yLine = yLine;
                    compositeColumn.rectangularWidth = rectangularWidth;
                    compositeColumn.rectangularMode = rectangularMode;
                    compositeColumn.minY = minY;
                    compositeColumn.maxY = maxY;
                    boolean keepCandidate = (para.getKeepTogether() && createHere && !firstPass);
                    status = compositeColumn.go(simulate || (keepCandidate && keep == 0));
                    if ((status & NO_MORE_TEXT) == 0 && keepCandidate) {
                        compositeColumn = null;
                        yLine = lastY;
                        return NO_MORE_COLUMN;
                    }
                    if (simulate || !keepCandidate)
                        break;
                    if (keep == 0) {
                        compositeColumn = null;
                        yLine = lastY;
                    }
                }
                firstPass = false;
                yLine = compositeColumn.yLine;
                linesWritten += compositeColumn.linesWritten;
                descender = compositeColumn.descender;
                if ((status & NO_MORE_TEXT) != 0) {
                    compositeColumn = null;
                    compositeElements.removeFirst();
                    yLine -= para.spacingAfter();
                }
                if ((status & NO_MORE_COLUMN) != 0) {
                    return NO_MORE_COLUMN;
                }
            }
            else if (element.type() == Element.LIST) {
                pdftk.com.lowagie.text.List list = (pdftk.com.lowagie.text.List)element;
                ArrayList items = list.getItems();
                ListItem item = null;
                float listIndentation = list.indentationLeft();
                int count = 0;
                Stack stack = new Stack();
                for (int k = 0; k < items.size(); ++k) {
                    Object obj = items.get(k);
                    if (obj instanceof ListItem) {
                        if (count == listIdx) {
                            item = (ListItem)obj;
                            break;
                        }
                        else ++count;
                    }
                    else if (obj instanceof pdftk.com.lowagie.text.List) {
                        stack.push(new Object[]{list, new Integer(k), new Float(listIndentation)});
                        list = (pdftk.com.lowagie.text.List)obj;
                        items = list.getItems();
                        listIndentation += list.indentationLeft();
                        k = -1;
                        continue;
                    }
                    if (k == items.size() - 1) {
                        if (!stack.isEmpty()) {
                            Object objs[] = (Object[])stack.pop();
                            list = (pdftk.com.lowagie.text.List)objs[0];
                            items = list.getItems();
                            k = ((Integer)objs[1]).intValue();
                            listIndentation = ((Float)objs[2]).floatValue();
                        }
                    }
                }
                int status = 0;
                for (int keep = 0; keep < 2; ++keep) {
                    float lastY = yLine;
                    boolean createHere = false;
                    if (compositeColumn == null) {
                        if (item == null) {
                            listIdx = 0;
                            compositeElements.removeFirst();
                            continue main_loop;
                        }
                        compositeColumn = new ColumnText(canvas);
                        compositeColumn.setUseAscender(firstPass ? useAscender : false);
                        compositeColumn.setAlignment(item.alignment());
                        compositeColumn.setIndent(item.indentationLeft() + listIndentation + item.getFirstLineIndent());
                        compositeColumn.setExtraParagraphSpace(item.getExtraParagraphSpace());
                        compositeColumn.setFollowingIndent(compositeColumn.getIndent());
                        compositeColumn.setRightIndent(item.indentationRight() + list.indentationRight());
                        compositeColumn.setLeading(item.leading(), item.getMultipliedLeading());
                        compositeColumn.setRunDirection(runDirection);
                        compositeColumn.setArabicOptions(arabicOptions);
                        compositeColumn.setSpaceCharRatio(spaceCharRatio);
                        compositeColumn.addText(item);
                        if (!firstPass) {
                            yLine -= item.spacingBefore();
                        }
                        createHere = true;
                    }
                    compositeColumn.leftX = leftX;
                    compositeColumn.rightX = rightX;
                    compositeColumn.yLine = yLine;
                    compositeColumn.rectangularWidth = rectangularWidth;
                    compositeColumn.rectangularMode = rectangularMode;
                    compositeColumn.minY = minY;
                    compositeColumn.maxY = maxY;
                    boolean keepCandidate = (item.getKeepTogether() && createHere && !firstPass);
                    status = compositeColumn.go(simulate || (keepCandidate && keep == 0));
                    if ((status & NO_MORE_TEXT) == 0 && keepCandidate) {
                        compositeColumn = null;
                        yLine = lastY;
                        return NO_MORE_COLUMN;
                    }
                    if (simulate || !keepCandidate)
                        break;
                    if (keep == 0) {
                        compositeColumn = null;
                        yLine = lastY;
                    }
                }
                firstPass = false;
                yLine = compositeColumn.yLine;
                linesWritten += compositeColumn.linesWritten;
                descender = compositeColumn.descender;
                if (!Float.isNaN(compositeColumn.firstLineY) && !compositeColumn.firstLineYDone) {
                    if (!simulate)
                        showTextAligned(canvas, Element.ALIGN_LEFT, new Phrase(item.listSymbol()), compositeColumn.leftX + listIndentation, compositeColumn.firstLineY, 0);
                    compositeColumn.firstLineYDone = true;
                }
                if ((status & NO_MORE_TEXT) != 0) {
                    compositeColumn = null;
                    ++listIdx;
                    yLine -= item.spacingAfter();
                }
                if ((status & NO_MORE_COLUMN) != 0) {
                    return NO_MORE_COLUMN;
                }
            }
	    /* ssteward: dropped in 1.44 
            else if (element.type() == Element.PTABLE) {
                if (yLine < minY || yLine > maxY)
                    return NO_MORE_COLUMN;
                PdfPTable table = (PdfPTable)element;
                if (table.size() <= table.getHeaderRows()) {
                    compositeElements.removeFirst();
                    continue;
                }
                float yTemp = yLine;
                float yLineWrite = yLine;
                if (!firstPass && listIdx == 0) {
                    yTemp -= table.spacingBefore();
                    yLineWrite = yTemp;
                }
                currentLeading = 0;
                if (yTemp < minY || yTemp > maxY)
                    return NO_MORE_COLUMN;
                float x1 = leftX;
                float tableWidth;
                if (table.isLockedWidth())
                    tableWidth = table.getTotalWidth();
                else {
                    tableWidth = rectangularWidth * table.getWidthPercentage() / 100f;
                    table.setTotalWidth(tableWidth);
                }
                int k;
                boolean skipHeader = (!firstPass && table.isSkipFirstHeader() && listIdx <= table.getHeaderRows());
                if (!skipHeader) {
                    yTemp -= table.getHeaderHeight();
                    if (yTemp < minY || yTemp > maxY) {
                        if (firstPass) {
                            compositeElements.removeFirst();
                            continue;
                        }
                        return NO_MORE_COLUMN;
                    }
                }
                if (listIdx < table.getHeaderRows())
                    listIdx = table.getHeaderRows();
                for (k = listIdx; k < table.size(); ++k) {
                    float rowHeight = table.getRowHeight(k);
                    if (yTemp - rowHeight < minY)
                        break;
                    yTemp -= rowHeight;
                }
                if (k < table.size()) {
                    if (table.isSplitRows() && (!table.isSplitLate() || (k == listIdx && firstPass))) {
                        if (!splittedRow) {
                            splittedRow = true;
                            table = new PdfPTable(table);
                            compositeElements.set(0, table);
                            ArrayList rows = table.getRows();
                            for (int i = table.getHeaderRows(); i < listIdx; ++i)
                                rows.set(i, null);
                        }
                        float h = yTemp - minY;
                        PdfPRow newRow = table.getRow(k).splitRow(h);
                        if (newRow == null) {
                            if (k == listIdx)
                                return NO_MORE_COLUMN;
                        }
                        else {
                            yTemp = minY;
                            table.getRows().add(++k, newRow);
                        }
                    }
                    else if (!table.isSplitRows() && k == listIdx && firstPass) {
                        compositeElements.removeFirst();
                        splittedRow = false;
                        continue;
                    }
                    else if (k == listIdx && !firstPass && (!table.isSplitRows() || table.isSplitLate())) {
                            return NO_MORE_COLUMN;
                    }
                }
                firstPass = false;
                if (!simulate) {
                    switch (table.getHorizontalAlignment()) {
                        case Element.ALIGN_LEFT:
                            break;
                        case Element.ALIGN_RIGHT:
                            x1 += rectangularWidth - tableWidth;
                            break;
                        default:
                            x1 += (rectangularWidth - tableWidth) / 2f;
                    }
                    PdfPTable nt = PdfPTable.shallowCopy(table);
                    ArrayList rows = table.getRows();
                    ArrayList sub = nt.getRows();
                    if (!skipHeader) {
                        for (int j = 0; j < table.getHeaderRows(); ++j)
                            sub.add(rows.get(j));
                    }
                    else
                        nt.setHeaderRows(0);
                    for (int j = listIdx; j < k; ++j)
                        sub.add(rows.get(j));
                    float rowHeight = 0;
                    if (table.isExtendLastRow()) {
                        PdfPRow last = (PdfPRow)sub.get(sub.size() - 1);
                        rowHeight = last.getMaxHeights();
                        last.setMaxHeights(yTemp - minY + rowHeight);
                        yTemp = minY;
                    }
                    nt.writeSelectedRows(0, -1, x1, yLineWrite, canvas);
                    if (table.isExtendLastRow()) {
                        PdfPRow last = (PdfPRow)sub.get(sub.size() - 1);
                        last.setMaxHeights(rowHeight);
                    }
                }
                else if (table.isExtendLastRow() && minY > PdfPRow.BOTTOM_LIMIT)
                    yTemp = minY;
                yLine = yTemp;
                if (k >= table.size()) {
                    yLine -= table.spacingAfter();
                    compositeElements.removeFirst();
                    splittedRow = false;
                    listIdx = 0;
                }
                else {
                    if (splittedRow) {
                        ArrayList rows = table.getRows();
                        for (int i = listIdx; i < k; ++i)
                            rows.set(i, null);
                    }
                    listIdx = k;
                    return NO_MORE_COLUMN;
                }
            }
	    */
	    /* ssteward: dropped in 1.44
            else if (element.type() == Element.GRAPHIC) {
                if (!simulate) {
                    Graphic gr = (Graphic)element;
                    ByteBuffer bf = gr.getInternalBuffer();
                    ByteBuffer store = null;
                    if (bf.size() > 0) {
                        store = new ByteBuffer();
                        store.append(bf);
                        bf.reset();
                    }
                    gr.processAttributes(leftX, minY, rightX, maxY, yLine);
                    canvas.add(gr);
                    bf.reset();
                    if (store != null) {
                        bf.append(store);
                    }
                }
                compositeElements.removeFirst();
            }
	    */
            else
                compositeElements.removeFirst();
        }
    }
    
    /**
     * Gets the canvas.
     * @return a PdfContentByte.
     */
    public PdfContentByte getCanvas() {
        return canvas;
    }
    
    /**
     * Sets the canvas.
     * @param canvas
     */
    public void setCanvas(PdfContentByte canvas) {
        this.canvas = canvas;
        if (compositeColumn != null)
            compositeColumn.setCanvas(canvas);
    }
    
    /**
     * Checks if the element has a height of 0.
     * @return true or false
     */
    public boolean zeroHeightElement() {
        return composite == true && compositeElements.size() > 0 && ((Element)compositeElements.getFirst()).type() == Element.GRAPHIC;
    }

    /**
     * Checks if UseAscender is enabled/disabled.
     * @return true is the adjustment of the first line height is based on max ascender.
     */
    public boolean isUseAscender() {
        return useAscender;
    }

    /**
     * Enables/Disables adjustment of first line height based on max ascender.
     * @param use enable adjustment if true
     */
    public void setUseAscender(boolean use) {
        useAscender = use;
    }
} /*
 * $Id: Anchor.java,v 1.84 2005/05/03 13:03:49 blowagie Exp $
 * $Name:  $
 *
 * Copyright 1999, 2000, 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

import java.net.URL;
import java.net.MalformedURLException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Properties;

import pdftk.com.lowagie.text.markup.MarkupTags;
import pdftk.com.lowagie.text.markup.MarkupParser;

/**
 * An <CODE>Anchor</CODE> can be a reference or a destination of a reference.
 * <P>
 * An <CODE>Anchor</CODE> is a special kind of <CODE>Phrase</CODE>.
 * It is constructed in the same way.
 * <P>
 * Example:
 * <BLOCKQUOTE><PRE>
 * <STRONG>Anchor anchor = new Anchor("this is a link");</STRONG>
 * <STRONG>anchor.setName("LINK");</STRONG>
 * <STRONG>anchor.setReference("http://www.lowagie.com");</STRONG>
 * </PRE></BLOCKQUOTE>
 *
 * @see		Element
 * @see		Phrase
 */

public class Anchor extends Phrase implements TextElementArray, MarkupAttributes {
    
    // constant
    private static final long serialVersionUID = -852278536049236911L;

    // membervariables
    
/** This is the anchor tag. */
    public static final String ANCHOR = "anchor";
    
/** This is the name of the <CODE>Anchor</CODE>. */
    protected String name = null;
    
/** This is the reference of the <CODE>Anchor</CODE>. */
    protected String reference = null;
    
    // constructors
    
/**
 * Constructs an <CODE>Anchor</CODE> without specifying a leading.
 */
    
    public Anchor() {
        super(16);
    }
    
/**
 * Constructs an <CODE>Anchor</CODE> with a certain leading.
 *
 * @param	leading		the leading
 */
    
    public Anchor(float leading) {
        super(leading);
    }
    
/**
 * Constructs an <CODE>Anchor</CODE> with a certain <CODE>Chunk</CODE>.
 *
 * @param	chunk		a <CODE>Chunk</CODE>
 */
    
    public Anchor(Chunk chunk) {
        super(chunk);
    }
    
/**
 * Constructs an <CODE>Anchor</CODE> with a certain <CODE>String</CODE>.
 *
 * @param	string		a <CODE>String</CODE>
 */
    
    public Anchor(String string) {
        super(string);
    }
    
/**
 * Constructs an <CODE>Anchor</CODE> with a certain <CODE>String</CODE>
 * and a certain <CODE>Font</CODE>.
 *
 * @param	string		a <CODE>String</CODE>
 * @param	font		a <CODE>Font</CODE>
 */
    
    public Anchor(String string, Font font) {
        super(string, font);
    }
    
/**
 * Constructs an <CODE>Anchor</CODE> with a certain <CODE>Chunk</CODE>
 * and a certain leading.
 *
 * @param	leading		the leading
 * @param	chunk		a <CODE>Chunk</CODE>
 */
    
    public Anchor(float leading, Chunk chunk) {
        super(leading, chunk);
    }
    
/**
 * Constructs an <CODE>Anchor</CODE> with a certain leading
 * and a certain <CODE>String</CODE>.
 *
 * @param	leading		the leading
 * @param	string		a <CODE>String</CODE>
 */
    
    public Anchor(float leading, String string) {
        super(leading, string);
    }
    
/**
 * Constructs an <CODE>Anchor</CODE> with a certain leading,
 * a certain <CODE>String</CODE> and a certain <CODE>Font</CODE>.
 *
 * @param	leading		the leading
 * @param	string		a <CODE>String</CODE>
 * @param	font		a <CODE>Font</CODE>
 */
    
    public Anchor(float leading, String string, Font font) {
        super(leading, string, font);
    }
    
/**
 * Returns an <CODE>Anchor</CODE> that has been constructed taking in account
 * the value of some <VAR>attributes</VAR>.
 *
 * @param	attributes		Some attributes
 */
    
    public Anchor(Properties attributes) {
        this("", FontFactory.getFont(attributes));
        String value;
        if ((value = (String)attributes.remove(ElementTags.ITEXT)) != null) {
            Chunk chunk = new Chunk(value);
            if ((value = (String)attributes.remove(ElementTags.GENERICTAG)) != null) {
                chunk.setGenericTag(value);
            }
            add(chunk);
        }
        if ((value = (String)attributes.remove(ElementTags.LEADING)) != null) {
            setLeading(Float.valueOf(value + "f").floatValue());
        }
        else if ((value = (String)attributes.remove(MarkupTags.CSS_KEY_LINEHEIGHT)) != null) {
            setLeading(MarkupParser.parseLength(value));
        }
        if ((value = (String)attributes.remove(ElementTags.NAME)) != null) {
            setName(value);
        }
        if ((value = (String)attributes.remove(ElementTags.REFERENCE)) != null) {
            setReference(value);
        }
        if (attributes.size() > 0) setMarkupAttributes(attributes);
    }
    
    // implementation of the Element-methods
    
/**
 * Processes the element by adding it (or the different parts) to an
 * <CODE>ElementListener</CODE>.
 *
 * @param	listener	an <CODE>ElementListener</CODE>
 * @return	<CODE>true</CODE> if the element was processed successfully
 */
    
    public boolean process(ElementListener listener) {
        try {
            Chunk chunk;
            Iterator i = getChunks().iterator();
            boolean localDestination = (reference != null && reference.startsWith("#"));
            boolean notGotoOK = true;
            while (i.hasNext()) {
                chunk = (Chunk) i.next();
                if (name != null && notGotoOK && !chunk.isEmpty()) {
                    chunk.setLocalDestination(name);
                    notGotoOK = false;
                }
                if (localDestination) {
                    chunk.setLocalGoto(reference.substring(1));
                }
                listener.add(chunk);
            }
            return true;
        }
        catch(DocumentException de) {
            return false;
        }
    }
    
/**
 * Gets all the chunks in this element.
 *
 * @return	an <CODE>ArrayList</CODE>
 */
    
    public ArrayList getChunks() {
        ArrayList tmp = new ArrayList();
        Chunk chunk;
        Iterator i = iterator();
        boolean localDestination = (reference != null && reference.startsWith("#"));
        boolean notGotoOK = true;
        while (i.hasNext()) {
            chunk = (Chunk) i.next();
            if (name != null && notGotoOK && !chunk.isEmpty()) {
                chunk.setLocalDestination(name);
                notGotoOK = false;
            }
            if (localDestination) {
                chunk.setLocalGoto(reference.substring(1));
            }
            else if (reference != null)
                chunk.setAnchor(reference);
            tmp.add(chunk);
        }
        return tmp;
    }
    
/**
 * Gets the type of the text element.
 *
 * @return	a type
 */
    
    public int type() {
        return Element.ANCHOR;
    }
    
    // methods
    
/**
 * Gets an iterator of <CODE>Element</CODE>s.
 *
 * @return	an <CODE>Iterator</CODE>
 */
    
    // suggestion by by Curt Thompson
    public Iterator getElements() {
        return this.iterator();
    }
    
/**
 * Sets the name of this <CODE>Anchor</CODE>.
 *
 * @param	name		a new name
 */
    
    public void setName(String name) {
        this.name = name;
    }
    
/**
 * Sets the reference of this <CODE>Anchor</CODE>.
 *
 * @param	reference		a new reference
 */
    
    public void setReference(String reference) {
        this.reference = reference;
    }
    
    // methods to retrieve information
    
/**
 * Returns the name of this <CODE>Anchor</CODE>.
 *
 * @return	a name
 */
    
    public String name() {
        return name;
    }
    
/**
 * Gets the reference of this <CODE>Anchor</CODE>.
 *
 * @return	a reference
 */
    
    public String reference() {
        return reference;
    }
    
/**
 * Gets the reference of this <CODE>Anchor</CODE>.
 *
 * @return	an <CODE>URL</CODE>
 */
    
    public URL url() {
        try {
            return new URL(reference);
        }
        catch(MalformedURLException mue) {
            return null;
        }
    }
    
/**
 * Checks if a given tag corresponds with this object.
 *
 * @param   tag     the given tag
 * @return  true if the tag corresponds
 */
    
    public static boolean isTag(String tag) {
        return ElementTags.ANCHOR.equals(tag);
    }
}
 /*
 * $Id: Annotation.java,v 1.70 2005/04/13 09:17:09 blowagie Exp $
 * $Name:  $
 *
 * Copyright 1999, 2000, 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

import java.net.URL;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Properties;
import java.util.Set;

/**
 * An <CODE>Annotation</CODE> is a little note that can be added to a page on
 * a document.
 * 
 * @see Element
 * @see Anchor
 */

public class Annotation implements Element, MarkupAttributes {

	// membervariables

	/** This is a possible annotation type. */
	public static final int TEXT = 0;

	/** This is a possible annotation type. */
	public static final int URL_NET = 1;

	/** This is a possible annotation type. */
	public static final int URL_AS_STRING = 2;

	/** This is a possible annotation type. */
	public static final int FILE_DEST = 3;

	/** This is a possible annotation type. */
	public static final int FILE_PAGE = 4;

	/** This is a possible annotation type. */
	public static final int NAMED_DEST = 5;

	/** This is a possible annotation type. */
	public static final int LAUNCH = 6;

	/** This is a possible annotation type. */
	public static final int SCREEN = 7;

	/** This is a possible attribute. */
	public static String TITLE = "title";

	/** This is a possible attribute. */
	public static String CONTENT = "content";

	/** This is a possible attribute. */
	public static String URL = "url";

	/** This is a possible attribute. */
	public static String FILE = "file";

	/** This is a possible attribute. */
	public static String DESTINATION = "destination";

	/** This is a possible attribute. */
	public static String PAGE = "page";

	/** This is a possible attribute. */
	public static String NAMED = "named";

	/** This is a possible attribute. */
	public static String APPLICATION = "application";

	/** This is a possible attribute. */
	public static String PARAMETERS = "parameters";

	/** This is a possible attribute. */
	public static String OPERATION = "operation";

	/** This is a possible attribute. */
	public static String DEFAULTDIR = "defaultdir";

	/** This is a possible attribute. */
	public static String LLX = "llx";

	/** This is a possible attribute. */
	public static String LLY = "lly";

	/** This is a possible attribute. */
	public static String URX = "urx";

	/** This is a possible attribute. */
	public static String URY = "ury";

	/** This is a possible attribute. */
	public static String MIMETYPE = "mime";

	/** This is the type of annotation. */
	protected int annotationtype;

	/** This is the title of the <CODE>Annotation</CODE>. */
	protected HashMap annotationAttributes = new HashMap();

	/** Contains extra markupAttributes */
	protected Properties markupAttributes = null;

	/** This is the lower left x-value */
	protected float llx = Float.NaN;

	/** This is the lower left y-value */
	protected float lly = Float.NaN;

	/** This is the upper right x-value */
	protected float urx = Float.NaN;

	/** This is the upper right y-value */
	protected float ury = Float.NaN;

	// constructors

	/**
	 * Constructs an <CODE>Annotation</CODE> with a certain title and some
	 * text.
	 * 
	 * @param llx
	 *            lower left x coordinate
	 * @param lly
	 *            lower left y coordinate
	 * @param urx
	 *            upper right x coordinate
	 * @param ury
	 *            upper right y coordinate
	 */

	private Annotation(float llx, float lly, float urx, float ury) {
		this.llx = llx;
		this.lly = lly;
		this.urx = urx;
		this.ury = ury;
	}

    public Annotation(Annotation an) {
        annotationtype = an.annotationtype;
        annotationAttributes = an.annotationAttributes;
        markupAttributes = an.markupAttributes;
        llx = an.llx;
        lly = an.lly;
        urx = an.urx;
        ury = an.ury;
    }
    
	/**
	 * Constructs an <CODE>Annotation</CODE> with a certain title and some
	 * text.
	 * 
	 * @param title
	 *            the title of the annotation
	 * @param text
	 *            the content of the annotation
	 */

	public Annotation(String title, String text) {
		annotationtype = TEXT;
		annotationAttributes.put(TITLE, title);
		annotationAttributes.put(CONTENT, text);
	}

	/**
	 * Constructs an <CODE>Annotation</CODE> with a certain title and some
	 * text.
	 * 
	 * @param title
	 *            the title of the annotation
	 * @param text
	 *            the content of the annotation
	 * @param llx
	 *            the lower left x-value
	 * @param lly
	 *            the lower left y-value
	 * @param urx
	 *            the upper right x-value
	 * @param ury
	 *            the upper right y-value
	 */

	public Annotation(String title, String text, float llx, float lly,
			float urx, float ury) {
		this(llx, lly, urx, ury);
		annotationtype = TEXT;
		annotationAttributes.put(TITLE, title);
		annotationAttributes.put(CONTENT, text);
	}

	/**
	 * Constructs an <CODE>Annotation</CODE>.
	 * 
	 * @param llx
	 *            the lower left x-value
	 * @param lly
	 *            the lower left y-value
	 * @param urx
	 *            the upper right x-value
	 * @param ury
	 *            the upper right y-value
	 * @param url
	 *            the external reference
	 */

	public Annotation(float llx, float lly, float urx, float ury, URL url) {
		this(llx, lly, urx, ury);
		annotationtype = URL_NET;
		annotationAttributes.put(URL, url);
	}

	/**
	 * Constructs an <CODE>Annotation</CODE>.
	 * 
	 * @param llx
	 *            the lower left x-value
	 * @param lly
	 *            the lower left y-value
	 * @param urx
	 *            the upper right x-value
	 * @param ury
	 *            the upper right y-value
	 * @param url
	 *            the external reference
	 */

	public Annotation(float llx, float lly, float urx, float ury, String url) {
		this(llx, lly, urx, ury);
		annotationtype = URL_AS_STRING;
		annotationAttributes.put(FILE, url);
	}

	/**
	 * Constructs an <CODE>Annotation</CODE>.
	 * 
	 * @param llx
	 *            the lower left x-value
	 * @param lly
	 *            the lower left y-value
	 * @param urx
	 *            the upper right x-value
	 * @param ury
	 *            the upper right y-value
	 * @param file
	 *            an external PDF file
	 * @param dest
	 *            the destination in this file
	 */

	public Annotation(float llx, float lly, float urx, float ury, String file,
			String dest) {
		this(llx, lly, urx, ury);
		annotationtype = FILE_DEST;
		annotationAttributes.put(FILE, file);
		annotationAttributes.put(DESTINATION, dest);
	}

	/**
	 * Creates a Screen anotation to embed media clips
	 * 
	 * @param llx
	 * @param lly
	 * @param urx
	 * @param ury
	 * @param moviePath
	 *            path to the media clip file
	 * @param mimeType
	 *            mime type of the media
	 * @param showOnDisplay
	 *            if true play on display of the page
	 */
	public Annotation(float llx, float lly, float urx, float ury,
			String moviePath, String mimeType, boolean showOnDisplay) {
		this(llx, lly, urx, ury);
		annotationtype = SCREEN;
		annotationAttributes.put(FILE, moviePath);
		annotationAttributes.put(MIMETYPE, mimeType);
		annotationAttributes.put(PARAMETERS, new boolean[] {
				false /* embedded */, showOnDisplay });
	}

	/**
	 * Constructs an <CODE>Annotation</CODE>.
	 * 
	 * @param llx
	 *            the lower left x-value
	 * @param lly
	 *            the lower left y-value
	 * @param urx
	 *            the upper right x-value
	 * @param ury
	 *            the upper right y-value
	 * @param file
	 *            an external PDF file
	 * @param page
	 *            a page number in this file
	 */

	public Annotation(float llx, float lly, float urx, float ury, String file,
			int page) {
		this(llx, lly, urx, ury);
		annotationtype = FILE_PAGE;
		annotationAttributes.put(FILE, file);
		annotationAttributes.put(PAGE, new Integer(page));
	}

	/**
	 * Constructs an <CODE>Annotation</CODE>.
	 * 
	 * @param llx
	 *            the lower left x-value
	 * @param lly
	 *            the lower left y-value
	 * @param urx
	 *            the upper right x-value
	 * @param ury
	 *            the upper right y-value
	 * @param named
	 *            a named destination in this file
	 */

	public Annotation(float llx, float lly, float urx, float ury, int named) {
		this(llx, lly, urx, ury);
		annotationtype = NAMED_DEST;
		annotationAttributes.put(NAMED, new Integer(named));
	}

	/**
	 * Constructs an <CODE>Annotation</CODE>.
	 * 
	 * @param llx
	 *            the lower left x-value
	 * @param lly
	 *            the lower left y-value
	 * @param urx
	 *            the upper right x-value
	 * @param ury
	 *            the upper right y-value
	 * @param application
	 *            an external application
	 * @param parameters
	 *            parameters to pass to this application
	 * @param operation
	 *            the operation to pass to this application
	 * @param defaultdir
	 *            the default directory to run this application in
	 */

	public Annotation(float llx, float lly, float urx, float ury,
			String application, String parameters, String operation,
			String defaultdir) {
		this(llx, lly, urx, ury);
		annotationtype = LAUNCH;
		annotationAttributes.put(APPLICATION, application);
		annotationAttributes.put(PARAMETERS, parameters);
		annotationAttributes.put(OPERATION, operation);
		annotationAttributes.put(DEFAULTDIR, defaultdir);
	}

	/**
	 * Returns an <CODE>Annotation</CODE> that has been constructed taking in
	 * account the value of some <VAR>attributes </VAR>.
	 * 
	 * @param attributes
	 *            Some attributes
	 */

	public Annotation(Properties attributes) {
		String value = (String) attributes.remove(ElementTags.LLX);
		if (value != null) {
			llx = Float.valueOf(value + "f").floatValue();
		}
		value = (String) attributes.remove(ElementTags.LLY);
		if (value != null) {
			lly = Float.valueOf(value + "f").floatValue();
		}
		value = (String) attributes.remove(ElementTags.URX);
		if (value != null) {
			urx = Float.valueOf(value + "f").floatValue();
		}
		value = (String) attributes.remove(ElementTags.URY);
		if (value != null) {
			ury = Float.valueOf(value + "f").floatValue();
		}
		String title = (String) attributes.remove(ElementTags.TITLE);
		String text = (String) attributes.remove(ElementTags.CONTENT);
		if (title != null || text != null) {
			annotationtype = TEXT;
		} else if ((value = (String) attributes.remove(ElementTags.URL)) != null) {
			annotationtype = URL_AS_STRING;
			annotationAttributes.put(FILE, value);
		} else if ((value = (String) attributes.remove(ElementTags.NAMED)) != null) {
			annotationtype = NAMED_DEST;
			annotationAttributes.put(NAMED, Integer.valueOf(value));
		} else {
			String file = (String) attributes.remove(ElementTags.FILE);
			String destination = (String) attributes
					.remove(ElementTags.DESTINATION);
			String page = (String) attributes.remove(ElementTags.PAGE);
			if (file != null) {
				annotationAttributes.put(FILE, file);
				if (destination != null) {
					annotationtype = FILE_DEST;
					annotationAttributes.put(DESTINATION, destination);
				} else if (page != null) {
					annotationtype = FILE_PAGE;
					annotationAttributes.put(FILE, file);
					annotationAttributes.put(PAGE, Integer.valueOf(page));
				}
			} else if ((value = (String) attributes.remove(ElementTags.NAMED)) != null) {
				annotationtype = LAUNCH;
				annotationAttributes.put(APPLICATION, value);
				annotationAttributes.put(PARAMETERS, attributes
						.remove(ElementTags.PARAMETERS));
				annotationAttributes.put(OPERATION, attributes
						.remove(ElementTags.OPERATION));
				annotationAttributes.put(DEFAULTDIR, attributes
						.remove(ElementTags.DEFAULTDIR));
			}
		}
		if (annotationtype == TEXT) {
			if (title == null)
				title = "";
			if (text == null)
				text = "";
			annotationAttributes.put(TITLE, title);
			annotationAttributes.put(CONTENT, text);
		}
		if (attributes.size() > 0)
			setMarkupAttributes(attributes);
	}

	// implementation of the Element-methods

	/**
	 * Gets the type of the text element.
	 * 
	 * @return a type
	 */

	public int type() {
		return Element.ANNOTATION;
	}

	// methods

	/**
	 * Processes the element by adding it (or the different parts) to an <CODE>
	 * ElementListener</CODE>.
	 * 
	 * @param listener
	 *            an <CODE>ElementListener</CODE>
	 * @return <CODE>true</CODE> if the element was processed successfully
	 */

	public boolean process(ElementListener listener) {
		try {
			return listener.add(this);
		} catch (DocumentException de) {
			return false;
		}
	}

	/**
	 * Gets all the chunks in this element.
	 * 
	 * @return an <CODE>ArrayList</CODE>
	 */

	public ArrayList getChunks() {
		return new ArrayList();
	}

	// methods

	/**
	 * Sets the dimensions of this annotation.
	 * 
	 * @param llx
	 *            the lower left x-value
	 * @param lly
	 *            the lower left y-value
	 * @param urx
	 *            the upper right x-value
	 * @param ury
	 *            the upper right y-value
	 */

	public void setDimensions(float llx, float lly, float urx, float ury) {
		this.llx = llx;
		this.lly = lly;
		this.urx = urx;
		this.ury = ury;
	}

	// methods to retrieve information

	/**
	 * Returns the lower left x-value.
	 * 
	 * @return a value
	 */

	public float llx() {
		return llx;
	}

	/**
	 * Returns the lower left y-value.
	 * 
	 * @return a value
	 */

	public float lly() {
		return lly;
	}

	/**
	 * Returns the uppper right x-value.
	 * 
	 * @return a value
	 */

	public float urx() {
		return urx;
	}

	/**
	 * Returns the uppper right y-value.
	 * 
	 * @return a value
	 */

	public float ury() {
		return ury;
	}

	/**
	 * Returns the lower left x-value.
	 * 
	 * @param def
	 *            the default value
	 * @return a value
	 */

	public float llx(float def) {
		if (Float.isNaN(llx))
			return def;
		return llx;
	}

	/**
	 * Returns the lower left y-value.
	 * 
	 * @param def
	 *            the default value
	 * @return a value
	 */

	public float lly(float def) {
		if (Float.isNaN(lly))
			return def;
		return lly;
	}

	/**
	 * Returns the upper right x-value.
	 * 
	 * @param def
	 *            the default value
	 * @return a value
	 */

	public float urx(float def) {
		if (Float.isNaN(urx))
			return def;
		return urx;
	}

	/**
	 * Returns the upper right y-value.
	 * 
	 * @param def
	 *            the default value
	 * @return a value
	 */

	public float ury(float def) {
		if (Float.isNaN(ury))
			return def;
		return ury;
	}

	/**
	 * Returns the type of this <CODE>Annotation</CODE>.
	 * 
	 * @return a type
	 */

	public int annotationType() {
		return annotationtype;
	}

	/**
	 * Returns the title of this <CODE>Annotation</CODE>.
	 * 
	 * @return a name
	 */

	public String title() {
		String s = (String) annotationAttributes.get(TITLE);
		if (s == null)
			s = "";
		return s;
	}

	/**
	 * Gets the content of this <CODE>Annotation</CODE>.
	 * 
	 * @return a reference
	 */

	public String content() {
		String s = (String) annotationAttributes.get(CONTENT);
		if (s == null)
			s = "";
		return s;
	}

	/**
	 * Gets the content of this <CODE>Annotation</CODE>.
	 * 
	 * @return a reference
	 */

	public HashMap attributes() {
		return annotationAttributes;
	}

	/**
	 * Checks if a given tag corresponds with this object.
	 * 
	 * @param tag
	 *            the given tag
	 * @return true if the tag corresponds
	 */

	public static boolean isTag(String tag) {
		return ElementTags.ANNOTATION.equals(tag);
	}

	/**
	 * @see pdftk.com.lowagie.text.MarkupAttributes#setMarkupAttribute(java.lang.String,
	 *      java.lang.String)
	 */
	public void setMarkupAttribute(String name, String value) {
		if (markupAttributes == null) markupAttributes = new Properties();
		markupAttributes.put(name, value);
	}

	/**
	 * @see pdftk.com.lowagie.text.MarkupAttributes#setMarkupAttributes(java.util.Properties)
	 */
	public void setMarkupAttributes(Properties markupAttributes) {
		this.markupAttributes = markupAttributes;
	}

	/**
	 * @see pdftk.com.lowagie.text.MarkupAttributes#getMarkupAttribute(java.lang.String)
	 */
	public String getMarkupAttribute(String name) {
		return (markupAttributes == null) ? null : String
				.valueOf(markupAttributes.get(name));
	}

	/**
	 * @see pdftk.com.lowagie.text.MarkupAttributes#getMarkupAttributeNames()
	 */
	public Set getMarkupAttributeNames() {
		return Chunk.getKeySet(markupAttributes);
	}

	/**
	 * @see pdftk.com.lowagie.text.MarkupAttributes#getMarkupAttributes()
	 */
	public Properties getMarkupAttributes() {
		return markupAttributes;
	}
} /*
 * $Id: BadElementException.java,v 1.50 2004/12/14 11:33:49 blowagie Exp $
 * $Name:  $
 *
 * Copyright 1999, 2000, 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

/**
 * Signals an attempt to create an <CODE>Element</CODE> that hasn't got the right form.
 *
 * @see		DocumentException
 * @see		Cell
 * @see		Table
 */

public class BadElementException extends DocumentException {
    
    /** A serial version UID */
    private static final long serialVersionUID = -799006030723822254L;

    // constructors
    /**
     * Constructs a BadElementException
     * @param ex an Exception object that has to be turned into a BadElementException
     */
    public BadElementException(Exception ex) {
        super(ex);
    }
    
/**
 * Constructs a <CODE>BadElementException</CODE> whithout a message.
 */
    
    BadElementException() {
        super();
    }
    
/**
 * Constructs a <code>BadElementException</code> with a message.
 *
 * @param		message			a message describing the exception
 */
    
    public BadElementException(String message) {
        super(message);
    }
}
 /*
 * $Id: Chunk.java,v 1.112 2005/10/05 07:23:47 blowagie Exp $
 * $Name:  $
 *
 * Copyright 1999, 2000, 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

import java.awt.Color;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Properties;
import java.util.Set;
import java.net.URL;

import pdftk.com.lowagie.text.pdf.PdfAction;
import pdftk.com.lowagie.text.pdf.PdfAnnotation;
import pdftk.com.lowagie.text.pdf.HyphenationEvent;
import pdftk.com.lowagie.text.pdf.PdfContentByte;
import pdftk.com.lowagie.text.markup.MarkupTags;
import pdftk.com.lowagie.text.markup.MarkupParser;

/**
 * This is the smallest significant part of text that can be added to a
 * document.
 * <P>
 * Most elements can be divided in one or more <CODE>Chunk</CODE>s. A chunk
 * is a <CODE>String</CODE> with a certain <CODE>Font</CODE>. all other
 * layoutparameters should be defined in the object to which this chunk of text
 * is added.
 * <P>
 * Example: <BLOCKQUOTE>
 * 
 * <PRE>
 * 
 * <STRONG>Chunk chunk = new Chunk("Hello world",
 * FontFactory.getFont(FontFactory.COURIER, 20, Font.ITALIC, new Color(255, 0,
 * 0))); </STRONG> document.add(chunk);
 * 
 * </PRE>
 * 
 * </BLOCKQUOTE>
 */

public class Chunk implements Element, MarkupAttributes {

	// public static membervariables

	/**
	 * The character stand in for an image.
	 */
	public static final String OBJECT_REPLACEMENT_CHARACTER = "\ufffc";

	/** This is a Chunk containing a newline. */
	public static final Chunk NEWLINE = new Chunk("\n");

	/** This is a Chunk containing a newpage. */
	public static final Chunk NEXTPAGE = new Chunk("");
	static {
		NEXTPAGE.setNewPage();
	}

	/** Key for sub/superscript. */
	public static final String SUBSUPSCRIPT = "SUBSUPSCRIPT";

	/** Key for underline. */
	public static final String UNDERLINE = "UNDERLINE";

	/** Key for color. */
	public static final String COLOR = "COLOR";

	/** Key for encoding. */
	public static final String ENCODING = "ENCODING";

	/** Key for remote goto. */
	public static final String REMOTEGOTO = "REMOTEGOTO";

	/** Key for local goto. */
	public static final String LOCALGOTO = "LOCALGOTO";

	/** Key for local destination. */
	public static final String LOCALDESTINATION = "LOCALDESTINATION";

	/** Key for image. */
	public static final String IMAGE = "IMAGE";

	/** Key for generic tag. */
	public static final String GENERICTAG = "GENERICTAG";

	/** Key for newpage. */
	public static final String NEWPAGE = "NEWPAGE";

	/** Key for split character. */
	public static final String SPLITCHARACTER = "SPLITCHARACTER";

	/** Key for Action. */
	public static final String ACTION = "ACTION";

	/** Key for background. */
	public static final String BACKGROUND = "BACKGROUND";

	/** Key for annotation. */
	public static final String PDFANNOTATION = "PDFANNOTATION";

	/** Key for hyphenation. */
	public static final String HYPHENATION = "HYPHENATION";

	/** Key for text rendering mode. */
	public static final String TEXTRENDERMODE = "TEXTRENDERMODE";

	/** Key for text skewing. */
	public static final String SKEW = "SKEW";

	/** Key for text horizontal scaling. */
	public static final String HSCALE = "HSCALE";

	// member variables

	/** This is the content of this chunk of text. */
	protected StringBuffer content = null;

	/** This is the <CODE>Font</CODE> of this chunk of text. */
	protected Font font = null;

	/** Contains some of the attributes for this Chunk. */
	protected HashMap attributes = null;

	/** Contains extra markupAttributes */
	protected Properties markupAttributes = null;

	// constructors

	/**
	 * Empty constructor.
	 */
	protected Chunk() {
	}

	/**
	 * Constructs a chunk of text with a certain content and a certain <CODE>
	 * Font</CODE>.
	 * 
	 * @param content
	 *            the content
	 * @param font
	 *            the font
	 */

	public Chunk(String content, Font font) {
		this.content = new StringBuffer(content);
		this.font = font;
	}

	/**
	 * Constructs a chunk of text with a certain content, without specifying a
	 * <CODE>Font</CODE>.
	 * 
	 * @param content
	 *            the content
	 */
	public Chunk(String content) {
		this(content, new Font());
	}

	/**
	 * Constructs a chunk of text with a char and a certain <CODE>Font</CODE>.
	 * 
	 * @param c
	 *            the content
	 * @param font
	 *            the font
	 */
	public Chunk(char c, Font font) {
		this.content = new StringBuffer();
		this.content.append(c);
		this.font = font;
	}

	/**
	 * Constructs a chunk of text with a char, without specifying a <CODE>Font
	 * </CODE>.
	 * 
	 * @param c
	 *            the content
	 */
	public Chunk(char c) {
		this(c, new Font());
	}

	/**
	 * Constructs a chunk containing an <CODE>Image</CODE>.
	 * 
	 * @param image
	 *            the image
	 * @param offsetX
	 *            the image offset in the x direction
	 * @param offsetY
	 *            the image offset in the y direction
	 */
    /* ssteward: dropped in 1.44
	public Chunk(Image image, float offsetX, float offsetY) {
		this(OBJECT_REPLACEMENT_CHARACTER, new Font());
		Image copyImage = Image.getInstance(image);
		copyImage.setAbsolutePosition(Float.NaN, Float.NaN);
		setAttribute(IMAGE, new Object[] { copyImage, new Float(offsetX),
				new Float(offsetY), new Boolean(false) });
	}
    */

	/**
	 * Constructs a chunk containing an <CODE>Image</CODE>.
	 * 
	 * @param image
	 *            the image
	 * @param offsetX
	 *            the image offset in the x direction
	 * @param offsetY
	 *            the image offset in the y direction
	 * @param changeLeading
	 *            true if the leading has to be adapted to the image
	 */
    /* ssteward: dropped in 1.44
	public Chunk(Image image, float offsetX, float offsetY,
			boolean changeLeading) {
		this(OBJECT_REPLACEMENT_CHARACTER, new Font());
		setAttribute(IMAGE, new Object[] { image, new Float(offsetX),
				new Float(offsetY), new Boolean(changeLeading) });
	}
    */
	/**
	 * Returns a <CODE>Chunk</CODE> that has been constructed taking in
	 * account the value of some <VAR>attributes </VAR>.
	 * 
	 * @param attributes
	 *            Some attributes
	 */

	public Chunk(Properties attributes) {
		this("", FontFactory.getFont(attributes));
		String value;
		if ((value = (String) attributes.remove(ElementTags.ITEXT)) != null) {
			append(value);
		}
		if ((value = (String) attributes.remove(ElementTags.LOCALGOTO)) != null) {
			setLocalGoto(value);
		}
		if ((value = (String) attributes.remove(ElementTags.REMOTEGOTO)) != null) {
			String destination = (String) attributes
					.remove(ElementTags.DESTINATION);
			String page = (String) attributes.remove(ElementTags.PAGE);
			if (page != null) {
				setRemoteGoto(value, Integer.valueOf(page).intValue());
			} else if (destination != null) {
				setRemoteGoto(value, destination);
			}
		}
		if ((value = (String) attributes.remove(ElementTags.LOCALDESTINATION)) != null) {
			setLocalDestination(value);
		}
		if ((value = (String) attributes.remove(ElementTags.SUBSUPSCRIPT)) != null) {
			setTextRise(Float.valueOf(value + "f").floatValue());
		}
		if ((value = (String) attributes
				.remove(MarkupTags.CSS_KEY_VERTICALALIGN)) != null
				&& value.endsWith("%")) {
			float p = Float.valueOf(
					value.substring(0, value.length() - 1) + "f").floatValue() / 100f;
			setTextRise(p * font.size());
		}
		if ((value = (String) attributes.remove(ElementTags.GENERICTAG)) != null) {
			setGenericTag(value);
		}
		if ((value = (String) attributes.remove(ElementTags.BACKGROUNDCOLOR)) != null) {
			setBackground(MarkupParser.decodeColor(value));
		}
		if (attributes.size() > 0)
			setMarkupAttributes(attributes);
	}

	// implementation of the Element-methods

	/**
	 * Processes the element by adding it (or the different parts) to an <CODE>
	 * ElementListener</CODE>.
	 * 
	 * @param listener
	 *            an <CODE>ElementListener</CODE>
	 * @return <CODE>true</CODE> if the element was processed successfully
	 */

	public boolean process(ElementListener listener) {
		try {
			return listener.add(this);
		} catch (DocumentException de) {
			return false;
		}
	}

	/**
	 * Gets the type of the text element.
	 * 
	 * @return a type
	 */

	public int type() {
		return Element.CHUNK;
	}

	/**
	 * Gets all the chunks in this element.
	 * 
	 * @return an <CODE>ArrayList</CODE>
	 */

	public ArrayList getChunks() {
		ArrayList tmp = new ArrayList();
		tmp.add(this);
		return tmp;
	}

	// methods

	/**
	 * appends some text to this <CODE>Chunk</CODE>.
	 * 
	 * @param string
	 *            <CODE>String</CODE>
	 * @return a <CODE>StringBuffer</CODE>
	 */

	public StringBuffer append(String string) {
		return content.append(string);
	}

	// methods to retrieve information

	/**
	 * Gets the font of this <CODE>Chunk</CODE>.
	 * 
	 * @return a <CODE>Font</CODE>
	 */

	public Font font() {
		return font;
	}

	/**
	 * Sets the font of this <CODE>Chunk</CODE>.
	 * 
	 * @param font
	 *            a <CODE>Font</CODE>
	 */

	public void setFont(Font font) {
		this.font = font;
	}

	/**
	 * Returns the content of this <CODE>Chunk</CODE>.
	 * 
	 * @return a <CODE>String</CODE>
	 */

	public String content() {
		return content.toString();
	}

	/**
	 * Returns the content of this <CODE>Chunk</CODE>.
	 * 
	 * @return a <CODE>String</CODE>
	 */

	public String toString() {
		return content.toString();
	}

	/**
	 * Checks is this <CODE>Chunk</CODE> is empty.
	 * 
	 * @return <CODE>false</CODE> if the Chunk contains other characters than
	 *         space.
	 */

	public boolean isEmpty() {
		return (content.toString().trim().length() == 0)
				&& (content.toString().indexOf("\n") == -1)
				&& (attributes == null);
	}

	/**
	 * Gets the width of the Chunk in points.
	 * 
	 * @return a width in points
	 */
	public float getWidthPoint() {
	    /* ssteward: dropped in 1.44
		if (getImage() != null) {
			return getImage().scaledWidth();
		}
	    */
		return font.getCalculatedBaseFont(true).getWidthPoint(content(),
				font.getCalculatedSize())
				* getHorizontalScaling();
	}

	/**
	 * Sets the text displacement relative to the baseline. Positive values rise
	 * the text, negative values lower the text.
	 * <P>
	 * It can be used to implement sub/superscript.
	 * 
	 * @param rise
	 *            the displacement in points
	 * @return this <CODE>Chunk</CODE>
	 */

	public Chunk setTextRise(float rise) {
		return setAttribute(SUBSUPSCRIPT, new Float(rise));
	}

	/**
	 * Gets the text displacement relatiev to the baseline.
	 * 
	 * @return a displacement in points
	 */
	public float getTextRise() {
		if (attributes.containsKey(SUBSUPSCRIPT)) {
			Float f = (Float) attributes.get(SUBSUPSCRIPT);
			return f.floatValue();
		}
		return 0.0f;
	}

	/**
	 * Sets the text rendering mode. It can outline text, simulate bold and make
	 * text invisible.
	 * 
	 * @param mode
	 *            the text rendering mode. It can be <CODE>
	 *            PdfContentByte.TEXT_RENDER_MODE_FILL</CODE>,<CODE>
	 *            PdfContentByte.TEXT_RENDER_MODE_STROKE</CODE>,<CODE>
	 *            PdfContentByte.TEXT_RENDER_MODE_FILL_STROKE</CODE> and <CODE>
	 *            PdfContentByte.TEXT_RENDER_MODE_INVISIBLE</CODE>.
	 * @param strokeWidth
	 *            the stroke line width for the modes <CODE>
	 *            PdfContentByte.TEXT_RENDER_MODE_STROKE</CODE> and <CODE>
	 *            PdfContentByte.TEXT_RENDER_MODE_FILL_STROKE</CODE>.
	 * @param strokeColor
	 *            the stroke color or <CODE>null</CODE> to follow the text
	 *            color
	 * @return this <CODE>Chunk</CODE>
	 */
	public Chunk setTextRenderMode(int mode, float strokeWidth,
			Color strokeColor) {
		return setAttribute(TEXTRENDERMODE, new Object[] { new Integer(mode),
				new Float(strokeWidth), strokeColor });
	}

	/**
	 * Skews the text to simulate italic and other effects. Try <CODE>alpha=0
	 * </CODE> and <CODE>beta=12</CODE>.
	 * 
	 * @param alpha
	 *            the first angle in degrees
	 * @param beta
	 *            the second angle in degrees
	 * @return this <CODE>Chunk</CODE>
	 */
	public Chunk setSkew(float alpha, float beta) {
		alpha = (float) Math.tan(alpha * Math.PI / 180);
		beta = (float) Math.tan(beta * Math.PI / 180);
		return setAttribute(SKEW, new float[] { alpha, beta });
	}

	/**
	 * Sets the text horizontal scaling. A value of 1 is normal and a value of
	 * 0.5f shrinks the text to half it's width.
	 * 
	 * @param scale
	 *            the horizontal scaling factor
	 * @return this <CODE>Chunk</CODE>
	 */
	public Chunk setHorizontalScaling(float scale) {
		return setAttribute(HSCALE, new Float(scale));
	}

	/**
	 * Gets the horizontal scaling.
	 * 
	 * @return a percentage in float
	 */
	public float getHorizontalScaling() {
		if (attributes == null)
			return 1f;
		Float f = (Float) attributes.get(HSCALE);
		if (f == null)
			return 1f;
		return f.floatValue();
	}

	/**
	 * Sets an action for this <CODE>Chunk</CODE>.
	 * 
	 * @param action
	 *            the action
	 * @return this <CODE>Chunk</CODE>
	 */

	public Chunk setAction(PdfAction action) {
		return setAttribute(ACTION, action);
	}

	/**
	 * Sets an anchor for this <CODE>Chunk</CODE>.
	 * 
	 * @param url
	 *            the <CODE>URL</CODE> to link to
	 * @return this <CODE>Chunk</CODE>
	 */

	public Chunk setAnchor(URL url) {
		return setAttribute(ACTION, new PdfAction(url.toExternalForm()));
	}

	/**
	 * Sets an anchor for this <CODE>Chunk</CODE>.
	 * 
	 * @param url
	 *            the url to link to
	 * @return this <CODE>Chunk</CODE>
	 */

	public Chunk setAnchor(String url) {
		return setAttribute(ACTION, new PdfAction(url));
	}

	/**
	 * Sets a local goto for this <CODE>Chunk</CODE>.
	 * <P>
	 * There must be a local destination matching the name.
	 * 
	 * @param name
	 *            the name of the destination to go to
	 * @return this <CODE>Chunk</CODE>
	 */

	public Chunk setLocalGoto(String name) {
		return setAttribute(LOCALGOTO, name);
	}

	/**
	 * Sets the color of the background <CODE>Chunk</CODE>.
	 * 
	 * @param color
	 *            the color of the background
	 * @return this <CODE>Chunk</CODE>
	 */
	public Chunk setBackground(Color color) {
		return setBackground(color, 0, 0, 0, 0);
	}

	/**
	 * Sets the color and the size of the background <CODE>Chunk</CODE>.
	 * 
	 * @param color
	 *            the color of the background
	 * @param extraLeft
	 *            increase the size of the rectangle in the left
	 * @param extraBottom
	 *            increase the size of the rectangle in the bottom
	 * @param extraRight
	 *            increase the size of the rectangle in the right
	 * @param extraTop
	 *            increase the size of the rectangle in the top
	 * @return this <CODE>Chunk</CODE>
	 */
	public Chunk setBackground(Color color, float extraLeft, float extraBottom,
			float extraRight, float extraTop) {
		return setAttribute(BACKGROUND, new Object[] { color,
				new float[] { extraLeft, extraBottom, extraRight, extraTop } });
	}

	/**
	 * Sets an horizontal line that can be an underline or a strikethrough.
	 * Actually, the line can be anywhere vertically and has always the <CODE>
	 * Chunk</CODE> width. Multiple call to this method will produce multiple
	 * lines.
	 * 
	 * @param thickness
	 *            the absolute thickness of the line
	 * @param yPosition
	 *            the absolute y position relative to the baseline
	 * @return this <CODE>Chunk</CODE>
	 */
	public Chunk setUnderline(float thickness, float yPosition) {
		return setUnderline(null, thickness, 0f, yPosition, 0f,
				PdfContentByte.LINE_CAP_BUTT);
	}

	/**
	 * Sets an horizontal line that can be an underline or a strikethrough.
	 * Actually, the line can be anywhere vertically and has always the <CODE>
	 * Chunk</CODE> width. Multiple call to this method will produce multiple
	 * lines.
	 * 
	 * @param color
	 *            the color of the line or <CODE>null</CODE> to follow the
	 *            text color
	 * @param thickness
	 *            the absolute thickness of the line
	 * @param thicknessMul
	 *            the thickness multiplication factor with the font size
	 * @param yPosition
	 *            the absolute y position relative to the baseline
	 * @param yPositionMul
	 *            the position multiplication factor with the font size
	 * @param cap
	 *            the end line cap. Allowed values are
	 *            PdfContentByte.LINE_CAP_BUTT, PdfContentByte.LINE_CAP_ROUND
	 *            and PdfContentByte.LINE_CAP_PROJECTING_SQUARE
	 * @return this <CODE>Chunk</CODE>
	 */
	public Chunk setUnderline(Color color, float thickness, float thicknessMul,
			float yPosition, float yPositionMul, int cap) {
		if (attributes == null)
			attributes = new HashMap();
		Object obj[] = {
				color,
				new float[] { thickness, thicknessMul, yPosition, yPositionMul, cap } };
		Object unders[][] = addToArray((Object[][]) attributes.get(UNDERLINE),
				obj);
		return setAttribute(UNDERLINE, unders);
	}

	/**
	 * Utility method to extend an array.
	 * 
	 * @param original
	 *            the original array or <CODE>null</CODE>
	 * @param item
	 *            the item to be added to the array
	 * @return a new array with the item appended
	 */
	public static Object[][] addToArray(Object original[][], Object item[]) {
		if (original == null) {
			original = new Object[1][];
			original[0] = item;
			return original;
		} else {
			Object original2[][] = new Object[original.length + 1][];
			System.arraycopy(original, 0, original2, 0, original.length);
			original2[original.length] = item;
			return original2;
		}
	}

	/**
	 * Sets a generic annotation to this <CODE>Chunk</CODE>.
	 * 
	 * @param annotation
	 *            the annotation
	 * @return this <CODE>Chunk</CODE>
	 */
	public Chunk setAnnotation(PdfAnnotation annotation) {
		return setAttribute(PDFANNOTATION, annotation);
	}

	/**
	 * sets the hyphenation engine to this <CODE>Chunk</CODE>.
	 * 
	 * @param hyphenation
	 *            the hyphenation engine
	 * @return this <CODE>Chunk</CODE>
	 */
	public Chunk setHyphenation(HyphenationEvent hyphenation) {
		return setAttribute(HYPHENATION, hyphenation);
	}

	/**
	 * Sets a goto for a remote destination for this <CODE>Chunk</CODE>.
	 * 
	 * @param filename
	 *            the file name of the destination document
	 * @param name
	 *            the name of the destination to go to
	 * @return this <CODE>Chunk</CODE>
	 */

	public Chunk setRemoteGoto(String filename, String name) {
		return setAttribute(REMOTEGOTO, new Object[] { filename, name });
	}

	/**
	 * Sets a goto for a remote destination for this <CODE>Chunk</CODE>.
	 * 
	 * @param filename
	 *            the file name of the destination document
	 * @param page
	 *            the page of the destination to go to. First page is 1
	 * @return this <CODE>Chunk</CODE>
	 */

	public Chunk setRemoteGoto(String filename, int page) {
		return setAttribute(REMOTEGOTO, new Object[] { filename,
				new Integer(page) });
	}

	/**
	 * Sets a local destination for this <CODE>Chunk</CODE>.
	 * 
	 * @param name
	 *            the name for this destination
	 * @return this <CODE>Chunk</CODE>
	 */
	public Chunk setLocalDestination(String name) {
		return setAttribute(LOCALDESTINATION, name);
	}

	/**
	 * Sets the generic tag <CODE>Chunk</CODE>.
	 * <P>
	 * The text for this tag can be retrieved with <CODE>PdfPageEvent</CODE>.
	 * 
	 * @param text
	 *            the text for the tag
	 * @return this <CODE>Chunk</CODE>
	 */

	public Chunk setGenericTag(String text) {
		return setAttribute(GENERICTAG, text);
	}

	/**
	 * Sets the split characters.
	 * 
	 * @param splitCharacter
	 *            the <CODE>SplitCharacter</CODE> interface
	 * @return this <CODE>Chunk</CODE>
	 */
	public Chunk setSplitCharacter(SplitCharacter splitCharacter) {
		return setAttribute(SPLITCHARACTER, splitCharacter);
	}

	/**
	 * Sets a new page tag..
	 * 
	 * @return this <CODE>Chunk</CODE>
	 */

	public Chunk setNewPage() {
		return setAttribute(NEWPAGE, null);
	}

	/**
	 * Sets an arbitrary attribute.
	 * 
	 * @param name
	 *            the key for the attribute
	 * @param obj
	 *            the value of the attribute
	 * @return this <CODE>Chunk</CODE>
	 */

	private Chunk setAttribute(String name, Object obj) {
		if (attributes == null)
			attributes = new HashMap();
		attributes.put(name, obj);
		return this;
	}

	/**
	 * Gets the attributes for this <CODE>Chunk</CODE>.
	 * <P>
	 * It may be null.
	 * 
	 * @return the attributes for this <CODE>Chunk</CODE>
	 */

	public HashMap getAttributes() {
		return attributes;
	}

	/**
	 * Checks the attributes of this <CODE>Chunk</CODE>.
	 * 
	 * @return false if there aren't any.
	 */

	public boolean hasAttributes() {
		return attributes != null;
	}

	/**
	 * Returns the image.
	 * 
	 * @return the image
	 */
    /* ssteward: dropped in 1.44
	public Image getImage() {
		if (attributes == null)
			return null;
		Object obj[] = (Object[]) attributes.get(Chunk.IMAGE);
		if (obj == null)
			return null;
		else {
			return (Image) obj[0];
		}
	}
    */
	/**
	 * Checks if a given tag corresponds with this object.
	 * 
	 * @param tag
	 *            the given tag
	 * @return true if the tag corresponds
	 */

	public static boolean isTag(String tag) {
		return ElementTags.CHUNK.equals(tag);
	}

	/**
	 * @see pdftk.com.lowagie.text.MarkupAttributes#setMarkupAttribute(java.lang.String,
	 *      java.lang.String)
	 */
	public void setMarkupAttribute(String name, String value) {
		if (markupAttributes == null)
			markupAttributes = new Properties();
		markupAttributes.put(name, value);
	}

	/**
	 * @see pdftk.com.lowagie.text.MarkupAttributes#setMarkupAttributes(java.util.Properties)
	 */
	public void setMarkupAttributes(Properties markupAttributes) {
		this.markupAttributes = markupAttributes;
	}

	/**
	 * @see pdftk.com.lowagie.text.MarkupAttributes#getMarkupAttribute(java.lang.String)
	 */
	public String getMarkupAttribute(String name) {
		return (markupAttributes == null) ? null : String
				.valueOf(markupAttributes.get(name));
	}

	/**
	 * @see pdftk.com.lowagie.text.MarkupAttributes#getMarkupAttributeNames()
	 */
	public Set getMarkupAttributeNames() {
		return getKeySet(markupAttributes);
	}

	/**
	 * @see pdftk.com.lowagie.text.MarkupAttributes#getMarkupAttributes()
	 */
	public Properties getMarkupAttributes() {
		return markupAttributes;
	}

	/**
	 * Gets the keys of a Hashtable
	 * 
	 * @param table
	 *            a Hashtable
	 * @return the keyset of a Hashtable (or an empty set if table is null)
	 */
	public static Set getKeySet(Hashtable table) {
		return (table == null) ? Collections.EMPTY_SET : table.keySet();
	}
} /*
 * $Id: DocListener.java,v 1.52 2004/12/14 11:52:47 blowagie Exp $
 * $Name:  $
 *
 * Copyright (c) 1999, 2000, 2001, 2002 Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

/**
 * A class that implements <CODE>DocListener</CODE> will perform some
 * actions when some actions are performed on a <CODE>Document</CODE>.
 *
 * @see		ElementListener
 * @see		Document
 * @see		DocWriter
 */

public interface DocListener extends ElementListener {
    
    // methods
    
/**
 * Signals that the <CODE>Document</CODE> has been opened and that
 * <CODE>Elements</CODE> can be added.
 */
    
    public void open();
    
/**
 * Sets the pagesize.
 *
 * @param	pageSize	the new pagesize
 * @return	a <CODE>boolean</CODE>
 */
    
    public boolean setPageSize(Rectangle pageSize);
    
/**
 * Signals that a <CODE>Watermark</CODE> was added to the <CODE>Document</CODE>.
 * 
 * @param watermark the Watermark object
 * @return	<CODE>true</CODE> if the element was added, <CODE>false</CODE> if not.
 */
    
    // public boolean add(Watermark watermark); ssteward: dropped in 1.44
    
/**
 * Signals that a <CODE>Watermark</CODE> was removed from the <CODE>Document</CODE>.
 */
    
    // public void removeWatermark(); ssteward: dropped in 1.44
    
/**
 * Sets the margins.
 *
 * @param	marginLeft		the margin on the left
 * @param	marginRight		the margin on the right
 * @param	marginTop		the margin on the top
 * @param	marginBottom	the margin on the bottom
 * @return	a <CODE>boolean</CODE>
 */
    
    public boolean setMargins(float marginLeft, float marginRight, float marginTop, float marginBottom);
    
    /**
     * Parameter that allows you to do margin mirroring (odd/even pages)
     * @param marginMirroring
     * @return true if succesfull
     */
    public boolean setMarginMirroring(boolean marginMirroring);
    
/**
 * Signals that an new page has to be started.
 *
 * @return	<CODE>true</CODE> if the page was added, <CODE>false</CODE> if not.
 * @throws	DocumentException	when a document isn't open yet, or has been closed
 */
    
    public boolean newPage() throws DocumentException;
    
/**
 * Changes the header of this document.
 *
 * @param	header		the new header
 */
    
    // public void setHeader(HeaderFooter header); ssteward: dropped in 1.44
    
/**
 * Resets the header of this document.
 */
    
    // public void resetHeader(); ssteward: dropped in 1.44
    
/**
 * Changes the footer of this document.
 *
 * @param	footer		the new footer
 */
    
    // public void setFooter(HeaderFooter footer); ssteward: dropped in 1.44
    
/**
 * Resets the footer of this document.
 */
    
    // public void resetFooter(); ssteward: dropped in 1.44
    
/**
 * Sets the page number to 0.
 */
    
    public void resetPageCount();
    
/**
 * Sets the page number.
 *
 * @param	pageN		the new page number
 */
    
    public void setPageCount(int pageN);
    
/**
 * Clears text wrapping around images (if applicable).
 * Method suggested by Pelikan Stephan
 * @throws DocumentException
 */
	public void clearTextWrap() throws DocumentException;
    
/**
 * Signals that the <CODE>Document</CODE> was closed and that no other
 * <CODE>Elements</CODE> will be added.
 * <P>
 * The outputstream of every writer implementing <CODE>DocListener</CODE> will be closed.
 */
    
    public void close();
} /*
 * $Id: DocWriter.java,v 1.70 2004/12/14 11:52:47 blowagie Exp $
 * $Name:  $
 *
 * Copyright 1999, 2000, 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

import java.io.BufferedOutputStream;
import java.io.OutputStream;
import java.io.IOException;
import java.util.Iterator;
import pdftk.com.lowagie.text.pdf.OutputStreamCounter;

/**
 * An abstract <CODE>Writer</CODE> class for documents.
 * <P>
 * <CODE>DocWriter</CODE> is the abstract class of several writers such
 * as <CODE>PdfWriter</CODE> and <CODE>HtmlWriter</CODE>.
 * A <CODE>DocWriter</CODE> can be added as a <CODE>DocListener</CODE>
 * to a certain <CODE>Document</CODE> by getting an instance (see method
 * <CODE>getInstance()</CODE> in the specific writer-classes).
 * Every <CODE>Element</CODE> added to the original <CODE>Document</CODE>
 * will be written to the <CODE>OutputStream</CODE> of the listening
 * <CODE>DocWriter</CODE>.
 *
 * @see   Document
 * @see   DocListener
 */

public abstract class DocWriter implements DocListener {

/** This is some byte that is often used. */
    public static final byte NEWLINE = (byte)'\n';

/** This is some byte that is often used. */
    public static final byte TAB = (byte)'\t';

/** This is some byte that is often used. */
    public static final byte LT = (byte)'<';

/** This is some byte that is often used. */
    public static final byte SPACE = (byte)' ';

/** This is some byte that is often used. */
    public static final byte EQUALS = (byte)'=';

/** This is some byte that is often used. */
    public static final byte QUOTE = (byte)'\"';

/** This is some byte that is often used. */
    public static final byte GT = (byte)'>';

/** This is some byte that is often used. */
    public static final byte FORWARD = (byte)'/';

    // membervariables

/** The pageSize. */
    protected Rectangle pageSize;

/** This is the document that has to be written. */
    // ssteward omit: protected Document document;

/** The outputstream of this writer. */
    protected OutputStreamCounter os;

/** Is the writer open for writing? */
    protected boolean open = false;

/** Do we have to pause all writing actions? */
    // ssteward: changed from "pause" to "m_pause" to
    // remove gcj complaints over ambiguity with pause()
    protected boolean m_pause = false;
    
/** Closes the stream on document close */
    protected boolean closeStream = true;

    // constructor
    
    protected DocWriter()  {
    }

/**
 * Constructs a <CODE>DocWriter</CODE>.
 *
 * @param document  The <CODE>Document</CODE> that has to be written
 * @param os  The <CODE>OutputStream</CODE> the writer has to write to.
 */

    protected DocWriter( /* ssteward omit: Document document,*/ OutputStream os)  {
        // ssteward omit: this.document = document;
        this.os = new OutputStreamCounter(new BufferedOutputStream(os));
    }

    // implementation of the DocListener methods

/**
 * Signals that an <CODE>Element</CODE> was added to the <CODE>Document</CODE>.
 * <P>
 * This method should be overriden in the specific <CODE>DocWriter<CODE> classes
 * derived from this abstract class.
 * 
 * @param element A high level object to add
 * @return  <CODE>false</CODE>
 * @throws  DocumentException when a document isn't open yet, or has been closed
 */

    public boolean add(Element element) throws DocumentException {
        return false;
    }

/**
 * Signals that the <CODE>Document</CODE> was opened.
 */

    public void open() {
        open = true;
    }

/**
 * Sets the pagesize.
 *
 * @param pageSize  the new pagesize
 * @return  a <CODE>boolean</CODE>
 */

    public boolean setPageSize(Rectangle pageSize) {
        this.pageSize = pageSize;
        return true;
    }

/**
 * Sets the <CODE>Watermark</CODE>.
 * <P>
 * This method should be overriden in the specific <CODE>DocWriter<CODE> classes
 * derived from this abstract class if they actually support the use of
 * a <CODE>Watermark</CODE>.
 * 
 * @param watermark A watermark object
 * @return  <CODE>false</CODE> (because watermarks aren't supported by default).
 */
/* ssteward: dropped in 1.44
    public boolean add(Watermark watermark) {
        return false;
    }
*/
/**
 * Removes the <CODE>Watermark</CODE> (if there is one).
 */
/* ssteward: dropped in 1.44
    public void removeWatermark() {
    }
*/
/**
 * Sets the margins.
 * <P>
 * This does nothing. Has to be overridden if needed.
 *
 * @param marginLeft    the margin on the left
 * @param marginRight   the margin on the right
 * @param marginTop   the margin on the top
 * @param marginBottom  the margin on the bottom
 * @return  <CODE>false</CODE>
 */

    public boolean setMargins(float marginLeft, float marginRight, float marginTop, float marginBottom) {
        return false;
    }

/**
 * Signals that an new page has to be started.
 * <P>
 * This does nothing. Has to be overridden if needed.
 *
 * @return  <CODE>true</CODE> if the page was added, <CODE>false</CODE> if not.
 * @throws  DocumentException when a document isn't open yet, or has been closed
 */

    public boolean newPage() throws DocumentException {
        if (!open) {
            return false;
        }
        return true;
    }

/**
 * Changes the header of this document.
 * <P>
 * This method should be overriden in the specific <CODE>DocWriter<CODE> classes
 * derived from this abstract class if they actually support the use of
 * headers.
 *
 * @param header    the new header
 */
/* ssteward: dropped in 1.44
    public void setHeader(HeaderFooter header) {
    }
*/

/**
 * Resets the header of this document.
 * <P>
 * This method should be overriden in the specific <CODE>DocWriter<CODE> classes
 * derived from this abstract class if they actually support the use of
 * headers.
 */

    public void resetHeader() {
    }

/**
 * Changes the footer of this document.
 * <P>
 * This method should be overriden in the specific <CODE>DocWriter<CODE> classes
 * derived from this abstract class if they actually support the use of
 * footers.
 *
 * @param footer    the new footer
 */
/* ssteward: dropped in 1.44
    public void setFooter(HeaderFooter footer) {
    }
*/

/**
 * Resets the footer of this document.
 * <P>
 * This method should be overriden in the specific <CODE>DocWriter<CODE> classes
 * derived from this abstract class if they actually support the use of
 * footers.
 */

    public void resetFooter() {
    }

/**
 * Sets the page number to 0.
 * <P>
 * This method should be overriden in the specific <CODE>DocWriter<CODE> classes
 * derived from this abstract class if they actually support the use of
 * pagenumbers.
 */

    public void resetPageCount() {
    }

/**
 * Sets the page number.
 * <P>
 * This method should be overriden in the specific <CODE>DocWriter<CODE> classes
 * derived from this abstract class if they actually support the use of
 * pagenumbers.
 *
 * @param pageN   the new page number
 */

    public void setPageCount(int pageN) {
    }

/**
 * Signals that the <CODE>Document</CODE> was closed and that no other
 * <CODE>Elements</CODE> will be added.
 */

    public void close() {
        open = false;
        try {
            os.flush();
            if (closeStream)
                os.close();
        }
        catch(IOException ioe) {
            throw new ExceptionConverter(ioe);
        }
    }

    // methods

/** Converts a <CODE>String</CODE> into a <CODE>Byte</CODE> array
 * according to the ISO-8859-1 codepage.
 * @param text the text to be converted
 * @return the conversion result
 */

    public static final byte[] getISOBytes(String text)
    {
        if (text == null)
            return null;
        int len = text.length();
        byte b[] = new byte[len];
        for (int k = 0; k < len; ++k)
            b[k] = (byte)text.charAt(k);
        return b;
    }

/**
 * Let the writer know that all writing has to be paused.
 */

    public void pause() {
	// ssteward
        m_pause = true;
    }

/**
 * Let the writer know that writing may be resumed.
 */

    public void resume() {
	// ssteward
        m_pause = false;
    }

/**
 * Flushes the <CODE>BufferedOutputStream</CODE>.
 */

    public void flush() {
        try {
            os.flush();
        }
        catch(IOException ioe) {
            throw new ExceptionConverter(ioe);
        }
    }

/**
 * Writes a <CODE>String</CODE> to the <CODE>OutputStream</CODE>.
 *
 * @param string    the <CODE>String</CODE> to write
 * @throws IOException
 */

    protected void write(String string) throws IOException {
        os.write(getISOBytes(string));
    }

/**
 * Writes a number of tabs.
 *
 * @param   indent  the number of tabs to add
 * @throws IOException
 */

    protected void addTabs(int indent) throws IOException {
        os.write(NEWLINE);
        for (int i = 0; i < indent; i++) {
            os.write(TAB);
        }
    }

/**
 * Writes a key-value pair to the outputstream.
 *
 * @param   key     the name of an attribute
 * @param   value   the value of an attribute
 * @throws IOException
 */

    protected void write(String key, String value)
    throws IOException {
        os.write(SPACE);
        write(key);
        os.write(EQUALS);
        os.write(QUOTE);
        write(value);
        os.write(QUOTE);
    }

/**
 * Writes a starttag to the outputstream.
 *
 * @param   tag     the name of the tag
 * @throws IOException
 */

    protected void writeStart(String tag)
    throws IOException {
        os.write(LT);
        write(tag);
    }

/**
 * Writes an endtag to the outputstream.
 *
 * @param   tag     the name of the tag
 * @throws IOException
 */

    protected void writeEnd(String tag)
    throws IOException {
        os.write(LT);
        os.write(FORWARD);
        write(tag);
        os.write(GT);
    }

/**
 * Writes an endtag to the outputstream.
 * @throws IOException
 */

    protected void writeEnd()
    throws IOException {
        os.write(SPACE);
        os.write(FORWARD);
        os.write(GT);
    }

/**
 * Writes the markup attributes of the specified <CODE>MarkupAttributes</CODE>
 * object to the <CODE>OutputStream</CODE>.
 * @param mAtt   the <CODE>MarkupAttributes</CODE> to write.
 * @return true, if writing the markup attributes succeeded
 * @throws IOException
 */
    protected boolean writeMarkupAttributes(MarkupAttributes mAtt)
     throws IOException
    {
      Iterator attributeIterator = mAtt.getMarkupAttributeNames().iterator();
      boolean result = attributeIterator.hasNext();
      while (attributeIterator.hasNext()) {
        String name = String.valueOf(attributeIterator.next());
        write(name, mAtt.getMarkupAttribute(name));
      }
      return result;
    }

/**
 * Returns <CODE>true</CODE> if the specified <CODE>Element</CODE> implements
 * <CODE>MarkupAttributes</CODE> and has one or more attributes to write.
 * @param element   the <CODE>Element</CODE> to check.
 * @return <CODE>boolean</CODE>.
 */
    protected static boolean hasMarkupAttributes(Element element) {
      return (element instanceof MarkupAttributes &&
       !(((MarkupAttributes)element).getMarkupAttributeNames().isEmpty()));
    }

    /** Checks if the stream is to be closed on document close
     * @return true if the stream is closed on documnt close
     *
     */
    public boolean isCloseStream() {
        return closeStream;
    }
    
    /** Sets the close state of the stream after document close
     * @param closeStream true if the stream is closed on document close
     *
     */
    public void setCloseStream(boolean closeStream) {
        this.closeStream = closeStream;
    }
    
    
	/**
	 * @see pdftk.com.lowagie.text.DocListener#clearTextWrap()
	 */
	public void clearTextWrap() throws DocumentException {
		// do nothing
	}
    /**
     * @see pdftk.com.lowagie.text.DocListener#setMarginMirroring(boolean)
     */
    public boolean setMarginMirroring(boolean MarginMirroring) {
        return false;
    }
    
}
 /*
 * $Id: Document.java,v 1.100 2005/07/17 14:45:30 blowagie Exp $
 * $Name:  $
 *
 * Copyright 1999, 2000, 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Iterator;

import java.util.Date;

/**
 * A generic Document class.
 * <P>
 * All kinds of Text-elements can be added to a <CODE>HTMLDocument</CODE>.
 * The <CODE>Document</CODE> signals all the listeners when an element has
 * been added.
 * <P>
 * Remark:
 * <OL>
 *     <LI>Once a document is created you can add some meta information.
 *     <LI>You can also set the headers/footers.
 *     <LI>You have to open the document before you can write content.
 * <LI>You can only write content (no more meta-formation!) once a document is
 * opened.
 * <LI>When you change the header/footer on a certain page, this will be
 * effective starting on the next page.
 * <LI>Ater closing the document, every listener (as well as its <CODE>
 * OutputStream</CODE>) is closed too.
 * </OL>
 * Example: <BLOCKQUOTE>
 *
 * <PRE>// creation of the document with a certain size and certain margins
 * <STRONG>Document document = new Document(PageSize.A4, 50, 50, 50, 50);
 * </STRONG> try { // creation of the different writers HtmlWriter.getInstance(
 * <STRONG>document </STRONG>, System.out); PdfWriter.getInstance(
 * <STRONG>document </STRONG>, new FileOutputStream("text.pdf"));
 *    // we add some meta information to the document
 * <STRONG>document.addAuthor("Bruno Lowagie"); </STRONG>
 * <STRONG>document.addSubject("This is the result of a Test."); </STRONG>
 *  // we define a header and a footer HeaderFooter header = new
 * HeaderFooter(new Phrase("This is a header."), false); HeaderFooter footer =
 * new HeaderFooter(new Phrase("This is page "), new Phrase("."));
 *    footer.setAlignment(Element.ALIGN_CENTER);
 * <STRONG>document.setHeader(header); </STRONG>
 * <STRONG>document.setFooter(footer); </STRONG>// we open the document for
 * writing <STRONG>document.open(); </STRONG> <STRONG>document.add(new
 * Paragraph("Hello world")); </STRONG>} catch(DocumentException de) {
 * System.err.println(de.getMessage()); } <STRONG>document.close(); </STRONG>
 * </CODE>
 * </PRE>
 * 
 * </BLOCKQUOTE>
 */

public class Document implements DocListener {
    
    // membervariables
    
	/** This constant may only be changed by Paulo Soares and/or Bruno Lowagie. */
	private static final String ITEXT_VERSION = "itext-paulo-155 (itextpdf.sf.net-lowagie.com)";
    
	/**
	 * Allows the pdf documents to be produced without compression for debugging
	 * purposes.
	 */
    public static boolean compress = true; 
    
	/** The DocListener. */
    private ArrayList listeners = new ArrayList();
    
	/** Is the document open or not? */
    protected boolean open;
    
	/** Has the document already been closed? */
    protected boolean close;
    
    // membervariables concerning the layout
    
	/** The size of the page. */
    protected Rectangle pageSize;
    
	/** The watermark on the pages. */
    // protected Watermark watermark = null; ssteward: dropped in 1.44
    
	/** margin in x direction starting from the left */
    protected float marginLeft = 0;
    
	/** margin in x direction starting from the right */
    protected float marginRight = 0;
    
	/** margin in y direction starting from the top */
    protected float marginTop = 0;
    
	/** margin in y direction starting from the bottom */
    protected float marginBottom = 0;
    
    protected boolean marginMirroring = false;
    
	/** Content of JavaScript onLoad function */
    protected String javaScript_onLoad = null;

	/** Content of JavaScript onUnLoad function */
    protected String javaScript_onUnLoad = null;

	/** Style class in HTML body tag */
    protected String htmlStyleClass = null;

    // headers, footers
    
	/** Current pagenumber */
    protected int pageN = 0;
    
	/** This is the textual part of a Page; it can contain a header */
    // protected HeaderFooter header = null; ssteward: dropped in 1.44
    
	/** This is the textual part of the footer */
    // protected HeaderFooter footer = null; ssteward: dropped in 1.44
    
    // constructor
    
	/**
	 * Constructs a new <CODE>Document</CODE> -object.
 */
    
    public Document() {
        this(PageSize.A4);
    }
    
	/**
	 * Constructs a new <CODE>Document</CODE> -object.
 *
	 * @param pageSize
	 *            the pageSize
 */
    
    public Document(Rectangle pageSize) {
        this(pageSize, 36, 36, 36, 36);
    }
    
	/**
	 * Constructs a new <CODE>Document</CODE> -object.
 *
	 * @param pageSize
	 *            the pageSize
	 * @param marginLeft
	 *            the margin on the left
	 * @param marginRight
	 *            the margin on the right
	 * @param marginTop
	 *            the margin on the top
	 * @param marginBottom
	 *            the margin on the bottom
 */
    
	public Document(Rectangle pageSize, float marginLeft, float marginRight,
			float marginTop, float marginBottom) {
        this.pageSize = pageSize;
        this.marginLeft = marginLeft;
        this.marginRight = marginRight;
        this.marginTop = marginTop;
        this.marginBottom = marginBottom;
    }
    
    // listener methods
    
	/**
 * Adds a <CODE>DocListener</CODE> to the <CODE>Document</CODE>.
 *
	 * @param listener
	 *            the new DocListener.
 */
    
    public void addDocListener(DocListener listener) {
        listeners.add(listener);
    }
    
	/**
 * Removes a <CODE>DocListener</CODE> from the <CODE>Document</CODE>.
 *
	 * @param listener
	 *            the DocListener that has to be removed.
 */
    
    public void removeDocListener(DocListener listener) {
        listeners.remove(listener);
    }
    
    // methods implementing the DocListener interface
    
	/**
	 * Adds an <CODE>Element</CODE> to the <CODE>Document</CODE>.
 *
	 * @param element
	 *            the <CODE>Element</CODE> to add
	 * @return <CODE>true</CODE> if the element was added, <CODE>false
	 *         </CODE> if not
	 * @throws DocumentException
	 *             when a document isn't open yet, or has been closed
 */
    
    public boolean add(Element element) throws DocumentException {
        if (close) {
			throw new DocumentException(
					"The document has been closed. You can't add any Elements.");
        }
        int type = element.type();
        if (open) {
			if (!(type == Element.CHUNK || type == Element.PHRASE
					|| type == Element.PARAGRAPH || type == Element.TABLE
					|| type == Element.PTABLE
					|| type == Element.MULTI_COLUMN_TEXT
					|| type == Element.ANCHOR || type == Element.ANNOTATION
					|| type == Element.CHAPTER || type == Element.SECTION
					|| type == Element.LIST || type == Element.LISTITEM
					|| type == Element.RECTANGLE || type == Element.JPEG
					|| type == Element.IMGRAW || type == Element.IMGTEMPLATE || type == Element.GRAPHIC)) {
				throw new DocumentException(
						"The document is open; you can only add Elements with content.");
			}
		} else {
			if (!(type == Element.HEADER || type == Element.TITLE
					|| type == Element.SUBJECT || type == Element.KEYWORDS
					|| type == Element.AUTHOR || type == Element.PRODUCER
					|| type == Element.CREATOR || type == Element.CREATIONDATE)) {
				throw new DocumentException(
						"The document is not open yet; you can only add Meta information.");
            }
        }
        boolean success = false;
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
            success |= listener.add(element);
        }
        return success;
    }
    
	/**
 * Opens the document.
 * <P>
	 * Once the document is opened, you can't write any Header- or
	 * Meta-information anymore. You have to open the document before you can
	 * begin to add content to the body of the document.
 */
    
    public void open() {
		if (!close) {
            open = true;
        }
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
            listener.setPageSize(pageSize);
			listener.setMargins(marginLeft, marginRight, marginTop,
					marginBottom);
            listener.open();
        }
    }
    
	/**
 * Sets the pagesize.
 *
	 * @param pageSize
	 *            the new pagesize
 * @return	a <CODE>boolean</CODE>
 */
    
    public boolean setPageSize(Rectangle pageSize) {
        this.pageSize = pageSize;
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
            listener.setPageSize(pageSize);
        }
        return true;
    }
    
	/**
 * Sets the <CODE>Watermark</CODE>.
 *
	 * @param watermark
	 *            the watermark to add
	 * @return <CODE>true</CODE> if the element was added, <CODE>false
	 *         </CODE> if not.
 */
    /* ssteward: dropped in 1.44
    public boolean add(Watermark watermark) {
        this.watermark = watermark;
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
            listener.add(watermark);
        }
        return true;
    }
    */
    
	/**
 * Removes the <CODE>Watermark</CODE>.
 */
    /* ssteward: dropped in 1.44
    public void removeWatermark() {
        this.watermark = null;
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
            listener.removeWatermark();
        }
    }
    */
    
	/**
 * Sets the margins.
 *
	 * @param marginLeft
	 *            the margin on the left
	 * @param marginRight
	 *            the margin on the right
	 * @param marginTop
	 *            the margin on the top
	 * @param marginBottom
	 *            the margin on the bottom
 * @return	a <CODE>boolean</CODE>
 */
    
	public boolean setMargins(float marginLeft, float marginRight,
			float marginTop, float marginBottom) {
        this.marginLeft = marginLeft;
        this.marginRight = marginRight;
        this.marginTop = marginTop;
        this.marginBottom = marginBottom;
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
			listener.setMargins(marginLeft, marginRight, marginTop,
					marginBottom);
        }
        return true;
    }
    
	/**
 * Signals that an new page has to be started.
 *
	 * @return <CODE>true</CODE> if the page was added, <CODE>false</CODE>
	 *         if not.
	 * @throws DocumentException
	 *             when a document isn't open yet, or has been closed
 */
    
    public boolean newPage() throws DocumentException {
        if (!open || close) {
            return false;
        }
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
            listener.newPage();
        }
        return true;
    }
    
	/**
 * Changes the header of this document.
 *
	 * @param header
	 *            the new header
 */
    /* ssteward: dropped in 1.44
    public void setHeader(HeaderFooter header) {
        this.header = header;
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
            listener.setHeader(header);
        }
    }
    */
    
	/**
 * Resets the header of this document.
 */
    /* ssteward: dropped in 1.44
    public void resetHeader() {
        this.header = null;
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
            listener.resetHeader();
        }
    }
    */
    
	/**
 * Changes the footer of this document.
 *
	 * @param footer
	 *            the new footer
 */
    /* ssteward: dropped in 1.44
    public void setFooter(HeaderFooter footer) {
        this.footer = footer;
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
            listener.setFooter(footer);
        }
    }
    */
    
	/**
 * Resets the footer of this document.
 */
    /* ssteward: dropped in 1.44
    public void resetFooter() {
        this.footer = null;
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
            listener.resetFooter();
        }
    }
    */
    
	/**
 * Sets the page number to 0.
 */
    
    public void resetPageCount() {
        pageN = 0;
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
            listener.resetPageCount();
        }
    }
    
	/**
 * Sets the page number.
 *
	 * @param pageN
	 *            the new page number
 */
    
    public void setPageCount(int pageN) {
        this.pageN = pageN;
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
            listener.setPageCount(pageN);
        }
    }
    
	/**
 * Returns the current page number.
 *
 * @return the current page number
 */
    
    public int getPageNumber() {
        return this.pageN;
    }
    
	/**
 * Closes the document.
 * <P>
	 * Once all the content has been written in the body, you have to close the
	 * body. After that nothing can be written to the body anymore.
 */
    
    public void close() {
		if (!close) {
            open = false;
            close = true;
        }
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
            listener.close();
        }
    }
    
    // methods concerning the header or some meta information
    
	/**
 * Adds a user defined header to the document.
 *
	 * @param name
	 *            the name of the header
	 * @param content
	 *            the content of the header
 * @return	<CODE>true</CODE> if successful, <CODE>false</CODE> otherwise
 */
    
    public boolean addHeader(String name, String content) {
        try {
            return add(new Header(name, content));
		} catch (DocumentException de) {
            throw new ExceptionConverter(de);
        }
    }
    
	/**
 * Adds the title to a Document.
 *
	 * @param title
	 *            the title
 * @return	<CODE>true</CODE> if successful, <CODE>false</CODE> otherwise
 */
    
    public boolean addTitle(String title) {
        try {
            return add(new Meta(Element.TITLE, title));
		} catch (DocumentException de) {
            throw new ExceptionConverter(de);
        }
    }
    
	/**
 * Adds the subject to a Document.
 *
	 * @param subject
	 *            the subject
 * @return	<CODE>true</CODE> if successful, <CODE>false</CODE> otherwise
 */
    
    public boolean addSubject(String subject) {
        try {
            return add(new Meta(Element.SUBJECT, subject));
		} catch (DocumentException de) {
            throw new ExceptionConverter(de);
        }
    }
    
	/**
 * Adds the keywords to a Document.
 *
	 * @param keywords
	 *            adds the keywords to the document
 * @return <CODE>true</CODE> if successful, <CODE>false</CODE> otherwise
 */
    
    public boolean addKeywords(String keywords) {
        try {
            return add(new Meta(Element.KEYWORDS, keywords));
		} catch (DocumentException de) {
            throw new ExceptionConverter(de);
        }
    }
    
	/**
 * Adds the author to a Document.
 *
	 * @param author
	 *            the name of the author
 * @return	<CODE>true</CODE> if successful, <CODE>false</CODE> otherwise
 */
    
    public boolean addAuthor(String author) {
        try {
            return add(new Meta(Element.AUTHOR, author));
		} catch (DocumentException de) {
            throw new ExceptionConverter(de);
        }
    }
    
	/**
 * Adds the creator to a Document.
 *
	 * @param creator
	 *            the name of the creator
 * @return	<CODE>true</CODE> if successful, <CODE>false</CODE> otherwise
 */
    
    public boolean addCreator(String creator) {
        try {
            return add(new Meta(Element.CREATOR, creator));
		} catch (DocumentException de) {
            throw new ExceptionConverter(de);
        }
    }
    
	/**
 * Adds the producer to a Document.
 *
 * @return	<CODE>true</CODE> if successful, <CODE>false</CODE> otherwise
 */
    
    public boolean addProducer() {
        try {
            return add(new Meta(Element.PRODUCER, "iText by lowagie.com"));
		} catch (DocumentException de) {
            throw new ExceptionConverter(de);
        }
    }
    
	/**
 * Adds the current date and time to a Document.
 *
 * @return	<CODE>true</CODE> if successful, <CODE>false</CODE> otherwise
 */
    
    public boolean addCreationDate() {
        try {
			/* bugfix by 'taqua' (Thomas) */
			final SimpleDateFormat sdf = new SimpleDateFormat(
					"EEE MMM dd HH:mm:ss zzz yyyy");
			return add(new Meta(Element.CREATIONDATE, sdf.format(new Date())));
		} catch (DocumentException de) {
            throw new ExceptionConverter(de);
        }
    }
    
    // methods to get the layout of the document.
    
	/**
 * Returns the left margin.
 *
 * @return	the left margin
 */
    
    public float leftMargin() {
        return marginLeft;
    }
    
	/**
 * Return the right margin.
 *
 * @return	the right margin
 */
    
    public float rightMargin() {
        return marginRight;
    }
    
	/**
 * Returns the top margin.
 *
 * @return	the top margin
 */
    
    public float topMargin() {
        return marginTop;
    }
    
	/**
 * Returns the bottom margin.
 *
 * @return	the bottom margin
 */
    
    public float bottomMargin() {
        return marginBottom;
    }
    
	/**
 * Returns the lower left x-coordinate.
 *
 * @return	the lower left x-coordinate
 */
    
    public float left() {
        return pageSize.left(marginLeft);
    }
    
	/**
 * Returns the upper right x-coordinate.
 *
 * @return	the upper right x-coordinate
 */
    
    public float right() {
        return pageSize.right(marginRight);
    }
    
	/**
 * Returns the upper right y-coordinate.
 *
 * @return	the upper right y-coordinate
 */
    
    public float top() {
        return pageSize.top(marginTop);
    }
    
	/**
 * Returns the lower left y-coordinate.
 *
 * @return	the lower left y-coordinate
 */
    
    public float bottom() {
        return pageSize.bottom(marginBottom);
    }
    
	/**
 * Returns the lower left x-coordinate considering a given margin.
 *
	 * @param margin
	 *            a margin
 * @return	the lower left x-coordinate
 */
    
    public float left(float margin) {
        return pageSize.left(marginLeft + margin);
    }
    
	/**
 * Returns the upper right x-coordinate, considering a given margin.
 *
	 * @param margin
	 *            a margin
 * @return	the upper right x-coordinate
 */
    
    public float right(float margin) {
        return pageSize.right(marginRight + margin);
    }
    
	/**
 * Returns the upper right y-coordinate, considering a given margin.
 *
	 * @param margin
	 *            a margin
 * @return	the upper right y-coordinate
 */
    
    public float top(float margin) {
        return pageSize.top(marginTop + margin);
    }
    
	/**
 * Returns the lower left y-coordinate, considering a given margin.
 *
	 * @param margin
	 *            a margin
 * @return	the lower left y-coordinate
 */
    
    public float bottom(float margin) {
        return pageSize.bottom(marginBottom + margin);
    }
    
	/**
 * Gets the pagesize.
	 * 
 * @return the page size
 */
    
	public Rectangle getPageSize() {
        return this.pageSize;
    }
    
	/**
	 * Checks if the document is open.
	 * 
     * @return <CODE>true</CODE> if the document is open
     */    
    public boolean isOpen() {
        return open;
    }
    
	/**
	 * Gets the iText version.
	 * This method may only be changed by Paulo Soares and/or Bruno Lowagie.
     * @return iText version
     */    
    public static final String getVersion() {
        return ITEXT_VERSION;
    }

	/**
 * Adds a JavaScript onLoad function to the HTML body tag
 *
	 * @param code
	 *            the JavaScript code to be executed on load of the HTML page
 */
    
    public void setJavaScript_onLoad(String code) {
        this.javaScript_onLoad = code;
    }

	/**
 * Gets the JavaScript onLoad command.
	 * 
 * @return the JavaScript onLoad command
 */

    public String getJavaScript_onLoad() {
        return this.javaScript_onLoad;
    }

	/**
 * Adds a JavaScript onUnLoad function to the HTML body tag
 *
	 * @param code
	 *            the JavaScript code to be executed on unload of the HTML page
 */
    
    public void setJavaScript_onUnLoad(String code) {
        this.javaScript_onUnLoad = code;
    }

	/**
 * Gets the JavaScript onUnLoad command.
	 * 
 * @return the JavaScript onUnLoad command
 */

    public String getJavaScript_onUnLoad() {
        return this.javaScript_onUnLoad;
    }

	/**
 * Adds a style class to the HTML body tag
 *
	 * @param htmlStyleClass
	 *            the style class for the HTML body tag
 */
    
    public void setHtmlStyleClass(String htmlStyleClass) {
        this.htmlStyleClass = htmlStyleClass;
    }

	/**
 * Gets the style class of the HTML body tag
 *
 * @return		the style class of the HTML body tag
 */
    
    public String getHtmlStyleClass() {
        return this.htmlStyleClass;
    }

	/**
 	 * @see pdftk.com.lowagie.text.DocListener#clearTextWrap()
     */
	public void clearTextWrap() throws DocumentException {
		if (open && !close) {
			DocListener listener;
			for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
				listener = (DocListener) iterator.next();
				listener.clearTextWrap();
			}
		}
	}
    
    /**
     * Set the margin mirroring. It will mirror margins for odd/even pages.
     * <p>
     * Note: it will not work with {@link Table}.
	 * 
	 * @param marginMirroring
	 *            <CODE>true</CODE> to mirror the margins
     * @return always <CODE>true</CODE>
     */    
    public boolean setMarginMirroring(boolean marginMirroring) {
        this.marginMirroring = marginMirroring;
        DocListener listener;
		for (Iterator iterator = listeners.iterator(); iterator.hasNext();) {
            listener = (DocListener) iterator.next();
            listener.setMarginMirroring(marginMirroring);
        }
        return true;
    }
    
    /**
     * Gets the margin mirroring flag.
	 * 
     * @return the margin mirroring flag
     */    
    public boolean isMarginMirroring() {
        return marginMirroring;
    }
}
 /*
 * $Id: DocumentException.java,v 1.50 2004/12/14 11:52:46 blowagie Exp $
 * $Name:  $
 *
 * Copyright 1999, 2000, 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 *
 */

package pdftk.com.lowagie.text;

/**
 * Signals that an error has occurred in a <CODE>Document</CODE>.
 *
 * @see		BadElementException
 * @see		Document
 * @see		DocWriter
 * @see		DocListener
 */

public class DocumentException extends Exception {

    /** A serial version UID */
    private static final long serialVersionUID = -2191131489390840739L;

    private Exception ex;

    /**
     * Creates a Document exception.
     * @param ex an exception that has to be turned into a DocumentException
     */
    public DocumentException(Exception ex) {
        this.ex = ex;
    }
    
    // constructors
    
/**
 * Constructs a <CODE>DocumentException</CODE> whithout a message.
 */
    
    public DocumentException() {
        super();
    }
    
/**
 * Constructs a <code>DocumentException</code> with a message.
 *
 * @param		message			a message describing the exception
 */
    
    public DocumentException(String message) {
        super(message);
    }

    /**
     * We print the message of the checked exception 
     * @return the error message
     */
    public String getMessage() {
        if (ex == null)
            return super.getMessage();
        else
            return ex.getMessage();
    }

    /**
     * and make sure we also produce a localized version 
     * @return a localized message
     */
    public String getLocalizedMessage() {
        if (ex == null)
            return super.getLocalizedMessage();
        else
            return ex.getLocalizedMessage();
    }

    /**
     * The toString() is changed to be prefixed with ExceptionConverter 
     * @return the String version of the exception
     */
    public String toString() {
        if (ex == null)
            return super.toString();
        else
            return split(getClass().getName()) + ": " + ex;
    }

    /** we have to override this as well */
    public void printStackTrace() {
        printStackTrace(System.err);
    }

    /**
     * here we prefix, with s.print(), not s.println(), the stack
     * trace with "ExceptionConverter:" 
     * @param s a printstream object
     */
    public void printStackTrace(java.io.PrintStream s) {
        if (ex == null)
            super.printStackTrace(s);
        else {
            synchronized (s) {
                s.print(split(getClass().getName()) + ": ");
                ex.printStackTrace(s);
            }
        }
    }

    /**
     * Again, we prefix the stack trace with "ExceptionConverter:" 
     * @param s A PrintWriter object
     */
    public void printStackTrace(java.io.PrintWriter s) {
        if (ex == null)
            super.printStackTrace(s);
        else {
            synchronized (s) {
                s.print(split(getClass().getName()) + ": ");
                ex.printStackTrace(s);
            }
        }
    }

    /**
     * Removes everything in a String that comes before a '.'
     * @param s the original string
     * @return the part that comes after the dot
     */
    private static String split(String s) {
        int i = s.lastIndexOf('.');
        if (i < 0)
            return s;
        else
            return s.substring(i + 1);
    }
    
    /** requests to fill in the stack trace we will have to ignore.
     * We can't throw an exception here, because this method
     * is called by the constructor of Throwable */
//    public Throwable fillInStackTrace() {
//        if (ex == null)
//            return super.fillInStackTrace();
//        else
//            return this;
//    }

}
 /*
 * $Id: Element.java,v 1.66 2005/05/04 14:41:15 blowagie Exp $
 * $Name:  $
 *
 * Copyright 1999, 2000, 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

import java.util.ArrayList;

/**
 * Interface for a text element.
 * <P>
 * Remark: I looked at the interface javax.swing.text.Element, but I decided to
 * write my own text-classes for two reasons:
 * <OL>
 * <LI>The javax.swing.text-classes may be very generic, I think they are
 * overkill: they are to heavy for what they have to do.
 * <LI>A lot of people using iText (formerly known as rugPdf), still use
 * JDK1.1.x. I try to keep the Java2 requirements limited to the Collection
 * classes (I think they're really great). However, if I use the
 * javax.swing.text classes, it will become very difficult to downgrade rugPdf.
 * </OL>
 * 
 * @see Anchor
 * @see Cell
 * @see Chapter
 * @see Chunk
 * @see Graphic
 * @see Header
 * @see Image
 * @see Jpeg
 * @see List
 * @see ListItem
 * @see Meta
 * @see Paragraph
 * @see Phrase
 * @see Rectangle
 * @see Row
 * @see Section
 * @see Table
 */

public interface Element {

	// static membervariables (meta information)

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int HEADER = 0;

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int TITLE = 1;

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int SUBJECT = 2;

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int KEYWORDS = 3;

	/** This is a possible type of <CODE>Element </CIDE>. */
	public static final int AUTHOR = 4;

	/** This is a possible type of <CODE>Element </CIDE>. */
	public static final int PRODUCER = 5;

	/** This is a possible type of <CODE>Element </CIDE>. */
	public static final int CREATIONDATE = 6;

	/** This is a possible type of <CODE>Element </CIDE>. */
	public static final int CREATOR = 7;

	// static membervariables (content)

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int CHUNK = 10;

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int PHRASE = 11;

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int PARAGRAPH = 12;

	/** This is a possible type of <CODE>Element</CODE> */
	public static final int SECTION = 13;

	/** This is a possible type of <CODE>Element</CODE> */
	public static final int LIST = 14;

	/** This is a possible type of <CODE>Element</CODE> */
	public static final int LISTITEM = 15;

	/** This is a possible type of <CODE>Element</CODE> */
	public static final int CHAPTER = 16;

	/** This is a possible type of <CODE>Element</CODE> */
	public static final int ANCHOR = 17;

	// static membervariables (tables)

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int CELL = 20;

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int ROW = 21;

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int TABLE = 22;

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int PTABLE = 23;

	// static membervariables (annotations)

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int ANNOTATION = 29;

	// static membervariables (geometric figures)

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int RECTANGLE = 30;

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int JPEG = 32;

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int IMGRAW = 34;

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int IMGTEMPLATE = 35;

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int GRAPHIC = 39;

	/** This is a possible type of <CODE>Element</CODE>. */
	public static final int MULTI_COLUMN_TEXT = 40;

	// static membervariables (alignment)

	/**
	 * A possible value for paragraph alignment. This specifies that the text is
	 * aligned to the left indent and extra whitespace should be placed on the
	 * right.
	 */
	public static final int ALIGN_UNDEFINED = -1;

	/**
	 * A possible value for paragraph alignment. This specifies that the text is
	 * aligned to the left indent and extra whitespace should be placed on the
	 * right.
	 */
	public static final int ALIGN_LEFT = 0;

	/**
	 * A possible value for paragraph alignment. This specifies that the text is
	 * aligned to the center and extra whitespace should be placed equally on
	 * the left and right.
	 */
	public static final int ALIGN_CENTER = 1;

	/**
	 * A possible value for paragraph alignment. This specifies that the text is
	 * aligned to the right indent and extra whitespace should be placed on the
	 * left.
	 */
	public static final int ALIGN_RIGHT = 2;

	/**
	 * A possible value for paragraph alignment. This specifies that extra
	 * whitespace should be spread out through the rows of the paragraph with
	 * the text lined up with the left and right indent except on the last line
	 * which should be aligned to the left.
	 */
	public static final int ALIGN_JUSTIFIED = 3;

	/**
	 * A possible value for vertical alignment.
	 */

	public static final int ALIGN_TOP = 4;

	/**
	 * A possible value for vertical alignment.
	 */

	public static final int ALIGN_MIDDLE = 5;

	/**
	 * A possible value for vertical alignment.
	 */

	public static final int ALIGN_BOTTOM = 6;

	/**
	 * A possible value for vertical alignment.
	 */
	public static final int ALIGN_BASELINE = 7;

	/**
	 * Does the same as ALIGN_JUSTIFIED but the last line is also spread out.
	 */
	public static final int ALIGN_JUSTIFIED_ALL = 8;

	// static member variables for CCITT compression

	/**
	 * Pure two-dimensional encoding (Group 4)
	 */
	public static final int CCITTG4 = 0x100;

	/**
	 * Pure one-dimensional encoding (Group 3, 1-D)
	 */
	public static final int CCITTG3_1D = 0x101;

	/**
	 * Mixed one- and two-dimensional encoding (Group 3, 2-D)
	 */
	public static final int CCITTG3_2D = 0x102;

	/**
	 * A flag indicating whether 1-bits are to be interpreted as black pixels
	 * and 0-bits as white pixels,
	 */
	public static final int CCITT_BLACKIS1 = 1;

	/**
	 * A flag indicating whether the filter expects extra 0-bits before each
	 * encoded line so that the line begins on a byte boundary.
	 */
	public static final int CCITT_ENCODEDBYTEALIGN = 2;

	/**
	 * A flag indicating whether end-of-line bit patterns are required to be
	 * present in the encoding.
	 */
	public static final int CCITT_ENDOFLINE = 4;

	/**
	 * A flag indicating whether the filter expects the encoded data to be
	 * terminated by an end-of-block pattern, overriding the Rows parameter. The
	 * use of this flag will set the key /EndOfBlock to false.
	 */
	public static final int CCITT_ENDOFBLOCK = 8;

	// methods

	/**
	 * Processes the element by adding it (or the different parts) to an <CODE>
	 * ElementListener</CODE>.
	 * 
	 * @param listener
	 *            an <CODE>ElementListener</CODE>
	 * @return <CODE>true</CODE> if the element was processed successfully
	 */

	public boolean process(ElementListener listener);

	/**
	 * Gets the type of the text element.
	 * 
	 * @return a type
	 */

	public int type();

	/**
	 * Gets all the chunks in this element.
	 * 
	 * @return an <CODE>ArrayList</CODE>
	 */

	public ArrayList getChunks();

	/**
	 * Gets the content of the text element.
	 * 
	 * @return a type
	 */

	public String toString();
} /*
 * $Id: ElementListener.java,v 1.48 2004/12/14 11:52:46 blowagie Exp $
 * $Name:  $
 *
 * Copyright 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

import java.util.EventListener;

/**
 * A class that implements <CODE>ElementListener</CODE> will perform some
 * actions when an <CODE>Element</CODE> is added.
 *
 * @see		DocListener
 */

public interface ElementListener extends EventListener {
    
    // methods
    
/**
 * Signals that an <CODE>Element</CODE> was added to the <CODE>Document</CODE>.
 * 
 * @param element a high level object
 * @return	<CODE>true</CODE> if the element was added, <CODE>false</CODE> if not.
 * @throws	DocumentException	when a document isn't open yet, or has been closed
 */
    
    public boolean add(Element element) throws DocumentException;
} /*
 * $Id: ElementTags.java,v 1.84 2005/04/06 07:01:18 blowagie Exp $
 * $Name:  $
 *
 * Copyright (c) 2001, 2002 Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

/**
 * A class that contains all the possible tagnames and their attributes.
 */

public class ElementTags {
    
/** the root tag. */
    public static final String ITEXT = "itext";
    
/** attribute of the root and annotation tag (also a special tag within a chapter or section) */
    public static final String TITLE = "title";
    
/** attribute of the root tag */
    public static final String SUBJECT = "subject";
    
/** attribute of the root tag */
    public static final String KEYWORDS = "keywords";
    
/** attribute of the root tag */
    public static final String AUTHOR = "author";
    
/** attribute of the root tag */
    public static final String CREATIONDATE = "creationdate";
    
/** attribute of the root tag */
    public static final String PRODUCER = "producer";
    
    // Chapters and Sections
    
/** the chapter tag */
    public static final String CHAPTER = "chapter";
    
/** the section tag */
    public static final String SECTION = "section";
    
/** attribute of section/chapter tag */
    public static final String NUMBERDEPTH = "numberdepth";
    
/** attribute of section/chapter tag */
    public static final String DEPTH = "depth";
    
/** attribute of section/chapter tag */
    public static final String NUMBER = "number";
    
/** attribute of section/chapter tag */
    public static final String INDENT = "indent";
    
/** attribute of chapter/section/paragraph/table/cell tag */
    public static final String LEFT = "left";
    
/** attribute of chapter/section/paragraph/table/cell tag */
    public static final String RIGHT = "right";
    
    // Phrases, Anchors, Lists and Paragraphs
    
/** the phrase tag */
    public static final String PHRASE = "phrase";
    
/** the anchor tag */
    public static final String ANCHOR = "anchor";
    
/** the list tag */
    public static final String LIST = "list";
    
/** the listitem tag */
    public static final String LISTITEM = "listitem";
    
/** the paragraph tag */
    public static final String PARAGRAPH = "paragraph";
    
/** attribute of phrase/paragraph/cell tag */
    public static final String LEADING = "leading";
    
/** attribute of paragraph/image/table tag */
    public static final String ALIGN = "align";
    
/** attribute of paragraph */
    public static final String KEEPTOGETHER = "keeptogether";
    
/** attribute of anchor tag */
    public static final String NAME = "name";
    
/** attribute of anchor tag */
    public static final String REFERENCE = "reference";
    
/** attribute of list tag */
    public static final String LISTSYMBOL = "listsymbol";
    
/** attribute of list tag */
    public static final String NUMBERED = "numbered";
    
/** attribute of the list tag */
    public static final String LETTERED = "lettered";

/** attribute of list tag */
    public static final String FIRST = "first";
    
/** attribute of list tag */
    public static final String SYMBOLINDENT = "symbolindent";
    
/** attribute of list tag */
    public static final String INDENTATIONLEFT = "indentationleft";
    
/** attribute of list tag */
    public static final String INDENTATIONRIGHT = "indentationright";
    
    // Chunks
    
/** the chunk tag */
    public static final String IGNORE = "ignore";
    
/** the chunk tag */
    public static final String ENTITY = "entity";
    
/** the chunk tag */
    public static final String ID = "id";
    
/** the chunk tag */
    public static final String CHUNK = "chunk";
    
/** attribute of the chunk tag */
    public static final String ENCODING = "encoding";
    
/** attribute of the chunk tag */
    public static final String EMBEDDED = "embedded";
    
/** attribute of the chunk/table/cell tag */
    public static final String COLOR = "color";
    
/** attribute of the chunk/table/cell tag */
    public static final String RED = "red";
    
/** attribute of the chunk/table/cell tag */
    public static final String GREEN = "green";
    
/** attribute of the chunk/table/cell tag */
    public static final String BLUE = "blue";
    
/** attribute of the chunk tag */
    public static final String SUBSUPSCRIPT = Chunk.SUBSUPSCRIPT.toLowerCase();
    
/** attribute of the chunk tag */
    public static final String LOCALGOTO = Chunk.LOCALGOTO.toLowerCase();
    
/** attribute of the chunk tag */
    public static final String REMOTEGOTO = Chunk.REMOTEGOTO.toLowerCase();
    
/** attribute of the chunk tag */
    public static final String LOCALDESTINATION = Chunk.LOCALDESTINATION.toLowerCase();
    
/** attribute of the chunk tag */
    public static final String GENERICTAG = Chunk.GENERICTAG.toLowerCase();
    
    // tables/cells
    
/** the table tag */
    public static final String TABLE = "table";
    
/** the cell tag */
    public static final String ROW = "row";
    
/** the cell tag */
    public static final String CELL = "cell";
    
/** attribute of the table tag */
    public static final String COLUMNS = "columns";
    
/** attribute of the table tag */
    public static final String LASTHEADERROW = "lastHeaderRow";
    
/** attribute of the table tag */
    public static final String CELLPADDING = "cellpadding";
    
/** attribute of the table tag */
    public static final String CELLSPACING = "cellspacing";
    
/** attribute of the table tag */
    public static final String OFFSET = "offset";
    
/** attribute of the table tag */
    public static final String WIDTHS = "widths";
    
/** attribute of the table tag */
    public static final String TABLEFITSPAGE = "tablefitspage";
    
/** attribute of the table tag */
    public static final String CELLSFITPAGE = "cellsfitpage";
    
/** attribute of the cell tag */
    public static final String HORIZONTALALIGN = "horizontalalign";
    
/** attribute of the cell tag */
    public static final String VERTICALALIGN = "verticalalign";
    
/** attribute of the cell tag */
    public static final String COLSPAN = "colspan";
    
/** attribute of the cell tag */
    public static final String ROWSPAN = "rowspan";
    
/** attribute of the cell tag */
    public static final String HEADER = "header";
    
/** attribute of the cell tag */
    public static final String NOWRAP = "nowrap";
    
/** attribute of the table/cell tag */
    public static final String BORDERWIDTH = "borderwidth";
    
/** attribute of the table/cell tag */
    public static final String TOP = "top";
    
/** attribute of the table/cell tag */
    public static final String BOTTOM = "bottom";
    
/** attribute of the table/cell tag */
    public static final String WIDTH = "width";
    
/** attribute of the table/cell tag */
    public static final String BORDERCOLOR = "bordercolor";
    
/** attribute of the table/cell tag */
    public static final String BACKGROUNDCOLOR = "backgroundcolor";
    
/** attribute of the table/cell tag */
    public static final String BGRED = "bgred";
    
/** attribute of the table/cell tag */
    public static final String BGGREEN = "bggreen";
    
/** attribute of the table/cell tag */
    public static final String BGBLUE = "bgblue";
    
/** attribute of the table/cell tag */
    public static final String GRAYFILL = "grayfill";
    
    // Misc
    
/** the image tag */
    public static final String IMAGE = "image";
    
/** attribute of the image and annotation tag */
    public static final String URL = "url";
    
/** attribute of the image tag */
    public static final String UNDERLYING = "underlying";
    
/** attribute of the image tag */
    public static final String TEXTWRAP = "textwrap";
    
/** attribute of the image tag */
    public static final String ALT = "alt";
    
/** attribute of the image tag */
    public static final String ABSOLUTEX = "absolutex";
    
/** attribute of the image tag */
    public static final String ABSOLUTEY = "absolutey";
    
/** attribute of the image tag */
    public static final String PLAINWIDTH = "plainwidth";
    
/** attribute of the image tag */
    public static final String PLAINHEIGHT = "plainheight";
    
/** attribute of the image tag */
    public static final String SCALEDWIDTH = "scaledwidth";
    
/** attribute of the image tag */
    public static final String SCALEDHEIGHT = "scaledheight";
    
/** attribute of the image tag */
    public static final String  ROTATION = "rotation";
    
/** the newpage tag */
    public static final String NEWPAGE = "newpage";
    
/** the newpage tag */
    public static final String NEWLINE = "newline";
    
/** the annotation tag */
    public static final String ANNOTATION = "annotation";
    
/** attribute of the annotation tag */
    public static String FILE = "file";
    
/** attribute of the annotation tag */
    public static String DESTINATION = "destination";
    
/** attribute of the annotation tag */
    public static String PAGE = "page";
    
/** attribute of the annotation tag */
    public static String NAMED = "named";
    
/** attribute of the annotation tag */
    public static String APPLICATION = "application";
    
/** attribute of the annotation tag */
    public static String PARAMETERS = "parameters";
    
/** attribute of the annotation tag */
    public static String OPERATION = "operation";
    
/** attribute of the annotation tag */
    public static String DEFAULTDIR = "defaultdir";
    
/** attribute of the annotation tag */
    public static String LLX = "llx";
    
/** attribute of the annotation tag */
    public static String LLY = "lly";
    
/** attribute of the annotation tag */
    public static String URX = "urx";
    
/** attribute of the annotation tag */
    public static String URY = "ury";
    
/** attribute of the annotation tag */
    public static final String CONTENT = "content";
    
    // alignment attribute values
    
/** the possible value of an alignment attribute */
    public static final String ALIGN_LEFT = "Left";
    
/** the possible value of an alignment attribute */
    public static final String ALIGN_CENTER = "Center";
    
/** the possible value of an alignment attribute */
    public static final String ALIGN_RIGHT = "Right";
    
/** the possible value of an alignment attribute */
    public static final String ALIGN_JUSTIFIED = "Justify";
    
/** the possible value of an alignment attribute */
    public static final String ALIGN_JUSTIFIED_ALL = "JustifyAll";
    
/** the possible value of an alignment attribute */
    public static final String ALIGN_TOP = "Top";
    
/** the possible value of an alignment attribute */
    public static final String ALIGN_MIDDLE = "Middle";
    
/** the possible value of an alignment attribute */
    public static final String ALIGN_BOTTOM = "Bottom";
    
/** the possible value of an alignment attribute */
    public static final String ALIGN_BASELINE = "Baseline";
    
/** the possible value of an alignment attribute */
    public static final String DEFAULT = "Default";
    
/** the possible value of an alignment attribute */
    public static final String UNKNOWN = "unknown";
    
/** the possible value of an alignment attribute */
    public static final String FONT = "font";
    
/** the possible value of an alignment attribute */
    public static final String SIZE = "size";
    
/** the possible value of an alignment attribute */
    public static final String STYLE = "fontstyle";
    
/** the possible value of a tag */
    public static final String HORIZONTALRULE = "horizontalrule";

    /** the possible value of a tag */
    public static final String PAGE_SIZE  = "pagesize";

    /** the possible value of a tag */
    public static final String ORIENTATION  = "orientation";
    
    // methods
    
/**
 * Translates the alignment value.
 *
 * @param   alignment   the alignment value
 * @return  the translated value
 */
    
    public static String getAlignment(int alignment) {
        switch(alignment) {
            case Element.ALIGN_LEFT:
                return ALIGN_LEFT;
            case Element.ALIGN_CENTER:
                return ALIGN_CENTER;
            case Element.ALIGN_RIGHT:
                return ALIGN_RIGHT;
            case Element.ALIGN_JUSTIFIED:
            case Element.ALIGN_JUSTIFIED_ALL:
                return ALIGN_JUSTIFIED;
            case Element.ALIGN_TOP:
                return ALIGN_TOP;
            case Element.ALIGN_MIDDLE:
                return ALIGN_MIDDLE;
            case Element.ALIGN_BOTTOM:
                return ALIGN_BOTTOM;
            case Element.ALIGN_BASELINE:
                return ALIGN_BASELINE;
                default:
                    return DEFAULT;
        }
    }
    
} /*
 * $Id: Entities.java,v 1.43 2004/12/14 11:52:46 blowagie Exp $
 * $Name:  $
 *
 * Copyright 1999, 2000, 2001, 2002 Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

import java.util.HashMap;

/**
 * This class contains entities that can be used in an entity tag.
 */

public class Entities {
    
    /** This is a map that contains all possible id values of the entity tag. */
    public static final HashMap map;
    
    static {
        map = new HashMap();
        map.put("169", new Integer(227));
        map.put("172", new Integer(216));
        map.put("174", new Integer(210));
        map.put("177", new Integer(177));
        map.put("215", new Integer(180));
        map.put("247", new Integer(184));
        map.put("8230", new Integer(188));
        map.put("8242", new Integer(162));
        map.put("8243", new Integer(178));
        map.put("8260", new Integer(164));
        map.put("8364", new Integer(240));
        map.put("8465", new Integer(193));
        map.put("8472", new Integer(195));
        map.put("8476", new Integer(194));
        map.put("8482", new Integer(212));
        map.put("8501", new Integer(192));
        map.put("8592", new Integer(172));
        map.put("8593", new Integer(173));
        map.put("8594", new Integer(174));
        map.put("8595", new Integer(175));
        map.put("8596", new Integer(171));
        map.put("8629", new Integer(191));
        map.put("8656", new Integer(220));
        map.put("8657", new Integer(221));
        map.put("8658", new Integer(222));
        map.put("8659", new Integer(223));
        map.put("8660", new Integer(219));
        map.put("8704", new Integer(34));
        map.put("8706", new Integer(182));
        map.put("8707", new Integer(36));
        map.put("8709", new Integer(198));
        map.put("8711", new Integer(209));
        map.put("8712", new Integer(206));
        map.put("8713", new Integer(207));
        map.put("8717", new Integer(39));
        map.put("8719", new Integer(213));
        map.put("8721", new Integer(229));
        map.put("8722", new Integer(45));
        map.put("8727", new Integer(42));
        map.put("8729", new Integer(183));
        map.put("8730", new Integer(214));
        map.put("8733", new Integer(181));
        map.put("8734", new Integer(165));
        map.put("8736", new Integer(208));
        map.put("8743", new Integer(217));
        map.put("8744", new Integer(218));
        map.put("8745", new Integer(199));
        map.put("8746", new Integer(200));
        map.put("8747", new Integer(242));
        map.put("8756", new Integer(92));
        map.put("8764", new Integer(126));
        map.put("8773", new Integer(64));
        map.put("8776", new Integer(187));
        map.put("8800", new Integer(185));
        map.put("8801", new Integer(186));
        map.put("8804", new Integer(163));
        map.put("8805", new Integer(179));
        map.put("8834", new Integer(204));
        map.put("8835", new Integer(201));
        map.put("8836", new Integer(203));
        map.put("8838", new Integer(205));
        map.put("8839", new Integer(202));
        map.put("8853", new Integer(197));
        map.put("8855", new Integer(196));
        map.put("8869", new Integer(94));
        map.put("8901", new Integer(215));
        map.put("8992", new Integer(243));
        map.put("8993", new Integer(245));
        map.put("9001", new Integer(225));
        map.put("9002", new Integer(241));
        map.put("913", new Integer(65));
        map.put("914", new Integer(66));
        map.put("915", new Integer(71));
        map.put("916", new Integer(68));
        map.put("917", new Integer(69));
        map.put("918", new Integer(90));
        map.put("919", new Integer(72));
        map.put("920", new Integer(81));
        map.put("921", new Integer(73));
        map.put("922", new Integer(75));
        map.put("923", new Integer(76));
        map.put("924", new Integer(77));
        map.put("925", new Integer(78));
        map.put("926", new Integer(88));
        map.put("927", new Integer(79));
        map.put("928", new Integer(80));
        map.put("929", new Integer(82));
        map.put("931", new Integer(83));
        map.put("932", new Integer(84));
        map.put("933", new Integer(85));
        map.put("934", new Integer(70));
        map.put("935", new Integer(67));
        map.put("936", new Integer(89));
        map.put("937", new Integer(87));
        map.put("945", new Integer(97));
        map.put("946", new Integer(98));
        map.put("947", new Integer(103));
        map.put("948", new Integer(100));
        map.put("949", new Integer(101));
        map.put("950", new Integer(122));
        map.put("951", new Integer(104));
        map.put("952", new Integer(113));
        map.put("953", new Integer(105));
        map.put("954", new Integer(107));
        map.put("955", new Integer(108));
        map.put("956", new Integer(109));
        map.put("957", new Integer(110));
        map.put("958", new Integer(120));
        map.put("959", new Integer(111));
        map.put("960", new Integer(112));
        map.put("961", new Integer(114));
        map.put("962", new Integer(86));
        map.put("963", new Integer(115));
        map.put("964", new Integer(116));
        map.put("965", new Integer(117));
        map.put("966", new Integer(102));
        map.put("967", new Integer(99));
        map.put("9674", new Integer(224));
        map.put("968", new Integer(121));
        map.put("969", new Integer(119));
        map.put("977", new Integer(74));
        map.put("978", new Integer(161));
        map.put("981", new Integer(106));
        map.put("982", new Integer(118));
        map.put("9824", new Integer(170));
        map.put("9827", new Integer(167));
        map.put("9829", new Integer(169));
        map.put("9830", new Integer(168));
        map.put("Alpha", new Integer(65));
        map.put("Beta", new Integer(66));
        map.put("Chi", new Integer(67));
        map.put("Delta", new Integer(68));
        map.put("Epsilon", new Integer(69));
        map.put("Eta", new Integer(72));
        map.put("Gamma", new Integer(71));
        map.put("Iota", new Integer(73));
        map.put("Kappa", new Integer(75));
        map.put("Lambda", new Integer(76));
        map.put("Mu", new Integer(77));
        map.put("Nu", new Integer(78));
        map.put("Omega", new Integer(87));
        map.put("Omicron", new Integer(79));
        map.put("Phi", new Integer(70));
        map.put("Pi", new Integer(80));
        map.put("Prime", new Integer(178));
        map.put("Psi", new Integer(89));
        map.put("Rho", new Integer(82));
        map.put("Sigma", new Integer(83));
        map.put("Tau", new Integer(84));
        map.put("Theta", new Integer(81));
        map.put("Upsilon", new Integer(85));
        map.put("Xi", new Integer(88));
        map.put("Zeta", new Integer(90));
        map.put("alefsym", new Integer(192));
        map.put("alpha", new Integer(97));
        map.put("and", new Integer(217));
        map.put("ang", new Integer(208));
        map.put("asymp", new Integer(187));
        map.put("beta", new Integer(98));
        map.put("cap", new Integer(199));
        map.put("chi", new Integer(99));
        map.put("clubs", new Integer(167));
        map.put("cong", new Integer(64));
        map.put("copy", new Integer(211));
        map.put("crarr", new Integer(191));
        map.put("cup", new Integer(200));
        map.put("dArr", new Integer(223));
        map.put("darr", new Integer(175));
        map.put("delta", new Integer(100));
        map.put("diams", new Integer(168));
        map.put("divide", new Integer(184));
        map.put("empty", new Integer(198));
        map.put("epsilon", new Integer(101));
        map.put("equiv", new Integer(186));
        map.put("eta", new Integer(104));
        map.put("euro", new Integer(240));
        map.put("exist", new Integer(36));
        map.put("forall", new Integer(34));
        map.put("frasl", new Integer(164));
        map.put("gamma", new Integer(103));
        map.put("ge", new Integer(179));
        map.put("hArr", new Integer(219));
        map.put("harr", new Integer(171));
        map.put("hearts", new Integer(169));
        map.put("hellip", new Integer(188));
        map.put("horizontal arrow extender", new Integer(190));
        map.put("image", new Integer(193));
        map.put("infin", new Integer(165));
        map.put("int", new Integer(242));
        map.put("iota", new Integer(105));
        map.put("isin", new Integer(206));
        map.put("kappa", new Integer(107));
        map.put("lArr", new Integer(220));
        map.put("lambda", new Integer(108));
        map.put("lang", new Integer(225));
        map.put("large brace extender", new Integer(239));
        map.put("large integral extender", new Integer(244));
        map.put("large left brace (bottom)", new Integer(238));
        map.put("large left brace (middle)", new Integer(237));
        map.put("large left brace (top)", new Integer(236));
        map.put("large left bracket (bottom)", new Integer(235));
        map.put("large left bracket (extender)", new Integer(234));
        map.put("large left bracket (top)", new Integer(233));
        map.put("large left parenthesis (bottom)", new Integer(232));
        map.put("large left parenthesis (extender)", new Integer(231));
        map.put("large left parenthesis (top)", new Integer(230));
        map.put("large right brace (bottom)", new Integer(254));
        map.put("large right brace (middle)", new Integer(253));
        map.put("large right brace (top)", new Integer(252));
        map.put("large right bracket (bottom)", new Integer(251));
        map.put("large right bracket (extender)", new Integer(250));
        map.put("large right bracket (top)", new Integer(249));
        map.put("large right parenthesis (bottom)", new Integer(248));
        map.put("large right parenthesis (extender)", new Integer(247));
        map.put("large right parenthesis (top)", new Integer(246));
        map.put("larr", new Integer(172));
        map.put("le", new Integer(163));
        map.put("lowast", new Integer(42));
        map.put("loz", new Integer(224));
        map.put("minus", new Integer(45));
        map.put("mu", new Integer(109));
        map.put("nabla", new Integer(209));
        map.put("ne", new Integer(185));
        map.put("not", new Integer(216));
        map.put("notin", new Integer(207));
        map.put("nsub", new Integer(203));
        map.put("nu", new Integer(110));
        map.put("omega", new Integer(119));
        map.put("omicron", new Integer(111));
        map.put("oplus", new Integer(197));
        map.put("or", new Integer(218));
        map.put("otimes", new Integer(196));
        map.put("part", new Integer(182));
        map.put("perp", new Integer(94));
        map.put("phi", new Integer(102));
        map.put("pi", new Integer(112));
        map.put("piv", new Integer(118));
        map.put("plusmn", new Integer(177));
        map.put("prime", new Integer(162));
        map.put("prod", new Integer(213));
        map.put("prop", new Integer(181));
        map.put("psi", new Integer(121));
        map.put("rArr", new Integer(222));
        map.put("radic", new Integer(214));
        map.put("radical extender", new Integer(96));
        map.put("rang", new Integer(241));
        map.put("rarr", new Integer(174));
        map.put("real", new Integer(194));
        map.put("reg", new Integer(210));
        map.put("rho", new Integer(114));
        map.put("sdot", new Integer(215));
        map.put("sigma", new Integer(115));
        map.put("sigmaf", new Integer(86));
        map.put("sim", new Integer(126));
        map.put("spades", new Integer(170));
        map.put("sub", new Integer(204));
        map.put("sube", new Integer(205));
        map.put("sum", new Integer(229));
        map.put("sup", new Integer(201));
        map.put("supe", new Integer(202));
        map.put("tau", new Integer(116));
        map.put("there4", new Integer(92));
        map.put("theta", new Integer(113));
        map.put("thetasym", new Integer(74));
        map.put("times", new Integer(180));
        map.put("trade", new Integer(212));
        map.put("uArr", new Integer(221));
        map.put("uarr", new Integer(173));
        map.put("upsih", new Integer(161));
        map.put("upsilon", new Integer(117));
        map.put("vertical arrow extender", new Integer(189));
        map.put("weierp", new Integer(195));
        map.put("xi", new Integer(120));
        map.put("zeta", new Integer(122));
    }
    
 /**
  * Gets a chunk with a symbol character.
  * @param e a symbol value (see Entities class: alfa is greek alfa,...)
  * @param font the font if the symbol isn't found (otherwise Font.SYMBIL)
  * @return a Chunk
  */
    public static Chunk get(String e, Font font) {
        int s = getCorrespondingSymbol(e);
        if (s == -1) {
            try {
                return new Chunk(String.valueOf((char)Integer.parseInt(e)), font);
            }
            catch(Exception exception) {
                return new Chunk(e, font);
            }
        }
        Font symbol = new Font(Font.SYMBOL, font.size(), font.style(), font.color());
        return new Chunk(String.valueOf((char)s), symbol);
    }
    
/**
 * Looks for the corresponding symbol in the font Symbol.
 *
 * @param	c	the original ASCII-char
 * @return	the corresponding symbol in font Symbol
 */
    
    public static int getCorrespondingSymbol(String c) {
        Integer integer = (Integer) map.get(c);
        if (integer == null) {
            return -1;
        }
        return integer.intValue();
    }
    
/**
 * Checks if a given tag corresponds with this object.
 *
 * @param   tag     the given tag
 * @return  true if the tag corresponds
 */
    
    public static boolean isTag(String tag) {
        return ElementTags.ENTITY.equals(tag);
    }
}
 /*
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */
package pdftk.com.lowagie.text;

/**
 * The ExceptionConverter changes a checked exception into an
 * unchecked exception.
 */
public class ExceptionConverter extends RuntimeException {

    /** A serial version UID */
    private static final long serialVersionUID = 8657630363395849399L;

    /** we keep a handle to the wrapped exception */
    private Exception ex;
    /** prefix for the exception */
    private String prefix;

    /**
     * Construct a RuntimeException based on another Exception
     * @param ex the exception that has to be turned into a RuntimeException
     */
    public ExceptionConverter(Exception ex) {
        this.ex = ex;
        prefix = (ex instanceof RuntimeException) ? "" : "ExceptionConverter: ";
    }

    /**
     * and allow the user of ExceptionConverter to get a handle to it. 
     * @return the original exception
     */
    public Exception getException() {
        return ex;
    }

    /**
     * We print the message of the checked exception 
     * @return message of the original exception
     */
    public String getMessage() {
        return ex.getMessage();
    }

    /**
     * and make sure we also produce a localized version
     * @return localized version of the message
     */
    public String getLocalizedMessage() {
        return ex.getLocalizedMessage();
    }

    /**
     * The toString() is changed to be prefixed with ExceptionConverter 
     * @return Stringversion of the exception
     */
    public String toString() {
        return prefix + ex;
    }

    /** we have to override this as well */
    public void printStackTrace() {
        printStackTrace(System.err);
    }

    /**
     * here we prefix, with s.print(), not s.println(), the stack
     * trace with "ExceptionConverter:" 
     * @param s
     */
    public void printStackTrace(java.io.PrintStream s) {
        synchronized (s) {
            s.print(prefix);
            ex.printStackTrace(s);
        }
    }

    /**
     * Again, we prefix the stack trace with "ExceptionConverter:" 
     * @param s
     */
    public void printStackTrace(java.io.PrintWriter s) {
        synchronized (s) {
            s.print(prefix);
            ex.printStackTrace(s);
        }
    }

    /**
     * requests to fill in the stack trace we will have to ignore.
     * We can't throw an exception here, because this method
     * is called by the constructor of Throwable 
     * @return a Throwable
     */
    public Throwable fillInStackTrace() {
        return this;
    }
} /*
 * $Id: Font.java,v 1.94 2005/10/05 14:16:04 blowagie Exp $
 * $Name:  $
 *
 * Copyright 1999, 2000, 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

import java.awt.Color;

import pdftk.com.lowagie.text.pdf.BaseFont;
import pdftk.com.lowagie.text.markup.MarkupTags;

/**
 * Contains all the specifications of a font: fontfamily, size, style and color.
 * <P>
 * Example: <BLOCKQUOTE>
 * 
 * <PRE>
 * 
 * Paragraph p = new Paragraph("This is a paragraph", <STRONG>new
 * Font(Font.HELVETICA, 18, Font.BOLDITALIC, new Color(0, 0, 255)) </STRONG>);
 * 
 * </PRE>
 * 
 * </BLOCKQUOTE>
 */

public class Font implements Comparable {

	// static membervariables for the different families

	/** a possible value of a font family. */
	public static final int COURIER = 0;

	/** a possible value of a font family. */
	public static final int HELVETICA = 1;

	/** a possible value of a font family. */
	public static final int TIMES_ROMAN = 2;

	/** a possible value of a font family. */
	public static final int SYMBOL = 3;

	/** a possible value of a font family. */
	public static final int ZAPFDINGBATS = 4;

	// static membervariables for the different styles

	/** this is a possible style. */
	public static final int NORMAL = 0;

	/** this is a possible style. */
	public static final int BOLD = 1;

	/** this is a possible style. */
	public static final int ITALIC = 2;

	/** this is a possible style. */
	public static final int UNDERLINE = 4;

	/** this is a possible style. */
	public static final int STRIKETHRU = 8;

	/** this is a possible style. */
	public static final int BOLDITALIC = BOLD | ITALIC;

	// static membervariables

	/** the value of an undefined attribute. */
	public static final int UNDEFINED = -1;

	/** the value of the default size. */
	public static final int DEFAULTSIZE = 12;

	// membervariables

	/** the value of the fontfamily. */
	private int family = UNDEFINED;

	/** the value of the fontsize. */
	private float size = UNDEFINED;

	/** the value of the style. */
	private int style = UNDEFINED;

	/** the value of the color. */
	private Color color = null;

	/** the external font */
	private BaseFont baseFont = null;

	// constructors

	/**
	 * Copy constructor of a Font
	 * 
	 * @param other
	 *            the font that has to be copied
	 */
	public Font(Font other) {
		this.color = other.color;
		this.family = other.family;
		this.size = other.size;
		this.style = other.style;
		this.baseFont = other.baseFont;
	}

	/**
	 * Constructs a Font.
	 * 
	 * @param family
	 *            the family to which this font belongs
	 * @param size
	 *            the size of this font
	 * @param style
	 *            the style of this font
	 * @param color
	 *            the <CODE>Color</CODE> of this font.
	 */

	public Font(int family, float size, int style, Color color) {
		this.family = family;
		this.size = size;
		this.style = style;
		this.color = color;
	}

	/**
	 * Constructs a Font.
	 * 
	 * @param bf
	 *            the external font
	 * @param size
	 *            the size of this font
	 * @param style
	 *            the style of this font
	 * @param color
	 *            the <CODE>Color</CODE> of this font.
	 */

	public Font(BaseFont bf, float size, int style, Color color) {
		this.baseFont = bf;
		this.size = size;
		this.style = style;
		this.color = color;
	}

	/**
	 * Constructs a Font.
	 * 
	 * @param bf
	 *            the external font
	 * @param size
	 *            the size of this font
	 * @param style
	 *            the style of this font
	 */
	public Font(BaseFont bf, float size, int style) {
		this(bf, size, style, null);
	}

	/**
	 * Constructs a Font.
	 * 
	 * @param bf
	 *            the external font
	 * @param size
	 *            the size of this font
	 */
	public Font(BaseFont bf, float size) {
		this(bf, size, UNDEFINED, null);
	}

	/**
	 * Constructs a Font.
	 * 
	 * @param bf
	 *            the external font
	 */
	public Font(BaseFont bf) {
		this(bf, UNDEFINED, UNDEFINED, null);
	}

	/**
	 * Constructs a Font.
	 * 
	 * @param family
	 *            the family to which this font belongs
	 * @param size
	 *            the size of this font
	 * @param style
	 *            the style of this font
	 */

	public Font(int family, float size, int style) {
		this(family, size, style, null);
	}

	/**
	 * Constructs a Font.
	 * 
	 * @param family
	 *            the family to which this font belongs
	 * @param size
	 *            the size of this font
	 */

	public Font(int family, float size) {
		this(family, size, UNDEFINED, null);
	}

	/**
	 * Constructs a Font.
	 * 
	 * @param family
	 *            the family to which this font belongs
	 */

	public Font(int family) {
		this(family, UNDEFINED, UNDEFINED, null);
	}

	/**
	 * Constructs a Font.
	 */

	public Font() {
		this(UNDEFINED, UNDEFINED, UNDEFINED, null);
	}

	// implementation of the Comparable interface

	/**
	 * Compares this <CODE>Font</CODE> with another
	 * 
	 * @param object
	 *            the other <CODE>Font</CODE>
	 * @return a value
	 */

	public int compareTo(Object object) {
		if (object == null) {
			return -1;
		}
		Font font;
		try {
			font = (Font) object;
			if (baseFont != null && !baseFont.equals(font.getBaseFont())) {
				return -2;
			}
			if (this.family != font.family()) {
				return 1;
			}
			if (this.size != font.size()) {
				return 2;
			}
			if (this.style != font.style()) {
				return 3;
			}
			if (this.color == null) {
				if (font.color == null) {
					return 0;
				}
				return 4;
			}
			if (font.color == null) {
				return 4;
			}
			if (this.color.equals(font.color())) {
				return 0;
			}
			return 4;
		} catch (ClassCastException cce) {
			return -3;
		}
	}

	// methods

	/**
	 * Sets the family using a <CODE>String</CODE> ("Courier", "Helvetica",
	 * "Times New Roman", "Symbol" or "ZapfDingbats").
	 * 
	 * @param family
	 *            A <CODE>String</CODE> representing a certain font-family.
	 */

	public void setFamily(String family) {
		this.family = getFamilyIndex(family);
	}

	/**
	 * Translates a <CODE>String</CODE> -value of a certain family into the
	 * index that is used for this family in this class.
	 * 
	 * @param family
	 *            A <CODE>String</CODE> representing a certain font-family
	 * @return the corresponding index
	 */

	public static int getFamilyIndex(String family) {
		if (family.equalsIgnoreCase(FontFactory.COURIER)) {
			return COURIER;
		}
		if (family.equalsIgnoreCase(FontFactory.HELVETICA)) {
			return HELVETICA;
		}
		if (family.equalsIgnoreCase(FontFactory.TIMES_ROMAN)) {
			return TIMES_ROMAN;
		}
		if (family.equalsIgnoreCase(FontFactory.SYMBOL)) {
			return SYMBOL;
		}
		if (family.equalsIgnoreCase(FontFactory.ZAPFDINGBATS)) {
			return ZAPFDINGBATS;
		}
		return UNDEFINED;
	}

	/**
	 * Gets the familyname as a String.
	 * 
	 * @return the familyname
	 */

	public String getFamilyname() {
		String tmp = "unknown";
		switch (family()) {
		case Font.COURIER:
			return FontFactory.COURIER;
		case Font.HELVETICA:
			return FontFactory.HELVETICA;
		case Font.TIMES_ROMAN:
			return FontFactory.TIMES_ROMAN;
		case Font.SYMBOL:
			return FontFactory.SYMBOL;
		case Font.ZAPFDINGBATS:
			return FontFactory.ZAPFDINGBATS;
		default:
			if (baseFont != null) {
				String[][] names = baseFont.getFamilyFontName();
				for (int i = 0; i < names.length; i++) {
					if ("0".equals(names[i][2])) {
						return names[i][3];
					}
					if ("1033".equals(names[i][2])) {
						tmp = names[i][3];
					}
					if ("".equals(names[i][2])) {
						tmp = names[i][3];
					}
				}
			}
		}
		return tmp;
	}

	/**
	 * Sets the size.
	 * 
	 * @param size
	 *            The new size of the font.
	 */

	public void setSize(float size) {
		this.size = size;
	}

	/**
	 * Sets the style using a <CODE>String</CODE> containing one of more of
	 * the following values: normal, bold, italic, underline, strike.
	 * 
	 * @param style
	 *            A <CODE>String</CODE> representing a certain style.
	 */

	public void setStyle(String style) {
		if (this.style == UNDEFINED)
			this.style = NORMAL;
		this.style |= getStyleValue(style);
	}

	/**
	 * Sets the style.
	 * 
	 * @param style
	 *            the style.
	 */

	public void setStyle(int style) {
		if (this.style == UNDEFINED)
			this.style = NORMAL;
		this.style |= style;
	}

	/**
	 * Translates a <CODE>String</CODE> -value of a certain style into the
	 * index value is used for this style in this class.
	 * 
	 * @param style
	 *            A <CODE>String</CODE>
	 * @return the corresponding value
	 */

	public static int getStyleValue(String style) {
		int s = 0;
		if (style.indexOf(MarkupTags.CSS_VALUE_NORMAL) != -1) {
			s |= NORMAL;
		}
		if (style.indexOf(MarkupTags.CSS_VALUE_BOLD) != -1) {
			s |= BOLD;
		}
		if (style.indexOf(MarkupTags.CSS_VALUE_ITALIC) != -1) {
			s |= ITALIC;
		}
		if (style.indexOf(MarkupTags.CSS_VALUE_OBLIQUE) != -1) {
			s |= ITALIC;
		}
		if (style.indexOf(MarkupTags.CSS_VALUE_UNDERLINE) != -1) {
			s |= UNDERLINE;
		}
		if (style.indexOf(MarkupTags.CSS_VALUE_LINETHROUGH) != -1) {
			s |= STRIKETHRU;
		}
		return s;
	}

	/**
	 * Sets the color.
	 * 
	 * @param color
	 *            the new color of the font
	 */

	public void setColor(Color color) {
		this.color = color;
	}

	/**
	 * Sets the color.
	 * 
	 * @param red
	 *            the red-value of the new color
	 * @param green
	 *            the green-value of the new color
	 * @param blue
	 *            the blue-value of the new color
	 */

	public void setColor(int red, int green, int blue) {
		this.color = new Color(red, green, blue);
	}

	/**
	 * Gets the leading that can be used with this font.
	 * 
	 * @param linespacing
	 *            a certain linespacing
	 * @return the height of a line
	 */

	public float leading(float linespacing) {
		if (size == UNDEFINED) {
			return linespacing * DEFAULTSIZE;
		}
		return linespacing * size;
	}

	/**
	 * Checks if the properties of this font are undefined or null.
	 * <P>
	 * If so, the standard should be used.
	 * 
	 * @return a <CODE>boolean</CODE>
	 */

	public boolean isStandardFont() {
		return (family == UNDEFINED && size == UNDEFINED && style == UNDEFINED
				&& color == null && baseFont == null);
	}

	/**
	 * Replaces the attributes that are equal to <VAR>null </VAR> with the
	 * attributes of a given font.
	 * 
	 * @param font
	 *            the font of a bigger element class
	 * @return a <CODE>Font</CODE>
	 */

	public Font difference(Font font) {
		// size
		float dSize = font.size;
		if (dSize == UNDEFINED) {
			dSize = this.size;
		}
		// style
		int dStyle = UNDEFINED;
		int style1 = this.style;
		int style2 = font.style();
		if (style1 != UNDEFINED || style2 != UNDEFINED) {
			if (style1 == UNDEFINED)
				style1 = 0;
			if (style2 == UNDEFINED)
				style2 = 0;
			dStyle = style1 | style2;
		}
		// color
		Color dColor = font.color;
		if (dColor == null) {
			dColor = this.color;
		}
		// family
		if (font.baseFont != null) {
			return new Font(font.baseFont, dSize, dStyle, dColor);
		}
		if (font.family() != UNDEFINED) {
			return new Font(font.family, dSize, dStyle, dColor);
		}
		if (this.baseFont != null) {
			if (dStyle == style1) {
				return new Font(this.baseFont, dSize, dStyle, dColor);
			} else {
				return FontFactory.getFont(this.getFamilyname(), dSize, dStyle,
						dColor);
			}
		}
		return new Font(this.family, dSize, dStyle, dColor);
	}

	// methods to retrieve the membervariables

	/**
	 * Gets the family of this font.
	 * 
	 * @return the value of the family
	 */

	public int family() {
		return family;
	}

	/**
	 * Gets the size of this font.
	 * 
	 * @return a size
	 */

	public float size() {
		return size;
	}

	/**
	 * Gets the style of this font.
	 * 
	 * @return a size
	 */

	public int style() {
		return style;
	}

	/**
	 * checks if this font is Bold.
	 * 
	 * @return a <CODE>boolean</CODE>
	 */

	public boolean isBold() {
		if (style == UNDEFINED) {
			return false;
		}
		return (style & BOLD) == BOLD;
	}

	/**
	 * checks if this font is Bold.
	 * 
	 * @return a <CODE>boolean</CODE>
	 */

	public boolean isItalic() {
		if (style == UNDEFINED) {
			return false;
		}
		return (style & ITALIC) == ITALIC;
	}

	/**
	 * checks if this font is underlined.
	 * 
	 * @return a <CODE>boolean</CODE>
	 */

	public boolean isUnderlined() {
		if (style == UNDEFINED) {
			return false;
		}
		return (style & UNDERLINE) == UNDERLINE;
	}

	/**
	 * checks if the style of this font is STRIKETHRU.
	 * 
	 * @return a <CODE>boolean</CODE>
	 */

	public boolean isStrikethru() {
		if (style == UNDEFINED) {
			return false;
		}
		return (style & STRIKETHRU) == STRIKETHRU;
	}

	/**
	 * Gets the color of this font.
	 * 
	 * @return a color
	 */

	public Color color() {
		return color;
	}

	/**
	 * Gets the <CODE>BaseFont</CODE> inside this object.
	 * 
	 * @return the <CODE>BaseFont</CODE>
	 */

	public BaseFont getBaseFont() {
		return baseFont;
	}

	/**
	 * Gets the <CODE>BaseFont</CODE> this class represents. For the built-in
	 * fonts a <CODE>BaseFont</CODE> is calculated.
	 * 
	 * @param specialEncoding
	 *            <CODE>true</CODE> to use the special encoding for Symbol and
	 *            ZapfDingbats, <CODE>false</CODE> to always use <CODE>Cp1252
	 *            </CODE>
	 * @return the <CODE>BaseFont</CODE> this class represents
	 */
	public BaseFont getCalculatedBaseFont(boolean specialEncoding) {
		if (baseFont != null)
			return baseFont;
		int style = this.style;
		if (style == UNDEFINED) {
			style = NORMAL;
		}
		String fontName = BaseFont.HELVETICA;
		String encoding = BaseFont.WINANSI;
		BaseFont cfont = null;
		switch (family) {
		case COURIER:
			switch (style & BOLDITALIC) {
			case BOLD:
				fontName = BaseFont.COURIER_BOLD;
				break;
			case ITALIC:
				fontName = BaseFont.COURIER_OBLIQUE;
				break;
			case BOLDITALIC:
				fontName = BaseFont.COURIER_BOLDOBLIQUE;
				break;
			default:
				//case NORMAL:
				fontName = BaseFont.COURIER;
				break;
			}
			break;
		case TIMES_ROMAN:
			switch (style & BOLDITALIC) {
			case BOLD:
				fontName = BaseFont.TIMES_BOLD;
				break;
			case ITALIC:
				fontName = BaseFont.TIMES_ITALIC;
				break;
			case BOLDITALIC:
				fontName = BaseFont.TIMES_BOLDITALIC;
				break;
			default:
			case NORMAL:
				fontName = BaseFont.TIMES_ROMAN;
				break;
			}
			break;
		case SYMBOL:
			fontName = BaseFont.SYMBOL;
			if (specialEncoding)
				encoding = BaseFont.SYMBOL;
			break;
		case ZAPFDINGBATS:
			fontName = BaseFont.ZAPFDINGBATS;
			if (specialEncoding)
				encoding = BaseFont.ZAPFDINGBATS;
			break;
		default:
		case Font.HELVETICA:
			switch (style & BOLDITALIC) {
			case BOLD:
				fontName = BaseFont.HELVETICA_BOLD;
				break;
			case ITALIC:
				fontName = BaseFont.HELVETICA_OBLIQUE;
				break;
			case BOLDITALIC:
				fontName = BaseFont.HELVETICA_BOLDOBLIQUE;
				break;
			default:
			case NORMAL:
				fontName = BaseFont.HELVETICA;
				break;
			}
			break;
		}
		try {
			cfont = BaseFont.createFont(fontName, encoding, false);
		} catch (Exception ee) {
			throw new ExceptionConverter(ee);
		}
		return cfont;
	}

	/**
	 * Gets the style that can be used with the calculated <CODE>BaseFont
	 * </CODE>.
	 * 
	 * @return the style that can be used with the calculated <CODE>BaseFont
	 *         </CODE>
	 */
	public int getCalculatedStyle() {
		int style = this.style;
		if (style == UNDEFINED) {
			style = NORMAL;
		}
		if (baseFont != null)
			return style;
		if (family == SYMBOL || family == ZAPFDINGBATS)
			return style;
		else
			return style & (~BOLDITALIC);
	}

	/**
	 * Gets the size that can be used with the calculated <CODE>BaseFont
	 * </CODE>.
	 * 
	 * @return the size that can be used with the calculated <CODE>BaseFont
	 *         </CODE>
	 */
	public float getCalculatedSize() {
		float s = this.size;
		if (s == UNDEFINED) {
			s = DEFAULTSIZE;
		}
		return s;
	}
} /*
 * $Id: FontFactory.java,v 1.65 2005/05/03 13:03:47 blowagie Exp $
 * $Name:  $
 *
 * Copyright 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

import java.awt.Color;
import java.io.IOException;
import java.util.Hashtable;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.Properties;
import java.util.Set;
import java.util.Enumeration;
import java.io.File;
import pdftk.com.lowagie.text.pdf.BaseFont;
import pdftk.com.lowagie.text.markup.MarkupTags;
import pdftk.com.lowagie.text.markup.MarkupParser;

/**
 * If you are using True Type fonts, you can declare the paths of the different ttf- and ttc-files
 * to this static class first and then create fonts in your code using one of the static getFont-method
 * without having to enter a path as parameter.
 *
 * @author  Bruno Lowagie
 */

public class FontFactory extends java.lang.Object {
    
/** This is a possible value of a base 14 type 1 font */
    public static final String COURIER = BaseFont.COURIER;
    
/** This is a possible value of a base 14 type 1 font */
    public static final String COURIER_BOLD = BaseFont.COURIER_BOLD;
    
/** This is a possible value of a base 14 type 1 font */
    public static final String COURIER_OBLIQUE = BaseFont.COURIER_OBLIQUE;
    
/** This is a possible value of a base 14 type 1 font */
    public static final String COURIER_BOLDOBLIQUE = BaseFont.COURIER_BOLDOBLIQUE;
    
/** This is a possible value of a base 14 type 1 font */
    public static final String HELVETICA = BaseFont.HELVETICA;
    
/** This is a possible value of a base 14 type 1 font */
    public static final String HELVETICA_BOLD = BaseFont.HELVETICA_BOLD;
    
/** This is a possible value of a base 14 type 1 font */
    public static final String HELVETICA_OBLIQUE = BaseFont.HELVETICA_OBLIQUE;
    
/** This is a possible value of a base 14 type 1 font */
    public static final String HELVETICA_BOLDOBLIQUE = BaseFont.HELVETICA_BOLDOBLIQUE;
    
/** This is a possible value of a base 14 type 1 font */
    public static final String SYMBOL = BaseFont.SYMBOL;
    
/** This is a possible value of a base 14 type 1 font */
    public static final String TIMES = "Times";
    
/** This is a possible value of a base 14 type 1 font */
    public static final String TIMES_ROMAN = BaseFont.TIMES_ROMAN;
    
/** This is a possible value of a base 14 type 1 font */
    public static final String TIMES_BOLD = BaseFont.TIMES_BOLD;
    
/** This is a possible value of a base 14 type 1 font */
    public static final String TIMES_ITALIC = BaseFont.TIMES_ITALIC;
    
/** This is a possible value of a base 14 type 1 font */
    public static final String TIMES_BOLDITALIC = BaseFont.TIMES_BOLDITALIC;
    
/** This is a possible value of a base 14 type 1 font */
    public static final String ZAPFDINGBATS = BaseFont.ZAPFDINGBATS;
    
/** This is a map of postscriptfontnames of True Type fonts and the path of their ttf- or ttc-file. */
    private static Properties trueTypeFonts = new Properties();
    
    private static String[] TTFamilyOrder = {
        "3", "1", "1033",
        "3", "0", "1033",
        "1", "0", "0",
        "0", "3", "0"
    };

    static {
        trueTypeFonts.setProperty(COURIER.toLowerCase(), COURIER);
        trueTypeFonts.setProperty(COURIER_BOLD.toLowerCase(), COURIER_BOLD);
        trueTypeFonts.setProperty(COURIER_OBLIQUE.toLowerCase(), COURIER_OBLIQUE);
        trueTypeFonts.setProperty(COURIER_BOLDOBLIQUE.toLowerCase(), COURIER_BOLDOBLIQUE);
        trueTypeFonts.setProperty(HELVETICA.toLowerCase(), HELVETICA);
        trueTypeFonts.setProperty(HELVETICA_BOLD.toLowerCase(), HELVETICA_BOLD);
        trueTypeFonts.setProperty(HELVETICA_OBLIQUE.toLowerCase(), HELVETICA_OBLIQUE);
        trueTypeFonts.setProperty(HELVETICA_BOLDOBLIQUE.toLowerCase(), HELVETICA_BOLDOBLIQUE);
        trueTypeFonts.setProperty(SYMBOL.toLowerCase(), SYMBOL);
        trueTypeFonts.setProperty(TIMES_ROMAN.toLowerCase(), TIMES_ROMAN);
        trueTypeFonts.setProperty(TIMES_BOLD.toLowerCase(), TIMES_BOLD);
        trueTypeFonts.setProperty(TIMES_ITALIC.toLowerCase(), TIMES_ITALIC);
        trueTypeFonts.setProperty(TIMES_BOLDITALIC.toLowerCase(), TIMES_BOLDITALIC);
        trueTypeFonts.setProperty(ZAPFDINGBATS.toLowerCase(), ZAPFDINGBATS);
    }
    
/** This is a map of fontfamilies. */
    private static Hashtable fontFamilies = new Hashtable();
    
    static {
        ArrayList tmp;
        tmp = new ArrayList();
        tmp.add(COURIER);
        tmp.add(COURIER_BOLD);
        tmp.add(COURIER_OBLIQUE);
        tmp.add(COURIER_BOLDOBLIQUE);
        fontFamilies.put(COURIER.toLowerCase(), tmp);
        tmp = new ArrayList();
        tmp.add(HELVETICA);
        tmp.add(HELVETICA_BOLD);
        tmp.add(HELVETICA_OBLIQUE);
        tmp.add(HELVETICA_BOLDOBLIQUE);
        fontFamilies.put(HELVETICA.toLowerCase(), tmp);
        tmp = new ArrayList();
        tmp.add(SYMBOL);
        fontFamilies.put(SYMBOL.toLowerCase(), tmp);
        tmp = new ArrayList();
        tmp.add(TIMES_ROMAN);
        tmp.add(TIMES_BOLD);
        tmp.add(TIMES_ITALIC);
        tmp.add(TIMES_BOLDITALIC);
        fontFamilies.put(TIMES.toLowerCase(), tmp);
        fontFamilies.put(TIMES_ROMAN.toLowerCase(), tmp);
        tmp = new ArrayList();
        tmp.add(ZAPFDINGBATS);
        fontFamilies.put(ZAPFDINGBATS.toLowerCase(), tmp);
    }
    
    
/** This is the default encoding to use. */
    public static String defaultEncoding = BaseFont.WINANSI;
    
/** This is the default value of the <VAR>embedded</VAR> variable. */
    public static boolean defaultEmbedding = BaseFont.NOT_EMBEDDED;
    
/** Creates new FontFactory */
    private FontFactory() {
    }
    
/**
 * Constructs a <CODE>Font</CODE>-object.
 *
 * @param	fontname    the name of the font
 * @param	encoding    the encoding of the font
 * @param       embedded    true if the font is to be embedded in the PDF
 * @param	size	    the size of this font
 * @param	style	    the style of this font
 * @param	color	    the <CODE>Color</CODE> of this font.
 * @return the Font constructed based on the parameters
 */
    
    public static Font getFont(String fontname, String encoding, boolean embedded, float size, int style, Color color) {
        if (fontname == null) return new Font(Font.UNDEFINED, size, style, color);
        String lowercasefontname = fontname.toLowerCase();
        ArrayList tmp = (ArrayList) fontFamilies.get(lowercasefontname);
        if (tmp != null) {
            // some bugs were fixed here by Daniel Marczisovszky
            int s = style == Font.UNDEFINED ? Font.NORMAL : style;
            int fs = Font.NORMAL;
            boolean found = false;
            for (Iterator i = tmp.iterator(); i.hasNext(); ) {
                String f = (String) i.next();
                String lcf = f.toLowerCase();
                fs = Font.NORMAL;
                if (lcf.toLowerCase().indexOf("bold") != -1) fs |= Font.BOLD;
                if (lcf.toLowerCase().indexOf("italic") != -1 || lcf.toLowerCase().indexOf("oblique") != -1) fs |= Font.ITALIC;
                if ((s & Font.BOLDITALIC) == fs) {
                    fontname = f;
                    found = true;
                    break;
                }
            }
            if (style != Font.UNDEFINED && found) {
                style &= ~fs;
            }
        }
        BaseFont basefont = null;
        try {
            try {
                // the font is a type 1 font or CJK font
                basefont = BaseFont.createFont(fontname, encoding, embedded);
            }
            catch(DocumentException de) {
                // the font is a true type font or an unknown font
                fontname = trueTypeFonts.getProperty(fontname.toLowerCase());
                // the font is not registered as truetype font
                if (fontname == null) return new Font(Font.UNDEFINED, size, style, color);
                // the font is registered as truetype font
                basefont = BaseFont.createFont(fontname, encoding, embedded);
            }
        }
        catch(DocumentException de) {
            // this shouldn't happen
            throw new ExceptionConverter(de);
        }
        catch(IOException ioe) {
            // the font is registered as a true type font, but the path was wrong
            return new Font(Font.UNDEFINED, size, style, color);
        }
        catch(NullPointerException npe) {
            // null was entered as fontname and/or encoding
            return new Font(Font.UNDEFINED, size, style, color);
        }
        return new Font(basefont, size, style, color);
    }
    
/**
 * Constructs a <CODE>Font</CODE>-object.
 *
 * @param   attributes  the attributes of a <CODE>Font</CODE> object.
 * @return the Font constructed based on the attributes
 */
    
    public static Font getFont(Properties attributes) {
        String fontname = null;
        String encoding = defaultEncoding;
        boolean embedded = defaultEmbedding;
        float size = Font.UNDEFINED;
        int style = Font.NORMAL;
        Color color = null;
        String value = (String) attributes.remove(MarkupTags.HTML_ATTR_STYLE);
        if (value != null && value.length() > 0) {
            Properties styleAttributes = MarkupParser.parseAttributes(value);
            if (styleAttributes.size() == 0) {
                attributes.put(MarkupTags.HTML_ATTR_STYLE, value);
            }
            else {
                fontname = (String)styleAttributes.remove(MarkupTags.CSS_KEY_FONTFAMILY);
                if (fontname != null) {
                    String tmp;
                    while (fontname.indexOf(",") != -1) {
                        tmp = fontname.substring(0, fontname.indexOf(","));
                        if (isRegistered(tmp)) {
                            fontname = tmp;
                        }
                        else {
                            fontname = fontname.substring(fontname.indexOf(",") + 1);
                        }
                    }
                }
                if ((value = (String)styleAttributes.remove(MarkupTags.CSS_KEY_FONTSIZE)) != null) {
                    size = MarkupParser.parseLength(value);
                }
                if ((value = (String)styleAttributes.remove(MarkupTags.CSS_KEY_FONTWEIGHT)) != null) {
                    style |= Font.getStyleValue(value);
                }
                if ((value = (String)styleAttributes.remove(MarkupTags.CSS_KEY_FONTSTYLE)) != null) {
                    style |= Font.getStyleValue(value);
                }
                if ((value = (String)styleAttributes.remove(MarkupTags.CSS_KEY_COLOR)) != null) {
                    color = MarkupParser.decodeColor(value);
                }
                attributes.putAll(styleAttributes);
                for (Enumeration e = styleAttributes.keys(); e.hasMoreElements();) {
                    Object o = e.nextElement();
                    attributes.put(o, styleAttributes.get(o));
                }
            }
        }
        if ((value = (String)attributes.remove(ElementTags.ENCODING)) != null) {
            encoding = value;
        }
        if ("true".equals(attributes.remove(ElementTags.EMBEDDED))) {
            embedded = true;
        }
        if ((value = (String)attributes.remove(ElementTags.FONT)) != null) {
            fontname = value;
        }
        if ((value = (String)attributes.remove(ElementTags.SIZE)) != null) {
            size = Float.valueOf(value + "f").floatValue();
        }
        if ((value = (String)attributes.remove(MarkupTags.HTML_ATTR_STYLE)) != null) {
            style |= Font.getStyleValue(value);
        }
        if ((value = (String)attributes.remove(ElementTags.STYLE)) != null) {
            style |= Font.getStyleValue(value);
        }
        String r = (String)attributes.remove(ElementTags.RED);
        String g = (String)attributes.remove(ElementTags.GREEN);
        String b = (String)attributes.remove(ElementTags.BLUE);
        if (r != null || g != null || b != null) {
            int red = 0;
            int green = 0;
            int blue = 0;
            if (r != null) red = Integer.parseInt(r);
            if (g != null) green = Integer.parseInt(g);
            if (b != null) blue = Integer.parseInt(b);
            color = new Color(red, green, blue);
        }
        else if ((value = (String)attributes.remove(ElementTags.COLOR)) != null) {
            color = MarkupParser.decodeColor(value);
        }
        if (fontname == null) {
            return getFont(null, encoding, embedded, size, style, color);
        }
        return getFont(fontname, encoding, embedded, size, style, color);
    }
    
/**
 * Constructs a <CODE>Font</CODE>-object.
 *
 * @param	fontname    the name of the font
 * @param	encoding    the encoding of the font
 * @param       embedded    true if the font is to be embedded in the PDF
 * @param	size	    the size of this font
 * @param	style	    the style of this font
 * @return the Font constructed based on the parameters
 */
    
    public static Font getFont(String fontname, String encoding, boolean embedded, float size, int style) {
        return getFont(fontname, encoding, embedded, size, style, null);
    }
    
/**
 * Constructs a <CODE>Font</CODE>-object.
 *
 * @param	fontname    the name of the font
 * @param	encoding    the encoding of the font
 * @param       embedded    true if the font is to be embedded in the PDF
 * @param	size	    the size of this font
 * @return the Font constructed based on the parameters
 */
    
    public static Font getFont(String fontname, String encoding, boolean embedded, float size) {
        return getFont(fontname, encoding, embedded, size, Font.UNDEFINED, null);
    }
    
/**
 * Constructs a <CODE>Font</CODE>-object.
 *
 * @param	fontname    the name of the font
 * @param	encoding    the encoding of the font
 * @param       embedded    true if the font is to be embedded in the PDF
 * @return the Font constructed based on the parameters
 */
    
    public static Font getFont(String fontname, String encoding, boolean embedded) {
        return getFont(fontname, encoding, embedded, Font.UNDEFINED, Font.UNDEFINED, null);
    }
    
/**
 * Constructs a <CODE>Font</CODE>-object.
 *
 * @param	fontname    the name of the font
 * @param	encoding    the encoding of the font
 * @param	size	    the size of this font
 * @param	style	    the style of this font
 * @param	color	    the <CODE>Color</CODE> of this font.
 * @return the Font constructed based on the parameters
 */
    
    public static Font getFont(String fontname, String encoding, float size, int style, Color color) {
        return getFont(fontname, encoding, defaultEmbedding, size, style, color);
    }
    
/**
 * Constructs a <CODE>Font</CODE>-object.
 *
 * @param	fontname    the name of the font
 * @param	encoding    the encoding of the font
 * @param	size	    the size of this font
 * @param	style	    the style of this font
 * @return the Font constructed based on the parameters
 */
    
    public static Font getFont(String fontname, String encoding, float size, int style) {
        return getFont(fontname, encoding, defaultEmbedding, size, style, null);
    }
    
/**
 * Constructs a <CODE>Font</CODE>-object.
 *
 * @param	fontname    the name of the font
 * @param	encoding    the encoding of the font
 * @param	size	    the size of this font
 * @return the Font constructed based on the parameters
 */
    
    public static Font getFont(String fontname, String encoding, float size) {
        return getFont(fontname, encoding, defaultEmbedding, size, Font.UNDEFINED, null);
    }
    
/**
 * Constructs a <CODE>Font</CODE>-object.
 *
 * @param	fontname    the name of the font
 * @param	encoding    the encoding of the font
 * @return the Font constructed based on the parameters
 */
    
    public static Font getFont(String fontname, String encoding) {
        return getFont(fontname, encoding, defaultEmbedding, Font.UNDEFINED, Font.UNDEFINED, null);
    }
    
/**
 * Constructs a <CODE>Font</CODE>-object.
 *
 * @param	fontname    the name of the font
 * @param	size	    the size of this font
 * @param	style	    the style of this font
 * @param	color	    the <CODE>Color</CODE> of this font.
 * @return the Font constructed based on the parameters
 */
    
    public static Font getFont(String fontname, float size, int style, Color color) {
        return getFont(fontname, defaultEncoding, defaultEmbedding, size, style, color);
    }
    
/**
 * Constructs a <CODE>Font</CODE>-object.
 *
 * @param	fontname    the name of the font
 * @param	size	    the size of this font
 * @param	style	    the style of this font
 * @return the Font constructed based on the parameters
 */
    
    public static Font getFont(String fontname, float size, int style) {
        return getFont(fontname, defaultEncoding, defaultEmbedding, size, style, null);
    }
    
/**
 * Constructs a <CODE>Font</CODE>-object.
 *
 * @param	fontname    the name of the font
 * @param	size	    the size of this font
 * @return the Font constructed based on the parameters
 */
    
    public static Font getFont(String fontname, float size) {
        return getFont(fontname, defaultEncoding, defaultEmbedding, size, Font.UNDEFINED, null);
    }
    
/**
 * Constructs a <CODE>Font</CODE>-object.
 *
 * @param	fontname    the name of the font
 * @return the Font constructed based on the parameters
 */
    
    public static Font getFont(String fontname) {
        return getFont(fontname, defaultEncoding, defaultEmbedding, Font.UNDEFINED, Font.UNDEFINED, null);
    }
    
/**
 * Register a ttf- or a ttc-file.
 *
 * @param   path    the path to a ttf- or ttc-file
 */
    
    public static void register(String path) {
        register(path, null);
    }
    
/**
 * Register a font file and use an alias for the font contained in it.
 *
 * @param   path    the path to a font file
 * @param   alias   the alias you want to use for the font
 */
    
    public static void register(String path, String alias) {
        try {
            if (path.toLowerCase().endsWith(".ttf") || path.toLowerCase().endsWith(".otf") || path.toLowerCase().indexOf(".ttc,") > 0) {
                Object allNames[] = BaseFont.getAllFontNames(path, BaseFont.WINANSI, null);
                trueTypeFonts.setProperty(((String)allNames[0]).toLowerCase(), path);
                if (alias != null) {
                    trueTypeFonts.setProperty(alias, path);
                }
                // register all the font names with all the locales
                String[][] names = (String[][])allNames[2]; //full name
                for (int i = 0; i < names.length; i++) {
                    trueTypeFonts.setProperty(names[i][3].toLowerCase(), path);
                }
                String fullName = null;
                String familyName = null;
                names = (String[][])allNames[1]; //family name
                for (int k = 0; k < TTFamilyOrder.length; k += 3) {
                    for (int i = 0; i < names.length; i++) {
                        if (TTFamilyOrder[k].equals(names[i][0]) && TTFamilyOrder[k + 1].equals(names[i][1]) && TTFamilyOrder[k + 2].equals(names[i][2])) {
                            familyName = names[i][3].toLowerCase();
                            k = TTFamilyOrder.length;
                            break;
                        }
                    }
                }
                if (familyName != null) {
                    String lastName = "";
                    names = (String[][])allNames[2]; //full name
                    for (int i = 0; i < names.length; i++) {
                        for (int k = 0; k < TTFamilyOrder.length; k += 3) {
                            if (TTFamilyOrder[k].equals(names[i][0]) && TTFamilyOrder[k + 1].equals(names[i][1]) && TTFamilyOrder[k + 2].equals(names[i][2])) {
                                fullName = names[i][3];
                                if (fullName.equals(lastName))
                                    continue;
                                lastName = fullName;
                                ArrayList tmp = (ArrayList) fontFamilies.get(familyName);
                                if (tmp == null) {
                                    tmp = new ArrayList();
                                    tmp.add(fullName);
                                    fontFamilies.put(familyName, tmp);
                                }
                                else {
                                    int fullNameLength = fullName.length();
                                    boolean inserted = false;
                                    for (int j = 0; j < tmp.size(); ++j) {
                                        if (((String)tmp.get(j)).length() >= fullNameLength) {
                                            tmp.add(j, fullName);
                                            inserted = true;
                                            break;
                                        }
                                    }
                                    if (!inserted)
                                        tmp.add(fullName);
                                }
                                break;
                            }
                        }
                    }
                }
            }
            else if (path.toLowerCase().endsWith(".ttc")) {
                if (alias != null)
                    System.err.println("class FontFactory: You can't define an alias for a true type collection.");
                String[] names = BaseFont.enumerateTTCNames(path);
                for (int i = 0; i < names.length; i++) {
                    register(path + "," + i);
                }
            }
            else if (path.toLowerCase().endsWith(".afm")) {
                BaseFont bf = BaseFont.createFont(path, BaseFont.CP1252, false);
                trueTypeFonts.setProperty(bf.getPostscriptFontName().toLowerCase(), path);
                trueTypeFonts.setProperty((bf.getFullFontName()[0][3]).toLowerCase(), path);
            }
        }
        catch(DocumentException de) {
            // this shouldn't happen
            throw new ExceptionConverter(de);
        }
        catch(IOException ioe) {
            throw new ExceptionConverter(ioe);
        }
    }

    /** Register all the fonts in a directory.
     * @param dir the directory
     * @return the number of fonts registered
     */    
    public static int registerDirectory(String dir) {
        int count = 0;
        try {
            File file = new File(dir);
            if (!file.exists() || !file.isDirectory())
                return 0;
            String files[] = file.list();
            if (files == null)
                return 0;
            for (int k = 0; k < files.length; ++k) {
                try {
                    file = new File(dir, files[k]);
                    String name = file.getPath().toLowerCase();
                    if (name.endsWith(".ttf") || name.endsWith(".otf") || name.endsWith(".afm") || name.endsWith(".ttc")) {
                        register(file.getPath(), null);
                        ++count;
                    }
                }
                catch (Exception e) {
                    //empty on purpose
                }
            }
        }
        catch (Exception e) {
            //empty on purpose
        }
        return count;
    }

    /** Register fonts in some probable directories. It usually works in Windows,
     * Linux and Solaris.
     * @return the number of fonts registered
     */    
    public static int registerDirectories() {
        int count = 0;
        count += registerDirectory("c:/windows/fonts");
        count += registerDirectory("c:/winnt/fonts");
        count += registerDirectory("d:/windows/fonts");
        count += registerDirectory("d:/winnt/fonts");
        count += registerDirectory("/usr/X/lib/X11/fonts/TrueType");
        count += registerDirectory("/usr/openwin/lib/X11/fonts/TrueType");
        count += registerDirectory("/usr/share/fonts/default/TrueType");
        count += registerDirectory("/usr/X11R6/lib/X11/fonts/ttf");
        return count;
    }

/**
 * Gets a set of registered fontnames.
 * @return a set of registered fonts
 */
    
    public static Set getRegisteredFonts() {
        return Chunk.getKeySet(trueTypeFonts);
    }
    
/**
 * Gets a set of registered fontnames.
 * @return a set of registered font families
 */
    
    public static Set getRegisteredFamilies() {
        return Chunk.getKeySet(fontFamilies);
    }
    
/**
 * Gets a set of registered fontnames.
 * @param fontname of a font that may or may not be registered
 * @return true if a given font is registered
 */
    
    public static boolean contains(String fontname) {
        return trueTypeFonts.containsKey(fontname.toLowerCase());
    }
    
/**
 * Checks if a certain font is registered.
 *
 * @param   fontname    the name of the font that has to be checked.
 * @return  true if the font is found
 */
    
    public static boolean isRegistered(String fontname) {
        return trueTypeFonts.containsKey(fontname.toLowerCase());
    }
} /*
 * $Id: Header.java,v 1.29 2002/07/09 10:41:33 blowagie Exp $
 * $Name:  $
 *
 * Copyright 1999, 2000, 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

/**
 * This is an <CODE>Element</CODE> that contains
 * some userdefined meta information about the document.
 * <P>
 * <B>Example:</B>
 * <BLOCKQUOTE><PRE>
 * <STRONG>Header header = new Header("inspired by", "William Shakespeare");</STRONG>
 * </PRE></BLOCKQUOTE>
 *
 * @see		Element
 * @see		Meta
 */

public class Header extends Meta implements Element {
    
    // membervariables
    
/** This is the content of this chunk of text. */
    private StringBuffer name;
    
    // constructors
    
/**
 * Constructs a <CODE>Meta</CODE>.
 *
 * @param	name		the name of the meta-information
 * @param	content		the content
 */
    
    public Header(String name, String content) {
        super(Element.HEADER, content);
        this.name = new StringBuffer(name);
    }
    
    // methods to retrieve information
    
/**
 * Returns the name of the meta information.
 *
 * @return	a <CODE>String</CODE>
 */
    
    public String name() {
        return name.toString();
    }
} /*
 * $Id: List.java,v 1.74 2005/04/13 09:17:14 blowagie Exp $
 * $Name:  $
 *
 * Copyright 1999, 2000, 2001, 2002 by Bruno Lowagie.
 *
 *
 * The Original Code is 'iText, a free JAVA-PDF library'.
 *
 * The Initial Developer of the Original Code is Bruno Lowagie. Portions created by
 * the Initial Developer are Copyright (C) 1999, 2000, 2001, 2002 by Bruno Lowagie.
 * All Rights Reserved.
 * Co-Developer of the code is Paulo Soares. Portions created by the Co-Developer
 * are Copyright (C) 2000, 2001, 2002 by Paulo Soares. All Rights Reserved.
 *
 * Contributor(s): all the names of the contributors are added in the source code
 * where applicable.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 * 
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 * Boston, MA  02110-1301, USA.
 *
 *
 * If you didn't download this code from the following link, you should check if
 * you aren't using an obsolete version:
 * http://www.lowagie.com/iText/
 */

package pdftk.com.lowagie.text;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Properties;
import java.util.Set;

/**
 * A <CODE>List</CODE> contains several <CODE>ListItem</CODE>s.
 * <P>
 * <B>Example 1:</B>
 * <BLOCKQUOTE><PRE>
 * <STRONG>List list = new List(true, 20);</STRONG>
 * <STRONG>list.add(new ListItem("First line"));</STRONG>
 * <STRONG>list.add(new ListItem("The second line is longer to see what happens once the end of the line is reached. Will it start on a new line?"));</STRONG>
 * <STRONG>list.add(new ListItem("Third line"));</STRONG>
 * </PRE></BLOCKQUOTE>
 *
 * The result of this code looks like this:
 *	<OL>
 *		<LI>
 *			First line
 *		</LI>
 *		<LI>
 *			The second line is longer to see what happens once the end of the line is reached. Will it start on a new line?
 *		</LI>
 *		<LI>
 *			Third line
 *		</LI>
 *	</OL>
 *
 * <B>Example 2:</B>
 * <BLOCKQUOTE><PRE>
 * <STRONG>List overview = new List(false, 10);</STRONG>
 * <STRONG>overview.add(new ListItem("This is an item"));</STRONG>
 * <STRONG>overview.add("This is another item");</STRONG>
 * </PRE></BLOCKQUOTE>
 *
 * The result of this code looks like this:
 *	<UL>
 *		<LI>
 *			This is an item
 *		</LI>
 *		<LI>
 *			This is another item
 *		</LI>
 *	</UL>
 *
 * @see		Element
 * @see		ListItem
 */

public class List implements TextElementArray, MarkupAttributes {
    
    // membervariables
	/** a possible value for the numbered parameter */
	public static final boolean ORDERED = true;
	/** a possible value for the numbered parameter */
	public static final boolean UNORDERED = false;
	/** a possible value for the lettered parameter */
	public static final boolean NUMBERICAL = false;
	/** a possible value for the lettered parameter */
	public static final boolean ALPHABETICAL = true;
	
    
/** This is the <CODE>ArrayList</CODE> containing the different <CODE>ListItem</CODE>s. */
    protected ArrayList list = new ArrayList();
    
/** This variable indicates if the list has to be numbered. */
    protected boolean numbered;
    protected boolean lettered;
    
/** This variable indicates the first number of a numbered list. */
    protected int first = 1;
    protected char firstCh = 'A';
    protected char lastCh  = 'Z';
    
/** This is the listsymbol of a list that is not numbered. */
    protected Chunk symbol = new Chunk("-");
    
/** The indentation of this list on the left side. */
    protected float indentationLeft = 0;
    
/** The indentation of this list on the right side. */
    protected float indentationRight = 0;
    
/** The indentation of the listitems. */
    protected float symbolIndent;

/** Contains extra markupAttributes */
    protected Properties markupAttributes;
    
    // constructors
    
/**
 * Constructs a <CODE>List</CODE>.
 * <P>
 * Remark: the parameter <VAR>symbolIndent</VAR> is important for instance when
 * generating PDF-documents; it indicates the indentation of the listsymbol.
 * It is not important for HTML-documents.
 *
 * @param	numbered		a boolean
 * @param	symbolIndent	the indentation that has to be used for the listsymbol
 */
    
    public List(boolean numbered, float symbolIndent) {
        this.numbered = numbered;
        this.lettered = false;
        this.symbolIndent = symbolIndent;
    }
    
    /**
     * Creates a list
     * @param numbered has the list to be numbered?
     * @param lettered has the list to be 'numbered' with letters
     * @param symbolIndent the indentation of the symbol
     */
    public List(boolean numbered, boolean lettered, float symbolIndent ) {
        this.numbered = numbered;
        this.lettered = lettered;
        this.symbolIndent = symbolIndent;
    }
    
        /**
         * Returns a <CODE>List</CODE> that has been constructed taking in account
         * the value of some <VAR>attributes</VAR>.
         *
         * @param	attributes		Some attributes
         */
    
    public List(Properties attributes) {
        String value= (String)attributes.remove(ElementTags.LISTSYMBOL);
        if (value == null) {
            value = "-";
        }
        symbol = new Chunk(value, FontFactory.getFont(attributes));
        
        this.numbered = false;
        if ((value = (String)attributes.remove(ElementTags.NUMBERED)) != null) {
            this.numbered = new Boolean(value).booleanValue();
            if ( this.lettered && this.numbered )
                this.lettered = false;
        }
        if ((value = (String)attributes.remove(ElementTags.LETTERED)) != null) {
            this.lettered = new Boolean(value).booleanValue();
            if ( this.numbered && this.lettered )
                this.numbered = false;
        }
        this.symbolIndent = 0;
        if ((value = (String)attributes.remove(ElementTags.SYMBOLINDENT)) != null) {
            this.symbolIndent = Float.parseFloat(value);
        }
        
        if ((value = (String)attributes.remove(ElementTags.FIRST)) != null) {
            char khar = value.charAt(0);
            if ( Character.isLetter( khar ) ) {
                setFirst( khar );
            }
            else {
                setFirst(Integer.parseInt(value));
            }
        }
        if ((value = (String)attributes.remove(ElementTags.INDENTATIONLEFT)) != null) {
            setIndentationLeft(Float.valueOf(value + "f").floatValue());
        }
        if ((value = (String)attributes.remove(ElementTags.INDENTATIONRIGHT)) != null) {
            setIndentationRight(Float.valueOf(value + "f").floatValue());
        }
        if (attributes.size() > 0) setMarkupAttributes(attributes);
    }
    
    // implementation of the Element-methods
    
/**
 * Processes the element by adding it (or the different parts) to an
 * <CODE>ElementListener</CODE>.
 *
 * @param	listener	an <CODE>ElementListener</CODE>
 * @return	<CODE>true</CODE> if the element was processed successfully
 */
    
    public boolean process(ElementListener listener) {
        try {
            for (Iterator i = list.iterator(); i.hasNext(); ) {
                listener.add((Element) i.next());
            }
            return true;
        }
        catch(DocumentException de) {
            return false;
        }
    }
    
/**
 * Gets the type of the text element.
 *
 * @return	a type
 */
    
    public int type() {
        return Element.LIST;
    }
    
/**
 * Gets all the chunks in this element.
 *
 * @return	an <CODE>ArrayList</CODE>
 */
    
    public ArrayList getChunks() {
        ArrayList tmp = new ArrayList();
        for (Iterator i = list.iterator(); i.hasNext(); ) {
            tmp.addAll(((Element) i.next()).getChunks());
        }
        return tmp;
    }
    
    // methods to set the membervariables
    
/**
 * Adds an <CODE>Object</CODE> to the <CODE>List</CODE>.
 *
 * @param	o		the object to add.
 * @return true if adding the object succeeded
 */
    
    public boolean add(Object o) {
        if (o instanceof ListItem) {
            ListItem item = (ListItem) o;
            if (numbered || lettered) {
                Chunk chunk;
                if ( lettered )
                    chunk = new Chunk(nextLetter(), symbol.font());
                else
                    chunk = new Chunk(String.valueOf(first + list.size()), symbol.font());
                chunk.append(".");
                item.setListSymbol(chunk);
            }
            else {
                item.setListSymbol(symbol);
            }
            item.setIndentationLeft(symbolIndent);
            item.setIndentationRight(0);
            list.add(item);
        }
        else if (o instanceof List) {
            List nested = (List) o;
            nested.setIndentationLeft(nested.indentationLeft() + symbolIndent);
            first--;
            return list.add(nested);
        }
        else if (o instanceof String) {
            return this.add(new ListItem((String) o));
        }
        return false;
    }
    
/**
 * Sets the indentation of this paragraph on the left side.
 *
 * @param	indentation		the new indentation
 */
    
    public void setIndentationLeft(float indentation) {
        this.indentationLeft = indentation;
    }
    
/**
 * Sets the indentation of this paragraph on the right side.
 *
 * @param	indentation		the new indentation
 */
    
    public void setIndentationRight(float indentation) {
        this.indentationRight = indentation;
    }
    
/**
 * Sets the number that has to come first in the list.
 *
 * @param	first		a number
 */
    
    public void setFirst(int first) {
        this.first = first;
    }
    
    
/**
 * Sets the Letter that has to come first in the list.
 *
 * @param	first		a letter
 */
    
    public void setFirst(char first) {
        this.firstCh = first;
        if ( Character.isLowerCase( this.firstCh )) {
            this.lastCh = 'z';
        }
        else {
            this.lastCh = 'Z';
        }
    }
    
/**
 * Sets the listsymbol.
 *
 * @param	symbol		a <CODE>Chunk</CODE>
 */
    
    public void setListSymbol(Chunk symbol) {
        this.symbol = symbol;
    }
    
/**
 * Sets the listsymbol.
 * <P>
 * This is a shortcut for <CODE>setListSymbol(Chunk symbol)</CODE>.
 *
 * @param	symbol		a <CODE>String</CODE>
 */
    
    public void setListSymbol(String symbol) {
        this.symbol = new Chunk(symbol);
    }
    
    // methods to retrieve information
    
/**
 * Gets all the items in the list.
 *
 * @return	an <CODE>ArrayList</CODE> containing <CODE>ListItem</CODE>s.
 */
    
    public ArrayList getItems() {
        return list;
    }
    
/**
 * Gets the size of the list.
 *
 * @return	a <CODE>size</CODE>
 */
    
    public int size() {
        return list.size();
    }
    
/**
 * Gets the leading of the first listitem.
 *
 * @return	a <CODE>leading</CODE>
 */
    
    public float leading() {
        if (list.size() < 1) {
            return -1;
        }
        ListItem item = (ListItem) list.get(0);
        return item.leading();
    }
    
/**
 * Checks if the list is numbered.
 *
 * @return	<CODE>true</CODE> if the list is numbered, <CODE>false</CODE> otherwise.
 */
    
    public boolean isNumbered() {
        return numbered;
    }
    
/**
 * Gets the symbol indentation.
 * @return the symbol indentation
 */
    
    public float symbolIndent() {
        return symbolIndent;
    }
    
/**
 * Gets the Chunk containing the symbol.
 * @return a Chunk with a symbol
 */
    
    public Chunk symbol() {
        return symbol;
    }
    
/**
 * Gets the first number        .
 * @return a number
 */
    
    public int first() {
        return first;
    }
    
/**
 * Gets the indentation of this paragraph on the left side.
 *
 * @return	the indentation
 */
    
    public float indentationLeft() {
        return indentationLeft;
    }
    
/**
 * Gets the indentation of this paragraph on the right side.
 *
 * @return	the indentation
 */
    
    public float indentationRight() {
        return indentationRight;
    }
    
/**
 * Checks if a given tag corresponds with the listsymbol tag of this object.
 *
 * @param   tag     the given tag
 * @return  true if the tag corresponds
 */
    
    public static boolean isSymbol(String tag) {
        return ElementTags.LISTSYMBOL.equals(tag);
    }
    
/**
 * Checks if a given tag corresponds with this object.
 *
 * @param   tag     the given tag
 * @return  true if the tag corresponds
 */
    
    public static boolean isTag(String tag) {
        return ElementTags.LIST.equals(tag);
    }

/**
 * Retrieves the next letter in the sequence
 *
 * @return  String contains the next character (A-Z or a-z)
 */
    private String nextLetter() {
        int num_in_list = listItemsInList(); //list.size();
        int max_ival = (lastCh + 0);
        int ival = (firstCh + num_in_list);
        while ( ival > max_ival ) {
            ival -= 26;
        }
        char[] new_char = new char[1];
        new_char[0] = (char) ival;
        String ret = new String( new_char );
        return ret;
    }
    
    /**
     * Counts the number of ListItems in the list ommiting nested lists
     *
     * @return  Integer number of ListItems in the list
     */
    private int listItemsInList() {
        int result = 0;
        for (Iterator i = list.iterator(); i.hasNext(); ) {
            if (!(i.next() instanceof List)) result++;
        }
        return result;
    }
    
/**
 * @see pdftk.com.lowagie.text.MarkupAttributes#setMarkupAttribute(java.lang.String, java.lang.String)
 */
    public void setMarkupAttribute(String name, String value) {
		if (markupAttributes == null) markupAttributes = new Properties();
        markupAttributes.put(name, value);
    }
    
/**
 * @see pdftk.com.lowagie.text.MarkupAttributes#setMarkupAttributes(java.util.Properties)
 */
    public void setMarkupAttributes(Properties markupAttributes) {
        this.markupAttributes = markupAttributes;
    }
    
/**
 * @see pdftk.com.lowagie.text.MarkupAttributes#getMarkupAttribute(java.lang.String)
 */
    public String getMarkupAttribute(String name) {
        return (markupAttributes == null) ? null : String.valueOf(markupAttributes.get(name));
    }
    
/**
 * @see pdftk.com.lowagie.text.MarkupAttributes#getMarkupAttributeNames()
 */
    public Set getMarkupAttributeNames() {
        return Chunk.getKeySet(markupAttributes);
    }
    
/**
 * @see pdftk.com.lowagie.text.MarkupAttributes#getMarkupAttributes()
 */
    public Properties getMarkupAttributes() {
        return markupAttributes;
    }
}
 /*
 *   This file is part of the pdftk port to java
 *
 *   Copyright (c) Marc Vinyals 2017-2018
 *
 *   The program is a java port of PDFtk, the PDF Toolkit
 *   Copyright (c) 2003-2013 Steward and Lee, LLC
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   The program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/*
 * @deprecated  Use com.gitlab.pdftk_java.pdftk
 */
@Deprecated
public class pdftk {
  public static void main(String[] args) {
    System.err.println("Warning: class pdftk is deprecated. Use com.gitlab.pdftk_java.pdftk.");
    com.gitlab.pdftk_java.pdftk.main(args);
  }
}
 import static org.junit.Assert.assertEquals;
import org.junit.Rule;
import org.junit.Test;
import org.junit.contrib.java.lang.system.SystemOutRule;
import org.junit.contrib.java.lang.system.ExpectedSystemExit;

import java.nio.file.Files;
import java.nio.file.Paths;
import java.io.IOException;

import com.gitlab.pdftk_java.pdftk;

public class BlackBoxTest {
  @Rule
  public final SystemOutRule systemOutRule =
    new SystemOutRule().muteForSuccessfulTests();

  @Rule
  public final ExpectedSystemExit exit = ExpectedSystemExit.none();

  public String slurp(String filename) throws IOException {
    return new String(slurpBytes(filename));
  }
  public byte[] slurpBytes(String filename) throws IOException {
    return Files.readAllBytes(Paths.get(filename));
  }
  
  @Test
  public void dump_data() throws IOException {
    exit.expectSystemExitWithStatus(0);
    pdftk.main(new String[]{"test/files/blank.pdf", "dump_data_utf8"});
    String expectedData = slurp("test/files/blank.data");
    assertEquals(expectedData, systemOutRule.getLog());    
  }

  @Test
  public void cat() throws IOException {
    exit.expectSystemExitWithStatus(0);
    pdftk.main(new String[]{"test/files/refs.pdf",
                            "test/files/refsalt.pdf",
                            "cat", "output", "-"});
    byte[] expectedData = slurpBytes("test/files/cat-refs-refsalt.pdf");
    assertEquals(expectedData, systemOutRule.getLogAsBytes());
  }

  @Test
  public void cat_rotate_page_no_op() throws IOException {
    exit.expectSystemExitWithStatus(0);
    pdftk.main(new String[]{"test/files/blank.pdf",
                            "cat", "1north", "output", "-"});
    byte[] expectedData = slurpBytes("test/files/blank.pdf");
    assertEquals(expectedData, systemOutRule.getLogAsBytes());
  }

  @Test
  public void cat_rotate_range_no_op() throws IOException {
    exit.expectSystemExitWithStatus(0);
    pdftk.main(new String[]{"test/files/blank.pdf",
                            "cat", "1-1north", "output", "-"});
    byte[] expectedData = slurpBytes("test/files/blank.pdf");
    assertEquals(expectedData, systemOutRule.getLogAsBytes());
  }

  @Test
  public void cat_rotate_page() throws IOException {
    exit.expectSystemExitWithStatus(0);
    pdftk.main(new String[]{"test/files/blank.pdf",
                            "cat", "1east", "output", "-"});
    byte[] expectedData = slurpBytes("test/files/blank.pdf");
    assertEquals(expectedData, systemOutRule.getLogAsBytes());
  }

  @Test
  public void cat_rotate_range() throws IOException {
    exit.expectSystemExitWithStatus(0);
    pdftk.main(new String[]{"test/files/blank.pdf",
                            "cat", "1-1east", "output", "-"});
    byte[] expectedData = slurpBytes("test/files/blank.pdf");
    assertEquals(expectedData, systemOutRule.getLogAsBytes());
  }

};
 